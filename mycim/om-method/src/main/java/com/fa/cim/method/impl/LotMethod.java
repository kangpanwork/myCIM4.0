package com.fa.cim.method.impl;

import cn.hutool.core.util.ArrayUtil;
import cn.hutool.core.util.StrUtil;
import com.fa.cim.annotaion.OmMethod;
import com.fa.cim.common.constant.BizConstant;
import com.fa.cim.common.constant.CIMStateConst;
import com.fa.cim.common.constant.TransactionIDEnum;
import com.fa.cim.common.exception.ServiceException;
import com.fa.cim.common.support.ObjectIdentifier;
import com.fa.cim.common.support.OmCode;
import com.fa.cim.common.utils.*;
import com.fa.cim.config.RetCodeConfig;
import com.fa.cim.config.RetCodeConfigEx;
import com.fa.cim.dto.*;
import com.fa.cim.entity.nonruntime.CimBondGroupMapDO;
import com.fa.cim.entity.nonruntime.CimScheduleChangeReservationDO;
import com.fa.cim.entity.runtime.bank.CimBankDO;
import com.fa.cim.entity.runtime.cassette.CimCassetteDO;
import com.fa.cim.entity.runtime.code.CimCodeDO;
import com.fa.cim.entity.runtime.controljob.CimControlJobDO;
import com.fa.cim.entity.runtime.eqp.CimEquipmentDO;
import com.fa.cim.entity.runtime.flowbatch.CimFlowBatchDO;
import com.fa.cim.entity.runtime.futurerework.CimFutureReworkDO;
import com.fa.cim.entity.runtime.futurerework.CimFutureReworkRouteDO;
import com.fa.cim.entity.runtime.logicalrecipe.CimLogicalRecipeDO;
import com.fa.cim.entity.runtime.lot.*;
import com.fa.cim.entity.runtime.lotcomment.CimLotCommentDO;
import com.fa.cim.entity.runtime.lotfamily.CimLotFamilyDO;
import com.fa.cim.entity.runtime.lotnote.CimLotNoteDO;
import com.fa.cim.entity.runtime.lottype.CimLotTypeDO;
import com.fa.cim.entity.runtime.monitorgroup.CimMonitorGroupDO;
import com.fa.cim.entity.runtime.monitorgroup.CimMonitorGroupLotDO;
import com.fa.cim.entity.runtime.mtrlloc.CimMaterialLocationDO;
import com.fa.cim.entity.runtime.pfx.CimProcessFlowContextBackPODO;
import com.fa.cim.entity.runtime.pfx.CimProcessFlowContextDO;
import com.fa.cim.entity.runtime.pfx.CimProcessFlowContextPODO;
import com.fa.cim.entity.runtime.pfx.CimProcessFlowContextReturnDO;
import com.fa.cim.entity.runtime.po.CimPOBackUpDataDO;
import com.fa.cim.entity.runtime.po.CimProcessOperationDO;
import com.fa.cim.entity.runtime.pos.*;
import com.fa.cim.entity.runtime.processdefinition.CimProcessDefinitionDO;
import com.fa.cim.entity.runtime.processflow.CimPFDefinitionListDO;
import com.fa.cim.entity.runtime.processflow.CimPFPosListDO;
import com.fa.cim.entity.runtime.processflow.CimProcessFlowDO;
import com.fa.cim.entity.runtime.productgroup.CimProductGroupDO;
import com.fa.cim.entity.runtime.productrequest.CimProductRequestSourceLotDO;
import com.fa.cim.entity.runtime.productspec.CimProductSpecificationDO;
import com.fa.cim.entity.runtime.productspec.CimProductSpecificationSourceDO;
import com.fa.cim.entity.runtime.qtime.CimQTimeDO;
import com.fa.cim.entity.runtime.reticleset.CimReticleSetDFReticleGroupDO;
import com.fa.cim.entity.runtime.reticleset.CimReticleSetDefinitionDO;
import com.fa.cim.entity.runtime.reticleset.CimReticleSetSpecificGroupDO;
import com.fa.cim.entity.runtime.reticleset.CimReticleSetSpecificationDO;
import com.fa.cim.entity.runtime.stocker.CimStockerDO;
import com.fa.cim.entity.runtime.wafer.CimWaferDO;
import com.fa.cim.entity.runtime.wafer.CimWaferReworkCountDO;
import com.fa.cim.entity.runtime.wafer.CimWaferStbInfoDO;
import com.fa.cim.enums.MethodEnums;
import com.fa.cim.jpa.CimJpaRepository;
import com.fa.cim.jpa.SearchCondition;
import com.fa.cim.lmg.LotMonitorGroupResults;
import com.fa.cim.lot.LotNpwUsageRecycleCountUpdateParams;
import com.fa.cim.lot.LotNpwUsageRecycleLimitUpdateParams;
import com.fa.cim.lot.LotStbUsageRecycleLimitParams;
import com.fa.cim.lot.LotUsageRecycleCountParams;
import com.fa.cim.method.*;
import com.fa.cim.newcore.bo.code.CimCode;
import com.fa.cim.newcore.bo.code.CodeManager;
import com.fa.cim.newcore.bo.dc.CimDataCollectionSpecification;
import com.fa.cim.newcore.bo.dispatch.CimFlowBatch;
import com.fa.cim.newcore.bo.dispatch.DispatchingManager;
import com.fa.cim.newcore.bo.durable.CimCassette;
import com.fa.cim.newcore.bo.durable.CimReticleSet;
import com.fa.cim.newcore.bo.factory.CimBank;
import com.fa.cim.newcore.bo.factory.CimStage;
import com.fa.cim.newcore.bo.globalfunc.CimFrameWorkGlobals;
import com.fa.cim.newcore.bo.machine.CimEqpMonitor;
import com.fa.cim.newcore.bo.machine.CimEqpMonitorJob;
import com.fa.cim.newcore.bo.machine.CimMachine;
import com.fa.cim.newcore.bo.machine.CimMaterialLocation;
import com.fa.cim.newcore.bo.parts.CimBom;
import com.fa.cim.newcore.bo.pd.*;
import com.fa.cim.newcore.bo.person.CimPerson;
import com.fa.cim.newcore.bo.planning.CimLotOperationSchedule;
import com.fa.cim.newcore.bo.planning.CimProductRequest;
import com.fa.cim.newcore.bo.planning.PlanManager;
import com.fa.cim.newcore.bo.prodspec.*;
import com.fa.cim.newcore.bo.product.*;
import com.fa.cim.newcore.bo.recipe.CimLogicalRecipe;
import com.fa.cim.newcore.bo.recipe.CimMachineRecipe;
import com.fa.cim.newcore.dto.dc.EDCDTO;
import com.fa.cim.newcore.dto.event.Event;
import com.fa.cim.newcore.dto.machine.MachineDTO;
import com.fa.cim.newcore.dto.pd.ProcessDTO;
import com.fa.cim.newcore.dto.product.DispatchReadinessState;
import com.fa.cim.newcore.dto.product.ProductDTO;
import com.fa.cim.newcore.dto.productspec.ProductSpecDTO;
import com.fa.cim.newcore.exceptions.CoreFrameworkException;
import com.fa.cim.newcore.exceptions.DuplicateRecordException;
import com.fa.cim.newcore.exceptions.IllegalParameterException;
import com.fa.cim.newcore.factory.BaseCoreFactory;
import com.fa.cim.newcore.impl.bo.env.StandardProperties;
import com.fa.cim.newcore.standard.drblmngm.MaterialContainer;
import com.fa.cim.newcore.standard.mchnmngm.Machine;
import com.fa.cim.newcore.standard.mchnmngm.MaterialLocation;
import com.fa.cim.newcore.standard.mchnmngm.PortResource;
import com.fa.cim.newcore.standard.mchnmngm.ProcessResource;
import com.fa.cim.newcore.standard.mtrlmngm.Material;
import com.fa.cim.newcore.standard.prcssdfn.ProcessDefinition;
import com.fa.cim.newcore.standard.prcssdfn.ProcessOperationSpecification;
import com.fa.cim.newcore.standard.prdctmng.Lot;
import com.fa.cim.newcore.standard.prdctmng.Product;
import com.fa.cim.newcore.standard.prdctmng.Wafer;
import com.fa.cim.newcore.standard.prdctspc.ProductSpecification;
import com.fa.cim.sorter.Info;
import com.fa.cim.sorter.SorterHandler;
import com.google.common.collect.Lists;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;

import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static java.lang.Boolean.TRUE;
import static java.util.Comparator.comparingInt;


/**
 * description:
 * <p>
 * change history:
 * date             defect#             person             comments
 * ---------------------------------------------------------------------------------------------------------------------
 * 2018/6/21        ********             Bear               create file
 *
 * @author Bear
 * @since 2018/6/21 10:31
 * Copyright: 2018, FA Software (Shanghai) Co., Ltd. All Rights Reserved.
 */
@OmMethod
@Slf4j
public class LotMethod implements ILotMethod {

    @Autowired
    private IBondingGroupMethod bondingGroupMethod;

    @Autowired
    private IBondingMapMethod bondingMapMethod;

    @Autowired
    private IAutoDispatchControlMethod autoDispatchControlMethod;

    @Autowired
    private IPersonMethod personMethod;

    @Autowired
    private CimFrameWorkGlobals cimFrameWorkGlobals;

    @Autowired
    private IWaferMethod waferMethod;

    @Autowired
    private ILotMethod lotMethod;

    @Autowired
    private IControlJobMethod controlJobMethod;

    @Autowired
    private SorterNewMethod sorterMethod;

    @Autowired
    private ILogicalRecipeMethod logicalRecipeMethod;

    @Autowired
    private ISamplingSettingMethod samplingSettingMethod;

    @Autowired
    private IEquipmentMethod equipmentMethod;

    @Autowired
    private ICassetteMethod cassetteMethod;

    @Autowired
    private IMonitorGroupMethod monitorGroupMethod;

    @Autowired
    private ILotFamilyMethod lotFamilyMethod;

    @Autowired
    private IPortMethod portMethod;

    @Autowired
    private IExperimentalMethod experimentalMethod;

    @Autowired
    private IExperimentalForFutureMethod experimentalForFutureMethod;

    @Autowired
    private IProcessMethod processMethod;

    @Autowired
    private CimJpaRepository cimJpaRepository;

    @Autowired
    private IFPCMethod fpcMethod;

    @Autowired
    @Qualifier("PlanManagerCore")
    private PlanManager planManager;

    @Autowired
    private DataCollectionMethod dataCollectionMethod;

    @Autowired
    private IEventMethod eventMethod;

    @Autowired
    private BaseCoreFactory baseCoreFactory;

    @Autowired
    @Qualifier("ProductManagerCore")
    private ProductManager productManager;

    @Autowired
    @Qualifier("DispatchingManagerCore")
    private DispatchingManager dispatchingManager;

    @Autowired
    @Qualifier("CodeManagerCore")
    private CodeManager codeManager;

    @Autowired
    private ProductSpecificationManager productSpecificationManager;

    @Autowired
    private RetCodeConfig retCodeConfig;

    @Autowired
    private RetCodeConfigEx retCodeConfigEx;

    @Autowired
    private IInterFabMethod interFabMethod;

    @Autowired
    private ProcessDefinitionManager processDefinitionManager;

    @Autowired
    private IObjectLockMethod objectLockMethod;

    @Autowired
    private ICodeMethod codeMethod;

    @Autowired
    private IConstraintMethod constraintMethod;

    @Autowired
    private IContaminationMethod contaminationMethod;

    @Autowired
    private IMinQTimeMethod minQTimeMethod;

    private Random rand = new Random();

    @Override
    public Results.VendorLotReceiveReqResult lotMakeVendorLot(Infos.ObjCommon objCommon, Params.VendorLotReceiveParams vendorLotReceiveParams) {
        String assignedLotID = vendorLotReceiveParams.getLotID();

        //------------------------------
        // Check input parameter
        //------------------------------
        // 1: getProductSpecification by Product ID
        log.debug(" [step-1] getProductSpecification by Product ID");
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification productSpecificationBO = baseCoreFactory.getBO(com.fa.cim.newcore.bo.prodspec.CimProductSpecification.class, vendorLotReceiveParams.getProductID());
        log.info("productSpecification : {}", productSpecificationBO);
        Validations.check(CimObjectUtils.isEmpty(productSpecificationBO), retCodeConfig.getInvalidProdId(),ObjectIdentifier.fetchValue(vendorLotReceiveParams.getProductID()));

        // 2: get bank by bank id
        log.debug(" [step-2] get bank by bank id");
        CimBank bankBO = baseCoreFactory.getBO(CimBank.class, vendorLotReceiveParams.getBankID());
        log.debug("bank:{}", bankBO);
        Validations.check(CimObjectUtils.isEmpty(bankBO), retCodeConfig.getNotFoundBank(), ObjectIdentifier.fetchValue(vendorLotReceiveParams.getBankID()));

        Boolean bVendorLotReceiveBank = bankBO.isReceiveBank();
        log.debug("bVendorLotReceiveBank:{}", bVendorLotReceiveBank);
        Validations.check(!bVendorLotReceiveBank, retCodeConfig.getCanNotReceiveVendorLotInBank(), ObjectIdentifier.fetchValue(vendorLotReceiveParams.getBankID()));

        // check if sublottype is empty
        log.debug("check if sublottype is empty");
        Validations.check(CimStringUtils.isEmpty(vendorLotReceiveParams.getSubLotType()), retCodeConfig.getNotFoundSubLotType(), vendorLotReceiveParams.getSubLotType());

        //------------------------------
        // Create new lot
        //------------------------------
        log.debug(" [step-3] Create new lot");
        com.fa.cim.newcore.bo.planning.CimProductRequest newProductRequest;
        log.trace("!StringUtils.isEmpty(vendorLotReceiveParams.getLotID()) : {}", !CimStringUtils.isEmpty(vendorLotReceiveParams.getLotID()));
        if (!CimStringUtils.isEmpty(vendorLotReceiveParams.getLotID())) {
            //【Sun】add duplicate lot check,2018-09-10;
            // duplication will be checked inside this method
            try {
                newProductRequest = planManager.createProductRequestNamed(vendorLotReceiveParams.getLotID(), productSpecificationBO);
            }catch (ServiceException ex){
                throw new ServiceException(retCodeConfig.getDuplicateLot());
            }
        } else {
            while (true) {
                // creating LotID which doesn't exists.
                while (true) {
                    assignedLotID = lotTypeLotIDAssign(objCommon, BizConstant.SP_LOT_TYPE_VENDORLOT, vendorLotReceiveParams.getProductID(), vendorLotReceiveParams.getSubLotType());
                    CimLot cimLot1 = productManager.findLotNamed(assignedLotID);
                    log.trace("cimLot1 == null : {}", cimLot1 == null);
                    if (cimLot1 == null) {
                        log.debug("AssignedLotID : {}", assignedLotID);
                        break;
                    }
                }

                try {
                    newProductRequest = planManager.createProductRequestNamed(assignedLotID, productSpecificationBO);
                    break;
                } catch (ServiceException ex) {
                    log.error("Duplicate lot id");
                }
            }
        }
        Validations.check(CimObjectUtils.isEmpty(newProductRequest), retCodeConfig.getNotFoundSystemObj());

        //------------------------------
        // Set ProductRequest info
        //------------------------------
        log.debug(" [step-4] Set ProductRequest info");
        newProductRequest.setAllStatesForVendorLot();
        newProductRequest.setProductSpecification(productSpecificationBO);
        newProductRequest.setStartBank(bankBO);
        newProductRequest.setEndBank(bankBO);
        newProductRequest.setLotType(String.valueOf(BizConstant.SP_LOT_TYPE_VENDORLOT));
        newProductRequest.setSubLotType(vendorLotReceiveParams.getSubLotType());
        newProductRequest.setProductQuantity(vendorLotReceiveParams.getProductWaferCount());
        newProductRequest.setDeliveryDateTime(String.valueOf(objCommon.getTimeStamp().getReportTimeStamp()));
        newProductRequest.setPlanReleaseDateTime(String.valueOf(objCommon.getTimeStamp().getReportTimeStamp()));
        log.debug("productRequest:{}", newProductRequest);

        CimLot newCimLot = null;
        try {
            newCimLot = productManager.createLotUsing(newProductRequest);
            log.debug("newLot:{}", newCimLot);
        } catch (IllegalParameterException e) {
            ProductSpecification aProductSpecification = newProductRequest.getProductSpecification();
            Validations.check(null == aProductSpecification, retCodeConfig.getNotFoundProductSpec());

            String aProdID = newProductRequest.getIdentifier() ;
            Validations.check(new OmCode(retCodeConfig.getInvalidProductStat(), aProdID));
        } catch (DuplicateRecordException e) {
            log.trace("Validations.isEquals(e.getOmCode(), retCodeConfig.getDuplicateFamily()) : {}", Validations.isEquals(e.getCoreCode(), retCodeConfig.getDuplicateFamily()));
            if (Validations.isEquals(e.getCoreCode(), retCodeConfig.getDuplicateFamily())) {
                Validations.check(retCodeConfig.getDuplicateFamily(), newProductRequest.getIdentifier());
            } else {
                Validations.check(new OmCode(retCodeConfig.getDuplicateLot(), vendorLotReceiveParams.getLotID()));
            }
        }catch (ServiceException e){
            throw e;
        }


        //-----------------------------------
        //   Adjust split number if need.
        //-----------------------------------
        log.debug("[step-5] Adjust split number if need.");
        CimLotFamily newLotFamily;
        newLotFamily = newCimLot==null?null:newCimLot.getLotFamily();
        Validations.check(CimObjectUtils.isEmpty(newLotFamily), retCodeConfig.getNotFoundLotFamily());

        Boolean notInheritedFlag = newLotFamily.isNewlyCreated();
        log.trace("notInheritedFlag : {}", notInheritedFlag);
        if (notInheritedFlag) {

            // Eric-BUG-6382
            /*String duplicationAllowableFlag =  environmentVariableManager.getValue(EnvConst.OM_DUPLICATE_FAMILY_LOT_ENABLE);

            if (0 == duplicationAllowableFlag.compareToIgnoreCase(BizConstant.VALUE_ZERO)) {
                lotFamilyMethod.lotFamilyDuplicationCheckDR(objCommon, new ObjectIdentifier(newLotFamily.getIdentifier()));
            }*/
            // Eric-BUG-6382

            Outputs.ObjLotFamilySplitNoAdjustOut objLotFamilySplitNoAdjustOut = lotFamilyMethod.lotFamilySplitNoAdjust(objCommon, new ObjectIdentifier(newLotFamily.getIdentifier(), newLotFamily.getPrimaryKey()));
        }

        //------------------------------
        // Set Lot info
        //------------------------------
        log.debug("[step-6] Set Lot info");
        com.fa.cim.newcore.bo.person.CimPerson personBO = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        log.debug("person : {}", personBO);
        Validations.check(CimObjectUtils.isEmpty(personBO), new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));

        //【jerry】 bug -> 111 :This should be empty because this is a vendor lot
        //lot.setProductRequestID(vendorLotReceiveParams.getProductID().getValue());
        newCimLot.setAllStatesForVendorLot();
        newCimLot.setVendorLot(vendorLotReceiveParams.getVendorLotID());
        newCimLot.setVendor(vendorLotReceiveParams.getVendorID());
        newCimLot.setProductQuantity(0); //productWaferCount
        newCimLot.setControlQuantity(0);
        //[neko] below set wafercount and setNotAllocatedQuantity
        newCimLot.setVendorLotQuantity(vendorLotReceiveParams.getProductWaferCount());
        newCimLot.setBank(bankBO);
        //【jerry】 bug -> 111 :This should be empty because this is a vendor lot
        //lot.setManufacturingLayer(productSpecification.getManufacturingLayer());
        //[neko] new BO doesn't have this method
        //lot.setCreatedTime(new Timestamp(System.currentTimeMillis()));
        newCimLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        newCimLot.setLastClaimedPerson(personBO);
        newCimLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        newCimLot.setStateChangedPerson(personBO);
        newCimLot.setInventoryStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        newCimLot.setInventoryStateChangedPerson(personBO);
        //【jerry】 bug -> 111 :This should be empty because this is a vendor lot
        newCimLot.makeWaitUse();



        //-----------------------
        // Set output structure
        //-----------------------
        //cimProductRequest.save(productRequest);
        log.debug("lot : {}", newCimLot);

         // 2019/9/26 [neko] there's no save() method in original method
        //   productManager.save(lot);

        //【add】add by bear
        Results.VendorLotReceiveReqResult receiveReqResult = new Results.VendorLotReceiveReqResult();
        receiveReqResult.setCreatedLotID(assignedLotID);

        return receiveReqResult;
    }



    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param equipmentID
     * @param strStartCassette
     * @param operation
     * @return com.fa.cim.dto.RetCode<java.lang.Object>
     * @author Ho
     * @date 2018/10/31 15:46:32
     */
    @Override
    public void lotCheckConditionForOperationForInternalBuffer(Infos.ObjCommon strObjCommonIn, ObjectIdentifier equipmentID, List<Infos.StartCassette> strStartCassette, String operation) {

        /*-------------------------------------------------------------------------------------*/
        /*                                                                                     */
        /*   Check Condition for controlJobID, equipmentID, lotXxxxState, entityInhibition,    */
        /*   minWaferCount                                                                     */
        /*                                                                                     */
        /*-------------------------------------------------------------------------------------*/

        /*-----------------------------------------*/
        /*   Get Machine Object for Recipe Check   */
        /*-----------------------------------------*/
        CimMachine aMachine  = baseCoreFactory.getBO(CimMachine.class, equipmentID);
        Validations.check(null == aMachine, new OmCode(retCodeConfig.getNotFoundEqp(), equipmentID.getValue()));
        int SCLength = CimArrayUtils.getSize(strStartCassette);

        if( CimStringUtils.equals( operation, BizConstant.SP_OPERATION_OPESTART)
         || CimStringUtils.equals( operation, BizConstant.SP_OPERATION_CASSETTEDELIVERY )
         || CimStringUtils.equals( operation, BizConstant.SP_OPERATION_STARTRESERVATION)
         || CimStringUtils.equals( operation, BizConstant.SP_OPERATION_NPWCARRIERXFER) ) {
            //-----------------------------
            //  Check InPostProcessFlag
            //-----------------------------
            for(int i = 0; i < SCLength; i++ ) {
                //---------------------------------------
                //  Get InPostProcessFlag of Cassette
                //---------------------------------------
                Infos.StartCassette startCassette = strStartCassette.get(i);
                // step1 - cassette_inPostProcessFlag_Get
                Boolean strCassetteInPostProcessFlagGetOut = cassetteMethod.cassetteInPostProcessFlagGet(strObjCommonIn, startCassette.getCassetteID());

                //---------------------------------------------------
                //  If Cassette is in post process, returns error
                //---------------------------------------------------
                Validations.check(strCassetteInPostProcessFlagGetOut, new OmCode(retCodeConfig.getCassetteInPostProcess(), ObjectIdentifier.fetchValue(startCassette.getCassetteID())));
                //-------------------------------------------------------
                // Check cassette InterFabXfer State
                //-------------------------------------------------------
                // step2 - cassette_interFabXferState_Get
                String strCassetteInterFabXferStateGetOut = cassetteMethod.cassetteInterFabXferStateGet(strObjCommonIn, startCassette.getCassetteID());
                Validations.check(CimStringUtils.equals(BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING, strCassetteInterFabXferStateGetOut)
                        , new OmCode(retCodeConfig.getInterfabInvalidCassetteTransferStateForRequest(), startCassette.getCassetteID().getValue(), strCassetteInterFabXferStateGetOut) );

                List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
                int lotLen = CimArrayUtils.getSize(strLotInCassette);
                for(int j=0; j<lotLen; j++ ) {
                    Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                    if( !CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag())) {
                        continue;
                    }
                    //--------------------------------
                    // Check lot interFabXfer State
                    //--------------------------------
                    // step3 - lot_interFabXferState_Get
                    String strLot_interFabXferState_Get_out = lotInterFabXferStateGet(strObjCommonIn, lotInCassette.getLotID());
                    if( CimStringUtils.equals(strLot_interFabXferState_Get_out, BizConstant.SP_INTERFAB_XFERSTATE_REQUIRED)
                     || CimStringUtils.equals(strLot_interFabXferState_Get_out, BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING)) {
                        throw new ServiceException(new OmCode(retCodeConfig.getInterfabInvalidLotXferstateForReq()
                         , lotInCassette.getLotID().getValue(),strLot_interFabXferState_Get_out ));
                    }
                }
            }
        }
        /*-----------------------------------------------------*/
        /*   Check for NPWCarrierXfer                          */
        /*   The foolowing condition is checked.               */
        /*                                                     */
        /*   - holdState      : NotOnHold                      */
        /*   - inventoryState : InBank                         */
        /*   - finishedState  : Completed                      */
        /*   - lot's BankID   : same as eqp-defined CtrlBank   */
        /*                                                     */
        /*-----------------------------------------------------*/
        if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_NPWCARRIERXFER)) {
            //----------------------------------------
            //   Get eqp's controlBnak information
            //----------------------------------------
            // step4 - equipment_bankID_Get
            Outputs.ObjEquipmentBankIDGetOut strEquipment_bankID_Get_out = equipmentMethod.equipmentBankIDGet(strObjCommonIn, equipmentID);

            for (int i=0; i < SCLength; i++ ) {
                 /*------------------------*/
                /*   Omit EmptyCassette   */
                /*------------------------*/
                Infos.StartCassette startCassette = strStartCassette.get(i);
                if ( CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE) ) {
                    throw new ServiceException(new OmCode(retCodeConfig.getInvalidLoadpurpose(), startCassette.getLoadPurposeType(), startCassette.getCassetteID().getValue()));
                }

                List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
                int LICLength = CimArrayUtils.getSize(strLotInCassette);

                for (int j=0; j < LICLength; j++ ) {
                    //-----------------------------------
                    //   Get Lot Object
                    //-----------------------------------
                    Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                    CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                    Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(),lotInCassette.getLotID().getValue()));
                    //-----------------------------------
                    //   Get and check lot's xxxxState
                    //-----------------------------------
                    String holdState = aLot.getLotHoldState();
                    if ( !CimStringUtils.equals(holdState, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD) ) {
                        throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotHoldStat(), lotInCassette.getLotID().getValue(), holdState));
                    }
                    String inventoryState = aLot.getLotInventoryState();
                    if ( !CimStringUtils.equals(inventoryState, BizConstant.SP_LOT_INVENTORYSTATE_INBANK) ) {
                        Validations.check(retCodeConfig.getInvalidLotInventoryStat(), ObjectIdentifier.fetchValue(lotInCassette.getLotID()),
                                inventoryState);
                    }

                    String finishedState = aLot.getLotFinishedState();
                    if (!CimStringUtils.equals(finishedState, BizConstant.CIMFW_LOT_FINISHEDSTATE_COMPLETED)) {
                        throw new ServiceException(new OmCode(retCodeConfig.getInvalidFinishedStat(), finishedState));
                    }
                    //-----------------------------------
                    //   Get and check lot's bankID
                    //-----------------------------------
                    com.fa.cim.newcore.bo.factory.CimBank aPosBank= aLot.getBank();
                    Validations.check(null == aPosBank, new OmCode(retCodeConfig.getNotFoundBank(), ""));
                    ObjectIdentifier lotBankID = aPosBank.getBankID();
                    if ( CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT)) {
                        if ( !ObjectIdentifier.equalsWithValue(lotBankID, strEquipment_bankID_Get_out.getSideDummyBankID())) {
                            throw new ServiceException(new OmCode(retCodeConfig.getLotBankDifferent(), lotBankID.getValue(), strEquipment_bankID_Get_out.getSideDummyBankID().getValue()));
                        }
                    } else if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY) ) {
                        if ( !ObjectIdentifier.equalsWithValue(lotBankID, strEquipment_bankID_Get_out.getFillerDummyBankID())) {
                            throw new ServiceException(new OmCode(retCodeConfig.getLotBankDifferent(),lotBankID.getValue(), strEquipment_bankID_Get_out.getFillerDummyBankID().getValue()));
                        }
                    } else  if ( CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT)) {
                        if ( !ObjectIdentifier.equalsWithValue(lotBankID, strEquipment_bankID_Get_out.getMonitorBankID())) {
                            throw new ServiceException(new OmCode(retCodeConfig.getLotBankDifferent(), lotBankID.getValue(), strEquipment_bankID_Get_out.getMonitorBankID().getValue()));
                        }
                    } else {
                        throw new ServiceException(retCodeConfig.getInvalidInputParam());
                    }
                }
            }
            //--------------------------------------------------------
            //   Lot related check for NPWCarrierXfer is Finished
            //   return to caller with RC_OK ...
            //--------------------------------------------------------
            return;
        }
        /*------------------------------------------------------------*/
        /*   Get Equipment's MultiRecipeCapability for Recipe Check   */
        /*------------------------------------------------------------*/
        String multiRecipeCapability = aMachine.getMultipleRecipeCapability();
        /*---------------------------------------------*/
        /*   Get Equipment's Process Batch Condition   */
        /*---------------------------------------------*/
        // step5 - equipment_processBatchCondition_Get
        Outputs.ObjEquipmentProcessBatchConditionGetOut strEquipment_processBatchCondition_Get_out = equipmentMethod.equipmentProcessBatchConditionGet(strObjCommonIn, equipmentID);
        List<Infos.EqpInternalBufferInfo> strEquipment_internalBufferInfo_Get_out = null;
        if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART)) {
            strEquipment_internalBufferInfo_Get_out = equipmentMethod.equipmentInternalBufferInfoGet(strObjCommonIn, equipmentID);
        }
         /*-------------------------*/
        /*   Check Lot Condition   */
        /*-------------------------*/
        int totalWaferCount   = 0;

        ObjectIdentifier baseLogicalRecipeID=null;
        ObjectIdentifier baseMachineRecipeID=null;
        boolean baseRecipeSetFlag=false;

        for (int i=0; i < SCLength; i++ ) {
            List<Infos.LotInCassette> strLotInCassette = strStartCassette.get(i).getLotInCassetteList();
            int LICLength = CimArrayUtils.getSize(strLotInCassette);
            for (int j=0; j < LICLength; j++) {
                /*-------------------------------------------*/
                /*   Check OpeStartFlag for Batch-Type Eqp   */
                /*-------------------------------------------*/
                Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                if ( CimStringUtils.equals(operation ,BizConstant.SP_OPERATION_OPESTART)
                  || CimStringUtils.equals(operation ,BizConstant.SP_OPERATION_CASSETTEDELIVERY)
                  || CimStringUtils.equals(operation ,BizConstant.SP_OPERATION_STARTRESERVATION)) {
                    if ( CimStringUtils.equals(multiRecipeCapability, BizConstant.SP_EQP_MULTIRECIPECAPABILITY_BATCH) ) {

                        if ( !CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag())) {
                            throw new ServiceException(retCodeConfig.getNeedToSpecifyAllLotInCassette());
                        }
                    }
                }
                boolean operationStartFlag = CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag());
                if ( !operationStartFlag ) {
                    continue;
                }

                CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotInCassette.getLotID())));
                CimControlJob aControlJob = aLot.getControlJob();

                ObjectIdentifier lotID = aLot.getLotID();
                if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART)) {
                    if ( aControlJob != null) {
                         /*---------------------------------------------*/
                        /*    Check Lot's controlJob exists in shelf   */
                        /*---------------------------------------------*/
                        ObjectIdentifier controlJobID = aControlJob.getControlJobID();
                        boolean bFoundCtrlJobFlg = false;
                        int nBufferCategoryLen = CimArrayUtils.getSize(strEquipment_internalBufferInfo_Get_out);
                        for (int k=0; k < nBufferCategoryLen; k++ ) {
                            List<Infos.ShelfInBuffer> strShelfInBuffer = strEquipment_internalBufferInfo_Get_out.get(k).getShelfInBufferList();
                            int nShelfLen = CimArrayUtils.getSize(strShelfInBuffer);
                            for(int m=0; m < nShelfLen; m++ ) {
                                if (ObjectIdentifier.equalsWithValue(controlJobID, strShelfInBuffer.get(m).getControlJobID())) {
                                    bFoundCtrlJobFlg = true;
                                    break;
                                }
                            }
                        }

                        if ( !bFoundCtrlJobFlg ) {
                            throw new ServiceException(retCodeConfig.getLotPortControlJobUnMatch());
                        }
                    }
                } else {
                    if ( aControlJob!=null ) {
                        throw new ServiceException(new OmCode(retCodeConfig.getLotControlJobidFilled(), lotID.getValue(), aControlJob.getIdentifier()));
                    }
                }
                  /*-------------------------------*/
                /*   Get and Check Lot's State   */
                /*-------------------------------*/
                String holdState = aLot.getLotHoldState();
                String processState = aLot.getLotProcessState();
                String inventoryState = aLot.getLotInventoryState();

                if ( !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL)
                  && !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE)) {
                    if ( !CimStringUtils.equals(holdState, CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD) ) {
                        throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotHoldStat(), lotID.getValue()));
                    }
                }

                if ( !CimStringUtils.equals(processState, BizConstant.SP_LOT_PROCSTATE_WAITING) ) {
                    throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotProcessState(), lotID.getValue(), processState));
                }

                if ( !CimStringUtils.equals(inventoryState, BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR) ) {
                    Validations.check(retCodeConfig.getInvalidLotInventoryStat(), ObjectIdentifier.fetchValue(lotID),
                            inventoryState);
                }
                 /*------------------------------------------------------------------------*/
                /*   Check EqpMonitor Job for CassetteDelivery/StartReservation/OpeStart  */
                /*------------------------------------------------------------------------*/
                if ( CimStringUtils.equals( StandardProperties.OM_AUTOMON_FLAG.getValue(), "1" )
                        && ( CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                        || CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_DUMMYLOT))
                        && ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART)
                        || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_CASSETTEDELIVERY)
                        || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATION))) {
                    // step7 - lot_eqpMonitorSectionInfo_GetForJob
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut strLot_eqpMonitorSectionInfo_GetForJob_out = lotMethod.lotEqpMonitorSectionInfoGetForJob(strObjCommonIn, lotInCassette.getLotID());

                    if (CimStringUtils.equals(strLot_eqpMonitorSectionInfo_GetForJob_out.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)) {
                        ProductDTO.EqpMonitorJobLotInfo aEqpMonitorJobLotInfo = aLot.getEqpMonitorJobLotInfo();
                        if(!CimStringUtils.equals(aEqpMonitorJobLotInfo.getEquipmentID().getValue(), equipmentID.getValue())) {
                            throw new ServiceException(new OmCode(retCodeConfig.getDiffEquipmentMonitorJobEquipmentID(), ObjectIdentifier.fetchValue(lotID)));
                        }

                        ObjectIdentifier eqpMonitorID    = aEqpMonitorJobLotInfo.getEqpMonitorID();
                        ObjectIdentifier eqpMonitorJobID = aEqpMonitorJobLotInfo.getEqpMonitorJobID();
                        Long startSeqNo = aEqpMonitorJobLotInfo.getStartSeqNo();

                        CimEqpMonitor anEqpMonitor = baseCoreFactory.getBO(CimEqpMonitor.class, eqpMonitorID);
                        Validations.check(null == anEqpMonitor, new OmCode(retCodeConfig.getNotFoundEqpMonitor(), ObjectIdentifier.fetchValue(eqpMonitorID)));
                        CimEqpMonitorJob anEqpMonitorJob =  baseCoreFactory.getBO(CimEqpMonitorJob.class, eqpMonitorJobID);
                        Validations.check(null == anEqpMonitorJob, new OmCode(retCodeConfig.getNotFoundEqpMonitorJob(), ObjectIdentifier.fetchValue(eqpMonitorJobID)));
                        String strEqpMonitorJobStatus = anEqpMonitorJob.getMonitorJobStatus();
                        if(  !CimStringUtils.equals(strEqpMonitorJobStatus, BizConstant.SP_EQPMONITORJOB_STATUS_READY)
                          && !CimStringUtils.equals(strEqpMonitorJobStatus, BizConstant.SP_EQPMONITORJOB_STATUS_EXECUTING)) {
                            throw new ServiceException(new OmCode(retCodeConfig.getInvalidEqpMonitorJobStatus(), strEqpMonitorJobStatus));
                        }

                        List<MachineDTO.EqpMonitorLotInfo> strEqpMonitorLotInfoSeq = anEqpMonitorJob.allEqpMonitorLots();
                        for (i = 0; i< CimArrayUtils.getSize(strEqpMonitorLotInfoSeq); i++) {
                            if ( CimStringUtils.equals(strEqpMonitorLotInfoSeq.get(i).getMonitorLotStatus(), BizConstant.SP_EQPMONITORJOB_STATUS_RESERVED) ) {
                                if(startSeqNo > strEqpMonitorLotInfoSeq.get(i).getStartSeqNo()) {
                                    throw new ServiceException(retCodeConfig.getMismatchEqpMonitorStartSeq());
                                }
                            }
                        }
                    }
                }
                  /*-----------------------------------------------------------*/
                /*   Check Start Equipment for OpeStart / StartReservation   */
                /*-----------------------------------------------------------*/
                if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART)
                  || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_CASSETTEDELIVERY)
                  || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATION)) {
                    List<CimMachine> aMachineSeq = aLot.getQueuedMachines();
                    boolean matchFlag = false;
                    int MachineSeqLength = CimArrayUtils.getSize(aMachineSeq);
                    for (int k=0; k < MachineSeqLength; k++) {
                        CimMachine machine = aMachineSeq.get(k);
                        ObjectIdentifier qEquipmentID = new ObjectIdentifier(machine.getIdentifier(), machine.getPrimaryKey());
                        if (ObjectIdentifier.equalsWithValue(qEquipmentID, equipmentID)) {
                            matchFlag = true;
                            break;
                        }
                    }

                    if (!matchFlag ) {
                        throw new ServiceException(retCodeConfig.getNotCorrectEqpForOperationStart());
                    }
                    /*--------------------------------------------------------*/
                    /*   Check Current Operation is Bank-In Operation or Not  */
                    /*--------------------------------------------------------*/
                    boolean bankInFlag = aLot.isBankInRequired();
                    if ( bankInFlag ) {
                        throw new ServiceException(retCodeConfig.getBankinOperation());
                    }
                }
                 /*----------------------------------*/
                /*   Check Equipment Availability   */
                /*----------------------------------*/
                if ( !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL)
                  && !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE)) {
                    List<ObjectIdentifier> checkLotIDs=new ArrayList<>();
                    checkLotIDs.add(lotInCassette.getLotID());
                    // step8 - equipment_CheckAvailForLot
                    equipmentMethod.equipmentCheckAvailForLot(strObjCommonIn, equipmentID, checkLotIDs);
                      /*--------------------------------------------*/
                    /*   Save Total Wafer Count to be Processed   */
                    /*--------------------------------------------*/
                    totalWaferCount += CimArrayUtils.getSize(lotInCassette.getLotWaferList());

                }
                /*----------------------------------------------------------*/
                /*   Check Condition for Logical Recipe / Machine Recipe    */
                /*----------------------------------------------------------*/
                if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART)
                  || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_CASSETTEDELIVERY)
                  || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATION) ) {
                    if ( CimStringUtils.equals(multiRecipeCapability, BizConstant.SP_EQP_MULTIRECIPECAPABILITY_MULTIPLERECIPE) ) {
                        //result.setReturnCode(retCodeConfig.getSucc());
                    } else {
                        if ( !baseRecipeSetFlag ) {
                            baseLogicalRecipeID = lotInCassette.getStartRecipe().getLogicalRecipeID();
                            baseMachineRecipeID = lotInCassette.getStartRecipe().getMachineRecipeID();
                            baseRecipeSetFlag = true;
                        } else {

                            if ( ObjectIdentifier.equalsWithValue(baseLogicalRecipeID, lotInCassette.getStartRecipe().getLogicalRecipeID())
                              && ObjectIdentifier.equalsWithValue(baseMachineRecipeID, lotInCassette.getStartRecipe().getMachineRecipeID())) {
                                //result.setReturnCode(retCodeConfig.getSucc());
                            } else {
                                throw new ServiceException(retCodeConfig.getInvalidRecipeConditionForEqp());
                            }
                        }
                    }
                    /*--------------------------------------------------------------*/
                    /*   Check if the recipe is available on Eqp.                   */
                    /*   This check is skipped when recipe is overwritten by DOC.   */
                    /*--------------------------------------------------------------*/
                    String fpcAdop = StandardProperties.OM_DOC_ENABLE_FLAG.getValue();
                    long tmpFPCAdoptFlag = null != fpcAdop ? Long.parseLong(fpcAdop) : 0;
                    boolean bFPCFlag = false;
                    if( 1 == tmpFPCAdoptFlag ) {
                        // step9 - lot_effectiveFPCInfo_Get
                        Outputs.ObjLotEffectiveFPCInfoGetOut objLotEffectiveFPCInfoGetOut = lotMethod.lotEffectiveFPCInfoGet(strObjCommonIn, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEINFO, equipmentID, lotID);
                        if (CimBooleanUtils.isTrue(objLotEffectiveFPCInfoGetOut.isMachineRecipeActionRequiredFlag())) {
                            bFPCFlag = true;
                        }
                    }
                    if ( !bFPCFlag ) {
                        com.fa.cim.newcore.bo.recipe.CimMachineRecipe aMachineRecipe = baseCoreFactory.getBO(com.fa.cim.newcore.bo.recipe.CimMachineRecipe.class, lotInCassette.getStartRecipe().getMachineRecipeID());
                        boolean bUsedFlag = aMachineRecipe.isUsedBy(aMachine);
                        if ( !bUsedFlag ){
                            throw new ServiceException(new OmCode(retCodeConfig.getInvalidRecipeForEqp(), ObjectIdentifier.fetchValue(lotInCassette.getStartRecipe().getMachineRecipeID())
                                    , ObjectIdentifier.fetchValue(equipmentID)));
                        }
                    }
                    /*------------------------------------------*/
                    /*   Check condition for recipe / chamber   */
                    /*------------------------------------------*/
                    String tmpChamberCheckPolicy = StandardProperties.OM_CHAMBER_CHK_RULE.getValue();
                    if ( CimStringUtils.equals("1",tmpChamberCheckPolicy) ) {
                        Inputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_in = new Inputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn();
                        strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_in.setLotID(lotInCassette.getLotID());
                        strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_in.setEquipmentID(equipmentID);
                        strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_in.setLogicalRecipeID(lotInCassette.getStartRecipe().getLogicalRecipeID());
                        strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_in.setMachineRecipeID(lotInCassette.getStartRecipe().getMachineRecipeID());
                        strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_in.setInhibitCheckFlag(false);
                        // step10 - logicalRecipe_candidateChamberInfo_GetByMachineRecipe
                        Outputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_out = logicalRecipeMethod.logicalRecipeCandidateChamberInfoGetByMachineRecipe(strObjCommonIn, strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_in);
                        if ( strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_out.isMultiChamberFlag()) {
                            if ( strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_out.isRecipeDefinedFlag()
                                    &&    0 == CimArrayUtils.getSize(strLogicalRecipe_candidateChamberInfo_GetByMachineRecipe_out.getCandidateChamberList()) ) {
                                throw new ServiceException(new OmCode(retCodeConfig.getChamberNotAvailableForLot(), lotID.getValue()));
                            }
                        }
                    }
                }
                //------------------------------------------------------------//
                //   Check Validity of In-Parm's route/operationNumber/logicalRecipe    //
                //------------------------------------------------------------//
                if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART)
                  || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_CASSETTEDELIVERY)
                  || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATION)) {
                    if ( !ObjectIdentifier.isEmptyWithValue(lotInCassette.getStartOperationInfo().getProcessFlowID())
                      && !CimStringUtils.isEmpty(lotInCassette.getStartOperationInfo().getOperationNumber()) ) {
                        // step11 - lot_currentOperationInfo_Get
                        Outputs.ObjLotCurrentOperationInfoGetOut strLot_currentOperationInfo_Get_out = this.lotCurrentOperationInfoGet(strObjCommonIn, lotInCassette.getLotID());
                        if ( ObjectIdentifier.equalsWithValue(lotInCassette.getStartOperationInfo().getProcessFlowID(), strLot_currentOperationInfo_Get_out.getRouteID())
                          && CimStringUtils.equals(lotInCassette.getStartOperationInfo().getOperationNumber()  , strLot_currentOperationInfo_Get_out.getOperationNumber()) ) {
                            log.info("Route/Operation check OK. Go ahead...");
                        } else {
                            throw new ServiceException(retCodeConfig.getInvalidInputParam());
                        }
                    } else {
                        log.info("Route/Operation check skipped. Go ahead...");
                    }
                    if ( !ObjectIdentifier.isEmptyWithValue(lotInCassette.getStartRecipe().getLogicalRecipeID())) {
                         Outputs.ObjLotRecipeGetOut strLot_recipe_Get_out = this.lotRecipeGet(strObjCommonIn, equipmentID, lotInCassette.getLotID());
                      if (ObjectIdentifier.equalsWithValue(lotInCassette.getStartRecipe().getLogicalRecipeID(), strLot_recipe_Get_out.getLogicalRecipeId())) {
                        } else {
                            throw new ServiceException(retCodeConfig.getInvalidInputParam());
                        }
                    }
                }
                //------------------------------------------------//
                //   Check Lot condition in Bonding Flow Section  //
                //------------------------------------------------//
                if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART)
                  || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATION)) {
                    //----------------------------------//
                    //   Get Bonding Flow Section Name  //
                    //----------------------------------//
                    String bondFlowName = aLot.getBondingFlowName();
                    if ( !CimStringUtils.isEmpty(bondFlowName) ) {
                        // step13 - lot_bondingGroupID_GetDR
                        String strLot_bondingGroupID_GetDR_out = this.lotBondingGroupIDGetDR(strObjCommonIn, lotInCassette.getLotID());
                        if ( CimStringUtils.isEmpty( strLot_bondingGroupID_GetDR_out ) ) {
                            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundBondingGroupForLot(), ObjectIdentifier.fetchValue(lotInCassette.getLotID())));
                        } else {
                            com.fa.cim.newcore.bo.pd.CimProcessOperation aPosPO = aLot.getProcessOperation();
                            Validations.check(aPosPO == null,retCodeConfig.getNotFoundProcessOperation());
                            String operationNo = aPosPO.getOperationNumber();
                            boolean bValidEqpForBndFlow = true;
                            if( aPosPO.isBondingFlowSectionTargetOperation()){
                                bValidEqpForBndFlow = false;
                            }

                            if ( !bValidEqpForBndFlow ) {
                                throw new ServiceException(new OmCode(retCodeConfig.getBondGroupInvalidEqp(), ObjectIdentifier.fetchValue(aLot.getLotID()), equipmentID.getValue(), aPosPO.getOperationName()));
                            }
                        }
                    }
                }
            }
        }

        if ( !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL)
          && !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_CASSETTEDELIVERY)
          && !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE) ) {
            /*-------------------------------*/
            /*   Check Minimun Wafer Count   */
            /*-------------------------------*/
            if (strEquipment_processBatchCondition_Get_out.getMinWaferSize() > totalWaferCount) {
                throw new ServiceException(retCodeConfig.getInvalidInputWaferCount());
            }
        }
        /*---------------------------------------------------------------------*/
        /*   Get and Check Entity Inhibition for OpeStart / StartReservation   */
        /*---------------------------------------------------------------------*/
        if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART)
          || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_CASSETTEDELIVERY)
          || CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATION) ) {
            boolean bInhibitCheck = true;
            if ( CimStringUtils.equals(operation, BizConstant.SP_OPERATION_CASSETTEDELIVERY) ) {
                String inhibitCheckInDeliveryFlag = "0";

                String cimEnvironmentVariableBO = StandardProperties.OM_CONSTRAINT_CHK_FOR_DELIVERY.getValue();
                if (!CimStringUtils.isEmpty(cimEnvironmentVariableBO)) {
                    inhibitCheckInDeliveryFlag = cimEnvironmentVariableBO;
                }
                if ( CimStringUtils.equals("0", inhibitCheckInDeliveryFlag) ) {
                    bInhibitCheck = false;
                }
            }
            if ( bInhibitCheck ) {
                List<ObjectIdentifier> checkLotIDs=new ArrayList<>();
                SCLength = CimArrayUtils.getSize(strStartCassette);
                for (int i=0; i < SCLength; i++) {
                    List<Infos.LotInCassette> strLotInCassette = strStartCassette.get(i).getLotInCassetteList();
                    int LICLength = CimArrayUtils.getSize(strLotInCassette);
                    for (int j=0; j < LICLength; j++) {
                        if ( CimBooleanUtils.isTrue(strLotInCassette.get(j).getMoveInFlag())) {
                            checkLotIDs.add(strLotInCassette.get(j).getLotID());
                        }
                    }
                }
                // step14 - equipment_CheckInhibitForLotWithMachineRecipe
                equipmentMethod.equipmentCheckInhibitForLotWithMachineRecipe(strObjCommonIn, equipmentID, checkLotIDs, strStartCassette);
            }
        }
        /*----------------------*/
        /*   Return to Caller   */
        /*----------------------*/
        return;
    }

    @Override
    public String lotTypeLotIDAssign(Infos.ObjCommon objCommon, String lotType, ObjectIdentifier productID, String subLotType) {
        // step1 - get object reference of product spec. this ID must be given from input parameter.
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification aProductSpecification = baseCoreFactory.getBO(com.fa.cim.newcore.bo.prodspec.CimProductSpecification.class, productID);
        Validations.check(aProductSpecification == null, new OmCode(retCodeConfig.getInvalidProdId(), productID.getValue()));
        // step2 - get lotType
        CimLotType aPosLotType = productManager.findLotTypeNamed(lotType);
        log.info("lotType:{}", lotType);
        Validations.check(aPosLotType == null, new OmCode(retCodeConfig.getNotFoundLotType(), ""));
        // step3 - assign new lot ID
        return aPosLotType.nextIdentifier(aProductSpecification, subLotType);
    }


    /*
     * description:
     *
     * change history:
     * date             defect#             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * @author jerry
     * @date 2018/4/26 10:43
     * @param null
     * @return
     */

    @Override
    public Results.LotQuantitySubtractResult lotQuantitySubtract(Infos.ObjCommon objCommon, Params.VendorLotReturnParams vendorLotReturnParams) {
        CimLot lotBO = baseCoreFactory.getBO(CimLot.class, vendorLotReturnParams.getLotID());

        Integer aCurrentCount = lotBO.getQuantity();  // The numbers of products (wafers) in the lot.
        Integer aCurrentProdCount = lotBO.getProductQuantity(); // The numbers of production products (wafers) in the lot.
        Integer anAfterCount;

        aCurrentProdCount = null == aCurrentProdCount ? 0 : aCurrentProdCount;
        Integer aReturnCapableCount = aCurrentCount - aCurrentProdCount;
        log.debug("ProductWaferCount : {}", aCurrentProdCount);
        Validations.check(vendorLotReturnParams.getProductWaferCount() > aReturnCapableCount, new OmCode(retCodeConfig.getCannotVendorLotReturn(), String.valueOf(aCurrentCount), String.valueOf(aCurrentProdCount), String.valueOf(aReturnCapableCount)));

        anAfterCount = aCurrentCount - vendorLotReturnParams.getProductWaferCount();
        Validations.check(0 > anAfterCount, retCodeConfig.getInvalidParameter());
        log.debug("new Wafer Count : {}", anAfterCount);

        lotBO.setVendorLotQuantity(anAfterCount);
        lotBO.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());

        com.fa.cim.newcore.bo.person.CimPerson personBO = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(CimObjectUtils.isEmpty(personBO), new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
        lotBO.setLastClaimedPerson(personBO);

        com.fa.cim.newcore.bo.prodspec.CimProductSpecification productSpecificationBO = lotBO.getProductSpecification();
        log.debug("productSpecification : {}", productSpecificationBO);
        Validations.check(CimObjectUtils.isEmpty(productSpecificationBO), retCodeConfig.getNotFoundProductSpec());

        //lotQuantitySubtractResult.setProductID(productSpecification.getMonitorProductSpecificationID());
        //lotQuantitySubtractResult.setProductType(lot.getSourceLotType());
        //lotQuantitySubtractResult.setProductWaferCount(anAfterCount);
        //lotQuantitySubtractResult.setVendorID(lot.getVendorLotID());
        //lotQuantitySubtractResult.setBankID(lot.getBank());

        log.trace("0 == anAfterCount : {}", 0 == anAfterCount);
        if (0 == anAfterCount) {
            CimLotFamily lotFamilyBO = lotBO.getLotFamily();
            log.debug("lotFamily : {}", lotFamilyBO);
            Validations.check(CimObjectUtils.isEmpty(lotFamilyBO), retCodeConfig.getNotFoundLotFamily());

            lotFamilyBO.archiveLot(lotBO);
            lotFamilyBO.removeCurrentLot(lotBO);
            lotBO.makeEmptied();

            String envEventCreateType = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
            log.trace("StringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED), envEventCreateType)\n" +
                            "                    || StringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED), envEventCreateType) : {}"
                    , CimStringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED), envEventCreateType)
                            || CimStringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED), envEventCreateType));
            if (CimStringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED), envEventCreateType)
                    || CimStringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED), envEventCreateType)) {
                com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = lotBO.getProcessOperation();
                log.trace("null != processOperation : {}", null != processOperation);
                if (null != processOperation) {
                    processMethod.poDelQueuePutDR(objCommon, vendorLotReturnParams.getLotID());

                }
            }
        }

        Results.LotQuantitySubtractResult lotQuantitySubtractResult = new Results.LotQuantitySubtractResult();
        lotQuantitySubtractResult.setVendorLotID(lotBO.getVendorLot());
        lotQuantitySubtractResult.setVendorID(lotBO.getVendor());
        lotQuantitySubtractResult.setProductID(productSpecificationBO.getIdentifier());
        lotQuantitySubtractResult.setProductCount(lotBO.getQuantity());
        lotQuantitySubtractResult.setProductType(productSpecificationBO.getProductType());
        lotQuantitySubtractResult.setBankID(new ObjectIdentifier(lotBO.getBank().getIdentifier(), lotBO.getBank().getPrimaryKey()));

        return lotQuantitySubtractResult;
    }

    /*
     * description:
     *
     * change history:
     * date             defect#             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * @author jerry
     * @date 2018/4/26 10:43
     * @param null
     * @return
     */

    @Override
    public Results.LotFillInTxBKC007Result lotFillInTxBKC007(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {

        Results.LotFillInTxBKC007Result lotFillInTxBKC007Result = new Results.LotFillInTxBKC007Result();
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        lotFillInTxBKC007Result.setLotID(lotID);
        lotFillInTxBKC007Result.setVendorLotID(aLot.getVendorLot());

        ProductSpecification productSpecification = aLot.getProductSpecification();
        lotFillInTxBKC007Result.setProductID(new ObjectIdentifier(productSpecification.getIdentifier(), productSpecification.getPrimaryKey()));
        lotFillInTxBKC007Result.setProductWaferCount(aLot.getQuantity());
        lotFillInTxBKC007Result.setVendorID(aLot.getVendor());
        lotFillInTxBKC007Result.setBankID(new ObjectIdentifier(aLot.getBank().getIdentifier(), aLot.getBank().getPrimaryKey()));

        return lotFillInTxBKC007Result;
    }

    /*
     * description:
     *
     * change history:
     * date             defect#             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * @author jerry
     * @date 2018/4/26 10:43
     * @param null
     * @return
     */

    @Override
    public Results.LotBankHoldResult lotBankHold(Infos.ObjCommon objCommon, ObjectIdentifier lotID,ObjectIdentifier reasonCodeID,String claimMemo) {

        Results.LotBankHoldResult lotBankHoldResult = new Results.LotBankHoldResult();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        try {
            lot.makeOnHold();
        } catch (ServiceException e) {
            throw new ServiceException(retCodeConfig.getInvalidStateTrans());
        }
        ProductDTO.HoldRecord aHoldRecord = new ProductDTO.HoldRecord();
        aHoldRecord.setHoldType(BizConstant.SP_HOLDTYPE_BANKHOLD);
        aHoldRecord.setReasonCode(reasonCodeID);
        aHoldRecord.setHoldPerson(objCommon.getUser().getUserID());
        aHoldRecord.setHoldTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
        aHoldRecord.setRelatedLot(ObjectIdentifier.emptyIdentifier());
        aHoldRecord.setResponsibleOperationFlag(false);
        aHoldRecord.setHoldClaimMemo(claimMemo);
        try {
            lot.addHoldRecord(aHoldRecord);
        } catch (DuplicateRecordException e){
            throw new ServiceException(retCodeConfig.getExistSameHold());
        }
        lot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        CimPerson aPerson = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        lot.setLastClaimedPerson(aPerson);
        lot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        lot.setStateChangedPerson(aPerson);
        Infos.HoldHistory holdHistory = new Infos.HoldHistory();
        holdHistory.setMovementFlag(false);
        holdHistory.setChangeStateFlag(true);
        holdHistory.setHoldType(BizConstant.SP_HOLDTYPE_BANKHOLD);
        holdHistory.setHoldReasonCode(reasonCodeID);
        holdHistory.setHoldPerson(objCommon.getUser().getUserID());
        holdHistory.setHoldTime(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
        holdHistory.setResponsibleOperationFlag(false);
        holdHistory.setResponsibleOperationExistFlag(false);
        holdHistory.setHoldClaimMemo(claimMemo);
        List<Infos.HoldHistory> holdHistoryList = new ArrayList<>();
        holdHistoryList.add(holdHistory);
        lotBankHoldResult.setHoldHistoryList(holdHistoryList);

        return lotBankHoldResult;
    }

    @Override
    public List<Infos.HoldHistory> lotBankHoldRelease(Infos.ObjCommon objCommon,ObjectIdentifier lotID,ObjectIdentifier reasonCodeID,String claimMemo) {

        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        List<ProductDTO.HoldRecord> aHoldRecordList = aLot.allHoldRecords();

        if (CimArrayUtils.getSize(aHoldRecordList) > 1){
            throw new ServiceException(retCodeConfig.getDuplicateBankHold());

        } else if (CimArrayUtils.getSize(aHoldRecordList) == 0){
            throw new ServiceException(new OmCode(retCodeConfig.getNotExistHold(),
                    "*****", ObjectIdentifier.fetchValue(reasonCodeID), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));
        }
        List<Infos.HoldHistory> holdHistoryList = new ArrayList<>();
        if (CimStringUtils.equals(aHoldRecordList.get(0).getHoldType(), BizConstant.SP_HOLDTYPE_BANKHOLD)){
            Infos.HoldHistory history = new Infos.HoldHistory();
            history.setMovementFlag(false);
            history.setChangeStateFlag(true);
            history.setHoldReasonCode(aHoldRecordList.get(0).getReasonCode());
            history.setHoldPerson(aHoldRecordList.get(0).getHoldPerson());
            history.setHoldTime(aHoldRecordList.get(0).getHoldTimeStamp());
            history.setResponsibleOperationFlag(false);
            history.setResponsibleOperationExistFlag(false);
            history.setReleaseReasonCode(reasonCodeID);
            history.setReleaseTime(objCommon.getTimeStamp().getReportTimeStamp());
            history.setReleasePerson(objCommon.getUser().getUserID());
            history.setReleaseClaimMemo(claimMemo);
            holdHistoryList.add(history);
        } else {
            throw new ServiceException(new OmCode(retCodeConfig.getNotExistHold(),aHoldRecordList.get(0).getHoldType(),
                    ObjectIdentifier.fetchValue(reasonCodeID), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));
        }
        try {
            aLot.removeHoldRecord(aHoldRecordList.get(0));
        } catch (Exception e){
            throw new ServiceException(new OmCode(retCodeConfig.getNotExistHold(),aHoldRecordList.get(0).getHoldType(),
                    ObjectIdentifier.fetchValue(reasonCodeID), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));
        }
        try {
            aLot.makeNotOnHold();
        } catch (Exception e){
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidStateTrans(),"*****",BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD));

        }

        aLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        CimPerson person = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        if (CimObjectUtils.isEmpty(person)) {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundPerson(), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));

        }
        aLot.setLastClaimedPerson(person);
        aLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aLot.setStateChangedPerson(person);
        return holdHistoryList;
    }

    @Override
    public Outputs.ObjLotSTBOut lotSTB(Infos.ObjCommon objCommon, ObjectIdentifier productRequestID, Infos.NewLotAttributes newLotAttributes) {
        Outputs.ObjLotSTBOut objLotSTBOut = new Outputs.ObjLotSTBOut();
        //step 1 - Retrieve object reference from product request
        log.info("step 1 - Retrieve object reference from product request");
        com.fa.cim.newcore.bo.planning.CimProductRequest aProductRequest = baseCoreFactory.getBO(com.fa.cim.newcore.bo.planning.CimProductRequest.class, productRequestID);
        Validations.check(aProductRequest == null, new OmCode(retCodeConfig.getNotFoundProductRequest(), productRequestID.getValue()));
        //step 2 - Compare wafer Count
        log.info("step 2 - Compare wafer Count");
        List<Infos.NewWaferAttributes> newWaferAttributesList = newLotAttributes.getNewWaferAttributesList();
        int nInputWaferCount = CimArrayUtils.getSize(newWaferAttributesList);
        int nProdReqWaferCount = aProductRequest.getProductQuantity() == null ? 0 : aProductRequest.getProductQuantity();
        if (nInputWaferCount != nProdReqWaferCount) {
            throw new ServiceException(new OmCode(retCodeConfig.getStbWaferCountNotEnough(), String.valueOf(nInputWaferCount), productRequestID.getValue()));
        }
        //check if the source lot have contanimation level and pr Flag
        Infos.NewWaferAttributes example = newWaferAttributesList.get(0);
        ObjectIdentifier exampleLotID = example.getSourceLotID();
        CimLot exampleLot = baseCoreFactory.getBO(CimLot.class, exampleLotID);
        String contaminationLevel = exampleLot.getContaminationLevel();
        Integer prFlag = exampleLot.getPrFlag();
        for (Infos.NewWaferAttributes attributes : newWaferAttributesList) {
            ObjectIdentifier sourceLotID = attributes.getSourceLotID();
            CimLot tempLot = baseCoreFactory.getBO(CimLot.class, sourceLotID);
            Validations.check(!CimStringUtils.equals(contaminationLevel, tempLot.getContaminationLevel()),
                    retCodeConfigEx.getContaminationWaferChangeState());
            Validations.check(!prFlag.equals(tempLot.getPrFlag()) && (tempLot.getPrFlag() == 1 || prFlag == 1),
                    retCodeConfigEx.getContaminationWaferChangeState());
        }
        // step 3 - Check duplicate about NewWaferID and SourceWaferID
        log.info("step 3 - Check duplicate about NewWaferID and SourceWaferID");
        for (int i = 0; i < nInputWaferCount; i++) {
            int nNewWaferCnt = 0;
            if (!CimStringUtils.isEmpty(newWaferAttributesList.get(i).getNewWaferID().getValue())) {
                for (int j = 0; j < nInputWaferCount; j++) {
                    if (ObjectIdentifier.equalsWithValue(newWaferAttributesList.get(i).getNewWaferID(),
                            newWaferAttributesList.get(j).getNewWaferID())) {
                        nNewWaferCnt++;
                    }
                }
                if (1 != nNewWaferCnt) {
                    throw new ServiceException(retCodeConfig.getInvalidInputParam());
                }
            }
            int nSourceWaferCnt = 0;
            if (!CimStringUtils.isEmpty(newWaferAttributesList.get(i).getSourceWaferID().getValue())){
                for (int j = 0; j < nInputWaferCount; j++) {
                    if (ObjectIdentifier.equalsWithValue(newWaferAttributesList.get(i).getSourceWaferID(),
                            newWaferAttributesList.get(j).getSourceWaferID())) {
                        nSourceWaferCnt++;
                    }
                }
                if (1 != nSourceWaferCnt) {
                    throw new ServiceException(retCodeConfig.getInvalidInputParam());
                }
            }
        }
        //step 4 - Check relation about SourceLotID and SourceWaferID
        log.info("step 4 - Check relation about SourceLotID and SourceWaferID");
        for (int i = 0; i < nInputWaferCount; i++) {
            if (!CimStringUtils.isEmpty(newWaferAttributesList.get(i).getSourceWaferID().getValue())
                    && !CimStringUtils.isEmpty(newWaferAttributesList.get(i).getSourceLotID().getValue())) {
                ObjectIdentifier waferLotGet = waferMethod.waferLotGet(objCommon, newWaferAttributesList.get(i).getSourceWaferID());
                Validations.check(!ObjectIdentifier.equalsWithValue(newWaferAttributesList.get(i).getSourceLotID(), waferLotGet),
                        retCodeConfig.getInvalidInputParam());
            }
        }
        //step 5 - Store STB source lot info if OM_LOT_START_CANCEL is ON.
        log.info("step 5 - Store STB source lot info if OM_LOT_START_CANCEL is ON.");
        String tmpSTBCancelEnv = StandardProperties.OM_LOT_START_CANCEL.getValue();
        List<ProductDTO.STBSourceLotInfo> aSTBsourceLotInfoList = new ArrayList<>();
        if (CimStringUtils.equals(BizConstant.SP_LOT_STBCANCEL_ON, tmpSTBCancelEnv)) {
            int waferLen = CimArrayUtils.getSize(newWaferAttributesList);
            List<ObjectIdentifier> STBSrcLotIDs = new ArrayList<>();
            int STBSrcLotLen = 0;
            boolean addLotFlag = true;
            for (int i = 0; i < waferLen; i++) {
                // step 6 - Get source lot info sequence ( no duplicate )
                log.info("step 6 - Get source lot info sequence ( no duplicate )");
                addLotFlag = true;
                Infos.NewWaferAttributes newWaferAttributes = newWaferAttributesList.get(i);
                ObjectIdentifier sourceLotID = newWaferAttributes.getSourceLotID();
                for (int j = 0; j < STBSrcLotLen; j++){
                    if (!ObjectIdentifier.isEmptyWithValue(sourceLotID)
                            && ObjectIdentifier.equalsWithValue(sourceLotID, STBSrcLotIDs.get(j))){
                        addLotFlag = false;
                        break;
                    }
                }
                if (addLotFlag){
                    STBSrcLotIDs.add(sourceLotID);
                    STBSrcLotLen++;
                }
                //step 7 -  Store source lot info to wafer
                log.info("step 7 -  Store source lot info to wafer");
                CimWafer aTmpWafer = baseCoreFactory.getBO(CimWafer.class, newWaferAttributes.getSourceWaferID());
                Validations.check(aTmpWafer == null, retCodeConfig.getNotFoundSourceWafer());
                List<ProductDTO.STBInfo> stbInfoList = aTmpWafer.getSTBInfo();
                ProductDTO.STBInfo stbInfo = new ProductDTO.STBInfo();
                if (!CimObjectUtils.isEmpty(stbInfoList)){
                    stbInfo = stbInfoList.get(0);
                } else {
                    stbInfoList.add(stbInfo);
                }
                stbInfo.setSTBSourceLotID(sourceLotID.getValue());
                aTmpWafer.setSTBInfo(stbInfoList);
            }
            //step 7 - Collect source lot info
            log.info("step 7 - Collect source lot info");
            for (int i = 0; i < STBSrcLotLen; i++) {
                ProductDTO.STBSourceLotInfo stbSourceLotInfo = new ProductDTO.STBSourceLotInfo();
                aSTBsourceLotInfoList.add(stbSourceLotInfo);
                CimLot aSTBSourceLot = baseCoreFactory.getBO(CimLot.class, STBSrcLotIDs.get(i));
                Validations.check(aSTBSourceLot == null, retCodeConfig.getNotFoundLot());
                String stbSrcLotType = aSTBSourceLot.getLotType();
                String stbSrcSubLotType = aSTBSourceLot.getSubLotType();
                com.fa.cim.newcore.bo.prodspec.CimProductSpecification aSTBSrcProdSpec = aSTBSourceLot.getProductSpecification();
                ObjectIdentifier tmpProdSpecID = new ObjectIdentifier(aSTBSrcProdSpec.getIdentifier(), aSTBSrcProdSpec.getPrimaryKey());
                stbSourceLotInfo.setSourceLotID(STBSrcLotIDs.get(i).getValue());
                stbSourceLotInfo.setSourceLotLotType(stbSrcLotType);
                stbSourceLotInfo.setSourceLotSubLotType(stbSrcSubLotType);
                stbSourceLotInfo.setSourceLotProdSpecID(tmpProdSpecID);
            }
        }
        log.info("step8  - Retrieve source lot used count");
        int lenNewWaferAttr = CimArrayUtils.getSize(newWaferAttributesList);

        //step 9 - lot Generation
        log.info("step 9 - lot Generation");
        CimLot aNewLot = productManager.createLotUsing(aProductRequest);

        Validations.check(aNewLot == null, retCodeConfig.getNotFoundLot(),"");
        //-----------------------------------
        //   Adjust split number if need.
        //-----------------------------------
        // step 10 - Adjust split number if need.
        log.info("step 10 - Adjust split number if need.");
        CimLotFamily aLotFamily = aNewLot.getLotFamily();
        Validations.check(aLotFamily == null, retCodeConfig.getNotFoundLotFamily());
        boolean notInheritedFlag = aLotFamily.isNewlyCreated();
        if (notInheritedFlag) {
            ObjectIdentifier lotFamilyID = new ObjectIdentifier(aLotFamily.getIdentifier(), aLotFamily.getPrimaryKey());
            // Eric-BUG-6382
            /*String duplicationAllowableFlag = environmentVariableManager.getValue(EnvConst.OM_DUPLICATE_FAMILY_LOT_ENABLE);
            if (StringUtils.equals(duplicationAllowableFlag, "0")) {
                lotFamilyMethod.lotFamilyDuplicationCheckDR(objCommon, lotFamilyID);
            }*/
            // Eric-BUG-6382
            lotFamilyMethod.lotFamilySplitNoAdjust(objCommon, lotFamilyID);
        }
        // step 11 - Prepare output structure
        log.info("step 11 - Prepare output structure");
        objLotSTBOut.setCreatedLotID(new ObjectIdentifier(aNewLot.getIdentifier(), aNewLot.getPrimaryKey()));
        // step - Make lot's lot state as ACTIVE
        log.info("step 12-last  update lot");
        aNewLot.makeReleased();
        //step 12 - Make lot's Production State as InProduction
        aNewLot.makeInProduction();
        //step 13 - Make lot's Hold State as NotOnHold
        aNewLot.makeNotOnHold();
        //step 14 - Make lot Process State as Waiting
        aNewLot.makeWaiting();
        //step 15 - Make lot Inventory State as OnFloor
        aNewLot.makeOnFloor();
        //step - Collect necessary information of lot
        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(aPerson == null, new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
        Validations.check(CimArrayUtils.isEmpty(newWaferAttributesList),retCodeConfig.getWaferIDBlank());
        CimLot aSourceLot = baseCoreFactory.getBO(CimLot.class, newWaferAttributesList.get(0).getSourceLotID());
        Validations.check(aSourceLot == null, retCodeConfig.getNotFoundLot());
        String strVendorLotID = aSourceLot.getVendorLot();
        String strVendor = aSourceLot.getVendor();
        //-----------------------------
        // Update new lot's attributes
        //-----------------------------
        aNewLot.refreshQuantity();
        aNewLot.setVendorLot(strVendorLotID);
        aNewLot.setVendor(strVendor);
        aNewLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aNewLot.setLastClaimedPerson(aPerson);
        aNewLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aNewLot.setStateChangedPerson(aPerson);
        aNewLot.setInventoryStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aNewLot.setInventoryStateChangedPerson(aPerson);
        aNewLot.setContaminationLevel(contaminationLevel);
        aNewLot.setPrFlag(prFlag);
        //-----------------------------
        // Set STB source lot info if OM_LOT_START_CANCEL is ON.
        //-----------------------------
        if (CimStringUtils.equals(tmpSTBCancelEnv, BizConstant.SP_LOT_STBCANCEL_ON)){
            aNewLot.setSTBSourceLots(aSTBsourceLotInfoList);
        }
        //step 16 - Update lot's Used Count  update by wafer , not lot
//        log.info("step 16 - Update lot's Used Count");
//        if (!StringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_PRODUCTIONLOT)
//                && !StringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_ENGINEERINGLOT)
//                && !StringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_RECYCLELOT)) {
//            aNewLot.setUsedCount(nMaxUsedCount + 1);
//        } else {
//            aNewLot.setUsedCount(0);
//        }
        String strLotType = aNewLot.getLotType();

        //step 17 - Update lot's Control Use State
        log.info("step 17 - Update lot's Control Use State");
        if (CimStringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_RECYCLELOT)) {
            aNewLot.makeInRecycle();
        } else if (CimStringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_ENGINEERINGLOT)
                    || CimStringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)
                    || CimStringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                    || CimStringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_DUMMYLOT)
                    || CimStringUtils.equals(strLotType, BizConstant.SP_LOT_TYPE_CORRELATIONLOT)) {
            aNewLot.makeInUse();
        }

        // wafer assigned lot change
        log.info("step 18 - wafer assigned lot change");
        Infos.NewLotAttributes tmpNewLotAttributes = newLotAttributes;
        for (int i = 0; i < lenNewWaferAttr; i++) {
            tmpNewLotAttributes.getNewWaferAttributesList().get(i).setNewLotID(objLotSTBOut.getCreatedLotID());
        }
        // wafer_assignedLot_Change
        waferMethod.waferAssignedLotChange(objCommon, tmpNewLotAttributes.getNewWaferAttributesList());

        //---------------------------------
        // Update lot's Operation Info
        //---------------------------------
        aNewLot.beginNextProcessOperation();
        dispatchingManager.addToQueue(aNewLot);
        //step 19 - Get Product Specification
        log.info("step 19 - Get Product Specification");
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification aPosProdSpec = aNewLot.getProductSpecification();
        Validations.check(aPosProdSpec == null, retCodeConfig.getNotFoundProductSpec());
        //step 20 - Set Reticle Set ID
        log.info("step 20 - Set Reticle Set ID");
        com.fa.cim.newcore.bo.durable.CimReticleSet aReticleSet = aPosProdSpec.getReticleSet();
        if (aReticleSet != null){
            aNewLot.setReticleSet(aReticleSet);
        }
        //step 21 -  Set output structure
        log.info("Set output structure");
        objLotSTBOut.setCreatedLotID(new ObjectIdentifier(aNewLot.getIdentifier(), aNewLot.getPrimaryKey()));
        objLotSTBOut.setSubLotType(aNewLot.getSubLotType());
        objLotSTBOut.setProductType(aPosProdSpec.getProductType());
        //step 22 - wafer STB count up
        log.info("step 22 - wafer STB count up");
        List<Material> aMaterialList = aNewLot.allMaterial();
        int STBedCount = 0;
        int waferLen = CimArrayUtils.getSize(aMaterialList);
        if (waferLen > 0){
            for (int i = 0; i < waferLen; i++){
                CimWafer aPosWafer = (CimWafer) aMaterialList.get(i);
                Validations.check(aPosWafer == null, retCodeConfig.getNotFoundWafer());
                STBedCount = aPosWafer.getSTBedCount() == null ? 0 : aPosWafer.getSTBedCount();
                STBedCount++;
                aPosWafer.setSTBedCount(STBedCount);
            }
        }
        log.info("lotSTB over ---------------------------------------------------------------------------");

        //check contamination level , lot hold
        log.debug("[step-62] check contamination level , lot hold ");
        contaminationMethod.lotCheckContaminationLevelAndPrFlagStepOut(objCommon, objLotSTBOut.getCreatedLotID());
        return objLotSTBOut;
    }



    @Override
    public void lotCassetteCategoryUpdateForContaminationControl(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        //step 1 - lot is made by LotID.
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), "*****"));
        //step 2 - ProcessOperation_var is made by PosLot_var
        com.fa.cim.newcore.bo.pd.CimProcessOperation aProcessOperation = aLot.getProcessOperation();
        Validations.check(aProcessOperation == null,
                new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****", lotID.getValue()));
        // step 3 -  Get RequiredCassetteCategory
        String inventoryState = aLot.getLotInventoryState();
        //step 4 - Check lot's Inventory State
        if (CimStringUtils.equals(inventoryState, BizConstant.SP_LOT_INVENTORYSTATE_INBANK)) {
            //step 5 - blank is set on setRequiredCassetteCategory.
            aLot.setRequiredCassetteCategory(null);
        } else {
            //step 6 - Set RequiredCassetteCategory
            String requiredCassetteCategory = aProcessOperation.getRequiredCassetteCategory();
            aLot.setRequiredCassetteCategory(requiredCassetteCategory);
        }
    }

    @Override
    public List<Infos.HoldHistory> lotHold(Infos.ObjCommon objCommon, ObjectIdentifier lotID, List<Infos.LotHoldReq> holdReqList) {
        List<Infos.HoldHistory> holdHistoryList = new ArrayList<>();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());

        Boolean isOnHoldFlag = false;
        Boolean aChangeStateFlag = false;
        String lotHoldEqpUpdateFlag = StandardProperties.OM_EQP_HOLD_UPDATE_MODE.getValue();
        Validations.check(CimArrayUtils.isEmpty(holdReqList), retCodeConfig.getInvalidParameter());

        isOnHoldFlag = lot.isOnHold();

        Boolean bReasonLotLockFlag = false;
        if ("-1".equals(lotHoldEqpUpdateFlag)) {
            for (int i = 0; i < holdReqList.size(); i++) {
                if (CimStringUtils.equals(BizConstant.SP_REASON_LOTLOCK,holdReqList.get(i).getHoldReasonCodeID().getValue())) {
                    bReasonLotLockFlag = true;
                    break;
                }
            }
        }
        if ("1".equals(lotHoldEqpUpdateFlag) || !bReasonLotLockFlag) {
            dispatchingManager.addToHoldQueue(lot);
        }
        if (!isOnHoldFlag) {
            lot.makeOnHold();
            lot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            lot.setLastClaimedPerson(aPerson);
            aChangeStateFlag = true;
        }

        if ("1".equals(lotHoldEqpUpdateFlag) || !bReasonLotLockFlag) {
            dispatchingManager.removeFromQueue(lot);
        }


        lot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        lot.setLastClaimedPerson(aPerson);

        Boolean trueFalse = false;
        Boolean aRespOpeExistFlag = false;

        List<ProductDTO.HoldRecord> holdRecordList = lot.allHoldRecords();

        for (int i = 0; i < CimArrayUtils.getSize(holdRecordList); i++) {
            if (holdRecordList.get(i).isResponsibleOperationFlag()) {
                aRespOpeExistFlag = true;
                break;
            }
        }
        for (int i = 0; i < CimArrayUtils.getSize(holdReqList); i++) {
            trueFalse = false;
            if (BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS.equals(holdReqList.get(i).getResponsibleOperationMark())) {
                com.fa.cim.newcore.bo.pd.CimProcessFlowContext processFlowContext = lot.getProcessFlowContext();
                Validations.check(processFlowContext == null, new OmCode(retCodeConfig.getNotFoundPfx(), ""));

                com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = processFlowContext.getPreviousProcessOperation();
                OmCode omCode = new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****", ObjectIdentifier.fetchValue(lotID));
                Validations.check(processOperation == null, omCode);

                lot.makeResponsibleOperation();
                trueFalse = true;
            }

            ProductDTO.HoldRecord holdRecord = new ProductDTO.HoldRecord();
            if (!CimStringUtils.isEmpty(holdReqList.get(i).getHoldType())) {
                holdRecord.setHoldType(holdReqList.get(i).getHoldType());
            } else {
                holdRecord.setHoldType(BizConstant.SP_HOLDTYPE_LOTHOLD);
            }
            holdRecord.setReasonCode(holdReqList.get(i).getHoldReasonCodeID());

            if (!ObjectIdentifier.isEmpty(holdReqList.get(i).getHoldUserID())) {
                holdRecord.setHoldPerson(holdReqList.get(i).getHoldUserID());
            } else {
                holdRecord.setHoldPerson(objCommon.getUser().getUserID());
            }
            holdRecord.setHoldTimeStamp(objCommon.getTimeStamp().getReportTimeStamp().toString());
            holdRecord.setRelatedLot(holdReqList.get(i).getRelatedLotID());
            holdRecord.setResponsibleOperationFlag(trueFalse);
            holdRecord.setHoldClaimMemo(holdReqList.get(i).getClaimMemo());

            String department = holdReqList.get(i).getDepartment();
            String section = holdReqList.get(i).getSection();
            if (CimStringUtils.isNotEmpty(department) && CimStringUtils.isNotEmpty(section)) {
                holdRecord.setDepartmentNamePlate(department + BizConstant.DOT + section);
            }
            try {
                lot.addHoldRecord(holdRecord);
            }catch (DuplicateRecordException ex){
                throw new ServiceException(retCodeConfig.getExistSameHold());
            }

            Infos.HoldHistory holdHistory = new Infos.HoldHistory();
            if (!aRespOpeExistFlag) {
                if (trueFalse) {
                    holdHistory.setMovementFlag(true);
                } else {
                    holdHistory.setMovementFlag(false);
                }
            } else {
                holdHistory.setMovementFlag(false);
            }

            holdHistory.setResponsibleOperationExistFlag(aRespOpeExistFlag);
            if (0 == i && aChangeStateFlag) {
                holdHistory.setChangeStateFlag(true);
            } else {
                holdHistory.setChangeStateFlag(false);
            }
            holdHistory.setHoldType(holdReqList.get(i).getHoldType());
            holdHistory.setHoldReasonCode(holdReqList.get(i).getHoldReasonCodeID());
            if (!CimStringUtils.isEmpty(holdReqList.get(i).getHoldUserID().getValue())) {
                holdHistory.setHoldPerson(holdReqList.get(i).getHoldUserID());
            } else {
                holdHistory.setHoldPerson(objCommon.getUser().getUserID());
            }
            holdHistory.setHoldTime(objCommon.getTimeStamp().getReportTimeStamp().toString());
            holdHistory.setResponsibleOperationFlag(trueFalse);
            holdHistory.setHoldClaimMemo(holdReqList.get(i).getClaimMemo());
            holdHistory.setDepartmentNamePlate(holdRecord.getDepartmentNamePlate());
            if (trueFalse) {
                aRespOpeExistFlag = true;
            }
            holdHistoryList.add(i, holdHistory);
        }

        List<ProductDTO.HoldRecord> holdRecords = lot.allHoldRecords();
        int i;
        for (i = 0; i < holdRecords.size(); i++) {
            if (holdRecords.get(i).isResponsibleOperationFlag()) {
                lot.makeResponsibleOperation();
                break;
            }
        }
        if (i == holdRecords.size() || 0 == holdRecords.size()) {
            lot.makeNotResponsibleOperation();
        }
        return holdHistoryList;
    }

    @Override
    public Infos.LotInfo lotDetailInfoGetDR(Infos.ObjCommon objCommon, Infos.LotInfoInqFlag lotInfoInqFlag, ObjectIdentifier lotID) {

        // Get lot information
        Infos.LotInfo lotInfo = this.lotDBInfoGetDR(objCommon, lotInfoInqFlag, lotID);

        //step2 - Get Entity Inhibitions Information;
        ObjectIdentifier anEqpID = new ObjectIdentifier("");
        List<Infos.EntityInhibitInfo> entityInhibitCheckOut = constraintMethod.constraintCheckForLotDR(objCommon,lotID,anEqpID);

        int entityInhibitInfosSize = CimArrayUtils.getSize(entityInhibitCheckOut);
        if(entityInhibitInfosSize > 0){
            List<Infos.EntityInhibitAttributes> entityInhibitAttributesList = new ArrayList<>();
            entityInhibitCheckOut.forEach(t-> entityInhibitAttributesList.add(t.getEntityInhibitAttributes()));
            lotInfo.setEntityInhibitAttributesList(entityInhibitAttributesList);
        }

        //step3 - Get wafer attributes informaiton
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotWaferAttributesFlag())) {
            Inputs.ObjLotWafersGetIn objLotWafersGetIn = new Inputs.ObjLotWafersGetIn();
            objLotWafersGetIn.setLotID(lotID);
            objLotWafersGetIn.setScrapCheckFlag(true);

            List<Infos.LotWaferAttributes> lotWaferAttributesList = this.lotWafersGetDR(objCommon, objLotWafersGetIn);
            lotInfo.setLotWaferAttributesList(lotWaferAttributesList);

            Integer totalGoodDieCount = 0;
            Integer totalBadDieCount = 0;
            Integer maxReworkCount = 0;
            if (!CimObjectUtils.isEmpty(lotWaferAttributesList)) {
                for (int i = 0, j = lotWaferAttributesList.size(); i < j; i++) {
                    Infos.LotWaferAttributes lotWaferAttributes = lotWaferAttributesList.get(i);
                    Integer reworkCount = lotWaferAttributes.getReworkCount();
                    reworkCount = CimObjectUtils.isEmpty(reworkCount) ? 0 : reworkCount;
                    if (maxReworkCount < reworkCount) {
                        maxReworkCount = reworkCount;
                    }
                    if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotBasicInfoFlag())) {
                        int goodUnitCount = CimNumberUtils.intValue(lotWaferAttributes.getGoodUnitCount());
                        int failUnitCount = CimNumberUtils.intValue(lotWaferAttributes.getFailUnitCount());
                        totalGoodDieCount += goodUnitCount;
                        totalBadDieCount += failUnitCount;
                    }
                }
            }
            Infos.LotOperationInfo lotOperationInfo = lotInfo.getLotOperationInfo();
            lotOperationInfo.setReworkCount(maxReworkCount);

            Infos.LotBasicInfo lotBasicInfo = lotInfo.getLotBasicInfo();
            lotBasicInfo.setTotalGoodDieCount(totalGoodDieCount);
            lotBasicInfo.setTotalBadDieCount(totalBadDieCount);

            lotInfo.setLotOperationInfo(lotOperationInfo);
            lotInfo.setLotBasicInfo(lotBasicInfo);
        }
        return lotInfo;
    }

    @Override
    public Outputs.ObjLotCurrentOperationInfoGetDROut lotCurrentOperationInfoGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {

        CimLotDO example = new CimLotDO();
        example.setLotID(ObjectIdentifier.fetchValue(lotID));
        CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        //step 1 - Get current PO information
        CimProcessOperationDO processOperation = cimJpaRepository.queryOne("SELECT * FROM OMPROPE WHERE ID = ?1", CimProcessOperationDO.class, lot.getProcessOperationObj());
        Validations.check(null == processOperation, retCodeConfig.getNotFoundProcessOperation());

        //step 2 - if currrent module PF is inactive, search operationID from active module POS
        Boolean activeModulePOSFoundFlag = false;
        String currentModuleOpeNo = processOperation.getModuleOperationNumber();
        String currentModulePDID = processOperation.getModuleNumber();

        //------------------------------
        // Step 3 - Get module PF information
        //------------------------------
        List<CimPFPosListDO> processFlowPosList = null;
        ObjectIdentifier posPDID = null;
        String activeModulePFID = null;
        CimProcessFlowDO processFlow = cimJpaRepository.queryOne("SELECT * FROM OMPRF WHERE ID = ?1", CimProcessFlowDO.class,processOperation.getModuleProcessFlowObj());
        Validations.check(null == processFlow, retCodeConfig.getMsgNotFoundPf());

        if (CimBooleanUtils.isFalse(processFlow.getState())) {
            //----------------------------------------------
            // Get active module PF information
            //----------------------------------------------
            activeModulePOSFoundFlag = true;
            CimProcessFlowDO activeModulePF = cimJpaRepository.queryOne("SELECT * FROM OMPRF WHERE PRP_ID = ?1 AND PRP_LEVEL = ?2 AND ACTIVE_FLAG = ?3", CimProcessFlowDO.class,processOperation.getModuleProcessDefinitionID(), BizConstant.SP_PD_FLOWLEVEL_MODULE, true);
            Validations.check(null == activeModulePF, retCodeConfig.getMsgNotFoundPf());

            activeModulePFID = activeModulePF.getId();

            //step 3 - Find current operation no on active module PF
            processFlowPosList = cimJpaRepository.query("SELECT PRSS_RKEY FROM OMPRF_PRSSSEQ WHERE REFKEY = ?1 AND LINK_KEY = ?2 ", CimPFPosListDO.class, activeModulePFID, currentModuleOpeNo);
            //Validations.check(ArrayUtils.isEmpty(processFlowPosList), new OmCode(retCodeConfig.getNotFoundProcessFlow(), ""));
            if (CimArrayUtils.isNotEmpty(processFlowPosList)) {
                for (CimPFPosListDO cimPFPosListDO : processFlowPosList) {
                    CimProcessOperationSpecificationDO processOperationSpecifications = cimJpaRepository.queryOne("SELECT * FROM OMPRSS WHERE ID = ?1 ", CimProcessOperationSpecificationDO.class, cimPFPosListDO.getProcessOperationSpecificationsObj());
                    Validations.check(null == processOperationSpecifications, retCodeConfig.getNotFoundPos());

                    String operationID = processOperationSpecifications.getProcessDefinitionID();
                    posPDID = new ObjectIdentifier(processOperationSpecifications.getProcessDefinitionID(), processOperationSpecifications.getProcessDefinitionObj());

                    String strVersionID = cimFrameWorkGlobals.extractVersionFromID(operationID);

                    if (CimStringUtils.equals(BizConstant.SP_ACTIVE_VERSION, strVersionID)) {
                        CimProcessDefinitionDO processDefinition = cimJpaRepository.queryOne("SELECT * FROM OMPRP WHERE PRP_ID = ?1 AND PRP_LEVEL = ?2", CimProcessDefinitionDO.class, operationID, BizConstant.SP_PD_FLOWLEVEL_OPERATION);
                        Validations.check(null == processDefinition, retCodeConfig.getMsgNotFoundPd());

                        operationID = processDefinition.getActiveID();
                    }
                }
            }
        }
        ObjectIdentifier stageID = null;
        //step 4 -  Get StageID
        if (!CimObjectUtils.isEmpty(processOperation.getMainProcessFlowObj())) {
            String sql = "SELECT OMPRF_ROUTESEQ.STAGE_ID,\n" +
                    "                            OMPRF_ROUTESEQ.STAGE_RKEY\n" +
                    "                      FROM  OMPRF, OMPRF_ROUTESEQ\n" +
                    "                      WHERE OMPRF.ID = ?1 \n" +
                    "                      AND   OMPRF_ROUTESEQ.REFKEY = OMPRF.ID\n" +
                    "                      AND   OMPRF_ROUTESEQ.LINK_KEY = ?2";
            Object[] objects = cimJpaRepository.queryOne(sql, processOperation.getMainProcessFlowObj(), processOperation.getModuleNumber());
            stageID = ObjectIdentifier.build(objects[0].toString(), objects[1].toString());
        }

        Outputs.ObjLotCurrentOperationInfoGetDROut objLotCurrentOperationInfoGetDROut = new Outputs.ObjLotCurrentOperationInfoGetDROut();
        //step  5 - Set output parameter
        if (CimBooleanUtils.isTrue(activeModulePOSFoundFlag)) {
            objLotCurrentOperationInfoGetDROut.setOperationID(posPDID);
            objLotCurrentOperationInfoGetDROut.setModulePF(activeModulePFID);
            String modulePos = CimArrayUtils.isEmpty(processFlowPosList) ? null : processFlowPosList.get(0).getProcessOperationSpecificationsObj();
            objLotCurrentOperationInfoGetDROut.setModulePOS(modulePos);
        } else {
            objLotCurrentOperationInfoGetDROut.setOperationID(new ObjectIdentifier(processOperation.getProcessDefinitionID(), processOperation.getProcessDefinitionObj()));
            objLotCurrentOperationInfoGetDROut.setModulePF(processOperation.getModuleProcessFlowObj());
            objLotCurrentOperationInfoGetDROut.setModulePOS(processOperation.getModuleProcessOperationSpecificationsObj());
        }
        objLotCurrentOperationInfoGetDROut.setMainPDID(new ObjectIdentifier(processOperation.getMainProcessDefinitionID(), processOperation.getMainProcessDefinitionObj()));
        objLotCurrentOperationInfoGetDROut.setModulePDID(new ObjectIdentifier(processOperation.getModuleProcessDefinitionID(), processOperation.getModuleProcessDefinitionObj()));
        objLotCurrentOperationInfoGetDROut.setPassCount(processOperation.getPassCount());
        objLotCurrentOperationInfoGetDROut.setMainPFforMainPOS(processOperation.getProcessFlowObj());
        objLotCurrentOperationInfoGetDROut.setOpeNo(processOperation.getOperationNumber());
        objLotCurrentOperationInfoGetDROut.setMainPOS(processOperation.getProcessOperationSpecificationObj());
        objLotCurrentOperationInfoGetDROut.setMainPFforModulePD(processOperation.getMainProcessFlowObj());
        objLotCurrentOperationInfoGetDROut.setModuleNo(processOperation.getModuleNumber());
        objLotCurrentOperationInfoGetDROut.setModuleOpeNo(processOperation.getModuleOperationNumber());
        objLotCurrentOperationInfoGetDROut.setStageID(stageID);

        return objLotCurrentOperationInfoGetDROut;
    }

    @Override
    public Outputs.ObjLotCurrentOperationInfoGetOut lotCurrentOperationInfoGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aPosLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));

        CimProcessDefinition aPosMainPD = aPosLot.getMainProcessDefinition(); // OMPRP
        CimProcessOperation aPosPO = aPosLot.getProcessOperation(); // OMPROPE
        Validations.check(null == aPosPO, new OmCode(retCodeConfig.getNotFoundProcessOperation(), "***", lotID.getValue()));

        CimProcessDefinition aPosPD = aPosPO.getProcessDefinition(); // OMPRP

        Outputs.ObjLotCurrentOperationInfoGetOut lotCurrentOperationInfoGetOut = new Outputs.ObjLotCurrentOperationInfoGetOut();
        lotCurrentOperationInfoGetOut.setRouteID(new ObjectIdentifier(aPosMainPD.getIdentifier(), aPosMainPD.getPrimaryKey()));

        lotCurrentOperationInfoGetOut.setOperationID(new ObjectIdentifier(aPosPD.getIdentifier(), aPosPD.getPrimaryKey()));
        lotCurrentOperationInfoGetOut.setOperationNumber(aPosLot.getOperationNumber());

        // zqi: 添加此属性，参考 com.fa.cim.method.impl.LotMethod.lotPreviousOperationInfoGet 方法
        lotCurrentOperationInfoGetOut.setControlJobID(ObjectIdentifier.buildWithValue(aPosPO.getAssignedControlJobID()));
        lotCurrentOperationInfoGetOut.setOperationPass(CimObjectUtils.toString(aPosPO.getPassCount()));

        return lotCurrentOperationInfoGetOut;
    }


    /**
     * description:
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * 2018/7/16                             Nyx           Compare R18 code
     * @author jerry
     * @date 2018/5/24 11:00
     * @param objCommon
     * @param lotInfoInqFlag
     * @param lotID -
     * @return com.fa.cim.dto.RetCode<com.fa.cim.pojo.Infos.LotInfo>
     */
    @Override
    public Infos.LotInfo lotDBInfoGetDR(Infos.ObjCommon objCommon, Infos.LotInfoInqFlag lotInfoInqFlag,
                                        ObjectIdentifier lotID) {
        /*------------------*/
        /*    Initialize    */
        /*------------------*/
        Infos.LotInfo lotInfo = new Infos.LotInfo();
        Infos.LotBasicInfo lotBasicInfo = new Infos.LotBasicInfo();
        lotBasicInfo.setTotalWaferCount(0);
        lotBasicInfo.setProductWaferCount(0);
        lotBasicInfo.setControlWaferCount(0);
        lotBasicInfo.setTotalGoodDieCount(0);
        lotBasicInfo.setTotalBadDieCount(0);
        lotBasicInfo.setQtimeFlag(false);
        lotBasicInfo.setSorterJobExistFlag(false);
        lotBasicInfo.setInPostProcessFlagOfCassette(false);
        lotBasicInfo.setInPostProcessFlagOfLot(false);
        lotBasicInfo.setAutoDispatchControlFlag(false);
        Infos.LotControlUseInfo lotControlUseInfo = new Infos.LotControlUseInfo();
        lotControlUseInfo.setUsedCount(0);
        lotControlUseInfo.setRecycleCount(0);
        Infos.LotNoteFlagInfo lotNoteFlagInfo = new Infos.LotNoteFlagInfo();
        lotNoteFlagInfo.setLotCommentFlag(false);
        lotNoteFlagInfo.setLotNoteFlag(false);
        lotNoteFlagInfo.setLotOperationNoteFlag(false);
        Infos.LotOperationInfo lotOperationInfo = new Infos.LotOperationInfo();
        lotOperationInfo.setMandatoryOperationFlag(false);
        lotOperationInfo.setProcessHoldFlag(false);
        lotOperationInfo.setReworkCount(0);
        Infos.LotOrderInfo lotOrderInfo = new Infos.LotOrderInfo();
        lotOrderInfo.setShipRequireFlag(false);
        Infos.LotRecipeInfo lotRecipeInfo = new Infos.LotRecipeInfo();
        lotRecipeInfo.setFfEnforceFlag(false);
        lotRecipeInfo.setFbEnforceFlag(false);
        Infos.LotBackupInfo lotBackupInfo = new Infos.LotBackupInfo();
        lotBackupInfo.setBackupProcessingFlag(false);
        lotBackupInfo.setCurrentLocationFlag(false);
        lotBackupInfo.setTransferFlag(false);

        ObjectIdentifier eqpIDForGetReticleGroup = null;

        //-------------------------------------------------------
        //   Step 1- Get from LOT
        //-------------------------------------------------------
        CimLotDO example = new CimLotDO();
        example.setLotID(ObjectIdentifier.fetchValue(lotID));
        CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());
        //-------------------------------------------------------
        // Step 2 - Get lot information from OMLOT
        //-------------------------------------------------------

        //---------------------------------------------------------
        // Strp 3 - Get po information from FRPO
        //---------------------------------------------------------
        String currentModulePFSystemkey = null;
        Integer currentPoslistSeqno = 0;
        ObjectIdentifier activeProcessDefinitionID = null;
        CimProcessOperationDO processOperation = cimJpaRepository.queryOne("SELECT * FROM OMPROPE WHERE ID = ?1",
                CimProcessOperationDO.class, lot.getProcessOperationObj());
        String processDefinitionType = null;
        String department = null;
        String inspectionType = null;
        ObjectIdentifier stage = null;
        if (!CimObjectUtils.isEmpty(processOperation)) {
            activeProcessDefinitionID = new ObjectIdentifier(processOperation.getProcessDefinitionID(),
                    processOperation.getProcessDefinitionObj());
            //------------------------------------------------
            //  Step4 - Get systemkey of current module PF
            //------------------------------------------------
            String dTheSystemKeyModulePF = processOperation.getModuleProcessFlowObj();
            //------------------------------------------------------------------
            //  Step5 - Get seqno of current module POS in current module PF
            //------------------------------------------------------------------
            CimPFPosListDO processFlowPosList = cimJpaRepository
                    .queryOne("SELECT * FROM OMPRF_PRSSSEQ WHERE REFKEY = ?1 AND LINK_KEY = ?2",
                            CimPFPosListDO.class, dTheSystemKeyModulePF, processOperation.getModuleOperationNumber());
            Validations.check(processFlowPosList == null, retCodeConfig.getNotFoundProcessFlow(), lotID);
            currentPoslistSeqno = processFlowPosList.getSequenceNumber();

            //-----------------------------------------------
            //  Step 6 - Check state of current module PF
            //-----------------------------------------------
            CimProcessFlowDO processFlow = cimJpaRepository
                    .queryOne("SELECT * FROM OMPRF WHERE ID = ?1",CimProcessFlowDO.class,
                            dTheSystemKeyModulePF);
            Validations.check(null == processFlow, retCodeConfig.getNotFoundProcessFlow());
            if (!processFlow.getState()) {
                //-------------------------------------------
                //  step 7 - Get info from active module PF
                //-------------------------------------------
                Infos.ActiveModuleInfo activeModulePF = null;
                String sql = "SELECT OMPRF.PRP_STRING, OMPRF_PRSSSEQ.IDX_NO, OMPRF_PRSSSEQ.PRSS_RKEY " +
                        "FROM OMPRF, OMPRF_PRSSSEQ WHERE OMPRF.PRP_ID = ?1 AND OMPRF.ACTIVE_FLAG = ?2 AND " +
                        "OMPRF.PRP_STRING = OMPRF_PRSSSEQ.REFKEY " +
                        "AND OMPRF_PRSSSEQ.LINK_KEY = ?3 AND OMPRF.PRP_LEVEL = ?4";
                List<Object[]> list = cimJpaRepository.query(sql, processFlow.getMainProcessDefinitionID(),
                        1, processOperation.getModuleOperationNumber(), CIMStateConst.SP_PD_FLOWLEVEL_MODULE);
                if(CimArrayUtils.isEmpty(list)) {
                    activeModulePF = null;
                } else {
                    Object[] objects =  list.get(0);
                    Infos.ActiveModuleInfo info = new Infos.ActiveModuleInfo();
                    info.setProcessFlowID(String.valueOf(objects[0]));
                    info.setSequenceNumber(Integer.parseInt(String.valueOf(objects[1])));
                    info.setProcessOperationSpecificationsID(String.valueOf(objects[2]));
                }
            }

            //-----------------------------------------------
            //  Step 8 - Get information from active  PD
            //-----------------------------------------------
            CimProcessDefinitionDO processDefinition = cimJpaRepository
                    .queryOne("SELECT * FROM OMPRP WHERE ID = ?1",CimProcessDefinitionDO.class,
                            ObjectIdentifier.fetchReferenceKey(activeProcessDefinitionID));
            processDefinitionType = processDefinition.getProcessDefinitionType();
            department = processDefinition.getDepartment();
            inspectionType = processDefinition.getInspectionType();

            //-----------------------------------------------
            //  Step 9 - Get systmekey of current main PF
            //-----------------------------------------------
            String moduleProcessFlowID = processOperation.getModuleProcessFlowObj();

            //-----------------------------------------------------------------------
            //  Step 10 - Get seqno & stage of current module PD in current main PF
            //-----------------------------------------------------------------------
            String sql = "SELECT OMPRF.PRP_ID,\n" +
                    " OMPRF_ROUTESEQ.IDX_NO,\n" +
                    " OMPRF_ROUTESEQ.STAGE_ID,\n" +
                    " OMPRF_ROUTESEQ.STAGE_RKEY\n" +
                    " FROM   OMPRF, OMPRF_ROUTESEQ\n" +
                    " WHERE  OMPRF.ID = ?1\n" +
                    " AND    OMPRF_ROUTESEQ.REFKEY = OMPRF.ID\n" +
                    " AND    OMPRF_ROUTESEQ.LINK_KEY = ?2\n";
            Object[] pfPDList = cimJpaRepository.queryOne(sql,processOperation.getMainProcessFlowObj(),
                    processOperation.getModuleNumber());
            stage = new ObjectIdentifier((String) pfPDList[2], (String) pfPDList[3]);
        }

        lotBasicInfo.setLotID(ObjectIdentifier.build(lot.getIdentifier(), lot.getId()));
        //--------------------------------------------------------//
        // Step 10 - set LotBasicInfo                             //
        //--------------------------------------------------------//
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotBasicInfoFlag())) {
            lotBasicInfo.setLotType(lot.getLotType());
            lotBasicInfo.setSubLotType(lot.getSubLotType());
            lotBasicInfo.setLotContent(lot.getMaterialContents());

            if (BizConstant.SP_LOT_INVENTORYSTATE_NONPROBANK.equals(lot.getLotInventoryState())) {
                if (BizConstant.CIMFW_LOT_FINISHEDSTATE_SCRAPPED.equals(lot.getLotFinishedState())
                        || BizConstant.CIMFW_LOT_FINISHEDSTATE_EMPTIED.equals(lot.getLotFinishedState())
                        || BizConstant.SP_LOT_FINISHED_STATE_TERMINATED.equals(lot.getLotFinishedState())) {
                    lotBasicInfo.setLotStatus(lot.getLotFinishedState());
                } else {
                    lotBasicInfo.setLotStatus(lot.getLotInventoryState());
                }
            } else {
                if (BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD.equals(lot.getLotHoldState())) {
                    if (BizConstant.CIMFW_LOT_FINISHEDSTATE_SCRAPPED.equals(lot.getLotFinishedState())
                            || BizConstant.CIMFW_LOT_FINISHEDSTATE_EMPTIED.equals(lot.getLotFinishedState())
                            || BizConstant.SP_LOT_FINISHED_STATE_TERMINATED.equals(lot.getLotFinishedState())) {
                        lotBasicInfo.setLotStatus(lot.getLotFinishedState());
                    } else {
                        lotBasicInfo.setLotStatus(lot.getLotHoldState());
                    }
                } else {
                    if (BizConstant.CIMFW_LOT_STATE_LOTCREATED.equals(lot.getLotState())
                            || BizConstant.CIMFW_LOT_STATE_RELEASED.equals(lot.getLotState())
                            || BizConstant.CIMFW_LOT_STATE_SHIPPED.equals(lot.getLotState())) {
                        lotBasicInfo.setLotStatus(lot.getLotState());
                    } else if (BizConstant.CIMFW_LOT_STATE_FINISHED.equals(lot.getLotState())) {
                        lotBasicInfo.setLotStatus(lot.getLotFinishedState());
                    } else if (BizConstant.CIMFW_LOT_STATE_ACTIVE.equals(lot.getLotState())) {
                        lotBasicInfo.setLotStatus(lot.getLotProcessState());
                    }
                }
            }
            List<Infos.LotStatusList> states = new ArrayList<>();
            states.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_STATE, lot.getLotState()));
            states.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_PRODUCTIONSTATE, lot.getLotProductionState()));
            states.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_HOLDSTATE, lot.getLotHoldState()));
            states.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_FINISHEDSTATE, lot.getLotFinishedState()));
            states.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_PROCSTATE, lot.getLotProcessState()));
            states.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_INVENTORYSTATE, lot.getLotInventoryState()));
            lotBasicInfo.setLotStatusList(states);

            Timestamp plannedCompletionDateTime = lot.getPlanEndTimeStamp();
            lotBasicInfo.setDueTimeStamp(CimObjectUtils.isEmpty(plannedCompletionDateTime)
                    ? null : plannedCompletionDateTime);

            lotBasicInfo.setPriorityClass(lot.getPriorityClass());

            double internalPriority = 0D;
            if (!CimObjectUtils.isEmpty(processOperation)) {
                Timestamp currentTime = CimDateUtils.getCurrentTimeStamp();

                double plannedCompDuration = CimDateUtils.substractTimeStamp(currentTime.getTime(),
                        lot.getPlanEndTimeStamp().getTime()
                ).doubleValue();

                double aRemainingCycleTime = CimNumberUtils.doubleValue(processOperation.getRemainCycleTime());
                if (0 == aRemainingCycleTime) {
                    internalPriority = 0;
                } else {
                    internalPriority = plannedCompDuration / (aRemainingCycleTime * 60 * 1000);
                }

                if (lot.getPlanEndTimeStamp().before(currentTime)) {
                    internalPriority = -internalPriority;
                }
                lotBasicInfo.setInternalPriority(internalPriority);
            }
            lotBasicInfo.setTotalWaferCount(lot.getWaferCount());
            lotBasicInfo.setControlWaferCount(lot.getControlWaferCount());
            lotBasicInfo.setProductWaferCount(lot.getProductWaferCount());
            lotBasicInfo.setTotalBadDieCount(0);
            lotBasicInfo.setTotalGoodDieCount(0);
            lotBasicInfo.setBankID(new ObjectIdentifier(lot.getBankID(), lot.getBankObj()));
            lotBasicInfo.setQtimeFlag(false);
            lotBasicInfo.setRequiredCassetteCategory(lot.getRequiredCassetteCategory());
            CimLot lotBO = baseCoreFactory.getBO(CimLot.class, lot.getId());
            CimProcessOperation aProcessOperation = lotBO.getProcessOperation();
            if (!CimObjectUtils.isEmpty(aProcessOperation)){
                CimProcessOperationSpecification processOperationSpecification = aProcessOperation.getProcessOperationSpecification();
                if (!CimObjectUtils.isEmpty(processOperationSpecification)){
                    String contaminationInLevel = Optional.ofNullable(processOperationSpecification.getContaminationInLevel()).orElse("");
                    if (contaminationInLevel.contains(".")) {
                        String[] split = contaminationInLevel.split("\\.",2);
                        contaminationInLevel = split[1];
                    }
                    lotBasicInfo.setRequiredContaminationLevel(contaminationInLevel);
                }
            }

            //---------------------------------------
            // Step 11 - Get from FRLOT_QTIME
            //---------------------------------------
            //---------------------------------------
            // Step 12 - Get qtime info for lot
            //---------------------------------------
            //---------------------------------------
            //  Step 13 - Check current route.
            //---------------------------------------
            if (!CimObjectUtils.isEmpty(processOperation)) {
                int nLotQtimeInfoAdded = 0;

                //---------------------------------------
                //  Check current route.
                //---------------------------------------
                List<Infos.LotQtimeInfo>  strLotQtimeGetForRouteDROut;
                strLotQtimeGetForRouteDROut = this.lotQtimeGetForRouteDR( objCommon, lotID,
                        processOperation.getMainProcessFlowObj(),
                        processOperation.getModuleProcessFlowObj(), processOperation.getOperationNumber());

                nLotQtimeInfoAdded = CimArrayUtils.getSize(strLotQtimeGetForRouteDROut);
                if(nLotQtimeInfoAdded != 0) {
                    for( int i = 0 ; i < nLotQtimeInfoAdded ; i++ ) {
                        if( !CimStringUtils.equals(strLotQtimeGetForRouteDROut.get(i)
                                .getQrestrictionTargetTimeStamp(), BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING) ) {
                            lotBasicInfo.setQtimeFlag (true );
                            break;
                        }
                    }
                } else {
                    //--------------------------------------------------------
                    //  Select QTime restriction for Lot on Branch Route.
                    //--------------------------------------------------------
                    String hFRPFXd_theSystemKey=lot.getProcessFlowContextObj();

                    List<Object[]> RETNLIST=cimJpaRepository.query("SELECT OPE_NO,\n" +
                            "                            MROUTE_PRF_RKEY,\n" +
                            "                            ROUTE_PRF_RKEY\n" +
                            "                    FROM   OMPRFCX_RTNSEQ\n" +
                            "                    WHERE  REFKEY = ?1",hFRPFXd_theSystemKey);


                    for (Object[] RETN_LIST : RETNLIST) {
                        String hFRPFX_RETNLISTOPE_NO="";
                        String hFRPFX_RETNLISTMAIN_PF_OBJ="";
                        String hFRPFX_RETNLISTMODULE_PF_OBJ="";

                        hFRPFX_RETNLISTOPE_NO = (String)RETN_LIST[0];
                        hFRPFX_RETNLISTMAIN_PF_OBJ = (String)RETN_LIST[1];
                        hFRPFX_RETNLISTMODULE_PF_OBJ = (String)RETN_LIST[2];

                        try {
                            strLotQtimeGetForRouteDROut = this.lotQtimeGetForRouteDR(  objCommon,
                                    lotID,
                                    hFRPFX_RETNLISTMAIN_PF_OBJ,
                                    hFRPFX_RETNLISTMODULE_PF_OBJ,
                                    hFRPFX_RETNLISTOPE_NO );
                        } catch (ServiceException e) {
                            break;
                        }

                        nLotQtimeInfoAdded = CimArrayUtils.getSize(strLotQtimeGetForRouteDROut);
                        if(nLotQtimeInfoAdded != 0) {
                            for( int i = 0 ; i < nLotQtimeInfoAdded ; i++ ) {
                                if( !CimStringUtils.equals(strLotQtimeGetForRouteDROut.get(i)
                                        .getQrestrictionTargetTimeStamp(), BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING) ) {
                                    lotBasicInfo.setQtimeFlag (true);
                                    break;
                                }
                            }
                            break;
                        }
                    }

                }

                // check min q-time
                lotBasicInfo.setMinQTimeFlag(minQTimeMethod.checkIsInRestriction(lotID,
                        processOperation.getMainProcessFlowObj(), lot.getProcessFlowContextObj()));
            }

            lotBasicInfo.setParentLotID(new ObjectIdentifier(lot.getSplitLotID(), lot.getSplitLotObj()));
            lotBasicInfo.setVendorLotID(lot.getVendorLotID());
            if (!CimObjectUtils.isEmpty(lot.getLastClamiedTimeStamp())) {
                lotBasicInfo.setLastClaimedTimeStamp(lot.getLastClamiedTimeStamp());
            }
            if (!CimObjectUtils.isEmpty(lot.getInvChangeTimeStamp())) {
                lotBasicInfo.setInventoryChangeTimeStamp(lot.getInvChangeTimeStamp());
            }
            Timestamp stateChangeTime = lot.getStateChangeTime();
            lotBasicInfo.setStateChangeTimeStamp(CimObjectUtils.isEmpty(stateChangeTime)
                    ? "" : stateChangeTime.toString());
            if (!CimDateUtils.checkNull(lot.getProcessLagTimeStamp())) {
                lotBasicInfo.setProcessLagTime(lot.getProcessLagTimeStamp());
            }
            lotBasicInfo.setLastClaimedUserID(new ObjectIdentifier(lot.getLastClaimedUserID(),
                    lot.getLastClaimedUserObj()));
            lotBasicInfo.setFamilyLotID(new ObjectIdentifier(lot.getLotFamilyID(), lot.getLotFamilyReferenceKey()));
            //千岛二期增加
            lotBasicInfo.setFlip(lot.getFlip() == null ? false : lot.getFlip());
        }

        //---------------------------------------------
        // Step 15 - set LotControlUseInfo
        //---------------------------------------------
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotControlUseInfoFlag())) {
            //get usage recycle count by wafer
//            lotControlUseInfo.setUsedCount(lot.getUsedCount());
//            lotControlUseInfo.setRecycleCount(0);
            if (!CimStringUtils.equals(BizConstant.SP_LOT_TYPE_PRODUCTIONLOT,lot.getLotType())) {
                lotControlUseInfo.setRecycleLimit(lot.getRecycleLimit());
                lotControlUseInfo.setUsageLimit(lot.getUsageLimit());
                LotUsageRecycleCountParams usageRecycleCountByLot = waferMethod.getUsageRecycleCountByLot(objCommon,
                        lot.getId());
                lotControlUseInfo.setRecycleCount(usageRecycleCountByLot.getRecycleCount());
                lotControlUseInfo.setUsedCount(usageRecycleCountByLot.getUsageCount());
            }
            lotControlUseInfo.setControlUseState(lot.getControlUseState());
        }
        //--------------------------------------------------------------------------------------------//
        // Step16 - Set LotFlowBatchInfo                                                              //
        //--------------------------------------------------------------------------------------------//
        Infos.LotFlowBatchInfo lotFlowBatchInfo = new Infos.LotFlowBatchInfo();
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotFlowBatchInfoFlag())) {
            lotFlowBatchInfo.setFlowBatchID(new ObjectIdentifier(lot.getFlowBatchID(), lot.getFlowBatchObj()));
            if (!CimStringUtils.isEmpty(lot.getFlowBatchID())) {
                CimFlowBatchDO flowBatch = cimJpaRepository
                        .queryOne("SELECT * FROM OMFLOWB WHERE FLOWB_ID = ?1",
                        CimFlowBatchDO.class, lot.getFlowBatchID());
                lotFlowBatchInfo.setFlowBatchReserveEquipmentID(CimObjectUtils.isEmpty(flowBatch) ? null
                        : new ObjectIdentifier(flowBatch.getEquipmentID(), flowBatch.getEquipmentObj()));
            }
        }
        //--------------------------------------------------------------------------------------------//
        // Step 17 - Set LotNoteFlagInfo                                                                        //
        //--------------------------------------------------------------------------------------------//

        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotNoteFlagInfoFlag())) {
            if (CimStringUtils.isEmpty(lot.getCommentID())) {
                lotNoteFlagInfo.setLotCommentFlag(false);
            } else {
                CimLotCommentDO cimLotCommentExample = new CimLotCommentDO();
                cimLotCommentExample.setId(lot.getCommentID());
                CimLotCommentDO lotComment = cimJpaRepository.findOne(Example.of(cimLotCommentExample)).orElse(null);
                if (null != lotComment && !CimStringUtils.isEmpty(lotComment.getNoteContents())) {
                    lotNoteFlagInfo.setLotCommentFlag(true);
                }
            }
            CimLotNoteDO cimLotNoteExample = new CimLotNoteDO();
            cimLotNoteExample.setLotID(lot.getLotID());
            List<CimLotNoteDO> lotNote = cimJpaRepository.findAll(Example.of(cimLotNoteExample));
            if (CimObjectUtils.isEmpty(lotNote)) {
                lotNoteFlagInfo.setLotNoteFlag(false);
            } else {
                lotNoteFlagInfo.setLotNoteFlag(true);
            }

            String sql = "SELECT COUNT(ID)\n" +
                    " FROM   OMLOTOPEMEMO\n" +
                    " WHERE  LOT_ID = ?1\n" +
                    " AND    MAIN_PROCESS_ID = ?2\n" +
                    " AND    OPE_NO = ?3";
            Long lotOpeNote = cimJpaRepository.count(sql, lot.getLotID(), lot.getRouteID(), lot.getOperationNumber());
            if (0 == lotOpeNote.intValue()) {
                lotNoteFlagInfo.setLotOperationNoteFlag(false);
            } else {
                lotNoteFlagInfo.setLotOperationNoteFlag(true);
            }
        }
        //--------------------------------------------------------------------------------------------//
        // Step 18 - Set LotOperationInfo                                                             //
        //--------------------------------------------------------------------------------------------//
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotOperationInfoFlag())) {
            lotOperationInfo.setRouteID(new ObjectIdentifier(lot.getRouteID(), lot.getRouteObj()));
            lotOperationInfo.setOperationNumber(lot.getOperationNumber());
            lotOperationInfo.setProcessDefinitionType(processDefinitionType);
            List<Infos.LotEquipmentList> strLotEquipmentList = new ArrayList<>();
            if (CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_FINISHED,lot.getLotState())
                    || CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_SHIPPED,lot.getLotState())
                    || !CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR,lot.getLotInventoryState())) {
                lotOperationInfo.setLotEquipmentList(null);
            } else {
                if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING,lot.getLotProcessState())) {
                    if (null != processOperation) {
                        Infos.LotEquipmentList lotEquipmentList = new Infos.LotEquipmentList();
                        lotEquipmentList.setEquipmentID(new ObjectIdentifier(processOperation.getAssignEquipmentID(),
                                processOperation.getAssignEquipmentObj()));

                        CimEquipmentDO equipment = cimJpaRepository
                                .queryOne("SELECT * FROM OMEQP WHERE EQP_ID = ?1",
                                CimEquipmentDO.class, processOperation.getAssignEquipmentID());
                        Validations.check(null == equipment, retCodeConfig.getNotFoundEqp());

                        lotEquipmentList.setEquipmentName(equipment.getDescription());
                        strLotEquipmentList.add(lotEquipmentList);
                        lotOperationInfo.setLotEquipmentList(strLotEquipmentList);
                    }
                } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD,lot.getLotHoldState())) {
                    String sql = "SELECT OMLOT_HOLDEQP.EQP_ID,\n" +
                            "  OMLOT_HOLDEQP.EQP_RKEY,\n" +
                            "  OMEQP.DESCRIPTION\n" +
                            "  FROM   OMLOT_HOLDEQP, OMEQP\n" +
                            "  WHERE  OMLOT_HOLDEQP.REFKEY = ?1\n" +
                            "    AND  OMEQP.EQP_ID = OMLOT_HOLDEQP.EQP_ID";
                    List<Object[]> lotHoldEquipments = cimJpaRepository.query(sql, lot.getId());
                    if (CimArrayUtils.isNotEmpty(lotHoldEquipments)) {
                        for (Object[] lotEquipment : lotHoldEquipments) {
                            Infos.LotEquipmentList lotEquipmentList = new Infos.LotEquipmentList();
                            lotEquipmentList.setEquipmentID(new ObjectIdentifier((String) lotEquipment[0],
                                    (String) lotEquipment[1]));
                            lotEquipmentList.setEquipmentName((String) lotEquipment[2]);
                            strLotEquipmentList.add(lotEquipmentList);
                        }
                    }

                    lotOperationInfo.setLotEquipmentList(strLotEquipmentList);
                    if (CimArrayUtils.isEmpty(lotOperationInfo.getLotEquipmentList())) {
                        String sql1 = "SELECT OMLOT_EQP.EQP_ID,\n" +
                                "        OMLOT_EQP.EQP_RKEY,\n" +
                                "        OMEQP.DESCRIPTION\n" +
                                " FROM   OMLOT_EQP, OMEQP\n" +
                                " WHERE  OMLOT_EQP.REFKEY = ?1\n" +
                                " AND    OMEQP.EQP_ID = OMLOT_EQP.EQP_ID";
                        List<Object[]> lotEquipments = cimJpaRepository.query(sql1, lot.getId());
                        if (CimArrayUtils.isNotEmpty(lotEquipments)) {
                            for (Object[] lotEquipment : lotEquipments) {
                                Infos.LotEquipmentList lotEquipmentList = new Infos.LotEquipmentList();
                                lotEquipmentList.setEquipmentID(new ObjectIdentifier((String) lotEquipment[0],
                                        (String) lotEquipment[1]));
                                lotEquipmentList.setEquipmentName((String) lotEquipment[2]);
                                strLotEquipmentList.add(lotEquipmentList);
                            }
                        }
                        lotOperationInfo.setLotEquipmentList(strLotEquipmentList);
                    }
                } else if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_WAITING,lot.getLotProcessState())) {
                    String sql1 = "SELECT OMLOT_EQP.EQP_ID,\n" +
                            "        OMLOT_EQP.EQP_RKEY,\n" +
                            "        OMEQP.DESCRIPTION\n" +
                            " FROM   OMLOT_EQP, OMEQP\n" +
                            " WHERE  OMLOT_EQP.REFKEY = ?1\n" +
                            " AND    OMEQP.EQP_ID = OMLOT_EQP.EQP_ID";
                    List<Object[]> lotEquipments = cimJpaRepository.query(sql1, lot.getId());
                    if (CimArrayUtils.isNotEmpty(lotEquipments)) {
                        for (Object[] lotEquipment : lotEquipments) {
                            Infos.LotEquipmentList lotEquipmentList = new Infos.LotEquipmentList();
                            lotEquipmentList.setEquipmentID(new ObjectIdentifier((String) lotEquipment[0],
                                    (String) lotEquipment[1]));
                            lotEquipmentList.setEquipmentName((String) lotEquipment[2]);
                            strLotEquipmentList.add(lotEquipmentList);
                        }
                    }
                    lotOperationInfo.setLotEquipmentList(strLotEquipmentList);

                } else {
                    lotOperationInfo.setLotEquipmentList(null);
                }
            }
            if (null != lot.getQueuedTimeStap()) {
                lotOperationInfo.setQueuedTimeStamp(lot.getQueuedTimeStap());
            }
            String photoLayer = null;
            if (null != processOperation) {
                String sql = "SELECT * \n" +
                        "   FROM   OMPRF_PRSSSEQ\n" +
                        "   WHERE  REFKEY = ?1\n" +
                        "   AND    LINK_KEY= ?2";
                CimPFPosListDO processFlowPosList = cimJpaRepository.queryOne(sql, CimPFPosListDO.class,
                        processOperation.getProcessFlowObj(), processOperation.getOperationNumber());
//                Validations.check(null == processFlowPosList, retCodeConfig.getError());
                if (processFlowPosList != null && processFlowPosList.getProcessOperationSpecificationsObj() != null) {
                    CimProcessOperationSpecificationDO pos = cimJpaRepository
                            .queryOne("SELECT * FROM OMPRSS WHERE ID = ?1",
                                    CimProcessOperationSpecificationDO.class,
                                    processFlowPosList.getProcessOperationSpecificationsObj());
                    photoLayer = pos.getPhotoLayer();
                }
                CimProcessOperationSpecificationDO modulePos = cimJpaRepository
                        .queryOne("SELECT * FROM OMPRSS WHERE ID = ?1", CimProcessOperationSpecificationDO.class,
                                processOperation.getModuleProcessOperationSpecificationsObj());

                lotOperationInfo.setOperationID(activeProcessDefinitionID);
                lotOperationInfo.setOperationName(processOperation.getOperationName());
                lotOperationInfo.setDepartment(department);
                lotOperationInfo.setInspectionType(inspectionType);
                Timestamp planStartTime = processOperation.getPlanStartTime();
                Timestamp planEndTime = processOperation.getPlanEndTime();
                lotOperationInfo.setPlanStartTimeStamp(Timestamp.valueOf(BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING)
                        .equals(planStartTime) ? null : planStartTime);
                lotOperationInfo.setPlanEndTimeStamp(Timestamp.valueOf(BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING)
                        .equals(planEndTime) ? null : planEndTime);
                lotOperationInfo.setPlannedEquipmentID(ObjectIdentifier.build(processOperation.getPlanEuipmentID(),
                        processOperation.getPlanEuipmentObj()));
                lotOperationInfo.setMandatoryOperationFlag(modulePos.getMandatoryFlag());
                lotOperationInfo.setStageID(stage);
                Boolean testSpecFoundFlag = false;

                //----------------------------------------------------------------------------------
                // Step 19 - Search Test Specification by Product Specification
                //----------------------------------------------------------------------------------
                if (CimStringUtils.isNotEmpty(lot.getProductSpecificationID())) {
                    String sql1 = " SELECT * FROM  OMPRSS_TESTSPECPROD WHERE REFKEY = ?1\n" +
                            " AND LINK_KEY = ?2";
                    CimPOSTestSpecificationDO processOperationSpecificationTestSpecification = cimJpaRepository
                            .queryOne(sql1, CimPOSTestSpecificationDO.class, modulePos.getId(),
                                    lot.getProductSpecificationID());
                    if (!CimObjectUtils.isEmpty(processOperationSpecificationTestSpecification)) {
                        testSpecFoundFlag = true;
                    }
                }
                //----------------------------------------------------------------------------------
                // Step 20 - Search Test Specification  by Product Group
                //----------------------------------------------------------------------------------
                String productGroupID = null;
                if (!testSpecFoundFlag && !CimStringUtils.isEmpty(lot.getProductSpecificationID())) {
                    CimProductSpecificationDO processOperationSpecifications = cimJpaRepository
                            .queryOne("SELECT * FROM OMPRODINFO WHERE PROD_ID = ?1",
                                    CimProductSpecificationDO.class,
                                    lot.getProductSpecificationID());
                    productGroupID = processOperationSpecifications.getProductGroupID();
                    if (null != processOperationSpecifications) {
                        String sql2 = "SELECT * FROM OMPRSS_TESTSPECPRODFMLY \n" +
                                " WHERE  REFKEY = ?1\n" +
                                " AND    PRODFMLY_ID = ?2";
                        CimPOSTestSpecProdGrpDO posTestSpecProdGrpDO = cimJpaRepository.queryOne(sql2,
                                CimPOSTestSpecProdGrpDO.class, modulePos.getId(), productGroupID);
                        if (null != posTestSpecProdGrpDO) {
                            testSpecFoundFlag = true;
                        }
                    }
                }
                //----------------------------------------------------------------------------------
                // Step 21 - Search Test Specification by Technology
                //----------------------------------------------------------------------------------

                if (!testSpecFoundFlag && !CimStringUtils.isEmpty(productGroupID)) {
                    CimProductGroupDO productGroup = cimJpaRepository
                            .queryOne("SELECT * FROM OMPRODFMLY WHERE PRODFMLY_ID = ?1",
                                    CimProductGroupDO.class, productGroupID);
                    if (null != productGroup) {
                        String sql2 = "SELECT * FROM OMPRSS_TESTSPECTECH \n" +
                                " WHERE  REFKEY = ?1\n" +
                                " AND    TECH_ID = ?2";
                        CimPOSTestSpecTechnologyDO posTestSpecTechnology = cimJpaRepository
                                .queryOne(sql2, CimPOSTestSpecTechnologyDO.class, modulePos.getId(),
                                        productGroup.getTechnologyID());
                        if (null != posTestSpecTechnology) {
                            testSpecFoundFlag = true;
                        }
                    }
                }

                //----------------------------------------------------------------------------------
                // Step 21 - Search Default Test Specification
                //----------------------------------------------------------------------------------
                ObjectIdentifier testSpecificationID = null;
                if (CimBooleanUtils.isFalse(testSpecFoundFlag)) {
                    CimProcessOperationSpecificationDO modulePOS = cimJpaRepository
                            .queryOne("SELECT * FROM OMPRSS WHERE ID = ?1", CimProcessOperationSpecificationDO.class,
                                    modulePos.getId());
                    if (null != modulePos && CimStringUtils.isNotEmpty(modulePos.getTestSpecificationID())) {
                        testSpecificationID = ObjectIdentifier.build(modulePOS.getTestSpecificationID(),
                                modulePOS.getTestSpecificatioObj());
                        testSpecFoundFlag = true;
                    }
                }
                if (testSpecFoundFlag) {
                    lotOperationInfo.setTestSpecID(testSpecificationID);
                }
                lotOperationInfo.setMaskLevel(photoLayer);
                lotOperationInfo.setProcessHoldFlag(false);
                lotOperationInfo.setReworkCount(0);
            } else {
                lotOperationInfo.setMandatoryOperationFlag(false);
                lotOperationInfo.setProcessHoldFlag(false);
                lotOperationInfo.setReworkCount(0);
            }

            //--------------------------------------------------------
            //  Step 22 - Select Back PO List
            //--------------------------------------------------------
            if (null != processOperation) {
                //--------------------------------------------------------
                //  Select Back PO List
                //--------------------------------------------------------
                List<CimProcessFlowContextBackPODO> processFlowContextBackProcessOperations = cimJpaRepository
                        .query("SELECT * FROM OMPRFCX_BCKPROPESEQ WHERE REFKEY = ?1",
                                CimProcessFlowContextBackPODO.class ,
                                lot.getProcessFlowContextObj());
                if (!CimArrayUtils.isEmpty(processFlowContextBackProcessOperations)) {
                    List<Infos.SimpleOperationInfo> backOperations = new ArrayList<>();
                    for (int i = 0; i < processFlowContextBackProcessOperations.size(); i++) {
                        CimProcessOperationDO processOperation1 = cimJpaRepository
                                .queryOne("SELECT * FROM OMPROPE WHERE ID = ?1",CimProcessOperationDO.class,
                                        processFlowContextBackProcessOperations.get(i).getProcessOperationObj());
                        if (!CimObjectUtils.isEmpty(processOperation1)) {
                            Infos.SimpleOperationInfo simpleOperationInfo = new Infos.SimpleOperationInfo();
                            simpleOperationInfo.setOpeNo(processOperation1.getOperationNumber());
                            simpleOperationInfo.setRouteID(ObjectIdentifier
                                    .build(processOperation1.getMainProcessDefinitionID(),
                                            processOperation1.getMainProcessDefinitionObj()));
                            backOperations.add(simpleOperationInfo);
                        }
                        lotOperationInfo.setBackOperationList(backOperations);
                    }
                }
            }
        }

        //--------------------------------------------------------------------------------------------//
        // Step 23 - Set LotOrderInfo                                                                //
        //--------------------------------------------------------------------------------------------//
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotOrderInfoFlag())) {
            lotOrderInfo.setOrderNumber(lot.getOrderNumber());
            lotOrderInfo.setCustomerCode(lot.getCustomerID());
            lotOrderInfo.setShipRequireFlag(lot.getShipRequest());
        }

        //--------------------------------------------------------------------------------------------//
        // Step 24 - Set LotControlJobInfo                                                            //
        //--------------------------------------------------------------------------------------------//
        Infos.LotControlJobInfo lotControlJobInfo = new Infos.LotControlJobInfo();
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotControlJobInfoFlag())
                || CimBooleanUtils.isTrue(lotInfoInqFlag.getLotRecipeInfoFlag())) {
            lotControlJobInfo.setControlJobID(ObjectIdentifier.build(lot.getControlJobID(), lot.getControlJobObj()));
            if (null != lot.getControlJobID()) {
                CimControlJobDO cimControlJobExample = new CimControlJobDO();
                cimControlJobExample.setControlJobID(lot.getControlJobID());
                CimControlJobDO controlJob = cimJpaRepository.findOne(Example.of(cimControlJobExample)).orElse(null);
                if (!CimObjectUtils.isEmpty(controlJob)) {
                    if (lotInfoInqFlag.getLotControlJobInfoFlag()) {
                        lotControlJobInfo.setProcessReserveEquipmentID(ObjectIdentifier.build(controlJob.getEquipmentID(),
                                controlJob.getEquipmentObject()));
                        lotControlJobInfo.setProcessReserveUserID(ObjectIdentifier.build(controlJob.getOwnerID(),
                                controlJob.getOwnerObject()));
                    }
                    if (lotInfoInqFlag.getLotRecipeInfoFlag()) {
                        eqpIDForGetReticleGroup = ObjectIdentifier.build(controlJob.getEquipmentID(),
                                controlJob.getEquipmentObject());
                    }
                }
            }
        }
        //--------------------------------------------------------------------------------------------//
        // Step 25 - Set LotProductInfo                                                               //
        //--------------------------------------------------------------------------------------------//
        Infos.LotProductInfo lotProductInfo = new Infos.LotProductInfo();
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotProductInfoFlag())) {
            lotProductInfo.setReticleSetID(lot.getReticleSetID());
            lotProductInfo.setProductID(ObjectIdentifier
                    .build(lot.getProductSpecificationID(), lot.getProductSpecificationObj()));

            CimProductSpecificationDO productSpecification = cimJpaRepository
                    .queryOne("SELECT * FROM OMPRODINFO WHERE PROD_ID = ?1", CimProductSpecificationDO.class,
                            lot.getProductSpecificationID());
            if (!CimObjectUtils.isEmpty(productSpecification)) {
                lotProductInfo.setProductGroupID(ObjectIdentifier.build(productSpecification.getProductGroupID(),
                        productSpecification.getProductGroupObj()));
                lotProductInfo.setProductType(productSpecification.getProductType());
                if (CimStringUtils.isEmpty(productSpecification.getManufacturingLayer())) {
                    lotProductInfo.setManufacturingLayer(lot.getManufacturingLayer());
                } else {
                    lotProductInfo.setManufacturingLayer(productSpecification.getManufacturingLayer());
                }
                CimProductGroupDO productGroup = cimJpaRepository
                        .queryOne("SELECT * FROM OMPRODFMLY WHERE PRODFMLY_ID = ?1", CimProductGroupDO.class,
                                productSpecification.getProductGroupID());
                if (null != productGroup) {
                    lotProductInfo.setTechnologyCode(productGroup.getTechnologyID());
                }
            }

        }
        //---------------------------------------
        // Step 26 - Set LotRecipeInfo
        //---------------------------------------
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotRecipeInfoFlag())) {
            lotRecipeInfo.setFfEnforceFlag(false);
            lotRecipeInfo.setFbEnforceFlag(false);
            Boolean logicalRecipeFoundFlag = false;
            if (!CimStringUtils.isEmpty(lot.getControlJobID())) {
                if(null != processOperation){
                    lotRecipeInfo.setLogicalRecipeID(ObjectIdentifier.build(processOperation.getAssignLogicalRecipeID(),
                            processOperation.getAssignLogicalRecipeObj()));
                }
            } else {
                ObjectIdentifier objProcessLogicalRecipeGetDROut = null;
                if(!ObjectIdentifier.isEmpty(activeProcessDefinitionID)){
                    objProcessLogicalRecipeGetDROut = logicalRecipeMethod.processLogicalRecipeGetDR(objCommon,
                            ObjectIdentifier.build(lot.getProductSpecificationID(),lot.getProductSpecificationObj()),
                            activeProcessDefinitionID);
                    lotRecipeInfo.setLogicalRecipeID(objProcessLogicalRecipeGetDROut);
                }
            }

            if (!ObjectIdentifier.isEmpty(lotRecipeInfo.getLogicalRecipeID())) {
                CimLogicalRecipeDO logicalRecipe = cimJpaRepository
                        .queryOne("SELECT * FROM OMLRCP WHERE LRCP_ID = ?1", CimLogicalRecipeDO.class,
                                ObjectIdentifier.fetchValue(lotRecipeInfo.getLogicalRecipeID()));
                if (null != logicalRecipe) {
                    lotRecipeInfo.setProcessMonitorProductID(ObjectIdentifier
                            .build(logicalRecipe.getMonitorProductSpecificationID(),
                                    logicalRecipe.getMonitorProductSpecificationObj()));
                    lotRecipeInfo.setTestTypeID(ObjectIdentifier
                            .build(logicalRecipe.getTestTypeID(), logicalRecipe.getTestTypeObj()));
                }
            }

            String dummyPhotoLayer = null;
            List<ObjectIdentifier> objLotReticleGroupsGetDROut = this.lotReticleGroupsGetDR(objCommon, lotID,
                    eqpIDForGetReticleGroup, dummyPhotoLayer);
            lotRecipeInfo.setReticleGroupList(objLotReticleGroupsGetDROut);
        }
        //----------------------------------------------------------//
        // Step 26 - Set LotLocationInfo                            //
        //----------------------------------------------------------//
        Infos.LotLocationInfo lotLocationInfo = new Infos.LotLocationInfo();
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotLocationInfoFlag())) {
            CimLotMaterialContainerDO cimLotMaterialContainerExample = new CimLotMaterialContainerDO();
            cimLotMaterialContainerExample.setSequenceNumber(0);
            cimLotMaterialContainerExample.setReferenceKey(lot.getId());
            List<CimLotMaterialContainerDO> lotMaterialContainers = cimJpaRepository
                    .findAll(Example.of(cimLotMaterialContainerExample));
            if (CimArrayUtils.isNotEmpty(lotMaterialContainers)) {
                for (CimLotMaterialContainerDO lotMaterialContainer : lotMaterialContainers) {
                    lotLocationInfo.setCassetteID(ObjectIdentifier.build(lotMaterialContainer.getMaterialContainerID(),
                            lotMaterialContainer.getMaterialContainerObj()));
                    CimCassetteDO cimCassetteExample = new CimCassetteDO();
                    cimCassetteExample.setCassetteID(lotMaterialContainer.getMaterialContainerID());
                    CimCassetteDO cassette = cimJpaRepository.findOne(Example.of(cimCassetteExample)).orElse(null);
                    if (null != cassette) {
                        lotLocationInfo.setTransferStatus(cassette.getTransferState());
                        lotLocationInfo.setTransferReserveUserID(cassette.getReserveUserID());
                        lotLocationInfo.setCassetteCategory(cassette.getCassetteCategory());
                        lotLocationInfo.setCarrierType(cassette.getCarrierType());

                        if (CimStringUtils.isNotEmpty(cassette.getMaterialLocationObj())) {
                            CimMaterialLocationDO exampleMtrlL = new CimMaterialLocationDO();
                            exampleMtrlL.setId(cassette.getMaterialLocationObj());
                            CimMaterialLocationDO materialLocation = cimJpaRepository.findOne(Example.of(exampleMtrlL)).orElse(null);
                            if (null != materialLocation) {
                                lotLocationInfo.setShelfPositionX(materialLocation.getXCoor());
                                lotLocationInfo.setShelfPositionY(materialLocation.getYCoor());
                                lotLocationInfo.setShelfPositionZ(materialLocation.getZCoor());
                            }
                        }

                        CimEquipmentDO equipment = cimJpaRepository
                                .queryOne("SELECT * FROM OMEQP WHERE EQP_ID = ?1", CimEquipmentDO.class,
                                        cassette.getEquipmentID());
                        if (null != equipment) {
                            lotLocationInfo.setEquipmentID(ObjectIdentifier.build(cassette.getEquipmentID(),
                                    cassette.getEquipmentObj()));
                        } else {
                            CimStockerDO exampleStk = new CimStockerDO();
                            exampleStk.setStockerID(cassette.getEquipmentID());
                            CimStockerDO stocker = cimJpaRepository.findOne(Example.of(exampleStk)).orElse(null);
                            if (null != stocker) {
                                lotLocationInfo.setStockerID(ObjectIdentifier.build(cassette.getEquipmentID(),
                                        cassette.getEquipmentObj()));
                                lotLocationInfo.setShelfPosition(new Infos.ShelfPosition(cassette.getShelfPositionX(),
                                        cassette.getShelfPositionY(), cassette.getShelfPositionZ()));
                            }
                        }
                    }
                }
            } else {
                List<ObjectIdentifier> equipmentIDSeq = new ArrayList<>();
                if (CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_SHIPPED,lot.getLotState())
                        || CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_FINISHED,lot.getLotState())
                        || !CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR,lot.getLotInventoryState())) {

                } else {
                    if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING,lot.getLotProcessState())) {
                        if (null != processOperation) {
                            equipmentIDSeq.add(ObjectIdentifier.build(processOperation.getAssignEquipmentID(),
                                    processOperation.getAssignEquipmentObj()));
                        }
                    } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD,lot.getLotHoldState())) {
                        CimLotHoldEquipmentDO cimLotHoldEquipmentExample = new CimLotHoldEquipmentDO();
                        cimLotHoldEquipmentExample.setReferenceKey(lot.getId());
                        List<CimLotHoldEquipmentDO> lotHoldEquipments = cimJpaRepository
                                .findAll(Example.of(cimLotHoldEquipmentExample));
                        if (!CimArrayUtils.isEmpty(lotHoldEquipments)) {
                            for (CimLotHoldEquipmentDO lotHoldEquipment : lotHoldEquipments) {
                                equipmentIDSeq.add(ObjectIdentifier
                                        .build(lotHoldEquipment.getEquipmentID(),lotHoldEquipment.getEquipmentObj()));
                            }
                        }
                    } else if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_WAITING,lot.getLotProcessState())) {
                        CimLotEquipmentDO cimLotEquipmentExample = new CimLotEquipmentDO();
                        cimLotEquipmentExample.setReferenceKey(lot.getId());
                        List<CimLotEquipmentDO> lotEquipments = cimJpaRepository.findAll(Example.of(cimLotEquipmentExample));
                        if (!CimArrayUtils.isEmpty(lotEquipments)) {
                            for (CimLotEquipmentDO lotEquipment : lotEquipments) {
                                equipmentIDSeq.add(ObjectIdentifier
                                        .build(lotEquipment.getEquipmentID(),lotEquipment.getEquipmentObj()));
                            }
                        }
                    } else {
                        equipmentIDSeq.add(null);
                    }
                }
                List<ObjectIdentifier> waferIDs = new ArrayList<>();
                if (0 < CimArrayUtils.getSize(equipmentIDSeq)) {
                    CimLotMaterialDO cimLotMaterialExample = new CimLotMaterialDO();
                    cimLotMaterialExample.setReferenceKey(lot.getId());
                    List<CimLotMaterialDO> lotMaterials = cimJpaRepository.findAll(Example.of(cimLotMaterialExample));
                    if (!CimArrayUtils.isEmpty(lotMaterials)) {
                        for (CimLotMaterialDO lotMaterialDO : lotMaterials) {
                            waferIDs.add(ObjectIdentifier
                                    .build(lotMaterialDO.getMaterialID(), lotMaterialDO.getMaterialObj()));
                        }
                    }

                    for (int i = 0; i < CimArrayUtils.getSize(equipmentIDSeq); i++) {
                        Infos.EqpContainerInfo objEquipmentContainerInfoGetDROut = equipmentMethod
                                .equipmentContainerInfoGetDR(objCommon, equipmentIDSeq.get(i));
                        int ctnLen = CimArrayUtils.getSize(objEquipmentContainerInfoGetDROut.getEqpContainerList());
                        for (int j = 0; j < ctnLen; j++) {
                            int pstLen = CimArrayUtils.getSize(objEquipmentContainerInfoGetDROut
                                    .getEqpContainerList().get(j).getEqpContainerPosition());
                            for (int k = 0; k < pstLen; k++) {
                                for (int l = 0; l < CimArrayUtils.getSize(waferIDs); l++) {
                                    if (ObjectIdentifier.equalsWithValue(objEquipmentContainerInfoGetDROut
                                                    .getEqpContainerList().get(j).getEqpContainerPosition().get(k).getWaferID(),
                                            waferIDs.get(l))
                                            && CimStringUtils.equals(BizConstant.SP_SLMSTATE_STORED,
                                            objEquipmentContainerInfoGetDROut.getEqpContainerList().get(j)
                                                    .getEqpContainerPosition().get(k).getFmcState())) {
                                        lotLocationInfo.setEquipmentID(equipmentIDSeq.get(i));
                                        break;
                                    }
                                }
                                if (!ObjectIdentifier.isEmpty(lotLocationInfo.getEquipmentID())) {
                                    break;
                                }
                            }
                            if (!ObjectIdentifier.isEmpty(lotLocationInfo.getEquipmentID())) {
                                break;
                            }
                        }
                        if (!ObjectIdentifier.isEmpty(lotLocationInfo.getEquipmentID())) {
                            break;
                        }
                    }
                }
            }
        }
        //--------------------------------------------------------------------------------------------//
        // Step 27 - Set LotWipOperationInfo                                                          //
        //--------------------------------------------------------------------------------------------//
        Infos.LotWipOperationInfo lotWipOperationInfo = new Infos.LotWipOperationInfo();
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotWipOperationInfoFlag())) {
            if (!CimBooleanUtils.isTrue(lot.getRespOperationFlag())) {
                lotWipOperationInfo.setResponsibleRouteID(lotOperationInfo.getRouteID());
                lotWipOperationInfo.setResponsibleOperationID(lotOperationInfo.getOperationID());
                lotWipOperationInfo.setResponsibleOperationNumber(lotOperationInfo.getOperationNumber());
                lotWipOperationInfo.setResponsibleOperationName(lotOperationInfo.getOperationName());
            } else {
                //-----------------------------------------------------------------------------------//
                // Step 28 - Get Previous Process Operation                                          //
                //-----------------------------------------------------------------------------------//
                if (null != processOperation) {
                    CimProcessFlowContextPODO processFlowContextProcessOperations = cimJpaRepository
                            .queryOne("SELECT * FROM OMPRFCX_PROPESEQ WHERE PROPE_RKEY = ?1",
                                    CimProcessFlowContextPODO.class, processOperation.getId());
                    if (null != processFlowContextProcessOperations && 0 < processFlowContextProcessOperations.getSequenceNumber()) {
                        CimProcessFlowContextPODO tmpProcessFlowContextProcessOperations = cimJpaRepository
                                .queryOne("SELECT * FROM OMPRFCX_PROPESEQ WHERE ID = ?1 AND IDX_NO = ?2",
                                        CimProcessFlowContextPODO.class, processFlowContextProcessOperations.getId(),
                                        processFlowContextProcessOperations.getSequenceNumber() - 1);
                        if (null != tmpProcessFlowContextProcessOperations) {
                            CimProcessOperationDO previousProcessOperation = cimJpaRepository
                                    .queryOne("SELECT * FROM OMPROPE WHERE ID = ?1", CimProcessOperationDO.class,
                                            tmpProcessFlowContextProcessOperations.getProcessOperationObj());
                            if (!CimObjectUtils.isEmpty(previousProcessOperation)) {
                                lotWipOperationInfo.setResponsibleRouteID(ObjectIdentifier
                                        .build(previousProcessOperation.getMainProcessDefinitionID(),
                                                previousProcessOperation.getMainProcessDefinitionObj()));
                                lotWipOperationInfo.setResponsibleOperationName(previousProcessOperation
                                        .getOperationName());
                                lotWipOperationInfo.setResponsibleOperationID(ObjectIdentifier
                                        .build(previousProcessOperation.getProcessDefinitionID(),
                                                previousProcessOperation.getProcessDefinitionObj()));
                                lotWipOperationInfo.setResponsibleOperationNumber(previousProcessOperation
                                        .getOperationNumber());
                            }
                        }

                    }
                }
            }
        }
        //------------------------------------------------//
        //Step 29 - Set LotBackupInfo                     //
        //------------------------------------------------//
        if (CimBooleanUtils.isTrue(lotInfoInqFlag.getLotBackupInfoFlag())) {
            lotBackupInfo.setBackupProcessingFlag(lot.getBackupProcessingFlag());
            lotBackupInfo.setCurrentLocationFlag(lot.getCurrentLocationFlag());
            lotBackupInfo.setTransferFlag(lot.getTransferFlag());
            Infos.BackupAddress backupAddress = new Infos.BackupAddress();
            backupAddress.setHostName(lot.getHostName());
            lotBackupInfo.setBornSiteAddress(backupAddress);
            if (CimBooleanUtils.isTrue(lot.getBackupProcessingFlag())) {
                if (null != processOperation) {
                    List<CimPOBackUpDataDO> processOperationBackUpDatas = cimJpaRepository
                            .query("SELECT * FROM OMPROPE_INTFABDATA WHERE REFKEY = ?1", CimPOBackUpDataDO.class,
                                    processOperation.getId());
                    if (!CimArrayUtils.isEmpty(processOperationBackUpDatas)) {
                        CimPOBackUpDataDO processOperationBackUpData = null;
                        if (0 < processOperationBackUpDatas.size()) {
                            processOperationBackUpData = processOperationBackUpDatas
                                    .get(processOperationBackUpDatas.size() -1);
                        } else {
                            processOperationBackUpData = processOperationBackUpDatas
                                    .get(processOperationBackUpDatas.size());
                        }
                        if (processOperationBackUpData.getEntryFlag() && processOperationBackUpData.getSourceFlag()) {

                            CimProcessFlowContextReturnDO processFlowContextReturn = cimJpaRepository
                                    .queryOne("SELECT * FROM OMPRFCX_RTNSEQ WHERE ID = ?1 AND IDX_NO = ?2",
                                            CimProcessFlowContextReturnDO.class, lot.getProcessFlowContextObj(), 0);
                            if (null != processFlowContextReturn) {
                                lotBackupInfo.setReturnOperationNumber(processFlowContextReturn.getOperationNumber());

                                CimProcessFlowDO returnProcessFlow = cimJpaRepository
                                        .queryOne("SELECT * FROM OMPRF WHERE ID = ?1", CimProcessFlowDO.class,
                                                processFlowContextReturn.getProcessFlowObj());
                                if (null != returnProcessFlow) {
                                    lotBackupInfo.setReturnRouteID(ObjectIdentifier
                                            .build(returnProcessFlow.getMainProcessDefinitionID(),
                                                    returnProcessFlow.getMainProcessDefinitionObj()));
                                }
                            }
                        }
                    }
                }
            }
            //-----------------------------------------------------------------------------
            // Step 30 -  Set backup info for source site.
            //-----------------------------------------------------------------------------
            CimLotBackupSrcDO cimLotBackupSrcExample = new CimLotBackupSrcDO();
            cimLotBackupSrcExample.setReferenceKey(lot.getId());
            List<CimLotBackupSrcDO> lotBackupSrcs = cimJpaRepository.findAll(Example.of(cimLotBackupSrcExample));
            if (null != lotBackupSrcs) {
                List<Infos.LotBackupData> lotBackupDataList = new ArrayList<>();
                for (int i = 0, j = CimArrayUtils.getSize(lotBackupSrcs); i < j; i++) {
                    Infos.LotBackupData lotBackupData = new Infos.LotBackupData();
                    lotBackupData.setBackupState(lotBackupSrcs.get(i).getBackupState());
                    Infos.BackupAddress backupAddress1 = new Infos.BackupAddress();
                    backupAddress1.setHostName(lotBackupSrcs.get(i).getHostName());
                    lotBackupData.setBackupAddress(backupAddress1);
                    Infos.BackupProcess backupProcess = new Infos.BackupProcess();
                    backupProcess.setEntryOperationNumber(lotBackupSrcs.get(i).getEntryOperationNumber());
                    backupProcess.setEntryRouteId(lotBackupSrcs.get(i).getEntryRouteID());
                    backupProcess.setExitOperationNumber(lotBackupSrcs.get(i).getExitOperationNumber());
                    backupProcess.setExitRouteId(lotBackupSrcs.get(i).getExitRouteID());
                    lotBackupData.setBackupProcess(backupProcess);
                    lotBackupDataList.add(lotBackupData);
                }
                lotBackupInfo.setLotBackupSourceDataList(lotBackupDataList);
            }

            //-----------------------------------------------------------------------------
            //  Step 31 -  Set backup info for destination site.
            //-----------------------------------------------------------------------------
            CimLotBackupDestDO cimLotBackupDestExample = new CimLotBackupDestDO();
            cimLotBackupDestExample.setReferenceKey(lot.getId());
            List<CimLotBackupDestDO> lotBackupDests = cimJpaRepository.findAll(Example.of(cimLotBackupDestExample));
            List<Infos.LotBackupData> lotBackupDataList = new ArrayList<>();
            for (int i = 0, j = CimArrayUtils.getSize(lotBackupDests); i < j; i++) {
                Infos.LotBackupData lotBackupData = new Infos.LotBackupData();
                lotBackupData.setBackupState(lotBackupDests.get(i).getBackupState());
                Infos.BackupAddress backupAddress1 = new Infos.BackupAddress();
                backupAddress1.setHostName(lotBackupDests.get(i).getHostName());
                lotBackupData.setBackupAddress(backupAddress1);
                Infos.BackupProcess backupProcess = new Infos.BackupProcess();
                backupProcess.setEntryOperationNumber(lotBackupDests.get(i).getEntryOperationNumber());
                backupProcess.setEntryRouteId(lotBackupDests.get(i).getEntryRouteID());
                backupProcess.setExitOperationNumber(lotBackupDests.get(i).getExitOperationNumber());
                backupProcess.setExitRouteId(lotBackupDests.get(i).getExitRouteID());
                lotBackupData.setBackupProcess(backupProcess);
                lotBackupDataList.add(lotBackupData);
            }
            lotBackupInfo.setLotBackupDestDataList(lotBackupDataList);
        }

        //-----------------------------------------------------------------------------
        //  Step 32 -  Set contamination level and pr flag
        //-----------------------------------------------------------------------------
        lotBasicInfo.setContaminationLevel(lot.getContaminationLevel());
        if (!CimObjectUtils.isEmpty(lot.getPrFlag())) {
            if (lot.getPrFlag().equals(0)) {
                lotBasicInfo.setPrFlag(null);
            } else if (lot.getPrFlag().equals(1)) {
                lotBasicInfo.setPrFlag(true);
            } else if (lot.getPrFlag().equals(2)) {
                lotBasicInfo.setPrFlag(false);
            }
        }
        lotInfo.setLotBasicInfo(lotBasicInfo);
        lotInfo.setLotControlUseInfo(lotControlUseInfo);
        lotInfo.setLotFlowBatchInfo(lotFlowBatchInfo);
        lotInfo.setLotNoteFlagInfo(lotNoteFlagInfo);
        lotInfo.setLotOperationInfo(lotOperationInfo);
        lotInfo.setLotOrderInfo(lotOrderInfo);
        lotInfo.setLotControlJobInfo(lotControlJobInfo);
        lotInfo.setLotProductInfo(lotProductInfo);
        lotInfo.setLotRecipeInfo(lotRecipeInfo);
        lotInfo.setLotLocationInfo(lotLocationInfo);
        lotInfo.setLotWipOperationInfo(lotWipOperationInfo);
        return lotInfo;
    }

    /*
     *
     * description:
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * @author Jerry
     * @date
     * @param null -
     * @return
     */
    private List<Infos.EntityInhibitInfo> processForEntityinhibiTrecoeds(List<Infos.EntityInhibitRecord> entityInhibitRecords) {
        List<Infos.EntityInhibitInfo> entityInhibitInfos = new ArrayList<>();
        for (int i = 0; i < entityInhibitRecords.size(); i++) {
            List<Infos.EntityIdentifier> entities = new ArrayList<>();
            for (int j = 0; j < entityInhibitRecords.get(i).getEntities().size(); j++) {
                Infos.EntityIdentifier entityIdentifier = new Infos.EntityIdentifier();
                entityIdentifier.setAttribution(entityInhibitRecords.get(i).getEntities().get(i).getAttribution());
                entityIdentifier.setClassName(entityInhibitRecords.get(i).getEntities().get(j).getClassName());
                entityIdentifier.setObjectID(entityInhibitRecords.get(j).getEntities().get(j).getObjectID());
                entities.add(entityIdentifier);
            }
            Infos.EntityInhibitInfo entityInhibitInfo = new Infos.EntityInhibitInfo();
            Infos.EntityInhibitAttributes entityInhibitAttributes = new Infos.EntityInhibitAttributes();
            entityInhibitInfo.setEntityInhibitID(ObjectIdentifier.build(entityInhibitRecords.get(i).getId(), entityInhibitRecords.get(i).getReferenceKey()));
            entityInhibitInfo.setStringifiedObjectReference(entityInhibitRecords.get(i).getReferenceKey());
            entityInhibitAttributes.setSubLotTypes(entityInhibitRecords.get(i).getSubLotTypes());
            entityInhibitAttributes.setStartTimeStamp(entityInhibitRecords.get(i).getStartTimeStamp().toString());
            entityInhibitAttributes.setEndTimeStamp(entityInhibitRecords.get(i).getEndTimeStamp().toString());
            entityInhibitAttributes.setClaimedTimeStamp(entityInhibitRecords.get(i).getChangedTimeStamp().toString());
            entityInhibitAttributes.setReasonCode(entityInhibitRecords.get(i).getReasonCode().getValue());
            entityInhibitAttributes.setOwnerID(entityInhibitRecords.get(i).getOwner());
            entityInhibitAttributes.setMemo(entityInhibitRecords.get(i).getClaimMemo());
            entityInhibitAttributes.setEntities(entities);
            entityInhibitInfo.setEntityInhibitAttributes(entityInhibitAttributes);
            entityInhibitInfos.add(entityInhibitInfo);
        }
        return entityInhibitInfos;
    }

    @Override
    public List<Infos.LotQtimeInfo> lotQtimeGetForRouteDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID, String mainProcessFlow, String moduleProcessFlow, String operationNumber) {
        //step 1 -  Initialize

          // step 2 - Get PFX object reference
        List<Object> sqlResult = cimJpaRepository.queryOneColumn("SELECT OMLOT.PRFCX_RKEY\n" +
                "                 FROM   OMLOT\n" +
                "                 WHERE  OMLOT.LOT_ID = ?1 ", lotID.getValue());
        String pfxObj = CimObjectUtils.toString(sqlResult.get(0));
        //   Get PFX object
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aProcessFlowContext = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessFlowContext.class, pfxObj);
        Validations.check(CimObjectUtils.isEmpty(aProcessFlowContext), new OmCode(retCodeConfig.getNotFoundSystemObj(), pfxObj));

        //  check the value of mainPF

        //step 3 -  Get MainPDID from MainPF .
        // mainProcessFlow String is PF_Primary key, not PF_ID.
        sqlResult = cimJpaRepository.queryOneColumn("SELECT PRP_ID\n" +
                "                 FROM   OMPRF WHERE ID = ?1 ", mainProcessFlow);
        String pfMainPDID = CimObjectUtils.toString(sqlResult.get(0));

        //  Get QTime restriction for Lot.
        List<Object> qTimeObjList = cimJpaRepository.queryOneColumn("SELECT ID\n" +
                "                 FROM   OMQT\n" +
                "                 WHERE  LOT_ID = ?1 AND\n" +
                "                        TRIGGER_PRP_ID = ?2 AND\n" +
                "                        TIMER_FLAG = 1 AND\n" +
                "                        ACTION_COMPLETE_FLAG = 0\n" +
                "                 ORDER  BY TARGET_TIME ",  lotID.getValue(), pfMainPDID);


        List<Infos.LotQtimeInfo> lotQTimeInfos = new ArrayList<>();

        for(Object qTimeObj : qTimeObjList){
            //step 5 -  Get QTime object
            com.fa.cim.newcore.bo.pd.CimQTimeRestriction aQTime = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimQTimeRestriction.class, CimObjectUtils.toString(qTimeObj));
            Validations.check(CimObjectUtils.isEmpty(aQTime), retCodeConfig.getNotFoundSystemObj());

            //step 6 -  Check QTime Interval
            if (!aProcessFlowContext.isInQTimeInterval(aQTime)) {
                continue;
            }

            //   Get QTime information
            ProcessDTO.QTimeRestrictionInfo aQTimeInfo= aQTime.getQTimeRestrictionInfo();
            if (CimObjectUtils.isEmpty(aQTimeInfo) || CimStringUtils.isEmpty(aQTimeInfo.getTriggerOperationNumber())) {
                throw new  ServiceException(retCodeConfig.getNotFoundQtime());
            }

            //   Set return structure
            Infos.LotQtimeInfo lotQTimeInfo = new Infos.LotQtimeInfo();
            lotQTimeInfo.setQrestrictionTriggerRouteID(aQTimeInfo.getTriggerMainProcessDefinition());
            lotQTimeInfo.setQrestrictionTriggerOperationNumber(aQTimeInfo.getTriggerOperationNumber());
            lotQTimeInfo.setQrestrictionTriggerTimeStamp(aQTimeInfo.getTriggerTimeStamp());
            lotQTimeInfo.setQrestrictionTargetRouteID(aQTimeInfo.getTargetMainProcessDefinition());
            lotQTimeInfo.setQrestrictionTargetOperationNumber(aQTimeInfo.getTargetOperationNumber());
            lotQTimeInfo.setQrestrictionTargetTimeStamp(aQTimeInfo.getTargetTimeStamp());
            if (aQTimeInfo.getWatchdogRequired()) {
                lotQTimeInfo.setWatchDogRequired(BizConstant.SP_PROCESSJOBSTART_YES);
            } else {
                lotQTimeInfo.setWatchDogRequired(BizConstant.SP_PROCESSJOBSTART_NO);
            }
            if (aQTimeInfo.getActionDone()) {
                lotQTimeInfo.setActionDoneFlag(BizConstant.SP_PROCESSJOBSTART_YES);
            } else {
                lotQTimeInfo.setActionDoneFlag(BizConstant.SP_PROCESSJOBSTART_NO);
            }

            if (!BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING.equals(aQTimeInfo.getTargetTimeStamp())
                    && aQTimeInfo.getTargetTimeStamp() != null && !aQTimeInfo.getTargetTimeStamp().equals("null")) {
                lotQTimeInfo.setQrestrictionRemainTime(CimDateUtils.convertToHHmmss(
                        objCommon.getTimeStamp().getReportTimeStamp(),
                        Timestamp.valueOf(aQTimeInfo.getTargetTimeStamp())));
            } else {
                lotQTimeInfo.setQrestrictionRemainTime("-");
            }
            lotQTimeInfos.add(lotQTimeInfo);
        }

        return lotQTimeInfos;
    }

    /*
     * description:
     * change history:
     * date             defect#             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * @author jerry
     * @date 2018/6/4 11:14
     * @param null
     * @return
     */
    @Override
    public List<ObjectIdentifier> lotReticleGroupsGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier equipmentID, String photoLayer) {
        List<ObjectIdentifier> result = null;
        CimLotDO example = new CimLotDO();
        example.setLotID(ObjectIdentifier.fetchValue(lotID));
        CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
        Validations.check(lot == null, retCodeConfig.getNotFoundLot());

        if (!CimStringUtils.isEmpty(lot.getReticleSetID())) {
            if (CimStringUtils.isEmpty(photoLayer)) {

                // step 2 - Get photoLayer from CurrentOperation
                CimProcessOperationDO processOperation = cimJpaRepository.queryOne("SELECT * FROM OMPROPE WHERE ID = ?1", CimProcessOperationDO.class, lot.getProcessOperationObj());
                if (!CimObjectUtils.isEmpty(processOperation)) {
                    CimProcessOperationSpecificationDO processOperationSpecifications = cimJpaRepository.queryOne("SELECT * FROM OMPRSS WHERE ID = ?1", CimProcessOperationSpecificationDO.class, processOperation.getProcessOperationSpecificationObj());
                    if (null != processOperationSpecifications) {
                        photoLayer = processOperationSpecifications.getPhotoLayer();
                    }
                }
            }
            // step 3 -  Get default reticle groups of specified photo layer
            CimReticleSetDefinitionDO cimReticleSetDefinitionExample = new CimReticleSetDefinitionDO();
            cimReticleSetDefinitionExample.setReferenceKey(lot.getReticleSetObj());
            cimReticleSetDefinitionExample.setPhotoLayer(photoLayer);
            List<CimReticleSetDefinitionDO> reticleSetDefinition = cimJpaRepository.findAll(Example.of(cimReticleSetDefinitionExample));
            for (int i = 0; i < CimArrayUtils.getSize(reticleSetDefinition); i++) {
                CimReticleSetDFReticleGroupDO cimReticleSetDFRtclGrpExam = new CimReticleSetDFReticleGroupDO();
                cimReticleSetDFRtclGrpExam.setReferenceKey(lot.getReticleSetObj());
                cimReticleSetDFRtclGrpExam.setTheTableMarker(String.valueOf(reticleSetDefinition.get(i).getSequenceNumber()));
                List<CimReticleSetDFReticleGroupDO> reticleSetDFReticleGroups = cimJpaRepository.findAll(Example.of(cimReticleSetDFRtclGrpExam));
                List<ObjectIdentifier> defaultReticleGroupSeq = new ArrayList<>();
                for (int j = 0; j < CimArrayUtils.getSize(reticleSetDFReticleGroups); j++) {
                    //-----------------------------------------------------------------------------------
                    // Set default reticle groups into return value, when override flag is off or any
                    // specific reticle group is not found.
                    //-----------------------------------------------------------------------------------
                    defaultReticleGroupSeq.add(ObjectIdentifier.build(reticleSetDFReticleGroups.get(j).getIdentifier(),reticleSetDFReticleGroups.get(j).getId()));
                }
                List<ObjectIdentifier> specificReticleGroupSeq = new ArrayList<>();
                if (CimBooleanUtils.isTrue(reticleSetDefinition.get(i).getOverrideFlag())) {
                    //--------------------------------------------------
                    // Get specific reticle groups
                    //--------------------------------------------------
                    CimReticleSetSpecificationDO cimReticleSetSpecExam = new CimReticleSetSpecificationDO();
                    cimReticleSetSpecExam.setReferenceKey(lot.getReticleSetObj());
                    cimReticleSetSpecExam.setPhotoLayer(photoLayer);
                    List<CimReticleSetSpecificationDO> reticleSetSpecificGroupDatas = cimJpaRepository.findAll(Example.of(cimReticleSetSpecExam));
                    for (int j = 0; j < CimArrayUtils.getSize(reticleSetSpecificGroupDatas); j++) {
                        Boolean foundFlag = false;
                        // Check product ID + equipment ID
                        if (CimStringUtils.equals(reticleSetSpecificGroupDatas.get(j).getProductSpecificationID(), lot.getProductSpecificationID())
                                && ObjectIdentifier.equalsWithValue(reticleSetSpecificGroupDatas.get(j).getEquipmentID(), equipmentID)) {
                            foundFlag = true;
                        }
                        //  Check product ID + equipment ID "*"
                        else if (CimStringUtils.equals(reticleSetSpecificGroupDatas.get(j).getProductSpecificationID(), lot.getProductSpecificationID())
                                && CimStringUtils.equals(reticleSetSpecificGroupDatas.get(j).getEquipmentID(), "*")) {
                            foundFlag = true;

                        }
                        //  Check product ID "*" + equipment ID
                        else if (CimStringUtils.equals(reticleSetSpecificGroupDatas.get(j).getProductSpecificationID(), "*")
                                && ObjectIdentifier.equalsWithValue(reticleSetSpecificGroupDatas.get(j).getEquipmentID(), equipmentID)) {
                            foundFlag = true;
                        }
                        //  Check product ID "*" + equipment ID "*"
                        else if (CimStringUtils.equals(reticleSetSpecificGroupDatas.get(j).getProductSpecificationID(), "*")
                                && CimStringUtils.equals(reticleSetSpecificGroupDatas.get(j).getEquipmentID(), "*")) {
                            foundFlag = true;
                        }
                        if (foundFlag) {
                            CimReticleSetSpecificGroupDO cimReticleSetSpecificGroupExam = new CimReticleSetSpecificGroupDO();
                            cimReticleSetSpecificGroupExam.setReferenceKey(lot.getReticleSetObj());
                            cimReticleSetSpecificGroupExam.setTheTableMarker(String.valueOf(reticleSetSpecificGroupDatas.get(j).getSequenceNumber()));
                            List<CimReticleSetSpecificGroupDO> reticleSetSpecificGroups = cimJpaRepository.findAll(Example.of(cimReticleSetSpecificGroupExam));

                            for (int k = 0; k < CimArrayUtils.getSize(reticleSetSpecificGroups); k++) {
                                specificReticleGroupSeq.add(ObjectIdentifier.build(reticleSetSpecificGroups.get(k).getIdentifier(), reticleSetSpecificGroups.get(k).getId()));
                            }
                        }
                    }
                }
                if (CimArrayUtils.isNotEmpty(specificReticleGroupSeq)) {
                    result = specificReticleGroupSeq;
                } else {
                    result = defaultReticleGroupSeq;
                }
            }
        }

        return result;
    }

    @Override
    public Outputs.ObjLotGetSourceLotsOut lotGetSourceLotsDR(Infos.ObjCommon objCommon, Params.SourceLotListInqParams sourceLotListInqParams) {

        Outputs.ObjLotGetSourceLotsOut objLotGetSourceLotsOut = new Outputs.ObjLotGetSourceLotsOut();
        ObjectIdentifier productRequestID = sourceLotListInqParams.getProductRequestID();
        ObjectIdentifier productID = sourceLotListInqParams.getProductID();
        boolean forLotGenFlag = sourceLotListInqParams.isForLotGenFlag();

        CimProductSpecification productSpecification = baseCoreFactory.getBO(com.fa.cim.newcore.bo.prodspec.CimProductSpecification.class, productID);
        Validations.check(null == productSpecification, retCodeConfig.getNotFoundProductSpec(), ObjectIdentifier.fetchValue(productID));

        CimProductRequest productRequest = ObjectIdentifier.isEmpty(productRequestID) ? null : baseCoreFactory.getBO(CimProductRequest.class, productRequestID);
        CimProcessDefinition aMainPD = null != productRequest ? productRequest.getMainProcessDefinition() : (CimProcessDefinition) productSpecification.getProcessDefinition();
        Validations.check(null == aMainPD, retCodeConfig.getNotFoundMainRoute());

        CimBank aStartBank = aMainPD.getStartBank();
        Validations.check(null == aStartBank || ObjectIdentifier.isEmpty(aStartBank.getBankID()), retCodeConfig.getNotFoundBank());
        objLotGetSourceLotsOut.setStartBankID(aStartBank.getBankID());

        List<Infos.SourceLot> strSourceLot = new ArrayList<>();
        Page<CimLotDO> lotList = null;
        if (forLotGenFlag) {
            String sql = "SELECT f.*" +
                    "FROM\n" +
                    "\tOMLOT f,\n" +
                    "\tOMPRODINFO_SRC fs\n" +
                    "WHERE\n" +
                    "\tf.PROD_ID = fs.SRC_PROD_ID\n" +
                    "\tAND fs.REFKEY = ?1\n" +
                    "\tAND f.LOT_FINISHED_STATE = ?2\n" +
                    "\tAND f.LOT_STATE = ?3";

            List<Object> sqlParams = new ArrayList<>();
            sqlParams.add(productSpecification.getPrimaryKey());
            sqlParams.add(BizConstant.CIMFW_LOT_FINISHEDSTATE_COMPLETED);
            sqlParams.add(BizConstant.CIMFW_LOT_STATE_FINISHED);

            //check if wafer is already allocated as source lot or not if forLotGenFlag is TRUE & SP_IGNORE_WAFER is 0
            int ignoreWaferFlag = StandardProperties.OM_LOTID_GEN_IGNORE_WAFER.getIntValue();
            if (ignoreWaferFlag == 0) {
                sql += " AND (SELECT COUNT(WAFER_ID) FROM OMWAFER WHERE LOT_ID=f.LOT_ID AND SCRAP_STATE<>?4 AND LOT_START_ALLOCATED=0) <> 0 ";
                sqlParams.add(BizConstant.SP_SCRAPSTATE_SCRAP);
            }

            lotList = cimJpaRepository.query(sql, CimLotDO.class, sourceLotListInqParams.getSearchCondition(), sqlParams.toArray());

        } else {
            String sql = "SELECT f.* " +
                    "FROM\n" +
                    "\tOMLOT f,\n" +
                    "\tOMPRODINFO_SRC fs\n" +
                    "WHERE\n" +
                    "\tf.PROD_ID = fs.SRC_PROD_ID\n" +
                    "\tAND fs.REFKEY = ?1\n" +
                    "\tAND f.LOT_FINISHED_STATE = ?2\n" +
                    "\tAND f.LOT_INV_STATE = ?3\n" +
                    "\tAND f.LOT_HOLD_STATE = ?4\n" +
                    "\tAND f.BANK_ID = ?5\n" +
                    "\tAND f.QTY > 0";

            List<Object> params = new ArrayList<>();
            params.add(productSpecification.getPrimaryKey());
            params.add(BizConstant.CIMFW_LOT_FINISHEDSTATE_COMPLETED);
            params.add(BizConstant.SP_LOT_INVENTORYSTATE_INBANK);
            params.add(BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD);
            params.add(objLotGetSourceLotsOut.getStartBankID().getValue());
            lotList = cimJpaRepository.query(sql, CimLotDO.class, sourceLotListInqParams.getSearchCondition(), params.toArray());
        }

        if (lotList == null) return objLotGetSourceLotsOut;
        lotList.getContent().parallelStream().forEach(lot -> {
            //set value
            Infos.SourceLot sourceLot = new Infos.SourceLot();
            sourceLot.setLotID(new ObjectIdentifier(lot.getLotID(), lot.getId()));
            sourceLot.setBankID(new ObjectIdentifier(lot.getBankID(), lot.getBankObj()));
            sourceLot.setLotType(lot.getLotType());
            sourceLot.setManufacturingLayer(lot.getManufacturingLayer());
            sourceLot.setCustomerID(new ObjectIdentifier(lot.getCustomerID(), lot.getCustomerObj()));
            sourceLot.setLotOwnerID(new ObjectIdentifier(lot.getLotOwnerID(), lot.getLotOwnerIDObj()));
            sourceLot.setOrderNumber(lot.getOrderNumber());
            sourceLot.setLotState(lot.getLotState());
            sourceLot.setLotFinishedState(lot.getLotFinishedState());
            sourceLot.setCompletionTimeStamp(lot.getCompletionTimeStamp());
            sourceLot.setPlannedCompletionDateTimeStamp(lot.getPlanEndTimeStamp());
            sourceLot.setControlQuantity(lot.getWaferCount());

            //get usage/recycle count by lot ID through wafers
            LotUsageRecycleCountParams usageRecycleCountByLot = waferMethod.getUsageRecycleCountByLot(objCommon, lot.getId());
            sourceLot.setRecycleCount(usageRecycleCountByLot.getRecycleCount());
            sourceLot.setUsageCount(usageRecycleCountByLot.getUsageCount());
            sourceLot.setUsageLimit(lot.getUsageLimit());
            sourceLot.setRecycleLimit(lot.getRecycleLimit());

            CimProductSpecificationSourceDO sourceProduct = cimJpaRepository.
                    queryOne(" SELECT SRC_PROD_ID, SRC_PRIORITY FROM OMPRODINFO_SRC WHERE REFKEY = ?1 AND SRC_PROD_ID = ?2",
                            CimProductSpecificationSourceDO.class, productSpecification.getPrimaryKey(), lot.getProductSpecificationID());

            List<CimLotMaterialContainerDO> lotMaterialContainers = cimJpaRepository.
                    query("SELECT CARRIER_RKEY, CARRIER_RKEY FROM OMLOT_CARRIER WHERE REFKEY = ?", CimLotMaterialContainerDO.class, lot.getId());

            if (CimArrayUtils.isEmpty(lotMaterialContainers)) {
                //cassette not found
                // so no need to set cassette info

                sourceLot.setProductID(new ObjectIdentifier(lot.getProductSpecificationID(), lot.getProductSpecificationObj()));
                sourceLot.setPriority(sourceProduct.getSourcePriority());

                sourceLot.setWaferCount(lot.getWaferCount());
                sourceLot.setNotAllocCount(lot.getNotAllocWaferCount());
                sourceLot.setUsedCount(0);

                sourceLot.setLotType(lot.getLotType());
                sourceLot.setVendorLotID(lot.getVendorLotID());
                sourceLot.setVendorID(lot.getVendorName());
            } else {
                sourceLot.setCassetteID(new ObjectIdentifier(lotMaterialContainers.get(0).getMaterialContainerID(), lotMaterialContainers.get(0).getMaterialContainerObj()));

                CimBankDO bank = cimJpaRepository.queryOne("SELECT DESCRIPTION from OMBANK where BANK_ID = ?", CimBankDO.class, lot.getBankID());
                Validations.check(null == bank, retCodeConfig.getNotFoundBank(), lot.getBankID());

                sourceLot.setBankName(bank.getDescription());
                sourceLot.setVendorLotID(lot.getVendorLotID());
                sourceLot.setVendorID(lot.getVendorName());
                //    sourceLot.setBankID(new ObjectIdentifier(bank.getBank(), bank.getId()));

                // It is being set previous to this.
                CimCassette aCassette = baseCoreFactory.getBO(CimCassette.class, sourceLot.getCassetteID());
                if (null == aCassette) {
                    throw new ServiceException(new OmCode(retCodeConfig.getNotFoundCassette(), ObjectIdentifier.fetchValue(sourceLot.getCassetteID())));
                }

                sourceLot.setTransferStatus(aCassette.getTransportState());
                MaterialLocation aMaterialLocation = aCassette.getLocation();
                if (null != aMaterialLocation) {
                    if (aMaterialLocation instanceof CimMaterialLocation) {
                        MachineDTO.Coordinate3D aCoordinate3D = ((CimMaterialLocation) aMaterialLocation).getCoordinate();
                        if (null != aCoordinate3D) {
                            sourceLot.setShelfPositionX(aCoordinate3D.getX());
                            sourceLot.setShelfPositionY(aCoordinate3D.getY());
                            sourceLot.setShelfPositionZ(aCoordinate3D.getZ());
                        }
                    }
                }

                Machine aMachine = aCassette.currentAssignedMachine();
                if (null != aMachine) {
                    sourceLot.setStockerID(new ObjectIdentifier(aMachine.getIdentifier(), aMachine.getPrimaryKey()));
                }

                sourceLot.setProductID(new ObjectIdentifier(lot.getProductSpecificationID(), lot.getProductSpecificationObj()));
                sourceLot.setPriority(sourceProduct.getSourcePriority());
                sourceLot.setCustomField(null);
                sourceLot.setWaferCount(lot.getWaferCount());
                sourceLot.setNotAllocCount(lot.getNotAllocWaferCount());


                if (CimStringUtils.equals(BizConstant.SP_LOT_TYPE_VENDORLOT, lot.getLotType())) {
                    sourceLot.setUsedCount(0);
                } else {
                    CimLotMaterialDO cimLotMaterialExample = new CimLotMaterialDO();
                            cimLotMaterialExample.setReferenceKey(lot.getId());
                            List<CimLotMaterialDO> lotMaterialList = cimJpaRepository.findAll(Example.of(cimLotMaterialExample));

                    if (CimArrayUtils.isEmpty(lotMaterialList)) {
                        throw new ServiceException(retCodeConfig.getNotFoundWafer());
                    }

                    // get only one record.
                    CimWaferDO wafer = cimJpaRepository.queryOne("SELECT RECYCLE_COUNT FROM OMWAFER WHERE WAFER_ID = ?",
                            CimWaferDO.class, lotMaterialList.get(0).getMaterialID());
                    if (null == wafer) {
                        throw new ServiceException(retCodeConfig.getNotFoundWafer());
                    }
                    sourceLot.setUsedCount(wafer.getRecycleCount());
                }
            }
            if (CimBooleanUtils.isTrue(sourceLotListInqParams.isCurrentPOFlag())) {
                CimProcessOperationDO processOperation = cimJpaRepository.
                        queryOne(" SELECT  MAIN_PROCESS_ID, MAIN_PROCESS_RKEY, OPE_NO, STEP_ID, STEP_RKEY, REMAIN_CYCLE_TIME FROM OMPROPE WHERE ID = ?",
                                CimProcessOperationDO.class, lot.getProcessOperationObj());

                if (null != processOperation) {
                    sourceLot.setMainProcessDefinitionID(new ObjectIdentifier(processOperation.getMainProcessDefinitionID(), processOperation.getMainProcessDefinitionObj()));
                    sourceLot.setOperationNumber(processOperation.getOperationNumber());
                    sourceLot.setMainProcessDefinitionID(new ObjectIdentifier(processOperation.getProcessDefinitionID(), processOperation.getProcessDefinitionObj()));
                    sourceLot.setRemainCycleTime(null == processOperation.getRemainCycleTime()
                            ? 0 : Long.parseLong(processOperation.getRemainCycleTime().toString()));
                } else {
                    sourceLot.setRemainCycleTime(0L);
                }
            }
            strSourceLot.add(sourceLot);
        });
        objLotGetSourceLotsOut.setStartBankID(objLotGetSourceLotsOut.getStartBankID());
        objLotGetSourceLotsOut.setSourceLotList(new PageImpl<>(strSourceLot, lotList.getPageable(), lotList.getTotalElements()));

        return objLotGetSourceLotsOut;
    }

    @Override
    public Page<Infos.LotListAttributes>  lotListForDeletionGetDR(Infos.ObjCommon objCommon, Inputs.ObjLotListForDeletionGetDRIn in, SearchCondition searchCondition) {
        log.info("ObjLotListForDeletionGetDRIn = {}, SearchCondition = {}", in, searchCondition);
        List<String> conditions = searchCondition.getConditions();
        //----------
        //Set input parameters into local variable
        ObjectIdentifier lotId = in.getLotID();
//        String lotStatus = in.getLotStatus();
        List<String> lotStatusList = in.getLotStatusList();
        String lotType = in.getLotType();
        String subLotType = in.getSubLotType();
        ObjectIdentifier bankID = in.getBankID();
        ObjectIdentifier productID = in.getProductID();
        String orderNumber = in.getOrderNumber();
        String customerCode = in.getCustomerCode();
        ObjectIdentifier manufacturingLayerID = in.getManufacturingLayerID();
        ObjectIdentifier routeID = in.getRouteID();

        String sql = "SELECT * FROM OMLOT";
        Boolean bFirstCondition = false;
        StringBuilder tmpSql = new StringBuilder();

        // Lot ID
        // task-3899 LotID --> LOT_ID add new Fuzzy query of LotID
        if (!ObjectIdentifier.isEmpty(lotId)) {
            log.info("Specified Lot ID : {}",lotId.getValue());
            sql += String.format(" WHERE LOT_ID LIKE '%%%s%%'",lotId.getValue());
            bFirstCondition = false;
        } else {
            bFirstCondition = true;
        }

        // Lot Status
        // task-3899 lotStatus --> lotStatus add new Fuzzy query of lotStatus
        String shipped = CIMStateConst.CIM_LOT_STATE_SHIPPED;
        String scrapped = CIMStateConst.CIM_LOT_FINISHED_STATE_SCRAPPED;
        String stacked = BizConstant.SP_LOT_FINISHED_STATE_STACKED;
        String emptied = CIMStateConst.CIM_LOT_FINISHED_STATE_EMPTIED;
//        if (!ObjectUtils.isEmpty(lotStatus)) {
//            if (StringUtils.equals(shipped,lotStatus)) {
//                log.info("Specified Lot Status : {}",lotStatus);
//                tmpSql += String.format(" LOT_STATE LIKE '%%%s%%' ",lotStatus);
//
//            } else if (StringUtils.equals(scrapped,lotStatus) ||
//                    StringUtils.equals(stacked,lotStatus) ||
//                    StringUtils.equals(emptied,lotStatus)) {
//                tmpSql += String.format(" LOT_FINISHED_STATE LIKE '%%%s%%' ",lotStatus);
//            }
//        }
        if (!CimObjectUtils.isEmpty(lotStatusList)) {
            boolean firstLoop = true;
            for (String lotStatus : lotStatusList) {
                if (CimStringUtils.equals(shipped,lotStatus)) {
                    log.info("Specified Lot Status : {}",lotStatus);
                    if (!firstLoop){
                        tmpSql.append(" OR ");
                    }
                    tmpSql.append(String.format(" LOT_STATE LIKE '%%%s%%' ", lotStatus));
                } else if (CimStringUtils.equals(scrapped,lotStatus) ||
                        CimStringUtils.equals(stacked,lotStatus) ||
                        CimStringUtils.equals(emptied,lotStatus)) {
                    if (!firstLoop){
                        tmpSql.append(" OR ");
                    }
                    tmpSql.append(String.format(" LOT_FINISHED_STATE LIKE '%%%s%%' ", lotStatus));
                } else {
                    continue;
                }
                firstLoop = false;
            }
        }
        if (CimObjectUtils.isEmpty(tmpSql.toString())) {
            tmpSql = new StringBuilder(String.format(" ( LOT_STATE = '%s' OR LOT_FINISHED_STATE in ('%s', '%s', '%s') ) ", shipped, scrapped, emptied, stacked));
        }
        if (CimBooleanUtils.isTrue(bFirstCondition)){
            sql += " WHERE";
        }else {
            sql += " AND";
        }
        sql += tmpSql;

        // Lot Type
        if (CimStringUtils.isNotEmpty(lotType)){
            log.info("Specified Lot Type : {}",lotType);
            tmpSql = new StringBuilder(String.format(" AND LOT_TYPE = '%s'", lotType));
            sql += tmpSql;
        }

        // Sub Lot Type
        // task-3899 subLotType --> subLotTyoe add new Fuzzy query of subLottype
        if (CimStringUtils.isNotEmpty(subLotType)){
            log.info("Specified Sub Lot Type: {}",subLotType);
            tmpSql = new StringBuilder(String.format(" AND SUB_LOT_TYPE LIKE '%%%s%%'", subLotType));
            sql += tmpSql;
        }

        // Bank ID
        // task-3899 BankID --> BNAK_ID add new Fuzzy query of BankID
        if (!ObjectIdentifier.isEmpty(bankID)) {
            log.info("Specified Bank ID : {}",bankID.getValue());
            tmpSql = new StringBuilder(String.format(" AND BANK_ID LIKE '%%%s%%'", bankID.getValue()));
            sql += tmpSql;
        }

        // Product ID
        // task-3899 ProductID --> PRODSPEC_ID add new Fuzzy query of ProductID
        if (!ObjectIdentifier.isEmpty(productID)) {
            log.info("Specified Product ID: {}",productID.getValue());
            tmpSql = new StringBuilder(String.format(" AND PROD_ID LIKE '%%%s%%'", productID.getValue()));
            sql += tmpSql;
        }

        // Order Number
        // task-3899 orderNumber --> orderNumber add new Fuzzy query of orderNumber
        if (CimStringUtils.isNotEmpty(orderNumber)){
            log.info("Specified Order Number:{}",orderNumber);
            tmpSql = new StringBuilder(String.format(" AND MFG_ORDER_NO LIKE '%%%s%%'", orderNumber));
            sql += tmpSql;
        }

        // Customer Code
        if (CimStringUtils.isNotEmpty(customerCode)){
            log.info("Specified Customer Code: {}",customerCode);
            tmpSql = new StringBuilder(String.format(" AND CUSTOMER_ID = '%s'", customerCode));
            sql += tmpSql;
        }

        // Manufacturing Layer
        if (!ObjectIdentifier.isEmpty(manufacturingLayerID)) {
            log.info("Specified Manufacturing Layer : {}",manufacturingLayerID.getValue());
            tmpSql = new StringBuilder(String.format(" AND MFG_LAYER = '%s'", manufacturingLayerID.getValue()));
            sql += tmpSql;
        }

        // Route ID
        // task-3899 ProcessFlowID --> RouteID add new Fuzzy query of ProcessFlowID
        if (!ObjectIdentifier.isEmpty(routeID)) {
            log.info("Specified Route ID : {}",routeID.getValue());
            tmpSql = new StringBuilder(String.format(" AND MAIN_PROCESS_ID LIKE '%%%s%%'", routeID.getValue()));
            sql += tmpSql;
        }
        // sort parameter
        // Use the default sort field "Last CLaimed Time"
        // Use the default sort order DESC
        String defaultSortName = "TRX_TIME";
        String defaultSortOrder = "ASC";
        if (!CimObjectUtils.isEmpty(searchCondition.getSortName())){

            defaultSortName = searchCondition.getSortName();
        }

        if (CimBooleanUtils.isTrue(searchCondition.getSortDirection())){

            defaultSortOrder = "DESC";
        }

        sql += String.format(" ORDER BY %s %s",defaultSortName,defaultSortOrder);

        Page<CimLotDO> pageLots = cimJpaRepository.query(sql, CimLotDO.class, searchCondition);
        List<CimLotDO> lots = pageLots.getContent();
        List<Infos.LotListAttributes> lotListAttributesList = new ArrayList<>();
        long maxLotCnt = StandardProperties.OM_MAX_SIZE_LOT_LIST_INQ.getLongValue();
        if (maxLotCnt < 100){
            maxLotCnt = 100;
        }
        String evchkFlag = StandardProperties.OM_LOT_DELETE_EVENT_CHK.getValue();
        for (CimLotDO lot : lots) {
            //query FRPD.PD_ID, FRPD.PD_TYPE, FRPO.PLAN_START_TIME;
            String processInfoSql = getProcessInfoQuerySql(lot.getLotID(), BizConstant.SP_PD_FLOWLEVEL_OPERATION);
            Object[] sqlResult = cimJpaRepository.queryOne(processInfoSql);
            String lotID = lot.getLotID();

            //---------------------------------------------
            //  Check Sorter Job
            //---------------------------------------------
            //sorter_jobList_GetDR
            com.fa.cim.sorter.Params.ObjSorterJobListGetDRIn sorterJobListGetDRIn = new com.fa.cim.sorter.Params.ObjSorterJobListGetDRIn();
            sorterJobListGetDRIn.setLotID(new ObjectIdentifier(lotID,lot.getId()));
            List<Info.SortJobListAttributes> sorterListInqResult = sorterMethod.sorterJobListGetDR(objCommon, sorterJobListGetDRIn);
            if (CimArrayUtils.getSize(sorterListInqResult) > 0){
                log.info("SortJob exists.");
                continue;
            }

            //----------------------------------
            //  Acquire EqpMonitor job ID of Lot
            //----------------------------------
            sqlResult = cimJpaRepository.queryOne("SELECT  OMAMJOB.AM_JOB_ID\n" +
                    "            FROM\n" +
                    "                OMAMJOB,\n" +
                    "                OMAMJOB_LOT \n" +
                    "            WHERE\n" +
                    "                OMAMJOB.ID = OMAMJOB_LOT.REFKEY AND\n" +
                    "                OMAMJOB_LOT.LOT_ID = ?", lot.getLotID());
            String hFREQPMONJOBEQPMONJOB_ID = "";
            if(!CimObjectUtils.isEmpty(sqlResult)){
                hFREQPMONJOBEQPMONJOB_ID = CimObjectUtils.toString(sqlResult[0]);
                continue;
            }

            //---------------------------------------------
            //  Checks Lot's carrier
            //---------------------------------------------
            CimLotMaterialContainerDO cimLotMaterialContainerExample = new CimLotMaterialContainerDO();
            cimLotMaterialContainerExample.setReferenceKey(lot.getId());
            List<CimLotMaterialContainerDO> lotMaterialContainers = cimJpaRepository.findAll(Example.of(cimLotMaterialContainerExample));
            if (!CimObjectUtils.isEmpty(lotMaterialContainers)) {
                log.info("Lot[{}] is in carrier.", lotID);
                continue;
            }

            //----------------------------------------------------------------------------------------------
            // Check whether the lot hasn't been used as source lots of product request. (FRPRODREQ_SRCLOT)
            //----------------------------------------------------------------------------------------------
            CimProductRequestSourceLotDO productRequestSourceLot = cimJpaRepository.queryOne("SELECT * FROM OMPRORDER_SRCLOT WHERE SRC_LOT_ID = ?1", CimProductRequestSourceLotDO.class, lot.getLotID());
            if(!CimObjectUtils.isEmpty(productRequestSourceLot)){
                log.info("Lot[{}] is used by product request.", lotID);
                continue;
            }


            //---------------------------------------------
            //  Checks Lot's duraiton
            //---------------------------------------------
            Object[] queryDuration = cimJpaRepository.queryOne("SELECT OMLOT.TRX_TIME,  OMLOTTYPE_SUBTYPE.DURATION " +
                    "FROM   OMLOTTYPE_SUBTYPE, OMLOT " +
                    "WHERE  OMLOTTYPE_SUBTYPE.SUB_LOT_TYPE = OMLOT.SUB_LOT_TYPE " +
                    "AND    OMLOT.ID = ?1", lot.getId());
            if (queryDuration == null){
                continue;
            }
            Timestamp aClaimTime = Timestamp.valueOf(String.valueOf(queryDuration[0]));
            Timestamp currentTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
            long aDuration = Long.parseLong(String.valueOf(queryDuration[1])) * 24 * 60 * 60 * 1000;
            long targetTime = new BigDecimal(currentTimeStamp.getTime()).subtract(new BigDecimal(aDuration)).longValue();
            if (new BigDecimal(aClaimTime.getTime()).compareTo(new BigDecimal(targetTime)) > 0){
                continue;
            }
            //---------------------------------------------
            // Checks Lot's monitor group
            //---------------------------------------------
            List<Object> queryMonitor = cimJpaRepository.queryOneColumn("SELECT COUNT( P.ID ) " +
                    "FROM   OMMONGRP P, OMMONGRP_LOT C " +
                    "WHERE  P.ID = C.REFKEY " +
                    "AND    ( P.MON_LOT_ID = ?1 OR C.LOT_ID = ?2 )", lot.getLotID(), lot.getLotID());
            if (CimArrayUtils.getSize(queryMonitor) > 0){
               Integer  count = Integer.valueOf(String.valueOf(queryMonitor.get(0)));
               if (count > 0 ){
                   log.info("Lot belongs to the monitor group.");
                   continue;
               }
            }
            //---------------------------------------------
            //  Checks Event Record
            //---------------------------------------------
            // lot_eventRecord_CheckForDeletionDR
            if (CimStringUtils.equals(evchkFlag, "1")){
                //--- Checks event record existence -----//
                ObjectIdentifier checkLotID = new ObjectIdentifier(lot.getLotID());
                try {
                    this.lotEventRecordCheckForDeletionDR(objCommon, checkLotID);
                } catch (ServiceException e) {
                    if (Validations.isEquals(retCodeConfig.getLotHasEvent(), e.getCode())){
                        continue;
                    } else {
                        break;
                    }
                }
            }

            //---------------------------------------------
            //  Checks Original Lot
            //---------------------------------------------
            log.info("Checks Original Lot");
            if (CimBooleanUtils.isTrue(lot.getOriginalLot())) {
                //--- Gets Original Lot ID of Lot Family -----//
                CimLotFamilyDO cimLotFamilyExample = new CimLotFamilyDO();
                cimLotFamilyExample.setId(lot.getLotFamilyReferenceKey());
                CimLotFamilyDO lotFamily = cimJpaRepository.findOne(Example.of(cimLotFamilyExample)).orElse(null);
                Validations.check(lotFamily == null,retCodeConfig.getNotFoundLotFamily());

                //--- Gets Current Lot information of Lot Family -----//
                long currentLotCnt = cimJpaRepository.count("SELECT COUNT(1) FROM OMLOTFAMILY_CURLOT WHERE REFKEY=?", lotFamily.getId());
                //--- Gets Archive Lot information of Lot Family -----//
                long archiveLotCnt = cimJpaRepository.count("SELECT COUNT(1) FROM OMLOTFAMILY_ARCHIV WHERE REFKEY=?", lotFamily.getId());

                //--- Checks original lot condition -----//
                if (currentLotCnt > 0 || archiveLotCnt > 1) {
                    log.info("Any Lot except Original Lot must not belong to Lot Family.");
                    continue;
                }
            }

            //---------------------------------------------
            //  Gets Lot information
            //---------------------------------------------
            //--- Checks each state and specifies representative one -----//
            String representativeStatus = null;
            String lotInventoryState = lot.getLotInventoryState();
            String lotFinishedState = lot.getLotFinishedState();
            String lotHoldState = lot.getLotHoldState();
            String lotState = lot.getLotState();

            if (CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_NONPROBANK, lotInventoryState)) {
                representativeStatus = scrapped.equals(lotFinishedState) || emptied.equals(lotFinishedState) ? lotFinishedState : lotInventoryState;

            } else {
                if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, lotHoldState)) {
                    representativeStatus = scrapped.equals(lotFinishedState) || emptied.equals(lotFinishedState) ? lotFinishedState : lotInventoryState;

                } else {
                    if (CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_LOTCREATED, lotState) ||
                            CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_RELEASED, lotState) ||
                            CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_SHIPPED, lotState)) {
                        representativeStatus = lotState;

                    } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_FINISHED, lotState)) {
                        representativeStatus = lotFinishedState;

                    } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_ACTIVE, lotState)) {
                        representativeStatus = lot.getLotProcessState();
                    }
                }
            }
            log.info("representativeStatus = {}", representativeStatus);

            /***************************/
            /*  Get lot hold record    */
            /***************************/
            String lotHoldReasonCode = null;
            List<Infos.LotHoldRecordInfo> lotHoldRecordInfos = this.lotHoldRecordGetDR(lot.getLotID());
            if (!CimObjectUtils.isEmpty(lotHoldRecordInfos)) {
                lotHoldReasonCode = lotHoldRecordInfos.get(0).getHoldReasonID().getValue();
                lotHoldReasonCode = lotHoldRecordInfos.size() > 1 ? lotHoldReasonCode + "*" : lotHoldReasonCode;
            }
            log.info("lotHoldReasonCode = {}", lotHoldReasonCode);

            //---------------------------------------------
            //  Sets Lot information
            //---------------------------------------------
            log.info("Sets Lot information");
            Infos.LotListAttributes lotListAttributes = new Infos.LotListAttributes(lot);
            lotListAttributes.setLotStatus(representativeStatus);

            List<Infos.LotStatusList> lotStatusLists = new ArrayList<>();
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_STATE, lotState));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_PRODUCTIONSTATE, lot.getLotProductionState()));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_HOLDSTATE, lotHoldState));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_FINISHEDSTATE, lotFinishedState));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_PROCSTATE, lot.getLotProcessState()));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_INVENTORYSTATE, lotInventoryState));
            lotListAttributes.setLotStatusList(lotStatusLists);
            lotListAttributes.setFlip(lot.getFlip() == null ? false : lot.getFlip());
            lotListAttributes.setHoldReasonCodeID(new ObjectIdentifier(lotHoldReasonCode));
            lotListAttributes.setSorterJobExistFlag(false);
            lotListAttributes.setAutoDispatchControlFlag(false);

            CimProcessOperationDO processOperation = cimJpaRepository.queryOne("SELECT * FROM OMPROPE WHERE ID = ?1", CimProcessOperationDO.class, lot.getProcessOperationObj());
            if (null != processOperation) {
                CimProcessDefinitionDO processDefinition = cimJpaRepository.queryOne("SELECT * FROM OMPRP WHERE PRP_ID = ?1 AND PRP_LEVEL = ?2", CimProcessDefinitionDO.class, processOperation.getProcessDefinitionID(), BizConstant.SP_PD_FLOWLEVEL_OPERATION);
                if (null != processDefinition) {
                    lotListAttributes.setOperationID(new ObjectIdentifier(processDefinition.getProcessDefinitionID(), processDefinition.getId()));
                    lotListAttributes.setPdType(processDefinition.getProcessDefinitionType());
                }
            }
            lotListAttributesList.add(lotListAttributes);
            if (lotListAttributesList.size() >= maxLotCnt){
                break;
            }
        }
        return CimPageUtils.convertListToPage(lotListAttributesList, searchCondition.getPage(), searchCondition.getSize());
    }

    @Override
    public void lotEventRecordCheckForDeletionDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        /************************************************/
        /*  Check event record existence for input Lot  */
        /************************************************/
        String sql = String.format("select LOT_ID from (select LOT_ID,rownum rn from (SELECT LOT_ID FROM   OMEVBNKMOV WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVBCKUP WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVCJSC_LOTS WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVEDC WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVEDC_LOT WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVFBOP WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVFHOLD WHERE  RELATED_LOT_ID='%s' OR LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVLRWK WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVLHOLD WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVLRWK WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVLCHG WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVMVO WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVMVOP WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVMVI WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT PARENT_LOT_ID FROM   OMEVPSM_SUBPROC WHERE  PARENT_LOT_ID='%s' OR CHILD_LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   FREVPRCDP_LOTS WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVPREQ WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVPRCST WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVPORT WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVLOTRSETCHG WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVNOTIFY WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVVENDLOT WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVWFCMB WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVLWFMV WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVLWFMV_CURWFR WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVWFSCR WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVWSORT WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVBOND WHERE  LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT RELATED_LOT_ID FROM   OMEVBOND     WHERE  RELATED_LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT BASE_LOT_ID    FROM   OMEVBONDGRP_MAP WHERE  BASE_LOT_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT BASE_PROD_ID     FROM   OMEVBONDGRP_MAP WHERE  BASE_PROD_ID='%s'\n" +
                        "UNION\n" +
                        "SELECT LOT_ID FROM   OMEVADCLOT WHERE  LOT_ID='%s')) where rn=1 ", lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue()
                , lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue()
                , lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue()
                , lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue()
                , lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue()
                , lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue(), lotID.getValue());
        List<Object[]> queryResult = cimJpaRepository.query(sql);
        Validations.check(!CimArrayUtils.isEmpty(queryResult), retCodeConfig.getLotHasEvent());
        /************************************************/
        /*  Check event record existence for Lot wafer  */
        /************************************************/
        sql = "SELECT WAFER_ID\n" +
                "            FROM   OMWAFER\n" +
                "            WHERE  LOT_ID= ?";
        List<CimWaferDO> waferDOList = cimJpaRepository.query(sql, CimWaferDO.class, lotID.getValue());
        if (CimArrayUtils.isEmpty(waferDOList)){
            return;
        }
        for (CimWaferDO cimWaferDO : waferDOList){
            sql = "(SELECT WAFER_ID FROM   OMEVDOC_WAFER WHERE  WAFER_ID= ?)\n" +
                    "                UNION\n" +
                    "                (SELECT WAFER_ID FROM   OMEVPSM_SUBPROC_WFR WHERE  WAFER_ID=?)\n" +
                    "                FETCH FIRST 1 ROW ONLY";
            List<Object[]> queryResult2 = cimJpaRepository.query(sql, cimWaferDO.getWaferID());
            if (CimArrayUtils.isEmpty(queryResult2)){
                return;
            }
            Validations.check(!CimArrayUtils.isEmpty(queryResult2), retCodeConfig.getLotHasEvent());
        }
    }

    @Override
    public Boolean lotCheckDurationForOperation(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        //------------------------------------------------------------------------//
        //   Check carrier of lot                                                 //
        //------------------------------------------------------------------------//
        //-----   If the lot is in carrier, TRUE is returned immediately.
        //-----   If NOT, the duration is checked.
        Boolean result = false;
        try {
            ObjectIdentifier lotCassetteGet = this.lotCassetteGet(objCommon, lotID);
            log.info("Lot is in carrier.");
            log.info("lotCheckDurationForOperation return : TRUE");
            return true;
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getNotFoundCst(),e.getCode())){
                log.info("lotCassetteGet error");
                throw e;
            }else{
                log.info("Lot is not in carrier.");
            }
        }
        //----------------------------------------------------------------------------------------------
        // Check whether the lot hasn't been used as source lots of product request. (FRPRODREQ_SRCLOT)
        //----------------------------------------------------------------------------------------------
        Long hLotCount = 0L;
        String sql = "SELECT COUNT(ID) FROM OMPRORDER_SRCLOT WHERE SRC_LOT_ID = ?1";
        List<Object> resultListQuery = cimJpaRepository.queryOneColumn(sql, lotID.getValue());
        if (CimArrayUtils.getSize(resultListQuery) > 0){
            hLotCount = Long.valueOf(String.valueOf(resultListQuery.get(0)));
        }
        if (hLotCount != 0){
            log.info("Lot is used by product request.");
            return true;
        }else {
            log.info("Lot is NOT used by product request.");
        }

        //------------------------------------------------------------------------//
        //   Get lot object                                                       //
        //------------------------------------------------------------------------//
        CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(aPosLot),retCodeConfig.getNotFoundLot());

        //--------------------------//
        //   Get Lot SubLotType     //
        //--------------------------//
        String subLotType = aPosLot.getSubLotType();

        //------------------------------------------------------------------------//
        //   Check Lot Duration                                                   //
        //------------------------------------------------------------------------//
        Long subLotTypeDuration = 0L;
        Outputs.LotSubLotTypeGetDetailInfoDR lotSubLotTypeGetDetailInfoDR = this.lotSubLotTypeGetDetailInfoDR(objCommon, subLotType);
        subLotTypeDuration = CimNumberUtils.longValue(lotSubLotTypeGetDetailInfoDR.getDuration());
        log.info("subLotTypeDuration= {}",subLotTypeDuration);

        String envDuration = StandardProperties.OM_LOT_DELETE_RSRV_PERIOD.getValue();
        if (CimObjectUtils.isEmpty(envDuration)){
            envDuration = "1";
        }
        Long lEnvDuration = Long.valueOf(envDuration);
        if (lEnvDuration < 1L){
            lEnvDuration = 1L;
        }
        Long duration = subLotTypeDuration - lEnvDuration;
        if (duration < 0){
            duration = 0L;
        }
        Timestamp aTempTimeStamp = new Timestamp(duration* 86400000);
        Timestamp lastClaimedTimeStamp = aPosLot.getLastClaimedTimeStamp();
        result = lastClaimedTimeStamp.after(aTempTimeStamp);
        if (CimBooleanUtils.isTrue(result)){
            log.info("return true");
        }else {
            log.info("return false");
        }
        return result;
    }

    @Override
    public void lotStateChangeShipped(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));

        CimPerson person = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, new OmCode(retCodeConfig.getNotFoundPerson(), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));

        com.fa.cim.newcore.bo.factory.CimBank bank = lot.getBank();
        Validations.check(null == bank, new OmCode(retCodeConfig.getLotNotInBank(), ObjectIdentifier.fetchValue(lotID)));
        Validations.check(!CimBooleanUtils.isTrue(bank.isShipBank()), new OmCode(retCodeConfig.getCannotBankShipped(), bank.getIdentifier()));

        lot.makeShipped();

        String envEventCreateType = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
        int envEventCreateTypeInt = CimStringUtils.isEmpty(envEventCreateType) ? 0: Integer.valueOf(envEventCreateType);
        if (envEventCreateTypeInt == BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED
         || envEventCreateTypeInt == BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED) {
            com.fa.cim.newcore.bo.pd.CimProcessOperation currentPO = lot.getProcessOperation();
            if (null != currentPO) {
                // Insert Event Queue Record
                processMethod.poDelQueuePutDR(objCommon, lotID);
            }
        }

        Timestamp reportTime = objCommon.getTimeStamp().getReportTimeStamp();
        lot.setLastClaimedTimeStamp( reportTime);
        lot.setLastClaimedPerson(person);
        lot.setStateChangedTimeStamp(reportTime);
        lot.setStateChangedPerson(person);

        //step done:If lot exists in CurrentLot of lotfamily then lot move to ArciveLot of lotfamily.
        CimLotFamily lotFamily = lot.getLotFamily();
        Validations.check(null == lotFamily, new OmCode(retCodeConfig.getNotFoundLotFamily()));

        List<Lot> currentLotList = lotFamily.currentLots();
        for (Lot currentLot : currentLotList) {
            String currentLotID = currentLot.getIdentifier();
            if (ObjectIdentifier.equalsWithValue(lotID, currentLotID)) {
                lotFamily.archiveLot(lot);
                lotFamily.removeCurrentLot(lot);
                break;
            }
        }

        //step done:If lotfamily's CurrentLots count is 0 then lotfamily's ActualCompTime is changed to NowTime.
        if (CimArrayUtils.isEmpty(currentLotList)) {
            lotFamily.setActualCompletionTime(new Timestamp(System.currentTimeMillis()));
        }
    }

    @Override
    public ObjectIdentifier lotControlJobIDGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(lot == null, retCodeConfig.getNotFoundLot(), lotID);
        return lotControlJobIDGet(objCommon, lot);
    }

    @Override
    public ObjectIdentifier lotControlJobIDGet(Infos.ObjCommon objCommon, CimLot lot) {
        /*----------------------*/
        /*   Get controlJobID   */
        /*----------------------*/
        CimControlJob aControlJob = lot.getControlJob();
        return null != aControlJob ? aControlJob.getControlJobID() : null;
    }

    @Override
    public Outputs.ObjLotParameterForLotGenerationCheckOut lotParameterForLotGenerationCheck(Infos.ObjCommon objCommon, ObjectIdentifier bankID, Infos.NewLotAttributes newLotAttributes) {
        Outputs.ObjLotParameterForLotGenerationCheckOut objLotParameterForLotGenerationCheckOut = new Outputs.ObjLotParameterForLotGenerationCheckOut();
        // get object from input parameter
        com.fa.cim.newcore.bo.durable.CimCassette aCassette = baseCoreFactory.getBO(com.fa.cim.newcore.bo.durable.CimCassette.class, newLotAttributes.getCassetteID());
        if (null == aCassette) {
            log.info(String.format("[warn]can't find the cassette object from db which cassetteID's name is '%s'", newLotAttributes.getCassetteID()));
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundCassette(), ObjectIdentifier.fetchValue(newLotAttributes.getCassetteID())));
        }
        //【step1】check cassette state
        log.info("【step1】check cassette state");
        String cassetteState = aCassette.getDurableState();
        if (!CimStringUtils.equals(BizConstant.CIMFW_DURABLE_AVAILABLE, cassetteState)
                && !CimStringUtils.equals(BizConstant.CIMFW_DURABLE_INUSE, cassetteState)) {
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidCassetteState(), cassetteState, newLotAttributes.getCassetteID().getValue()));
        }
        com.fa.cim.newcore.bo.factory.CimBank aPosBank = baseCoreFactory.getBO(com.fa.cim.newcore.bo.factory.CimBank.class, bankID);
        Validations.check(aPosBank == null, retCodeConfig.getNotFoundBank());
        //--------------------------------------------
        // Get bank's wafer ID assign flag
        //--------------------------------------------
        boolean bWaferIDAssignRequired = aPosBank.isWaferIDAssignmentRequired();
        // check input parameter
        // target new lot must be the same in all input structure
        boolean bAllNewWaferIDFilled = true;
        boolean bSomeNewWaferIDFilled = false;
        boolean bAllSourceWaferIDFilled = true;
        boolean bSomeSourceWaferIDFilled = false;
        int lenNewWaferAttr = CimArrayUtils.getSize(newLotAttributes.getNewWaferAttributesList());
        for (int i = 0; i < lenNewWaferAttr; i++) {
            String strLotID1 = newLotAttributes.getNewWaferAttributesList().get(0).getNewLotID().getValue();
            String strLotID2 = newLotAttributes.getNewWaferAttributesList().get(i).getNewLotID().getValue();
            //【step2】check New lot ID
            log.info("【step2】check New lot ID");
            //【bear】the lotID and get(i).getNewLotID() all may be null, so we can't use equal to compare them
            Validations.check(!CimStringUtils.equals(strLotID1, strLotID2), retCodeConfig.getInvalidInputParam());
            //【step3】check New wafer ID
            if (!ObjectIdentifier.isEmptyWithValue(newLotAttributes.getNewWaferAttributesList().get(i).getNewWaferID())) {
                bSomeNewWaferIDFilled = true;
            } else {
                bAllNewWaferIDFilled = false;
            }

            if (!ObjectIdentifier.isEmptyWithValue(newLotAttributes.getNewWaferAttributesList().get(i).getSourceWaferID())) {
                bSomeSourceWaferIDFilled = true;
            } else {
                bAllSourceWaferIDFilled = false;
            }
        }
        if (!bAllNewWaferIDFilled && bSomeNewWaferIDFilled && !bAllSourceWaferIDFilled && bSomeSourceWaferIDFilled) {
            for (Infos.NewWaferAttributes newWaferAttributes : newLotAttributes.getNewWaferAttributesList()) {
                if (CimStringUtils.isEmpty(newWaferAttributes.getNewWaferID().getValue()) && CimStringUtils.isEmpty(newWaferAttributes.getSourceWaferID().getValue())) {
                    throw new ServiceException(retCodeConfig.getInvalidInputParam());
                }
            }
        }

        //【step4】check input parameter condition and bank's property
        log.info("【step4】check bank's property");
        boolean waferIDAssignRequired = false;  // wafer ID automatic generate
        if (bWaferIDAssignRequired) {
            if (!bAllNewWaferIDFilled && bSomeNewWaferIDFilled && !bAllSourceWaferIDFilled && !bSomeSourceWaferIDFilled) {
                throw new ServiceException(retCodeConfig.getInvalidInputParam());
            }
            if (!bAllNewWaferIDFilled && !bSomeNewWaferIDFilled) {
                waferIDAssignRequired = true;
            }
        } else {
            if (!bAllNewWaferIDFilled && bSomeNewWaferIDFilled && !bAllSourceWaferIDFilled && !bSomeSourceWaferIDFilled) {
                throw new ServiceException(retCodeConfig.getWaferIdAssignRequired());
            }
            if (!bAllNewWaferIDFilled && !bSomeNewWaferIDFilled && !bAllSourceWaferIDFilled) {
                throw new ServiceException(retCodeConfig.getWaferIdAssignRequired());
            }
        }
        //【step5】check wafer is in the same carrier or not
        log.info("【step5】check wafer is in the same carrier or not");
        if (bAllSourceWaferIDFilled || bSomeSourceWaferIDFilled) {
            for (Infos.NewWaferAttributes newWaferAttributes : newLotAttributes.getNewWaferAttributesList()) {
                if (ObjectIdentifier.isEmptyWithValue(newWaferAttributes.getSourceWaferID())) {
                    continue;
                }
                CimWafer aPosWafer = baseCoreFactory.getBO(CimWafer.class, newWaferAttributes.getSourceWaferID());
                Validations.check(aPosWafer == null, retCodeConfig.getNotFoundWafer());
                MaterialContainer aMaterialContainer = aPosWafer.getMaterialContainer();
                String strCassetteID = null;
                if (aMaterialContainer != null){
                    strCassetteID = aMaterialContainer.getIdentifier();
                }
                if (!CimStringUtils.equals(strCassetteID, newLotAttributes.getCassetteID().getValue())) {
                    throw new ServiceException(new OmCode(retCodeConfig.getWaferInDifferentCassette(), newWaferAttributes.getSourceWaferID().getValue(), strCassetteID));
                }
            }
        }
        for (Infos.NewWaferAttributes newWaferAttributes : newLotAttributes.getNewWaferAttributesList()) {
            if (!ObjectIdentifier.isEmptyWithValue(newWaferAttributes.getSourceWaferID())) {
                continue;
            }
            CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, newWaferAttributes.getSourceLotID());
            Validations.check(aPosLot == null, retCodeConfig.getNotFoundLot());
            List<MaterialContainer> aMaterialContainerList = aPosLot.materialContainers();
            if (!CimObjectUtils.isEmpty(aMaterialContainerList)) {
                throw new ServiceException(new OmCode(retCodeConfig.getLotMultipleCassette(), newWaferAttributes.getSourceLotID().getValue()));
            }
        }
        objLotParameterForLotGenerationCheckOut.setWaferIDAssignRequiredFlag(waferIDAssignRequired);
        return objLotParameterForLotGenerationCheckOut;
    }

    @Override
    public Outputs.ObjLotWaferIDGenerateOut lotWaferIDGenerate(Infos.ObjCommon objCommon, Infos.NewLotAttributes newLotAttributes) {
        //【step1】in the begining, copy input parameter to output parameter
        log.debug("【step1】in the begining, copy input parameter to output parameter");
        Outputs.ObjLotWaferIDGenerateOut generateOut = new Outputs.ObjLotWaferIDGenerateOut();
        generateOut.setNewLotAttributes(newLotAttributes);
        //【step2】generate wafer id
        log.debug("【step2】generate wafer id");
        for (int i = 0; i < CimArrayUtils.getSize(newLotAttributes.getNewWaferAttributesList()); i++) {
            Infos.NewWaferAttributes newWaferAttributes = newLotAttributes.getNewWaferAttributesList().get(i);
            Validations.check(ObjectIdentifier.isEmptyWithValue(newWaferAttributes.getNewLotID()), retCodeConfig.getNewLotIdBlank());
            String tmpWaferID = String.format("%s.%02d", newWaferAttributes.getNewLotID().getValue(),
                    newWaferAttributes.getNewSlotNumber());
            ObjectIdentifier waferID = new ObjectIdentifier(tmpWaferID);
            generateOut.getNewLotAttributes().getNewWaferAttributesList().get(i).setNewWaferID(waferID);
        }
        return generateOut;
    }

    @Override
    public Outputs.ObjLotEffectiveFPCInfoGetOut lotEffectiveFPCInfoGet(Infos.ObjCommon objCommon, String exchangeType, ObjectIdentifier equipmentID, ObjectIdentifier lotID) {

        Outputs.ObjLotEffectiveFPCInfoGetOut objLotEffectiveFPCInfoGetOut = new Outputs.ObjLotEffectiveFPCInfoGetOut();

        // Null EqpID Request or not?
        Boolean nullEQPRequest = false;
        if (ObjectIdentifier.isEmpty(equipmentID)) {
            log.debug("Input EquipmentID is NULL");
            nullEQPRequest = true;
        }

        // Check Adopt Flag
        String tmpFPCAdoptFlag = StandardProperties.OM_DOC_ENABLE_FLAG.getValue();
        if (!CimStringUtils.equals("1",tmpFPCAdoptFlag)) {
            log.debug("DOC Adopt Flag is OFF. Now return RC_OK");
            return objLotEffectiveFPCInfoGetOut;
        }

        // Exchange control Flags
        boolean EquipmentRequest = false;
        boolean MachineRecipeRequest = false;
        boolean RecipeParameterRequest = false;
        boolean DCDefRequest = false;
        boolean DCSpecRequest = false;
        boolean ReticleRequest = false;

        log.debug("{} ExchangeType", exchangeType);
        if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEINFO)) {
            MachineRecipeRequest = true;
            RecipeParameterRequest = true;
        } else if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEREQ)) {
            DCDefRequest = true;
            DCSpecRequest = true;
            ReticleRequest = true;
        } else if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_OPECOMPREQ)) {
            //nothing to do.
        } else if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_ALL)) {
            EquipmentRequest = false;    //Now it is not supported.
            MachineRecipeRequest = true;
            RecipeParameterRequest = true;
            DCDefRequest = true;
            DCSpecRequest = true;
            ReticleRequest = true;
        } else {
            log.debug("{} Invalid ExchangeType", exchangeType);
            throw new ServiceException(retCodeConfig.getInvalidParameter());
        }

        // Get DOC Infomation at Lot's current operation.

        boolean waferIDInfoGetFlag = true;       //always TRUE.
        boolean recipeParmInfoGetFlag = false;
        boolean reticleInfoGetFlag = false;
        boolean dcSpecItemInfoGetFlag = false;

        if (RecipeParameterRequest) {
            recipeParmInfoGetFlag = true;
        }
        if (DCSpecRequest) {
            dcSpecItemInfoGetFlag = true;
        }
        if (ReticleRequest) {
            reticleInfoGetFlag = true;
        }

        List<Infos.FPCInfo> fpcInfos = lotCurrentFPCInfoGet(objCommon, lotID, equipmentID, waferIDInfoGetFlag, recipeParmInfoGetFlag, reticleInfoGetFlag, dcSpecItemInfoGetFlag);
        int FPCInfoCount = CimArrayUtils.getSize(fpcInfos);

        if (CimObjectUtils.isEmpty(fpcInfos)) {
            // DOC Info does not exist. now return OK and do nothing.
            log.debug("{} DOC Info does not exist for this lot", lotID);
            return objLotEffectiveFPCInfoGetOut;
        }
        log.debug("{} DOC Info found for this lot", lotID);

        // check FPCInfo consistency
        boolean recipeParmCheckFlag = recipeParmInfoGetFlag;
        boolean dcSpecItemCheckFlag = dcSpecItemInfoGetFlag;

        List<Infos.FPCDispatchEqpInfo> fpcDispatchEqpInfos = fpcMethod.fpcInfoConsistencyCheck(objCommon, fpcInfos, recipeParmCheckFlag, dcSpecItemCheckFlag);
        log.debug("FPCInfo's consistency check is ok.");

        // at first, count groups in FPCInfo.
        int groupCount = CimArrayUtils.getSize(fpcDispatchEqpInfos);
        log.debug("{} Groups in acquired FPCInfo", groupCount);

        // next, extract effective FPCInfo.
        //   Acquired FPCInfo's equipmentID is "" or input equipmentID.
        //   If both of them exists, equipmentID filled FPCInfo has priority over blank one. - if input equipmentID is filled.
        List<Infos.FPCInfo> strEffectiveFPCInfoList = new ArrayList<>();
        int effectiveFPCInfoCount = 0;
        int i = 0;
        for (i = 0; i < FPCInfoCount; i++) {
            Infos.FPCInfo fpcInfo = fpcInfos.get(i);
            int j = 0;
            int toBeAdd = 1;
            log.debug("{} {} DOC Equipment/GroupNo", fpcInfo.getEquipmentID(), fpcInfo.getFpcGroupNumber());

            for (j = 0; j < effectiveFPCInfoCount; j++) {
                if (fpcInfo.getFpcGroupNumber().equals(strEffectiveFPCInfoList.get(j).getFpcGroupNumber())) {
                    toBeAdd = 0;  // to be replace case.
                    break;
                }
            }

            if (!nullEQPRequest)    // If input equipmentID is filled - the user required rigid FPCInfo for use.
            {
                if (ObjectIdentifier.equalsWithValue(fpcInfo.getEquipmentID(), equipmentID)) {
                    log.debug("{} {}   Add or Replace equipment/Pos", equipmentID, j);
                    strEffectiveFPCInfoList.add(j, fpcInfo);
                    effectiveFPCInfoCount += toBeAdd;
                }
                if (ObjectIdentifier.isEmpty(fpcInfo.getEquipmentID()) && 1 == toBeAdd) {
                    log.debug("{}   Add null equipment to Pos", j);
                    strEffectiveFPCInfoList.add(j, fpcInfo);
                    effectiveFPCInfoCount += toBeAdd;
                }
            } else  // If input equipmentID is not filled - the user only request for the output flags
            {
                if (0 != toBeAdd) {
                    log.debug("{} {}   Add only a group data to Pos", j, i);
                    strEffectiveFPCInfoList.add(j, fpcInfo);
                    effectiveFPCInfoCount++;
                } else {
                    log.debug("{} {}   Merge group data at Pos", j, i);
                    Infos.FPCInfo effFPCInfo = strEffectiveFPCInfoList.get(j);
                    effFPCInfo.setFpcID("");

                    // following 'Merge' logics must be taken place at the first time.
                    if (ObjectIdentifier.isEmpty(effFPCInfo.getMachineRecipeID())) {
                        log.debug("{} {}     Merge GroupData : MachineRecipe", j, i);
                        effFPCInfo.setMachineRecipeID(fpcInfo.getMachineRecipeID());
                    }

                    if (ObjectIdentifier.isEmpty(effFPCInfo.getDcDefineID())) {
                        log.debug("{} {}     Merge GroupData : dcDef", j, i);
                        effFPCInfo.setDcDefineID(fpcInfo.getDcDefineID());
                    }

                    if (ObjectIdentifier.isEmpty(effFPCInfo.getDcSpecID())) {
                        log.debug("{} {}     Merge GroupData : dcSpec", j, i);
                        effFPCInfo.setDcSpecID(fpcInfo.getDcSpecID());
                        effFPCInfo.setDcSpecList(fpcInfo.getDcSpecList());
                    }

                    if (CimObjectUtils.isEmpty(effFPCInfo.getRecipeParameterChangeType())) {
                        log.debug("{} {}     Merge GroupData : RecipeParameter", j, i);
                        effFPCInfo.setRecipeParameterChangeType(fpcInfo.getRecipeParameterChangeType());
                        effFPCInfo.setLotWaferInfoList(effFPCInfo.getLotWaferInfoList());
                    }

                    if (CimObjectUtils.isEmpty(effFPCInfo.getReticleInfoList())) {
                        log.debug("{} {}     Merge GroupData : Reticle", j, i);
                        effFPCInfo.setReticleInfoList(fpcInfo.getReticleInfoList());
                    }
                }
            }
        }

        // Note : effectiveFPCInfoCount must be equal to groupCount...
        log.debug("{} {} groupCount vs effectiveFPCInfoCount (must be equal)", groupCount, effectiveFPCInfoCount);

        if (0 == effectiveFPCInfoCount) {
            // Effective DOC Info does not exist. now return RC_OK and do nothing.
            log.debug("{} Effective DOC Info does not exist (accidental?) for this lot", lotID);
            return objLotEffectiveFPCInfoGetOut;
        }

        // Get Wafers in Lot
        List<Infos.LotWaferAttributes> lotWaferAttributes = lotMaterialsGetWafers(objCommon, lotID);
        int waferCountInLot = CimArrayUtils.getSize(lotWaferAttributes);
        log.debug("{} wafers in lot", waferCountInLot);

        if (CimObjectUtils.isEmpty(lotWaferAttributes)) {
            log.debug("{} Lot has no wafer (perhaps strange...)", lotID);
            return objLotEffectiveFPCInfoGetOut;
        }

        List<ObjectIdentifier> lotWaferIDList = new ArrayList<>();
        lotWaferAttributes.forEach(x -> lotWaferIDList.add(x.getWaferID()));

        // Find the FPCInfo which used by the lot wafer,
        // and check the using FPCInfo is same all over the lot wafer
        List<Integer> usedFPCInfoByWafer = new ArrayList<>();
        for (i = 0; i < waferCountInLot; i++) {
            usedFPCInfoByWafer.add(i, -1);
            int j = 0;
            for (j = 0; j < effectiveFPCInfoCount; j++) {
                Infos.FPCInfo effFPCInfo = strEffectiveFPCInfoList.get(j);
                List<Infos.LotWaferInfo> effLotWaferInfoList = effFPCInfo.getLotWaferInfoList();
                int waferCountInFPCInfo = CimArrayUtils.getSize(effLotWaferInfoList);
                int k = 0;
                for (k = 0; k < waferCountInFPCInfo; k++) {
                    Infos.LotWaferInfo lotWaferInfo = effLotWaferInfoList.get(k);
                    if (ObjectIdentifier.equalsWithValue(lotWaferIDList.get(i), lotWaferInfo.getWaferID())) {
                        log.debug("{} {}   wafer/usedFPC", lotWaferIDList.get(i), j);
                        usedFPCInfoByWafer.set(i, j);
                        break;
                    }
                }
                if (usedFPCInfoByWafer.get(i) >= 0) {
                    break;  // to the next wafer
                }
            }
        }

        int usedFPCInfo = -1;    //initialize
        if (!nullEQPRequest) {
            // compare usedFPCInfo for all wafers in lot.
            log.debug("Check Wafer-Group relation.");

            usedFPCInfo = usedFPCInfoByWafer.get(0);
            boolean uniqueFPCInfo = true;
            for (i = 1; i < waferCountInLot; i++) {
                if (usedFPCInfo != usedFPCInfoByWafer.get(i)) {
                    uniqueFPCInfo = false;
                    break;
                }
            }

            if (!uniqueFPCInfo) {
                log.debug("There is least one wafer in this lot which belongs to different FPCGroup from others.");
                throw new ServiceException(retCodeConfig.getFpcWaferMismatchInFpcGroup());
            }
        } else {
            log.debug("Merge All usedFPCInfo by wafers.");

            List<Infos.RecipeParameterInfo> RecipeParamMerged = new ArrayList<>();

            Infos.FPCInfo FPCInfoMerged = new Infos.FPCInfo();
            List<Integer> mergedFPCInfoNo = new ArrayList<>();
            int mergedCount = 0;

            List<ObjectIdentifier> FPCUseWaferIDList = new ArrayList<>();
            int FPCUseWaferCount = 0;

            usedFPCInfo = -1;    //Initialize
            for (i = 0; i < waferCountInLot; i++) {
                if (0 > usedFPCInfoByWafer.get(i)) {
                    log.debug("{} This wafer does not use FPCInfo", lotWaferIDList.get(i));
                    continue;
                }

                log.debug("{} This wafer uses FPCInfo", lotWaferIDList.get(i));

                // add Wafers to List which uses FPCInfo
                FPCUseWaferIDList.add(FPCUseWaferCount, lotWaferIDList.get(i));
                FPCUseWaferCount++;

                if (-1 == usedFPCInfo) {
                    log.debug("{} This is first used FPCInfo", usedFPCInfoByWafer.get(i));
                    usedFPCInfo = 0;
                    FPCInfoMerged = strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i));
                    RecipeParamMerged = strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i)).getLotWaferInfoList().get(0).getRecipeParameterInfoList();
                    mergedFPCInfoNo.add(mergedCount, usedFPCInfoByWafer.get(i));
                    mergedCount++;
                } else {
                    log.debug("{} This is used FPCInfo", usedFPCInfoByWafer.get(i));
                    int j = 0;
                    for (j = 0; j < mergedCount; j++) {
                        if (Objects.equals(mergedFPCInfoNo.get(j), usedFPCInfoByWafer.get(i))) {
                            log.debug("{} This FPCInfo is already merged.", usedFPCInfoByWafer.get(i));
                            break;
                        }
                    }
                    if (j != mergedCount) {
                        continue;  //to the next wafer;
                    }

                    log.debug("{} Merge FPCInfo", usedFPCInfoByWafer.get(i));
                    mergedFPCInfoNo.add(mergedCount, usedFPCInfoByWafer.get(i));
                    mergedCount++;
                    FPCInfoMerged.setFpcID("");

                    //Machine Recipe
                    if (ObjectIdentifier.isEmpty(FPCInfoMerged.getMachineRecipeID())) {
                        log.debug("{}   Merge MachineRecipeID", i);
                        FPCInfoMerged.setMachineRecipeID(strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i)).getMachineRecipeID());
                    }

                    //DCDef
                    if (ObjectIdentifier.isEmpty(FPCInfoMerged.getDcDefineID())) {
                        log.debug("{}   Merge DCDefID", i);
                        FPCInfoMerged.setDcDefineID(strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i)).getDcDefineID());
                    }

                    //DCSpec
                    if (ObjectIdentifier.isEmpty(FPCInfoMerged.getDcSpecID())) {
                        log.debug("{}   Merge DCSpecID", i);
                        FPCInfoMerged.setDcSpecID(strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i)).getDcSpecID());
                        FPCInfoMerged.setDcSpecList(strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i)).getDcSpecList());
                    }

                    //Recipe Parameter
                    if (CimObjectUtils.isEmpty(FPCInfoMerged.getRecipeParameterChangeType())) {
                        log.debug("{}   Merge RecipeParameters", i);
                        FPCInfoMerged.setRecipeParameterChangeType(strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i)).getRecipeParameterChangeType());
                        RecipeParamMerged = strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i)).getLotWaferInfoList().get(0).getRecipeParameterInfoList();
                    }

                    //Reticle
                    if (CimObjectUtils.isEmpty(FPCInfoMerged.getReticleInfoList())) {
                        log.debug("{}   Merge Reticle", i);
                        FPCInfoMerged.setReticleInfoList(strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i)).getReticleInfoList());
                    }
                }
            }
            if (0 == usedFPCInfo) {
                log.debug("{} add wafers/recipeParams.", FPCUseWaferCount);
                for (i = 0; i < FPCUseWaferCount; i++) {
                    FPCInfoMerged.getLotWaferInfoList().get(i).setWaferID(FPCUseWaferIDList.get(i));
                    FPCInfoMerged.getLotWaferInfoList().get(i).setRecipeParameterInfoList(RecipeParamMerged);
                }
                strEffectiveFPCInfoList.set(0, FPCInfoMerged);
            }
        }

        if (usedFPCInfo < 0)  //it is -1 when effective FPCInfo not found.
        {
            log.debug("{} This lot is not DOC target lot.(lotfamily is target.)", lotID);
            return objLotEffectiveFPCInfoGetOut;
        }


        // set the selected FPCInfo for output.
        log.debug("{} Used FPC_ID", strEffectiveFPCInfoList.get(usedFPCInfo).getFpcID());
        objLotEffectiveFPCInfoGetOut.setFpcInfo(strEffectiveFPCInfoList.get(usedFPCInfo));

        // Check the items of fpcInfoUsedFPC before use it for exchange.

        if (EquipmentRequest) {
            log.debug("Equipment Exchange requested.");
            objLotEffectiveFPCInfoGetOut.setEquipmentActionRequiredFlag(true);
        }

        if (MachineRecipeRequest) {
            log.debug("MachineRecipe Exchange requested.");
            ObjectIdentifier tmpMachineRecipeID;
            tmpMachineRecipeID = strEffectiveFPCInfoList.get(usedFPCInfo).getMachineRecipeID();

            if (!ObjectIdentifier.isEmpty(tmpMachineRecipeID)) {
                log.debug("{} MachineRecipe will be changed.", tmpMachineRecipeID);
                objLotEffectiveFPCInfoGetOut.setMachineRecipeActionRequiredFlag(true);
            } else {
                log.debug("MachineRecipe will not be changed.");
            }
        }

        if (RecipeParameterRequest) {
            log.debug("RecipeParameter Exchange requested.");
            // All wafers in group must have same recipeParameter Name.(But the value or order might be different when paramChangeType is "ByWafer")
            // That is already checked in FPC_infoConsistency_Check()
            if (!CimObjectUtils.isEmpty(strEffectiveFPCInfoList.get(usedFPCInfo).getRecipeParameterChangeType())) {
                log.debug("{} RecipeParameter will be changed. Now check it.",strEffectiveFPCInfoList.get(usedFPCInfo).getRecipeParameterChangeType());

                int tmpWaferCount = CimArrayUtils.getSize(strEffectiveFPCInfoList.get(usedFPCInfo).getLotWaferInfoList());

                if (tmpWaferCount == 0) {
                    log.debug("effective FPCInfo has no wafer (it is strange and it is not occur by before check.)");
                    throw new ServiceException(retCodeConfig.getSystemError());
                }

                int tmpRecipeParamCount = CimArrayUtils.getSize(strEffectiveFPCInfoList.get(usedFPCInfo).getLotWaferInfoList().get(0).getRecipeParameterInfoList());
                log.debug("{} RecipeParam Count", tmpRecipeParamCount);

                if (!nullEQPRequest)    // recipe parameter check requires input EquipmentID.
                {
                    log.debug("RecipeParameter Check start.");
                    List<Infos.RecipeParameterInfo> recipeParameterInfoList = strEffectiveFPCInfoList.get(usedFPCInfo).getLotWaferInfoList().get(0).getRecipeParameterInfoList();
                    List<String> recipeParamNameList = new ArrayList<>();
                    recipeParameterInfoList.forEach(x -> recipeParamNameList.add(x.getParameterName()));

                    fpcMethod.fpcRecipeParameterConsistencyCheck(objCommon, equipmentID, recipeParamNameList);

                    log.debug("RecipeParameter Check ok.");
                }
                log.debug("RecipeParameter action Required.");
                objLotEffectiveFPCInfoGetOut.setRecipeParameterActionRequiredFlag(true);
            } else {
                log.debug("RecipeParameter will not be changed.");
            }
        }

        if (DCDefRequest) {
            log.debug("DCDef Exchange requested.");
            ObjectIdentifier tmpDCDefID;
            tmpDCDefID = strEffectiveFPCInfoList.get(usedFPCInfo).getDcDefineID();
            if (!ObjectIdentifier.isEmpty(tmpDCDefID)) {
                log.debug("{} DCDef will be changed.", tmpDCDefID);
                objLotEffectiveFPCInfoGetOut.setDcDefActionRequiredFlag(true);

                // check delta dcDef
                if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEREQ)) {
                    Results.EDCPlanInfoInqResult  edcPlanInfoInqResult = dataCollectionMethod.dcDefDetailInfoGetDR(objCommon, tmpDCDefID);

                    int itemLen = 0;
                    itemLen = CimArrayUtils.getSize(edcPlanInfoInqResult.getStrDCItemList());
                    for (int itemCnt = 0; itemCnt < itemLen; itemCnt++) {
                        if (CimStringUtils.equals(edcPlanInfoInqResult.getStrDCItemList().get(itemCnt).getCalculationType(), BizConstant.SP_DCDEF_CALC_DELTA)) {
                            log.debug("This dcDefID is Delta.");
                            throw new ServiceException(retCodeConfig.getFpcInvalidDcinfo());
                        }
                    }
                }
            } else {
                log.debug("DCDef will not be changed");
            }
        }

        if (DCSpecRequest) {
            log.debug("DCSpec Exchange requested.");
            ObjectIdentifier FPCDCSpecID;
            FPCDCSpecID = strEffectiveFPCInfoList.get(usedFPCInfo).getDcSpecID();
            int FPCDCSpecItemCount = CimArrayUtils.getSize(strEffectiveFPCInfoList.get(usedFPCInfo).getDcSpecList());

            if (!ObjectIdentifier.isEmpty(FPCDCSpecID) && 0 != FPCDCSpecItemCount) {
                log.debug("DCSpec and the Item found in FPCInfo. They will be override the startCassette's one. Now check them.");
                log.debug("{} DCSpec Item count of FPCInfo", FPCDCSpecItemCount);

                if (!nullEQPRequest) {
                    log.debug("DCSpec Item Check start.");
                    List<String> dcSpecItemNameList = new ArrayList<>();
                    List<Infos.DCSpecDetailInfo> dcSpecList = strEffectiveFPCInfoList.get(usedFPCInfo).getDcSpecList();
                    dcSpecList.forEach(x -> dcSpecItemNameList.add(x.getDataItemName()));

                    fpcMethod.fpcDcSpecItemConsistencyCheck(objCommon, FPCDCSpecID, dcSpecItemNameList);

                    log.debug("DCSpec check ok.");
                }
                log.debug("DCSpec Action Required.");
                objLotEffectiveFPCInfoGetOut.setDcSpecActionRequiredFlag(true);
            } else {
                log.debug("DCSpecID or (and) DCSpecItem of FPCInfo are not filled. Not changed.");
            }
        }

        if (ReticleRequest) {
            log.debug("Exchange Reticle");
            int FPCReticleCount = CimArrayUtils.getSize(strEffectiveFPCInfoList.get(usedFPCInfo).getReticleInfoList());

            log.debug("{} Reticle Count", FPCReticleCount);
            if (FPCReticleCount > 0) {
                log.debug("Reticle will be changed.");
                objLotEffectiveFPCInfoGetOut.setReticleActionRequiredFlag(true);
            } else {
                log.debug("There is no DOC Reticle. Not exchange.");
            }
        }
        return objLotEffectiveFPCInfoGetOut;
    }

    /**
     * description:lot_bondingGroupID_GetDR
     * <p>
     * change history:
     * date             defect#             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param objCommon
     * @param lotID     -
     * @return com.fa.cim.pojo.obj.Outputs.ObjLotBondingGroupIDGetDROut
     * @author Panda
     * @date 2018/4/19
     */

    @Override
    public String lotBondingGroupIDGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        String lotId = ObjectIdentifier.fetchValue(lotID);
        String sql = "SELECT * FROM OSBONDGRP_MAP WHERE BASE_LOT_ID = ?1 OR PLAN_TOP_LOT_ID = ?2";
        List<CimBondGroupMapDO> bondGroupMapDO = cimJpaRepository.query(sql, CimBondGroupMapDO.class, lotId, lotId);
        if (CimArrayUtils.isEmpty(bondGroupMapDO)) {
            return CimStringUtils.EMPTY;
        }

        return bondGroupMapDO.get(0).getBondGroupID();
    }

    /**
     * description:
     * <p> jerry修改
     * change history:
     * date             defect#             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param objCommon -
     * @param lotTypeId -
     * @return com.fa.cim.pojo.obj.Outputs.ObjLotTypeSubLotTypeInfoOut
     * @author Panda
     * @since 2018/5/10
     */
    @Override
    public List<Infos.LotTypeInfo> lotTypeSubLotTypeInfoGet(Infos.ObjCommon objCommon, String lotTypeId) {
        List<CimLotType> aPosLotTypeSeq = new ArrayList<>();
        if (!CimStringUtils.isEmpty(lotTypeId)) {
            CimLotType lotType = productManager.findLotTypeNamed(lotTypeId);
            aPosLotTypeSeq.add(lotType);
        } else {
            aPosLotTypeSeq = productManager.allLotTypes();
        }
        //------------------------------------------
        // set output structure length
        //------------------------------------------
        int lenLotTypeSeq = CimArrayUtils.getSize(aPosLotTypeSeq);
        //------------------------------------------
        // Retrieve subLot Type information from PosLotType
        //------------------------------------------
        List<Infos.LotTypeInfo> lotTypeInfoList = new ArrayList<>();
        for (int i = 0; i < lenLotTypeSeq; i++) {
            CimLotType lotTypeSublotTypeInfo = aPosLotTypeSeq.get(i);
            if (lotTypeSublotTypeInfo == null){
                throw new ServiceException(new OmCode(retCodeConfig.getNotFoundLotType(), ""));
            }
            Infos.LotTypeInfo lotTypeInfo = new Infos.LotTypeInfo();
            lotTypeInfoList.add(lotTypeInfo);
            lotTypeInfo.setLotType(new ObjectIdentifier(lotTypeSublotTypeInfo.getIdentifier(), lotTypeSublotTypeInfo.getPrimaryKey()));
            List<ProductDTO.SubLotType> aPosSubLotTypeSeq = lotTypeSublotTypeInfo.allSubLotTypes();
            List<Infos.SubLotType> lotTypeSubLotTypeList = new ArrayList<>();
            lotTypeInfo.setStrSubLotTypes(lotTypeSubLotTypeList);
            int lenSubLotTypeSeq = CimArrayUtils.getSize(aPosSubLotTypeSeq);
            for (int j = 0; j < lenSubLotTypeSeq; j++){
                Infos.SubLotType subLotType = new Infos.SubLotType();
                lotTypeSubLotTypeList.add(subLotType);
                subLotType.setSubLotType(aPosSubLotTypeSeq.get(j).getSubLotType());
                subLotType.setLeadingCharacter(aPosSubLotTypeSeq.get(j).getLeadingCharacter());
                subLotType.setDescription(aPosSubLotTypeSeq.get(j).getDescription());
            }
        }
        return lotTypeInfoList;
    }


    @Override
    public Outputs.ObjLotSTBCancelInfoOut lotSTBCancelInfoGetDR(Infos.ObjCommon objCommon, ObjectIdentifier stbCancelledLotID) {
        // Get lot information
        Infos.STBCancelledLotInfo tmpSTBCancelledLotInfo = new Infos.STBCancelledLotInfo();
        CimLot stbCancelledLot = baseCoreFactory.getBO(CimLot.class, stbCancelledLotID);
        Validations.check(stbCancelledLot == null, new OmCode(retCodeConfig.getNotFoundLot(), stbCancelledLotID.getValue()));
        tmpSTBCancelledLotInfo.setLotID(new ObjectIdentifier(stbCancelledLot.getIdentifier(), stbCancelledLot.getPrimaryKey()));
        tmpSTBCancelledLotInfo.setLotType(stbCancelledLot.getLotType());
        tmpSTBCancelledLotInfo.setSubLotType(stbCancelledLot.getSubLotType());
        tmpSTBCancelledLotInfo.setLotStatus(stbCancelledLot.getLotState());
        tmpSTBCancelledLotInfo.setProductID(stbCancelledLot.getProductSpecificationID());
        CimProcessDefinition processID = stbCancelledLot.getMainProcessDefinition();
        if (null != processID) {
            tmpSTBCancelledLotInfo.setRouteID(new ObjectIdentifier(processID.getIdentifier(), processID.getPrimaryKey()));
        }
        tmpSTBCancelledLotInfo.setOperationNumber(stbCancelledLot.getOperationNumber());
        tmpSTBCancelledLotInfo.setWaferCount(stbCancelledLot.getQuantity() == null ? 0 : (long)stbCancelledLot.getQuantity());
        /*--------------------------------------*/
        /*    Get STB source lot information    */
        /*--------------------------------------*/
        List<Infos.NewPreparedLotInfo> tmpNewPreparedLotInfoSeq = new ArrayList<>();
        List<ProductDTO.STBSourceLotInfo> stbSourceLots = stbCancelledLot.getSTBSourceLots();
        if (!CimArrayUtils.isEmpty(stbSourceLots)){
            for (ProductDTO.STBSourceLotInfo stbSourceLotInfo : stbSourceLots) {
                /*------------------------------------------------------*/
                /*    Set source lot information to output parameter    */
                /*------------------------------------------------------*/
                Infos.NewPreparedLotInfo newPreparedLotInfo = new Infos.NewPreparedLotInfo();
                tmpNewPreparedLotInfoSeq.add(newPreparedLotInfo);
                newPreparedLotInfo.setStbSourceLotID(stbSourceLotInfo.getSourceLotID());
                newPreparedLotInfo.setLotType(stbSourceLotInfo.getSourceLotLotType());
                newPreparedLotInfo.setSubLotType(stbSourceLotInfo.getSourceLotSubLotType());
                newPreparedLotInfo.setProductID(stbSourceLotInfo.getSourceLotProdSpecID());
                newPreparedLotInfo.setWaferCount(0L);
            }
        }
        /*--------------------------------*/
        /*    Get StartBank of product    */
        /*--------------------------------*/
        ObjectIdentifier startBank = null;
        String specSql = "SELECT * FROM OMPRODINFO WHERE PROD_ID = ?1";
        CimProductSpecificationDO productSpecification = cimJpaRepository.queryOne(specSql, CimProductSpecificationDO.class, ObjectIdentifier.fetchValue(tmpSTBCancelledLotInfo.getProductID()));
        Validations.check(productSpecification == null, retCodeConfig.getNotFoundProductSpec());
        if (CimStringUtils.isNotEmpty(productSpecification.getMainProcessDefinitionID())) {
            String pdSql = "SELECT * FROM OMPRP WHERE PRP_ID = ?1 AND PRP_LEVEL = ?2";
            CimProcessDefinitionDO processDefinition = cimJpaRepository.queryOne(pdSql, CimProcessDefinitionDO.class, productSpecification.getMainProcessDefinitionID(), BizConstant.SP_PD_FLOWLEVEL_MAIN);
            if (null != processDefinition) {
                startBank = new ObjectIdentifier(processDefinition.getStartBankID(), processDefinition.getStartBankObj());
            }
        }
        tmpSTBCancelledLotInfo.setRouteStartBankID(startBank);
        /*--------------------------------*/
        /*    Get cassette information    */
        /*--------------------------------*/
        List<MaterialContainer> materialContainers = stbCancelledLot.materialContainers();
        if (!CimArrayUtils.isEmpty(materialContainers)) {
            //get one(siview)
            MaterialContainer materialContainer = materialContainers.get(0);
            tmpSTBCancelledLotInfo.setCassetteID(new ObjectIdentifier(materialContainer.getIdentifier(), materialContainer.getPrimaryKey()));
        }
        /*------------------*/
        /*    Get wafers    */
        /*------------------*/
        List<Infos.STBCancelWaferInfo> tmpSTBCancelledWaferInfoSeq = new ArrayList<>();
        if (!ObjectIdentifier.isEmptyWithValue(tmpSTBCancelledLotInfo.getCassetteID())) {
            //Get wafers in cassette
            List<Infos.WaferMapInCassetteInfo> waferMapInCassetteInfoList = cassetteMethod.cassetteGetWaferMapDR(objCommon, tmpSTBCancelledLotInfo.getCassetteID());
            int castWaferLen = CimArrayUtils.getSize(waferMapInCassetteInfoList);
            if (castWaferLen > 0) {
                for (int i = 0; i < castWaferLen; i++) {
                    if (!ObjectIdentifier.isEmptyWithValue(waferMapInCassetteInfoList.get(i).getWaferID())) {
                        Infos.STBCancelWaferInfo stbCancelWaferInfo = new Infos.STBCancelWaferInfo();
                        tmpSTBCancelledWaferInfoSeq.add(stbCancelWaferInfo);
                        stbCancelWaferInfo.setWaferID(waferMapInCassetteInfoList.get(i).getWaferID());
                        stbCancelWaferInfo.setCurrentLotID(waferMapInCassetteInfoList.get(i).getLotID());
                        long slotNumber = waferMapInCassetteInfoList.get(i).getSlotNumber() == null ? 0: CimLongUtils.longValue(waferMapInCassetteInfoList.get(i).getSlotNumber());
                        stbCancelWaferInfo.setSlotNo(slotNumber);
                    }
                }
            }
        } else {
            /*-------------------------*/
            /*    Get wafers in lot    */
            /*-------------------------*/
            Inputs.ObjLotWaferIDListGetDRIn objLotWaferIDListGetDRIn = new Inputs.ObjLotWaferIDListGetDRIn();
            objLotWaferIDListGetDRIn.setLotID(stbCancelledLotID);
            objLotWaferIDListGetDRIn.setScrapCheckFlag(false);
            List<ObjectIdentifier> waferIDs = this.lotWaferIDListGetDR(objCommon, objLotWaferIDListGetDRIn);
            if (!CimArrayUtils.isEmpty(waferIDs)) {
                for (int i = 0; i < waferIDs.size(); i++) {
                    Infos.STBCancelWaferInfo stbCancelWaferInfo = new Infos.STBCancelWaferInfo();
                    tmpSTBCancelledWaferInfoSeq.add(stbCancelWaferInfo);
                    stbCancelWaferInfo.setWaferID(waferIDs.get(i));
                    stbCancelWaferInfo.setCurrentLotID(stbCancelledLotID);
                    stbCancelWaferInfo.setSlotNo(0L);    // init slot number to 0
                }
            }
        }
        int waferLen = CimArrayUtils.getSize(tmpSTBCancelledWaferInfoSeq);
        int stbSrcLotLen = 0;
        if (waferLen > 0) {
            for (int i = 0; i < waferLen; i++){
                CimWafer cimWafer = baseCoreFactory.getBO(CimWafer.class, tmpSTBCancelledWaferInfoSeq.get(i).getWaferID());
                Validations.check(cimWafer == null, new OmCode(retCodeConfig.getNotFoundWafer(), ObjectIdentifier.fetchValue(tmpSTBCancelledWaferInfoSeq.get(i).getWaferID())));
                /*--------------------------*/
                /*    Get STB source lot    */
                /*--------------------------*/
                List<ProductDTO.STBInfo> stbInfoList = cimWafer.getSTBInfo();
                if (CimArrayUtils.getSize(stbInfoList) > 0){
                    /*--------------------------*/
                    /*    Set STB source lot    */
                    /*--------------------------*/
                    ProductDTO.STBInfo stbInfo = stbInfoList.get(0);
                    Infos.STBCancelWaferInfo stbCancelWaferInfo = tmpSTBCancelledWaferInfoSeq.get(i);
                    stbCancelWaferInfo.setStbSourceLotID(stbInfo.getSTBSourceLotID());
                }
            }
            /*-----------------------------------------------*/
            /*    Get wafer count for each STB source lot    */
            /*-----------------------------------------------*/
            stbSrcLotLen = CimArrayUtils.getSize(tmpNewPreparedLotInfoSeq);
            for (int i = 0; i < stbSrcLotLen; i++){
                int waferCount = 0;
                for (int j = 0; j < waferLen; j++){
                    if (ObjectIdentifier.equalsWithValue(stbCancelledLotID, tmpSTBCancelledWaferInfoSeq.get(j).getCurrentLotID())
                     && CimStringUtils.equals(tmpNewPreparedLotInfoSeq.get(i).getStbSourceLotID(), tmpSTBCancelledWaferInfoSeq.get(j).getStbSourceLotID())){
                        waferCount++;
                    }
                }
                Infos.NewPreparedLotInfo newPreparedLotInfo = tmpNewPreparedLotInfoSeq.get(i);
                newPreparedLotInfo.setWaferCount((long)waferCount);
            }
        }
        //Set output structure
        Outputs.ObjLotSTBCancelInfoOut infoOut = new Outputs.ObjLotSTBCancelInfoOut();
        infoOut.setStbCancelledLotInfo(tmpSTBCancelledLotInfo);
        infoOut.setStbCancelWaferInfoList(tmpSTBCancelledWaferInfoSeq);
        //Set STB source lot info whose waferCount isn't 0
        infoOut.setNewPreparedLotInfoList(tmpNewPreparedLotInfoSeq.stream().
                filter(tmpNewPreparedLotInfo -> tmpNewPreparedLotInfo.getWaferCount() > 0).collect(Collectors.toList()));
        return infoOut;
    }

    @Override
    public List<Infos.LotWaferAttributes> lotWafersGetDR(Infos.ObjCommon objCommon, Inputs.ObjLotWafersGetIn objLotWafersIn) {
        String sql = String.format("SELECT * FROM OMWAFER WHERE LOT_ID='%s'", ObjectIdentifier.fetchValue(objLotWafersIn.getLotID()));
        if (objLotWafersIn.getScrapCheckFlag()) {
            sql = String.format(sql + " AND SCRAP_STATE <> '%s'", BizConstant.SP_SCRAPSTATE_SCRAP);
            sql = String.format(sql + " AND SCRAP_STATE <> '%s'", BizConstant.SP_SCRAPSTATE_GARBAGE);
        }
        sql = sql + "order by POSITION";
        List<CimWaferDO> wafers = cimJpaRepository.query(sql, CimWaferDO.class);

        String tLenStr = StandardProperties.OM_MAX_WAFER_COUNT_FOR_LOT.getValue();
        Integer tLen = tLenStr == null ? 0 : Integer.valueOf(tLenStr);
        if (tLen < 1) {
            tLen = 25;
        }
        Integer count = 0;
        String searchRouteIDdummy = "";
        Inputs.ObjProcessOperationListForLotIn objProcessOperationListForLotIn = new Inputs.ObjProcessOperationListForLotIn();
        objProcessOperationListForLotIn.setSearchDirectionFlag(false);
        objProcessOperationListForLotIn.setPosSearchFlag(true);
        objProcessOperationListForLotIn.setSearchCount(1);
        objProcessOperationListForLotIn.setSearchOperationNumber(searchRouteIDdummy);
        objProcessOperationListForLotIn.setCurrentFlag(false);
        objProcessOperationListForLotIn.setLotID(objLotWafersIn.getLotID());
        //【TODO】【TODO - NOTIMPL】- 有问题需要确认
        List<Infos.OperationNameAttributes> processOperationOut = new ArrayList<>();
        try {
            processOperationOut = processMethod.processOperationListForLot(objCommon, objProcessOperationListForLotIn);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getSomeopelistDataError(),e.getCode())){
                log.info("process_OperationNumberListForLot() == RC_SOMEOPELIST_DATA_ERROR");
            }else if (Validations.isEquals(retCodeConfig.getNotFoundProcessOperation(),e.getCode())){
                log.info("process_OperationNumberListForLot() == RC_NOT_FOUND_PO : This means This Lot doesn't on route.");
            }else{
                throw e;
            }
        }
        String key = "";

        if (!CimArrayUtils.isEmpty(processOperationOut)) {
            String routeID = processOperationOut.get(0).getRouteID().getValue();
            String operationNumber = processOperationOut.get(0).getOperationNumber();
            boolean firstOperationFlag = false;

            CimLotDO example = new CimLotDO();
            example.setLotID(ObjectIdentifier.fetchValue(objLotWafersIn.getLotID()));
            CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
            Validations.check(null == lot, retCodeConfig.getNotFoundLot());

            if (!CimStringUtils.equals(lot.getRouteID(), routeID)) {
                CimProcessDefinitionDO processDefinition = cimJpaRepository.queryOne("SELECT * FROM OMPRP WHERE PRP_ID = ?1 AND PRP_LEVEL = ?2", CimProcessDefinitionDO.class, lot.getRouteID(), BizConstant.SP_FLOWTYPE_MAIN);
                if (null != processDefinition && CimStringUtils.equals(BizConstant.SP_FLOWTYPE_SUB,processDefinition.getFlowType())) {
                    firstOperationFlag = true;
                }
            }

            if (!CimStringUtils.isEmpty(routeID) && !CimStringUtils.isEmpty(operationNumber) && !firstOperationFlag) {
                key = routeID + BizConstant.SP_POSPROCESSFLOWCONTEXT_SEPARATOR_CHAR + operationNumber;
            }
        }


        List<Infos.LotWaferAttributes> strLotWaferAttributes = new ArrayList<>();
        if (!CimArrayUtils.isEmpty(wafers)) {
            for (CimWaferDO w : wafers) {
                Infos.LotWaferAttributes lotWaferAttributes = new Infos.LotWaferAttributes();
                lotWaferAttributes.setWaferID(new ObjectIdentifier(w.getWaferID(), w.getId()));
                lotWaferAttributes.setCassetteID(new ObjectIdentifier(w.getMaterialContainerID(), w.getMaterialContainerObj()));
                lotWaferAttributes.setAliasWaferName(w.getAliasWaferName());
                lotWaferAttributes.setSlotNumber(w.getPosition());
                lotWaferAttributes.setProductID(new ObjectIdentifier(w.getProductSpecificationID(), w.getProductSpecificationObj()));
                lotWaferAttributes.setGrossUnitCount(w.getTotalDiceCount());
                lotWaferAttributes.setGoodUnitCount(w.getGoodDiceCount());
                lotWaferAttributes.setRepairUnitCount(w.getRepairedDiceQty());
                lotWaferAttributes.setFailUnitCount(w.getBadDiceQty());
                lotWaferAttributes.setControlWaferFlag(w.getControlWaferFlag());
                lotWaferAttributes.setSTBAllocFlag(w.getStbAllocatedFlag());
                lotWaferAttributes.setEqpMonitorUsedCount(w.getEquipmentMonitorUsedCount());
                lotWaferAttributes.setUsageCount(w.getUsageCount());
                lotWaferAttributes.setRecycleCount(w.getRecycleCount());
                /*-------------------------------------*/
                /*   Get reworkCount of each wafers    */
                /*-------------------------------------*/
                lotWaferAttributes.setReworkCount(0);
                if (!CimStringUtils.isEmpty(key)) {
                    CimWaferReworkCountDO cimWaferReworkCountExample = new CimWaferReworkCountDO();
                    cimWaferReworkCountExample.setLinkKey(key);
                    cimWaferReworkCountExample.setReferenceKey(w.getId());
                    CimWaferReworkCountDO waferRwkcnt = cimJpaRepository.findOne(Example.of(cimWaferReworkCountExample)).orElse(null);
                    if (null != waferRwkcnt) {
                        lotWaferAttributes.setReworkCount(waferRwkcnt.getReworkCount());
                    }
                }
                strLotWaferAttributes.add(lotWaferAttributes);
            }
        }

        if (CimArrayUtils.isEmpty(strLotWaferAttributes)) {
            CimLotDO example = new CimLotDO();
            example.setLotID(ObjectIdentifier.fetchValue(objLotWafersIn.getLotID()));
            CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
            if (null != lot && lot.getWaferCount() > 0) {
                String sMaxWfr = StandardProperties.OM_MAX_WAFER_COUNT_FOR_LOT.getValue();
                Long lMaxWfr = CimStringUtils.isEmpty(sMaxWfr) ? 0 : Long.valueOf(sMaxWfr);
                Long compValue = lMaxWfr > 0L ? lMaxWfr : (long) BizConstant.SP_LOT_MAXIMUMWAFERSINALOT;
                Long lotQty = lot.getWaferCount() < compValue ? lot.getWaferCount() : compValue;

                for (int i = 0; i < lotQty; i++) {
                    Infos.LotWaferAttributes lotWaferAttributes = new Infos.LotWaferAttributes();
                    lotWaferAttributes.setWaferID(null);
                    lotWaferAttributes.setSlotNumber(i + 1);
                    lotWaferAttributes.setCassetteID(null);
                    lotWaferAttributes.setProductID(new ObjectIdentifier(lot.getProductSpecificationID(), lot.getProductSpecificationObj()));
                    lotWaferAttributes.setGrossUnitCount(0);
                    lotWaferAttributes.setGoodUnitCount(0);
                    lotWaferAttributes.setRepairUnitCount(0);
                    lotWaferAttributes.setFailUnitCount(0);
                    lotWaferAttributes.setControlWaferFlag(false);
                    lotWaferAttributes.setSTBAllocFlag(false);
                    strLotWaferAttributes.add(lotWaferAttributes);
                }
            }
        }
        return strLotWaferAttributes;
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param objCommon -
     * @param lotID -
     * @return com.fa.cim.dto.RetCode<com.fa.cim.dto.Results.LotInterFabXferStateResult>
     * @author Ho
     * @since 2018/11/6 10:39:17
     */
    @Override
    public String lotInterFabXferStateGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        return aLot.getInterFabTransferState();
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param cassetteID
     * @param strLotInCassette
     * @return com.fa.cim.dto.RetCode<com.fa.cim.bean.extension.Infos.LotRecipeParameterEventStructOut>
     * @exception
     * @author Ho
     * @date 2019/3/5 16:50
     */
    @Override
    public Infos.LotRecipeParameterEventStructOut lotRecipeParameterEventStruct(Infos.ObjCommon strObjCommonIn, ObjectIdentifier cassetteID, Infos.LotInCassette strLotInCassette) {

        Infos.LotRecipeParameterEventStructOut lotRecipeParameterEventStructOut = new Infos.LotRecipeParameterEventStructOut();
        if(!strLotInCassette.getMoveInFlag()){
            throw new ServiceException(retCodeConfig.getInvalidInputParam());
        }
        int lenWafer = CimArrayUtils.getSize(strLotInCassette.getLotWaferList());
        if (lenWafer == 0){
            throw new ServiceException(retCodeConfig.getNotFoundWafer());
        }
        List<Infos.OpeHisRecipeParmInfo> opeHisRecipeParmInfoList = new ArrayList<>();
        List<Infos.StartRecipeParameter> startRecipeParameterList = strLotInCassette.getLotWaferList().get(0).getStartRecipeParameterList();
        int lenFirstRParm = CimArrayUtils.getSize(startRecipeParameterList);
        for (Infos.StartRecipeParameter startRecipeParameter : startRecipeParameterList){
            Infos.OpeHisRecipeParmInfo opeHisRecipeParmInfo = new Infos.OpeHisRecipeParmInfo();
            opeHisRecipeParmInfoList.add(opeHisRecipeParmInfo);
            opeHisRecipeParmInfo.setRecipeParameterName(startRecipeParameter.getParameterName());
            opeHisRecipeParmInfo.setRecipeParameterValue(startRecipeParameter.getParameterValue());
        }
        /*--------------------------------------*/
        /*   Set strOpeHisRecipeParmWaferInfo   */
        /*--------------------------------------*/
        List<Infos.OpeHisRecipeParmWaferInfo> opeHisRecipeParmWaferInfoList = new ArrayList<>();
        for (Infos.LotWafer lotWafer : strLotInCassette.getLotWaferList()){
            int lenRParm = CimArrayUtils.getSize(lotWafer.getStartRecipeParameterList());
            if(lenRParm != lenFirstRParm){
                throw new ServiceException(retCodeConfig.getInvalidInputParam());
            }
            Infos.OpeHisRecipeParmWaferInfo opeHisRecipeParmWaferInfo = new Infos.OpeHisRecipeParmWaferInfo();
            opeHisRecipeParmWaferInfoList.add(opeHisRecipeParmWaferInfo);
            opeHisRecipeParmWaferInfo.setWaferID(lotWafer.getWaferID());
            opeHisRecipeParmWaferInfo.setMachineRecipeID(strLotInCassette.getStartRecipe().getMachineRecipeID());
            List<Infos.OpeHisRecipeParmInfo> strOpeHisRecipeParmInfo = new ArrayList<>();
            opeHisRecipeParmWaferInfo.setStrOpeHisRecipeParmInfo(strOpeHisRecipeParmInfo);
            for (Infos.StartRecipeParameter startRecipeParameter : lotWafer.getStartRecipeParameterList()){
                Infos.OpeHisRecipeParmInfo opeHisRecipeParmInfo = new Infos.OpeHisRecipeParmInfo();
                strOpeHisRecipeParmInfo.add(opeHisRecipeParmInfo);
                opeHisRecipeParmInfo.setRecipeParameterName(startRecipeParameter.getParameterName());
                opeHisRecipeParmInfo.setRecipeParameterValue(startRecipeParameter.getParameterValue());
            }
        }
        /*--------------------------*/
        /*   Set Output Parameter   */
        /*--------------------------*/
        lotRecipeParameterEventStructOut.setStrOpeHisRecipeParmInfo(opeHisRecipeParmInfoList);
        lotRecipeParameterEventStructOut.setStrOpeHisRecipeParmWaferInfo(opeHisRecipeParmWaferInfoList);
        return lotRecipeParameterEventStructOut;
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param lotID
     * @return com.fa.cim.dto.RetCode<java.lang.String>
     * @author Ho
     * @date 2019/1/9 16:42:58
     */
    @Override
    public String lotSubLotTypeGetDR(Infos.ObjCommon strObjCommonIn, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(lot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        return lot.getSubLotType();
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param lotID
     * @return com.fa.cim.dto.RetCode<com.fa.cim.dto.ObjectIdentifier>
     * @author Ho
     * @date 2018/12/5 13:53:00
     */
    @Override
    public ObjectIdentifier lotMainRouteIDGet(Infos.ObjCommon strObjCommonIn, ObjectIdentifier lotID) {
        ObjectIdentifier mainRouteID = null;
        /*---------------------------*/
        /* Get Process Flow Context  */
        /*---------------------------*/
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = aLot.getProcessFlowContext();
        Validations.check(aPFX == null, new OmCode(retCodeConfig.getNotFoundPfx(), ""));
        /*--------------------------------------*/
        /*   Check Lot is on Main or Sub Route  */
        /*   if return no is 0, MainRoute       */
        /*   if return no >0, SubRoute          */
        /*--------------------------------------*/
        List<ProcessDTO.ReturnOperation> aReturnOperationList = aPFX.allReturnOperations();
        int aReturnOperationSequenceLen = CimArrayUtils.getSize(aReturnOperationList);
        /* -------------------------------------- */
        /* On MainRoute.                          */
        /* -------------------------------------- */
        if (aReturnOperationSequenceLen == 0){
            /* ---------------------------- */
            /* Get CurrentRouteID.          */
            /* ---------------------------- */
            mainRouteID = this.lotCurrentRouteIDGet(strObjCommonIn, lotID);
        }
        /* -------------------------------------- */
        /* On SubRoute.                           */
        /* ( aReturnOperationSequenceLen > 0 )    */
        /* -------------------------------------- */
        else {
            /*--------------------------------------*/
            /*   Get Process Flow of Main Route ID  */
            /*--------------------------------------*/
            aReturnOperationSequenceLen = aReturnOperationSequenceLen - 1;
            ProcessDTO.ReturnOperation strPosReturnOperation = aPFX.getReturnOperationFor(aReturnOperationSequenceLen);
            com.fa.cim.newcore.bo.pd.CimProcessFlow aPF = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessFlow.class, strPosReturnOperation.getProcessFlow());
            Validations.check(aPF == null, new OmCode(retCodeConfig.getNotFoundProcessFlow(), lotID.getValue()));
            /*-----------------------------------*/
            /*   Get Main Process Definition ID  */
            /*-----------------------------------*/
            ProcessDefinition rootPD = aPF.getRootProcessDefinition();
            Validations.check(rootPD == null, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), ""));
            mainRouteID = new ObjectIdentifier(rootPD.getIdentifier(), rootPD.getPrimaryKey());
        }
        return mainRouteID;
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param strOperationNameAttributes
     * @param strRequestActionFlagSeq
     * @param lotID
     * @return com.fa.cim.dto.RetCode<java.util.List<com.fa.cim.pojo.Infos.OperationFutureActionAttributes>>
     * @author Ho
     * @date 2018/12/4 14:54:06
     */
    @Override
    public List<Infos.OperationFutureActionAttributes> lotFutureActionInfoGetDR(Infos.ObjCommon strObjCommonIn, List<Infos.OperationNameAttributes> strOperationNameAttributes, List<Infos.HashedInfo> strRequestActionFlagSeq, ObjectIdentifier lotID) {

        List<Infos.OperationFutureActionAttributes> strOperationFutureActionAttributes=new ArrayList<>();

        Boolean bFQTime  = false;
        Boolean bFHold   = false;
        Boolean bFRework = false;
        Boolean bADC     = false;
        Boolean bPSM     = false;
        Boolean bFPC     = false;
        Boolean bScript  = false;
        Boolean bPHold   = false;

        for (int i = 0; i < CimArrayUtils.getSize(strRequestActionFlagSeq); i++) {
            Infos.HashedInfo strRequestActionFlag = strRequestActionFlagSeq.get(i);
            if( CimStringUtils.equals(strRequestActionFlag.getHashKey(), BizConstant.SP_HASHKEY_FUTUREQTIMEFLAG) ) {
                if( CimStringUtils.equals(strRequestActionFlag.getHashData(), BizConstant.SP_HASHDATA_FLAG_1) ) {
                    bFQTime = true;
                }
            } else if( CimStringUtils.equals(strRequestActionFlag.getHashKey(), BizConstant.SP_HASHKEY_FUTUREHOLDFLAG) ) {
                if( CimStringUtils.equals(strRequestActionFlag.getHashData(), BizConstant.SP_HASHDATA_FLAG_1) ) {
                    bFHold = true;
                }
            } else if( CimStringUtils.equals(strRequestActionFlag.getHashKey(), BizConstant.SP_HASHKEY_FUTUREREWORKFLAG) ) {
                if( CimStringUtils.equals(strRequestActionFlag.getHashData(), BizConstant.SP_HASHDATA_FLAG_1) ) {
                    bFRework = true;
                }
            } else if( CimStringUtils.equals(strRequestActionFlag.getHashKey(), BizConstant.SP_HASHKEY_ADCFLAG) ) {
                if( CimStringUtils.equals(strRequestActionFlag.getHashData(), BizConstant.SP_HASHDATA_FLAG_1) ) {
                    bADC = true;
                }
            } else if( CimStringUtils.equals(strRequestActionFlag.getHashKey(), BizConstant.SP_HASHKEY_PSMFLAG) ) {
                if( CimStringUtils.equals(strRequestActionFlag.getHashData(), BizConstant.SP_HASHDATA_FLAG_1) ) {
                    bPSM = true;
                }
            } else if( CimStringUtils.equals(strRequestActionFlag.getHashKey(), BizConstant.SP_HASHKEY_FPCFLAG) ) {
                if( CimStringUtils.equals(strRequestActionFlag.getHashData(), BizConstant.SP_HASHDATA_FLAG_1) ) {
                    bFPC = true;
                }
            } else if( CimStringUtils.equals(strRequestActionFlag.getHashKey(), BizConstant.SP_HASHKEY_SCRIPTFLAG) ) {
                if( CimStringUtils.equals(strRequestActionFlag.getHashData(), BizConstant.SP_HASHDATA_FLAG_1) ) {
                    bScript = true;
                }
            } else if( CimStringUtils.equals(strRequestActionFlag.getHashKey(), BizConstant.SP_HASHKEY_PROCESSHOLDFLAG) ) {
                if( CimStringUtils.equals(strRequestActionFlag.getHashData(), BizConstant.SP_HASHDATA_FLAG_1) ) {
                    bPHold = true;
                }
            }
        }

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));

        ObjectIdentifier productID = lot.getProductSpecificationID();
        ObjectIdentifier lotFamilyID = lot.getLotFamilyID();
        String aPFXObjRef         = lot.getProcessFlowContextObj();

        String strProdGroup = null;
        String strTechnology = null;
        if( CimBooleanUtils.isTrue(bFQTime) ) {
            CimTechnology aPosTechnology  = null;

            CimProductSpecification aPosProduct= baseCoreFactory.getBO(CimProductSpecification.class, productID);
            Validations.check(null == aPosProduct, new OmCode(retCodeConfig.getInvalidProdId(), "******"));

            com.fa.cim.newcore.bo.prodspec.CimProductGroup aPosProductGroup = aPosProduct.getProductGroup();
            if( aPosProductGroup != null ) {
                strProdGroup = aPosProductGroup.getIdentifier();
            }

            if( aPosProductGroup != null ) {
                aPosTechnology = aPosProductGroup.getTechnology();
            }

            if( aPosTechnology!=null ) {
                strTechnology = aPosTechnology.getIdentifier();
            }
        }

        List<Infos.FutureHoldListAttributes> strFutureHoldListAttributesSeq = new ArrayList<>();
        if( CimBooleanUtils.isTrue(bFHold) ) {
            CimLotFutureHoldDO cimLotFutureHoldExample = new CimLotFutureHoldDO();
            cimLotFutureHoldExample.setReferenceKey(lot.getPrimaryKey());
            List<CimLotFutureHoldDO> lotFutureHoldList = cimJpaRepository.findAll(Example.of(cimLotFutureHoldExample));
            if (CimArrayUtils.isNotEmpty(lotFutureHoldList)) {
                for (CimLotFutureHoldDO lotFutureHold:lotFutureHoldList) {
                    String hfrlotfutureholdmainpdid=lotFutureHold.getMainProcessDefinitionID();
                    String hfrlotfutureholdopeno=lotFutureHold.getOperationNumber();

                    Infos.FutureHoldListAttributes strFutureHoldListAttributes=new Infos.FutureHoldListAttributes();
                    strFutureHoldListAttributesSeq.add(strFutureHoldListAttributes);
                    strFutureHoldListAttributes.setRouteID(ObjectIdentifier.buildWithValue(hfrlotfutureholdmainpdid));
                    strFutureHoldListAttributes.setOperationNumber( hfrlotfutureholdopeno);
                }
            }
        }

        List<Infos.FutureReworkInfo> strFutureReworkInfoSeq = new ArrayList<>();
        if( CimBooleanUtils.isTrue(bFRework) ) {
            CimFutureReworkDO example = new CimFutureReworkDO();
            example.setLotID(lot.getIdentifier());
            List<CimFutureReworkDO> futureReworkList = cimJpaRepository.findAll(Example.of(example));
            if (CimArrayUtils.isNotEmpty(futureReworkList)) {
                for (CimFutureReworkDO futureRework:futureReworkList) {
                    String hfrftrwkmainpdid=futureRework.getMainProcessDefinitionID();
                    String hfrftrwkopeno=futureRework.getOperationNumber();
                    Infos.FutureReworkInfo strFutureReworkInfo=new Infos.FutureReworkInfo();

                    strFutureReworkInfoSeq.add(strFutureReworkInfo);
                    strFutureReworkInfo.setRouteID(ObjectIdentifier.buildWithValue(hfrftrwkmainpdid));
                    strFutureReworkInfo.setOperationNumber( hfrftrwkopeno);
                }
            }

        }

        List<Infos.LotAutoDispatchControlInfo>  strAutoDispatchControlInfoGetDROut=null;
        if( CimBooleanUtils.isTrue(bADC) ) {
            Inputs.ObjAutoDispatchControlInfoGetDRIn strAutoDispatchControlInfoGetDRIn = new Inputs.ObjAutoDispatchControlInfoGetDRIn();
            strAutoDispatchControlInfoGetDRIn.setLotID(lotID);

            // step1 - autoDispatchControl_info_GetDR
            strAutoDispatchControlInfoGetDROut = autoDispatchControlMethod.autoDispatchControlInfoGetDR(strObjCommonIn, strAutoDispatchControlInfoGetDRIn);
        }

        List<Infos.ExperimentalLotInfo> strExperimentalLotListGetDROut=null;
        if( CimBooleanUtils.isTrue(bPSM) ) {

            // step2 - experimental_lotList_GetDR
            strExperimentalLotListGetDROut = experimentalMethod.experimentalLotListGetDR(strObjCommonIn, ObjectIdentifier.fetchValue(lotFamilyID), null, null, null, null, true, false);
        }

       List<Infos.FPCInfo> strFPCListGetDROut = null;
        if( CimBooleanUtils.isTrue(bFPC) ) {

            // step3 - FPC_list_GetDR
            Inputs.ObjFPCListGetDRIn fpcListGetDRIn = new Inputs.ObjFPCListGetDRIn();
            fpcListGetDRIn.setLotID(lotID);
            fpcListGetDRIn.setWaferIDInfoGetFlag(false);
            fpcListGetDRIn.setRecipeParmInfoGetFlag(false);
            fpcListGetDRIn.setReticleInfoGetFlag(false);
            fpcListGetDRIn.setDcSpecItemInfoGetFlag(false);
            strFPCListGetDROut = fpcMethod.fpcListGetDR(strObjCommonIn, fpcListGetDRIn);
        }

        Boolean bSubRoute = false;


        // step4 - lot_mainRouteID_Get
        ObjectIdentifier mainRouteID = lotMainRouteIDGet(strObjCommonIn, lotID);

        // step5 - lot_currentRouteID_Get
        ObjectIdentifier currentRouteID = this.lotCurrentRouteIDGet(strObjCommonIn, lotID);

        if( !ObjectIdentifier.equalsWithValue(mainRouteID, currentRouteID)) {
            bSubRoute = true;
        }

        String originalMainPDID = "";
        String originalOpeNo    = "";
        String subOrigMainPDID  = "";
        String subOrigOpeNo     = "";
        String branchMainPDID   = "";

        Infos.ProcessOriginalOperationGetOut strProcessOriginalOperationGetOut;
        if( CimBooleanUtils.isTrue(bSubRoute) && ( CimBooleanUtils.isTrue(bFQTime) || CimBooleanUtils.isTrue(bPSM) || CimBooleanUtils.isTrue(bFPC) ) ) {

            // step6 - process_originalOperation_Get
            strProcessOriginalOperationGetOut = processMethod.processOriginalOperationGet(strObjCommonIn,lotID);

            long branchNestLevel= strProcessOriginalOperationGetOut.getBranchNestLevel();
            if( branchNestLevel==0 ) {
            } else if( 1 == branchNestLevel ) {
                originalMainPDID = strProcessOriginalOperationGetOut.getOriginalMainPDID();
                originalOpeNo    = strProcessOriginalOperationGetOut.getOriginalOpeNo();
                subOrigMainPDID  = currentRouteID.getValue();
            } else if( 2 == branchNestLevel ) {
                originalMainPDID = strProcessOriginalOperationGetOut.getOriginalMainPDID();
                originalOpeNo    = strProcessOriginalOperationGetOut.getOriginalOpeNo();
                subOrigMainPDID  = strProcessOriginalOperationGetOut.getSubOrigMainPDID();
                subOrigOpeNo     = strProcessOriginalOperationGetOut.getSubOrigOpeNo();
                branchMainPDID   = currentRouteID.getValue();
            } else {
                originalMainPDID = strProcessOriginalOperationGetOut.getOriginalMainPDID();
                originalOpeNo    = strProcessOriginalOperationGetOut.getOriginalOpeNo();
                subOrigMainPDID  = strProcessOriginalOperationGetOut.getSubOrigMainPDID();
                subOrigOpeNo     = strProcessOriginalOperationGetOut.getSubOrigOpeNo();
                branchMainPDID   = strProcessOriginalOperationGetOut.getBranchMainPDID();
            }
        }

        ObjectIdentifier tmpRouteID=null;
        List<Infos.ProcHoldListAttributes> tmpProcHoldListAttributes=null;
        String tmpKey = "";
        for (int n = 0; n< CimArrayUtils.getSize(strOperationNameAttributes); n++) {

            Infos.OperationNameAttributes strOperationNameAttribute = strOperationNameAttributes.get(n);
            String strRouteID  = strOperationNameAttribute.getRouteID().getValue();
            String strOperID   = strOperationNameAttribute.getOperationID().getValue();
            String strOperNo   = strOperationNameAttribute.getOperationNumber();
            String strMainPOS  = strOperationNameAttribute.getProcessRef().getProcessOperationSpecification();
            String strModPOS   = strOperationNameAttribute.getProcessRef().getModulePOS();

            List<Infos.HashedInfo> strFutureActionFlagSeq;
            strFutureActionFlagSeq=new ArrayList<>();

            Infos.HashedInfo strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_FUTUREQTIMEFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);
            strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_FUTUREHOLDFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);
            strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_FUTUREREWORKFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);
            strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_ADCFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);
            strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_PSMFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);
            strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_FPCFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);
            strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_SCRIPTFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);
            strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_PROCESSHOLDFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);
            strFutureActionFlag=new Infos.HashedInfo();
            strFutureActionFlagSeq.add(strFutureActionFlag);
            strFutureActionFlag.setHashKey(BizConstant.SP_HASHKEY_FUTUREMINQTIMEFLAG);
            strFutureActionFlag.setHashData(BizConstant.SP_HASHDATA_FLAG_0);

            if( CimBooleanUtils.isTrue(bFQTime) ) {
                if (haveFutureQTime(true, strMainPOS, strModPOS, strProdGroup, strTechnology, productID, bSubRoute,
                        aPFXObjRef, strRouteID, currentRouteID, strOperNo)) {
                    strFutureActionFlagSeq.get(0).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                }
                if (haveFutureQTime(false, strMainPOS, strModPOS, strProdGroup, strTechnology, productID, bSubRoute,
                        aPFXObjRef, strRouteID, currentRouteID, strOperNo)) {
                    strFutureActionFlagSeq.get(8).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                }
            }

            if( CimBooleanUtils.isTrue(bFHold) ) {
                int fHoldLen = CimArrayUtils.getSize(strFutureHoldListAttributesSeq);
                for( int fHoldCnt=0; fHoldCnt < fHoldLen; fHoldCnt++ ) {
                    Infos.FutureHoldListAttributes strFutureHoldListAttributes = strFutureHoldListAttributesSeq.get(fHoldCnt);
                    if( CimStringUtils.equals(strFutureHoldListAttributes.getRouteID().getValue(), strRouteID)
                            && CimStringUtils.equals(strFutureHoldListAttributes.getOperationNumber(), strOperNo) ) {
                        strFutureActionFlagSeq.get(1).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                        break;
                    }
                }
            }

            if( CimBooleanUtils.isTrue(bFRework) ) {
                int fReworkLen = CimArrayUtils.getSize(strFutureReworkInfoSeq);
                for( int fReworkCnt=0; fReworkCnt < fReworkLen; fReworkCnt++ ) {

                    Infos.FutureReworkInfo strFutureReworkInfo = strFutureReworkInfoSeq.get(fReworkCnt);
                    if( CimStringUtils.equals(strFutureReworkInfo.getRouteID().getValue(), strRouteID)
                            && CimStringUtils.equals(strFutureReworkInfo.getOperationNumber(), strOperNo) ) {
                        strFutureActionFlagSeq.get(2).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                        break;
                    }
                }
            }

            if( CimBooleanUtils.isTrue(bADC)) {
                List<Infos.LotAutoDispatchControlInfo> strLotAutoDispatchControlInfoSeq = strAutoDispatchControlInfoGetDROut;
                int adcLen = CimArrayUtils.getSize(strLotAutoDispatchControlInfoSeq);
                for( int adcCnt=0; adcCnt < adcLen; adcCnt++ ) {
                    Infos.LotAutoDispatchControlInfo strLotAutoDispatchControlInfo = strLotAutoDispatchControlInfoSeq.get(adcCnt);
                    String routeID         = strLotAutoDispatchControlInfo.getRouteID().getValue();
                    String operationNumber = strLotAutoDispatchControlInfo.getOperationNumber();
                    if( CimStringUtils.equals(routeID, BizConstant.SP_ADCSETTING_ASTERISK) && CimStringUtils.equals(operationNumber, BizConstant.SP_ADCSETTING_ASTERISK) ) {

                        strFutureActionFlagSeq.get(3).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                        break;
                    } else if( !CimStringUtils.equals(routeID, BizConstant.SP_ADCSETTING_ASTERISK) && CimStringUtils.equals(operationNumber, BizConstant.SP_ADCSETTING_ASTERISK) ) {
                        if( CimStringUtils.equals(strRouteID, routeID) ) {

                            strFutureActionFlagSeq.get(3).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                            break;
                        }
                    }
                    else if( !CimStringUtils.equals(routeID, BizConstant.SP_ADCSETTING_ASTERISK) && !CimStringUtils.equals(operationNumber, BizConstant.SP_ADCSETTING_ASTERISK) ) {
                        if( CimStringUtils.equals(strRouteID, routeID) && CimStringUtils.equals(strOperNo, operationNumber) ) {

                            strFutureActionFlagSeq.get(3).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                            break;
                        }
                    }
                }
            }

            String originalRouteID         = "";
            String originalOperationNumber = "";
            String subMainPDID             = "";
            String subOperationNumber      = "";

            if( CimStringUtils.equals(strRouteID, mainRouteID.getValue()) ) {
            } else if( CimStringUtils.equals(strRouteID, subOrigMainPDID) ) {
                originalRouteID         = originalMainPDID;
                originalOperationNumber = originalOpeNo;
            } else if( CimStringUtils.equals(strRouteID, branchMainPDID) ) {
                originalRouteID         = originalMainPDID;
                originalOperationNumber = originalOpeNo;
                subMainPDID             = subOrigMainPDID;
                subOperationNumber      = subOrigOpeNo;
            }

            if( CimBooleanUtils.isTrue(bPSM) ) {
                List<Infos.ExperimentalLotInfo> strExperimentalLotInfoList = strExperimentalLotListGetDROut;
                int psmLen = CimArrayUtils.getSize(strExperimentalLotInfoList);
                for( int psmCnt=0; psmCnt < psmLen; psmCnt++ ) {
                    Infos.ExperimentalLotInfo strExperimentalLotInfo = strExperimentalLotInfoList.get(psmCnt);
                    if( CimStringUtils.equals(strRouteID, mainRouteID.getValue()) ) {
                        if( CimStringUtils.equals(strRouteID, strExperimentalLotInfo.getSplitRouteID().getValue())
                                && CimStringUtils.equals(strOperNo, strExperimentalLotInfo.getSplitOperationNumber()) ) {

                            strFutureActionFlagSeq.get(4).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                            break;
                        }
                    } else if( CimStringUtils.equals(strRouteID, subOrigMainPDID) ) {
                        if( CimStringUtils.equals(strRouteID, strExperimentalLotInfo.getSplitRouteID().getValue())
                                && CimStringUtils.equals(strOperNo, strExperimentalLotInfo.getSplitOperationNumber())
                                && CimStringUtils.equals(originalRouteID, strExperimentalLotInfo.getOriginalRouteID().getValue())
                                && CimStringUtils.equals(originalOperationNumber, strExperimentalLotInfo.getOriginalOperationNumber()) ) {

                            strFutureActionFlagSeq.get(4).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                            break;
                        }
                    } else {
                        break;
                    }
                }
            }

            if( CimBooleanUtils.isTrue(bFPC) ) {
                List<Infos.FPCInfo> strFPCInfoList = strFPCListGetDROut;
                int fpcLen = CimArrayUtils.getSize(strFPCInfoList);
                for( int fpcCnt=0; fpcCnt < fpcLen; fpcCnt++ ) {
                    Infos.FPCInfo strFPCInfo = strFPCInfoList.get(fpcCnt);
                    if( CimStringUtils.equals(strRouteID, mainRouteID.getValue()) ) {
                        if( CimStringUtils.equals(strRouteID, strFPCInfo.getMainProcessDefinitionID().getValue())
                                && CimStringUtils.equals(strOperNo, strFPCInfo.getOperationNumber()) ) {

                            strFutureActionFlagSeq.get(5).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                            break;
                        }
                    } else if( CimStringUtils.equals(strRouteID, subOrigMainPDID) ) {
                        if( CimStringUtils.equals(strRouteID, strFPCInfo.getMainProcessDefinitionID().getValue())
                                && CimStringUtils.equals(strOperNo, strFPCInfo.getOperationNumber())
                                && CimStringUtils.equals(originalRouteID, strFPCInfo.getOriginalMainProcessDefinitionID().getValue())
                                && CimStringUtils.equals(originalOperationNumber, strFPCInfo.getOriginalOperationNumber()) ) {

                            strFutureActionFlagSeq.get(5).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                            break;
                        }
                    } else if( CimStringUtils.equals(strRouteID, branchMainPDID) ) {
                        if( CimStringUtils.equals(strRouteID, strFPCInfo.getMainProcessDefinitionID().getValue())
                                && CimStringUtils.equals(strOperNo, strFPCInfo.getOperationNumber())
                                && CimStringUtils.equals(originalRouteID, strFPCInfo.getOriginalMainProcessDefinitionID().getValue())
                                && CimStringUtils.equals(originalOperationNumber, strFPCInfo.getOriginalOperationNumber())
                                && CimStringUtils.equals(subMainPDID, strFPCInfo.getSubMainProcessDefinitionID().getValue())
                                && CimStringUtils.equals(subOperationNumber, strFPCInfo.getSubOperationNumber()) ) {

                            strFutureActionFlagSeq.get(5).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                            break;
                        }
                    }  else {
                        break;
                    }
                }
            }

            if( CimBooleanUtils.isTrue(bScript) ) {
                Infos.OperationNameAttributes operationNameAttribute = strOperationNameAttributes.get(n);
                Infos.ProcessRef processRef = operationNameAttribute.getProcessRef();
                Infos.ScriptInfo scriptInfo = processMethod.processScriptInfoGetDR(strObjCommonIn, operationNameAttribute.getRouteID(),
                        operationNameAttribute.getOperationID(), operationNameAttribute.getOperationNumber(),
                        processRef.getProcessOperationSpecification(), processRef.getModulePOS());

                if (!CimObjectUtils.isEmpty(scriptInfo) && (!ObjectIdentifier.isEmpty(scriptInfo.getPost()) || !ObjectIdentifier.isEmpty(scriptInfo.getPre1()) || !ObjectIdentifier.isEmpty(scriptInfo.getPre2()))) {
                    strFutureActionFlagSeq.get(6).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                }
            }

            if( CimBooleanUtils.isTrue(bPHold) ) {

                Infos.OperationNameAttributes operationNameAttributes = strOperationNameAttributes.get(n);
                if( !ObjectIdentifier.equalsWithValue(tmpRouteID, operationNameAttributes.getRouteID())) {
                    tmpRouteID = operationNameAttributes.getRouteID();

                    Infos.ProcessHoldSearchKey strProcessHoldSearchKey=new Infos.ProcessHoldSearchKey();
                    ObjectIdentifier reasonCodeID=null;

                    strProcessHoldSearchKey.setRouteID(tmpRouteID);

                    // step8 - processHold_holdList_GetDR
                    List<Infos.ProcHoldListAttributes> strProcessHoldHoldListGetDROut = null;
                    try {
                        strProcessHoldHoldListGetDROut = processMethod.processHoldHoldListGetDR(strObjCommonIn, strProcessHoldSearchKey, reasonCodeID, 0L, false, false);
                    }catch(ServiceException ex){
                        if (!Validations.isEquals(retCodeConfig.getNotFoundEntryW(),ex.getCode())){
                            throw ex;
                        }
                    }



                    tmpProcHoldListAttributes = strProcessHoldHoldListGetDROut;
                }

                int phLen = 0;
                phLen = CimArrayUtils.getSize(tmpProcHoldListAttributes);

                for( int phCnt = 0; phCnt < phLen; phCnt++ ) {
                    Infos.ProcHoldListAttributes tmpProcHoldListAttribute = tmpProcHoldListAttributes.get(phCnt);
                    if( ( CimStringUtils.equals( strRouteID, tmpProcHoldListAttribute.getRouteID().getValue())) &&
                            ( CimStringUtils.equals( strOperNo,  tmpProcHoldListAttribute.getOperationNumber())) ) {
                        if( !CimStringUtils.isEmpty( tmpProcHoldListAttribute.getProductID().getValue()) ) {

                            if( CimStringUtils.equals( productID.getValue(), tmpProcHoldListAttribute.getProductID().getValue()) ) {

                                strFutureActionFlagSeq.get(7).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                                break;
                            }
                        } else {

                            strFutureActionFlagSeq.get(7).setHashData(BizConstant.SP_HASHDATA_FLAG_1);
                            break;
                        }
                    }
                }
            }
            Infos.OperationFutureActionAttributes strOperationFutureActionAttribute=new Infos.OperationFutureActionAttributes();
            strOperationFutureActionAttributes.add(strOperationFutureActionAttribute);
            strOperationFutureActionAttribute.setRouteID(strOperationNameAttribute.getRouteID());
            strOperationFutureActionAttribute.setOperationID(strOperationNameAttribute.getOperationID());
            strOperationFutureActionAttribute.setOperationNumber(strOperationNameAttribute.getOperationNumber());
            strOperationFutureActionAttribute.setOperationName(strOperationNameAttribute.getOperationName());
            strOperationFutureActionAttribute.setMainPOS(strOperationNameAttribute.getProcessRef().getProcessOperationSpecification());
            strOperationFutureActionAttribute.setModulePOS(strOperationNameAttribute.getProcessRef().getModulePOS());
            strOperationFutureActionAttribute.setOriginalMainPDID(originalRouteID);
            strOperationFutureActionAttribute.setOriginalOpeNo(originalOperationNumber);
            strOperationFutureActionAttribute.setSubOrigMainPDID(subMainPDID);
            strOperationFutureActionAttribute.setSubOrigOpeNo(subOperationNumber);
            strOperationFutureActionAttribute.setStrFutureActionFlagSeq(strFutureActionFlagSeq);
        }

        return strOperationFutureActionAttributes;
    }

    private boolean haveFutureQTime(boolean isMaxQTime, String strMainPOS, String strModPOS, String strProdGroup,
                                    String strTechnology, ObjectIdentifier productID, boolean bSubRoute,
                                    String aPFXObjRef, String strRouteID, ObjectIdentifier currentRouteID,
                                    String strOperNo) {
        String hfrlotprodspecid = ObjectIdentifier.fetchValue(productID);

        // judge by Main
        String hfrposdthesystemkey = (strMainPOS == null ? null : strMainPOS.split("#")[0]);
        String sql;
        if (isMaxQTime) {
            sql = "SELECT refkey FROM OMPRSS_QT WHERE refkey=?1\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_QTPROD WHERE refkey=?1 AND PROD_ID = ?2\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_QTPRODFMLY WHERE refkey=?1 AND PRODFMLY_ID = ?3\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_QTTECH WHERE refkey=?1 AND TECH_ID = ?4";
        } else {
            sql = "SELECT refkey FROM OMPRSS_MINQT WHERE refkey=?1\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_MINQTPROD WHERE refkey=?1 AND PROD_ID = ?2\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_MINQTPRODFMLY WHERE refkey=?1 AND PRODFMLY_ID = ?3\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_MINQTTECH WHERE refkey=?1 AND TECH_ID = ?4";
        }
        List<Object> posObjs= cimJpaRepository.queryOneColumn(sql, hfrposdthesystemkey, hfrlotprodspecid,
                strProdGroup, strTechnology);
        if (CimArrayUtils.isNotEmpty(posObjs)) {
            return true;
        }

        // judge by Module
        hfrposdthesystemkey = (strModPOS == null ? null : strModPOS.split("#")[0]);
        if (isMaxQTime) {
            sql = "SELECT refkey FROM OMPRSS_QT WHERE refkey=?1\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_QTPROD WHERE refkey=?1 AND PROD_ID = ?2\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_QTPRODFMLY WHERE refkey=?1 AND PRODFMLY_ID = ?3\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_QTTECH WHERE refkey=?1 AND TECH_ID = ?4";
        } else {
            sql = "SELECT refkey FROM OMPRSS_MINQT WHERE refkey=?1\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_MINQTPROD WHERE refkey=?1 AND PROD_ID = ?2\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_MINQTPRODFMLY WHERE refkey=?1 AND PRODFMLY_ID = ?3\n" +
                    "UNION ALL\n" +
                    "SELECT refkey FROM OMPRSS_MINQTTECH WHERE refkey=?1 AND TECH_ID = ?4";
        }

        posObjs= cimJpaRepository.queryOneColumn(sql, hfrposdthesystemkey, hfrlotprodspecid,
                strProdGroup, strTechnology);
        if (CimArrayUtils.isNotEmpty(posObjs)) {
            return true;
        }

        if(CimBooleanUtils.isTrue(bSubRoute)) {
            CimProcessFlowContext aProcessFlowContext = baseCoreFactory.getBO(CimProcessFlowContext.class,
                    ObjectIdentifier.build(null, aPFXObjRef));
            if( aProcessFlowContext == null ) {
                throw new ServiceException(retCodeConfig.getNotFoundSystemObj());
            }

            List<ProcessDTO.BranchInfo> branchInfoSeq = aProcessFlowContext.allBranchInfos();
            List<ProcessDTO.ReturnInfo> returnInfoSeq = aProcessFlowContext.allReturnInfos();

            int branchInfoLen = CimArrayUtils.getSize(branchInfoSeq);
            int returnInfoLen = CimArrayUtils.getSize(returnInfoSeq);
            int routeMax = ( branchInfoLen <= returnInfoLen ) ? branchInfoLen : returnInfoLen;

            ProcessDTO.BranchInfo branchInfo = null;
            ProcessDTO.ReturnInfo returnInfo = null;

            if( CimStringUtils.equals(strRouteID, currentRouteID.getValue()) ) {
                if( routeMax > 0 ) {
                    branchInfo = branchInfoSeq.get(routeMax-1);
                    returnInfo = returnInfoSeq.get(routeMax - 1);
                }
            } else {
                for( int routeIdx = 0; routeIdx < routeMax; routeIdx++ ) {

                    if(ObjectIdentifier.equalsWithValue(strRouteID, branchInfoSeq.get(routeIdx).getRouteID())) {
                        if( routeIdx > 0 ) {
                            branchInfo = branchInfoSeq.get(routeIdx-1);
                            returnInfo = returnInfoSeq.get(routeIdx-1);
                        }
                        break;
                    }
                }
            }

            if( branchInfo != null && returnInfo != null ) {
                String branchOpeNoforMainPD;
                String returnOpeNoforMainPD;
                String branchModuleNo;
                String branchModuleOpeNo;
                String returnModuleOpeNo;

                ObjectIdentifier branchRouteIDforMainPD = branchInfo.getRouteID();

                if( CimStringUtils.isEmpty(branchInfo.getReworkOutKey()) ) {

                    branchOpeNoforMainPD = branchInfo.getOperationNumber();

                    branchModuleNo = BaseStaticMethod.convertOpeNoToModuleNo(branchOpeNoforMainPD);
                    branchModuleOpeNo = BaseStaticMethod.convertOpeNoToModuleOpeNo(branchOpeNoforMainPD);
                } else {
                    List<String> reworkOutKeys = BaseStaticMethod.splitStringIntoTokens(branchInfo.getReworkOutKey(),
                            "\\" + BizConstant.SP_KEY_SEPARATOR_DOT);
                    if( 4 != CimArrayUtils.getSize(reworkOutKeys) ) {
                        throw new ServiceException("4 != reworkOutKeys->length()");
                    }

                    branchModuleNo    = reworkOutKeys.get(2);
                    branchModuleOpeNo = reworkOutKeys.get(3);

                    List<String> tmpStrings = new ArrayList<>();
                    tmpStrings.add(branchModuleNo);
                    tmpStrings.add(branchModuleOpeNo);
                    branchOpeNoforMainPD = CimArrayUtils.mergeStringIntoTokens(tmpStrings,
                            BizConstant.SP_KEY_SEPARATOR_DOT );
                }

                returnOpeNoforMainPD = returnInfo.getOperationNumber();

                String returnModuleNo = BaseStaticMethod.convertOpeNoToModuleNo(returnOpeNoforMainPD);
                returnModuleOpeNo = BaseStaticMethod.convertOpeNoToModuleOpeNo(returnOpeNoforMainPD);

                String pfMainPdID = branchRouteIDforMainPD.getValue(),
                        pfPdLevel = BizConstant.SP_PD_FLOWLEVEL_MAIN_FOR_MODULE,
                        pfPdListModuleNo = branchModuleNo,
                        pfPdListPdID,
                        pfPdListPdObj;

                Integer pfState = 1;
                sql = "SELECT OMPRF_ROUTESEQ.*\n" +
                        "    FROM   OMPRF, OMPRF_ROUTESEQ\n" +
                        "    WHERE  OMPRF.PRP_ID        = ?1\n" +
                        "    AND  OMPRF.PRP_LEVEL         = ?2\n" +
                        "    AND  OMPRF.ACTIVE_FLAG            = ?3\n" +
                        "    AND  OMPRF.ID   = OMPRF_ROUTESEQ.REFKEY\n" +
                        "    AND  OMPRF_ROUTESEQ.ROUTE_NO = ?4";
                CimPFDefinitionListDO processFlowDefinitionList = cimJpaRepository.queryOne(sql,
                        CimPFDefinitionListDO.class, pfMainPdID, pfPdLevel, pfState, pfPdListModuleNo);
                if (processFlowDefinitionList == null){
                    throw new ServiceException(retCodeConfig.getNotFoundProcessDefinition());
                } else {
                    pfPdListPdID = processFlowDefinitionList.getProcessDefinitionID();
                    pfPdListPdObj = processFlowDefinitionList.getProcessDefinitionObj();
                }

                ObjectIdentifier branchRouteIDforModPD = ObjectIdentifier.build(pfPdListPdID, pfPdListPdObj);

                String branchOpeNoforModPD = branchModuleOpeNo;
                String returnOpeNoforModPD = returnModuleOpeNo;

                List<String> subRouteStrings = BaseStaticMethod.splitStringIntoTokens(strRouteID,
                        "\\" + BizConstant.SP_VERSION_SEPARATOR);
                if (CimArrayUtils.isEmpty(subRouteStrings)) {
                    return false;
                }

                subRouteStrings.set(subRouteStrings.size() - 1, BizConstant.SP_ACTIVE_VERSION);
                String hactiveSubRouteID = CimArrayUtils.mergeStringIntoTokens( subRouteStrings,
                        BizConstant.SP_VERSION_SEPARATOR );

                if( !CimStringUtils.isEmpty(branchInfo.getReworkOutKey()) ){
                    pfMainPdID = branchRouteIDforMainPD.getValue();
                    pfPdLevel = BizConstant.SP_PD_FLOWLEVEL_MAIN_FOR_OPERATION;
                    String hfrposTimerestrictSubbranchInfo = branchOpeNoforMainPD;

                    List<String> qrests = this.findAllPosObj(isMaxQTime, pfMainPdID, pfPdLevel, hfrlotprodspecid,
                            hfrposTimerestrictSubbranchInfo, strRouteID, hactiveSubRouteID,
                            strOperNo, strProdGroup, strTechnology);
                    if (CimArrayUtils.isNotEmpty(qrests)) {
                        return true;
                    }

                    pfMainPdID = branchRouteIDforModPD.getValue();
                    pfPdLevel = BizConstant.SP_PD_FLOWLEVEL_MODULE;
                    hfrposTimerestrictSubbranchInfo = branchOpeNoforModPD;

                    qrests= this.findAllPosObj(isMaxQTime, pfMainPdID, pfPdLevel, hfrlotprodspecid, hfrposTimerestrictSubbranchInfo,
                            strRouteID, hactiveSubRouteID, strOperNo, strProdGroup, strTechnology,
                            "AND PF.STATE = 1");

                    for (String qrest:qrests) {
                        CimPOSSubProcessFlowDO posSubProcessFlow = cimJpaRepository
                                .queryOne("SELECT  SUBPF.* \n" +
                                "\tFROM    OMPRF PF,\n" +
                                "\t\t\tOMPRSS POS,\n" +
                                "\t\t\tOMPRSS_SUBPRF SUBPF\n" +
                                "\tWHERE   PF.PRP_ID = ?1\n" +
                                "\tAND   PF.PRP_LEVEL = ?2\n" +
                                "\tAND   PF.ACTIVE_FLAG = 1\n" +
                                "\tAND   POS.PRF_RKEY = PF.ID\n" +
                                "\tAND   POS.OPE_NO = ?3\n" +
                                "\tAND   SUBPF.REFKEY = POS.ID",
                                        CimPOSSubProcessFlowDO.class, pfMainPdID, pfPdLevel, branchOpeNoforModPD);

                        if (posSubProcessFlow!=null){
                            String hfrposSubpfrtnOpeNo = posSubProcessFlow.getReturnOperationNumber();

                            if( CimStringUtils.equals(hfrposSubpfrtnOpeNo, returnOpeNoforModPD) ) {
                                return true;
                            }
                        }
                    }
                } else {
                    pfMainPdID = branchRouteIDforMainPD.getValue();
                    pfPdLevel = BizConstant.SP_PD_FLOWLEVEL_OPERATION;
                    String hfrposTimerestrictSubbranchInfo = branchOpeNoforMainPD;

                    List<String> qrests = this.findAllPosObjForRework(isMaxQTime, pfMainPdID, pfPdLevel,
                            hfrlotprodspecid, hfrposTimerestrictSubbranchInfo, strRouteID, hactiveSubRouteID,
                            strOperNo, strProdGroup, strTechnology);
                    if (CimArrayUtils.isNotEmpty(qrests)) {
                        return true;
                    }

                    pfMainPdID = branchRouteIDforModPD.getValue();
                    pfPdLevel = BizConstant.SP_PD_FLOWLEVEL_MODULE;
                    hfrposTimerestrictSubbranchInfo = branchOpeNoforModPD;

                    qrests= this.findAllPosObj(isMaxQTime, pfMainPdID, pfPdLevel, hfrlotprodspecid,
                            hfrposTimerestrictSubbranchInfo, strRouteID, hactiveSubRouteID, strOperNo,
                            strProdGroup, strTechnology, "AND PF.STATE = 1");
                    if (CimArrayUtils.isNotEmpty(qrests)) {
                        CimPOSSubProcessFlowDO posSubProcessFlow = cimJpaRepository
                                .queryOne("SELECT  RWKPF.* \n" +
                                "\tFROM    OMPRF PF,\n" +
                                "\t\t\tOMPRSS POS,\n" +
                                "\t\t\tOMPRSS_REWORKPRF RWKPF\n" +
                                "\tWHERE   PF.PRP_ID = ?1\n" +
                                "\tAND   PF.PRP_LEVEL = ?2\n" +
                                "\tAND   PF.ACTIVE_FLAG = 1\n" +
                                "\tAND   POS.PRF_RKEY = PF.ID\n" +
                                "\tAND   POS.OPE_NO = ?3\n" +
                                "\tAND   RWKPF.REFKEY = POS.ID",
                                        CimPOSSubProcessFlowDO.class, pfMainPdID, pfPdLevel, branchOpeNoforModPD);

                        if (posSubProcessFlow != null) {
                            String hfrposSubpfrtnOpeNo = posSubProcessFlow.getReturnOperationNumber();

                            return CimStringUtils.equals(hfrposSubpfrtnOpeNo, returnOpeNoforModPD);
                        }
                    }
                }
            }
        }
        return false;
    }

    private  List<String> findAllPosObj(boolean isMaxQTime, String pfMainPdID, String pfPdLevel,
                                        String hfrlotprodspecid, String hfrposTimerestrictSubbranchInfo,
                                        String frposTimerestrictSubsubRouteID, String hactiveSubRouteID,
                                        String hfrposTimerestrictSubtriggerOpeNo, String hfrposqrestpgrpprodgrpid,
                                        String hfrposqresttechtechid,
                                        String... state) {
        String sql = "SELECT  QREST.REFKEY\n" +
                "    FROM    OMPRF PF,\n" +
                "        OMPRSS POS,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTPROD" : "OMPRSS_MINQTPROD") + " QREST,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTPROD_SUBPRF" : "OMPRSS_MINQTPROD_SUBPRF") + " QREST_SUB\n" +
                "    WHERE   PF.PRP_ID = ?\n" +
                "    AND   PF.PRP_LEVEL = ?\n" +
                "    AND   PF.ACTIVE_FLAG = 1\n" +
                "    AND   POS.PRF_RKEY = PF.ID\n" +
                "    AND   QREST.REFKEY = POS.ID\n" +
                "    AND   QREST.PROD_ID = ?\n" +
                "    AND   QREST_SUB.REFKEY = QREST.REFKEY\n" +
                "    AND   QREST_SUB.LINK_MARKER = QREST.LINK_KEY\n" +
                "    AND   QREST_SUB.SUB_PROCESS_INFO = ?\n" +
                "    AND ( QREST_SUB.SUB_PROCESS_ID = ? OR QREST_SUB.SUB_PROCESS_ID = ? )\n" +
                "    AND   QREST_SUB.TRIGGER_OPE_NO = ?\n" +
                "    UNION ALL\n" +
                "    SELECT  QREST.REFKEY\n" +
                "    FROM    OMPRF PF,\n" +
                "        OMPRSS POS,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTPRODFMLY" : "OMPRSS_MINQTPRODFMLY") + " QREST,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTPRODFMLY_SUBPRF" : "OMPRSS_MINQTPRODFMLY_SUBPRF") + " QREST_SUB\n" +
                "    WHERE   PF.PRP_ID = ?\n" +
                "    AND   PF.PRP_LEVEL = ?\n" +
                "    AND   PF.ACTIVE_FLAG = 1\n" +
                "    AND   POS.PRF_RKEY = PF.ID\n" +
                "    AND   QREST.REFKEY = POS.ID\n" +
                "    AND   QREST.PRODFMLY_ID = ?\n" +
                "    AND   QREST_SUB.REFKEY = QREST.REFKEY\n" +
                "    AND   QREST_SUB.LINK_MARKER = QREST.LINK_KEY\n" +
                "    AND   QREST_SUB.SUB_PROCESS_INFO = ?\n" +
                "    AND ( QREST_SUB.SUB_PROCESS_ID = ? OR QREST_SUB.SUB_PROCESS_ID = ? )\n" +
                "    AND   QREST_SUB.TRIGGER_OPE_NO = ?\n" +
                "    UNION ALL\n" +
                "    SELECT  QREST.REFKEY\n" +
                "    FROM    OMPRF PF,\n" +
                "        OMPRSS POS,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTTECH" : "OMPRSS_MINQTTECH") + " QREST,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTTECH_SUBPRF" : "OMPRSS_MINQTTECH_SUBPRF") + " QREST_SUB\n" +
                "    WHERE   PF.PRP_ID = ?\n" +
                "    AND   PF.PRP_LEVEL = ?\n" +
                "    AND   PF.ACTIVE_FLAG = 1 \n" +
                "    AND   POS.PRF_RKEY = PF.ID\n" +
                "    AND   QREST.REFKEY = POS.ID\n" +
                "    AND   QREST.TECH_ID = ?\n" +
                "    AND   QREST_SUB.REFKEY = QREST.REFKEY\n" +
                "    AND   QREST_SUB.LINK_MARKER = QREST.LINK_KEY\n" +
                "    AND   QREST_SUB.SUB_PROCESS_INFO = ?\n" +
                "    AND ( QREST_SUB.SUB_PROCESS_ID = ? OR QREST_SUB.SUB_PROCESS_ID = ? )\n" +
                "    AND   QREST_SUB.TRIGGER_OPE_NO = ?\n" +
                "    UNION ALL\n" +
                "    SELECT  QREST.REFKEY\n" +
                "    FROM    OMPRF PF,\n" +
                "        OMPRSS POS,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QT" : "OMPRSS_MINQT") + " QREST,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QT_SUBPRF" : "OMPRSS_MINQT_SUBPRF") + " QREST_SUB\n" +
                "    WHERE   PF.PRP_ID = ?\n" +
                "    AND   PF.PRP_LEVEL = ?\n" +
                "    AND   PF.ACTIVE_FLAG = 1\n" +
                "    AND   POS.PRF_RKEY = PF.ID\n" +
                "    AND   QREST.REFKEY = POS.ID\n" +
                "    AND   QREST_SUB.REFKEY = QREST.REFKEY\n" +
                "    AND   QREST_SUB.LINK_MARKER = QREST.LINK_KEY\n" +
                "    AND   QREST_SUB.SUB_PROCESS_INFO = ?\n" +
                "    AND ( QREST_SUB.SUB_PROCESS_ID = ? OR QREST_SUB.SUB_PROCESS_ID = ? )\n" +
                "    AND   QREST_SUB.TRIGGER_OPE_NO = ?";

        if(state.length == 0) {
            sql = String.format(sql, " ");
        } else {
            sql = String.format(sql, state[0]);
        }

        List<Object[]> ids = cimJpaRepository.query(sql, pfMainPdID, pfPdLevel, hfrlotprodspecid,
                hfrposTimerestrictSubbranchInfo,
                frposTimerestrictSubsubRouteID, hactiveSubRouteID, hfrposTimerestrictSubtriggerOpeNo,
                pfMainPdID, pfPdLevel, hfrposqrestpgrpprodgrpid, hfrposTimerestrictSubbranchInfo,
                frposTimerestrictSubsubRouteID, hactiveSubRouteID, hfrposTimerestrictSubtriggerOpeNo, pfMainPdID,
                pfPdLevel, hfrposqresttechtechid, hfrposTimerestrictSubbranchInfo, frposTimerestrictSubsubRouteID,
                hactiveSubRouteID, hfrposTimerestrictSubtriggerOpeNo, pfMainPdID, pfPdLevel,
                hfrposTimerestrictSubbranchInfo, frposTimerestrictSubsubRouteID, hactiveSubRouteID,
                hfrposTimerestrictSubtriggerOpeNo);
        List<String> objs = new ArrayList<>();

        for (Object[] id : ids) {
            objs.add((String) id[0]);
        }

        return objs;
    }


    private  List<String> findAllPosObjForRework(boolean isMaxQTime, String pfMainPdID, String pfPdLevel,
                                                 String hfrlotprodspecid, String hfrposTimerestrictSubbranchInfo,
                                                 String frposTimerestrictSubsubRouteID, String hactiveSubRouteID,
                                                 String hfrposTimerestrictSubtriggerOpeNo,
                                                 String hfrposqrestpgrpprodgrpid, String hfrposqresttechtechid,
                                                 String... state) {
        String sql = "SELECT  QREST.REFKEY\n" +
                "    FROM    OMPRF PF,\n" +
                "        OMPRSS POS,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTPROD" : "OMPRSS_MINQTPROD") + " QREST,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTPROD_REWORK" : "OMPRSS_MINQTPROD_REWORK") + " QREST_RWK\n" +
                "    WHERE   PF.PRP_ID = ?\n" +
                "    AND   PF.PRP_LEVEL = ?\n" +
                "    AND   PF.ACTIVE_FLAG = 1\n" +
                "    AND   POS.PRF_RKEY = PF.ID\n" +
                "    AND   QREST.REFKEY = POS.ID\n" +
                "    AND   QREST.PROD_ID = ?\n" +
                "    AND   QREST_RWK.REFKEY = QREST.REFKEY\n" +
                "    AND   QREST_RWK.LINK_MARKER = QREST.LINK_KEY\n" +
                "    AND   QREST_RWK.SUB_PROCESS_INFO = ?\n" +
                "    AND ( QREST_RWK.SUB_PROCESS_ID = ? OR QREST_RWK.SUB_PROCESS_ID = ? )\n" +
                "    AND   QREST_RWK.TRIGGER_OPE_NO = ?\n" +
                "    UNION ALL\n" +
                "    SELECT  QREST.REFKEY\n" +
                "    FROM    OMPRF PF,\n" +
                "        OMPRSS POS,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTPRODFMLY" : "OMPRSS_MINQTPRODFMLY") + " QREST,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTPRODFMLY_REWORK" : "OMPRSS_MINQTPRODFMLY_REWORK") + " QREST_RWK\n" +
                "    WHERE   PF.PRP_ID = ?\n" +
                "    AND   PF.PRP_LEVEL = ?\n" +
                "    AND   PF.ACTIVE_FLAG = 1\n" +
                "    AND   POS.PRF_RKEY = PF.ID\n" +
                "    AND   QREST.REFKEY = POS.ID\n" +
                "    AND   QREST.PRODFMLY_ID = ?\n" +
                "    AND   QREST_RWK.REFKEY = QREST.REFKEY\n" +
                "    AND   QREST_RWK.LINK_MARKER = QREST.LINK_KEY\n" +
                "    AND   QREST_RWK.SUB_PROCESS_INFO = ?\n" +
                "    AND ( QREST_RWK.SUB_PROCESS_ID = ? OR QREST_RWK.SUB_PROCESS_ID = ? )\n" +
                "    AND   QREST_RWK.TRIGGER_OPE_NO = ?\n" +
                "    UNION ALL\n" +
                "    SELECT  QREST.REFKEY\n" +
                "    FROM    OMPRF PF,\n" +
                "        OMPRSS POS,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTTECH" : "OMPRSS_MINQTTECH") + " QREST,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QTTECH_REWORK" : "OMPRSS_MINQTTECH_REWORK") + " QREST_RWK\n" +
                "    WHERE   PF.PRP_ID = ?\n" +
                "    AND   PF.PRP_LEVEL = ?\n" +
                "    AND   PF.ACTIVE_FLAG = 1\n" +
                "    AND   POS.PRF_RKEY = PF.ID\n" +
                "    AND   QREST.REFKEY = POS.ID\n" +
                "    AND   QREST.TECH_ID = ?\n" +
                "    AND   QREST_RWK.REFKEY = QREST.REFKEY\n" +
                "    AND   QREST_RWK.LINK_MARKER = QREST.LINK_KEY\n" +
                "    AND   QREST_RWK.SUB_PROCESS_INFO = ?\n" +
                "    AND ( QREST_RWK.SUB_PROCESS_ID = ? OR QREST_RWK.SUB_PROCESS_ID = ? )\n" +
                "    AND   QREST_RWK.TRIGGER_OPE_NO = ?\n" +
                "    UNION ALL\n" +
                "    SELECT  QREST.REFKEY\n" +
                "    FROM    OMPRF PF,\n" +
                "        OMPRSS POS,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QT" : "OMPRSS_MINQT") + " QREST,\n" +
                "        " + (isMaxQTime ? "OMPRSS_QT_REWORK" : "OMPRSS_MINQT_REWORK") + " QREST_RWK\n" +
                "    WHERE   PF.PRP_ID = ?\n" +
                "    AND   PF.PRP_LEVEL = ?\n" +
                "    AND   PF.ACTIVE_FLAG = 1\n" +
                "    AND   POS.PRF_RKEY = PF.ID\n" +
                "    AND   QREST.REFKEY = POS.ID\n" +
                "    AND   QREST_RWK.REFKEY = QREST.REFKEY\n" +
                "    AND   QREST_RWK.LINK_MARKER = QREST.LINK_KEY\n" +
                "    AND   QREST_RWK.SUB_PROCESS_INFO = ?\n" +
                "    AND ( QREST_RWK.SUB_PROCESS_ID = ? OR QREST_RWK.SUB_PROCESS_ID = ? )\n" +
                "    AND   QREST_RWK.TRIGGER_OPE_NO = ?";

        sql = String.format(sql, state);

        List<Object[]> ids = cimJpaRepository.query(sql, pfMainPdID, pfPdLevel, hfrlotprodspecid,
                hfrposTimerestrictSubbranchInfo,
                frposTimerestrictSubsubRouteID, hactiveSubRouteID, hfrposTimerestrictSubtriggerOpeNo,
                pfMainPdID, pfPdLevel, hfrposqrestpgrpprodgrpid, hfrposTimerestrictSubbranchInfo,
                frposTimerestrictSubsubRouteID, hactiveSubRouteID, hfrposTimerestrictSubtriggerOpeNo, pfMainPdID,
                pfPdLevel, hfrposqresttechtechid, hfrposTimerestrictSubbranchInfo, frposTimerestrictSubsubRouteID,
                hactiveSubRouteID, hfrposTimerestrictSubtriggerOpeNo, pfMainPdID, pfPdLevel,
                hfrposTimerestrictSubbranchInfo, frposTimerestrictSubsubRouteID, hactiveSubRouteID, hfrposTimerestrictSubtriggerOpeNo);
        List<String> objs = new ArrayList<>();

        for (Object[] id : ids) {
            objs.add((String) id[0]);
        }

        return objs;
    }
    @Override
    public void lotFutureHoldRequestsCheckLocate(Infos.ObjCommon objCommon, Boolean locateDirection, ObjectIdentifier lotID, Infos.ProcessRef processRef) {
        log.debug("!locateDirection : {}",!locateDirection);
        if (!locateDirection) {
            return ;
        } else {
            CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
            Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
            String aTmpString = processRef.getProcessFlow();
            com.fa.cim.newcore.bo.pd.CimProcessFlow aTargetProcessFlow = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessFlow.class, aTmpString);
            Validations.check(null == aTargetProcessFlow, new OmCode(retCodeConfig.getNotFoundProcessFlow(), lotID.getValue()));
            aTmpString = processRef.getModulePOS();
            com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aTargetProcessOperationSpecification = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification.class, aTmpString);
            Validations.check(null == aTargetProcessOperationSpecification, new OmCode(retCodeConfig.getNotFoundMainRoute()));
            ProcessDefinition targetMainPD = aTargetProcessFlow.getRootProcessDefinition();
            Validations.check(null == targetMainPD, new OmCode(retCodeConfig.getNotFoundPos(), lotID.getValue()));
            String targetMainPDId = targetMainPD.getIdentifier();
            String targetModuleOpeNo = aTargetProcessOperationSpecification.getOperationNumber();
            String targetOpeNo = null;
            log.debug("!StringUtils.isEmpty(processRef.getModuleNumber()) && !StringUtils.isEmpty(targetModuleOpeNo) : {}",!CimStringUtils.isEmpty(processRef.getModuleNumber()) && !CimStringUtils.isEmpty(targetModuleOpeNo));
            if (!CimStringUtils.isEmpty(processRef.getModuleNumber()) && !CimStringUtils.isEmpty(targetModuleOpeNo)){
                targetOpeNo = processRef.getModuleNumber() + BizConstant.SP_POSPROCESSOPERATIONSPECIFICATION_SEPARATOR_CHAR + targetModuleOpeNo;
            }
            com.fa.cim.newcore.bo.pd.CimProcessFlowContext aFlowContext = aLot.getProcessFlowContext();
            Validations.check(null == aFlowContext, new OmCode(retCodeConfig.getNotFoundPfx(), ""));
            com.fa.cim.newcore.bo.pd.CimProcessDefinition aMainPD = aLot.getMainProcessDefinition();
            Validations.check(null == aMainPD, new OmCode(retCodeConfig.getMsgNotFoundPd(), ""));
            com.fa.cim.newcore.bo.pd.CimProcessOperation aPosPO = aLot.getProcessOperation();
            Validations.check(null == aPosPO, new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****", lotID.getValue()));
            String currentOperationNumber = aPosPO.getOperationNumber();
            List<ProductDTO.FutureHoldRecord> aFutureHoldRecordSequence = aLot.findFutureHoldRecordsFor(aMainPD, currentOperationNumber);
            for (ProductDTO.FutureHoldRecord lotFutureHold : aFutureHoldRecordSequence) {
                Validations.check(CimBooleanUtils.isTrue(lotFutureHold.isPostFlag()),
                        new OmCode(retCodeConfig.getNotFutureholdInLocate(), lotFutureHold.getMainProcessDefinition().getValue(), lotFutureHold.getOperationNumber()));
            }
            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainPF = new AtomicReference<>();
            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outModulePF = new AtomicReference<>();
            AtomicReference<String> outModuleNo = new AtomicReference<>();
            com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aModulePOS = aFlowContext.getNextProcessOperationSpecification(outMainPF, outModuleNo, outModulePF);
            String mainPDID = aMainPD.getIdentifier();
            Infos.FutureHoldSearchKey futureHoldSearchKey = new Infos.FutureHoldSearchKey();
            futureHoldSearchKey.setLotID(lotID);
            futureHoldSearchKey.setRouteID(new ObjectIdentifier(mainPDID));
            List<Infos.FutureHoldListAttributes> aTmpFutureHoldList = null;
            try{
                aTmpFutureHoldList = this.lotFutureHoldListbyKeyDR(objCommon, futureHoldSearchKey, 0);
            }catch (ServiceException e) {
                if (!Validations.isEquals(retCodeConfig.getNotFoundFtholdEntW(), e.getCode())) {
                    throw e;
                } else {
                    aTmpFutureHoldList = e.getData(List.class);
                }
            }
            int futureHoldLen = CimArrayUtils.getSize(aTmpFutureHoldList);
            int inseqno = 0;
            AtomicReference<Integer> outseqno = new AtomicReference<>(0);
            com.fa.cim.newcore.bo.pd.CimProcessFlow mainPF = outMainPF.get();
            com.fa.cim.newcore.bo.pd.CimProcessFlow modulePF = outModulePF.get();
            String moduleNo = outModuleNo.get();
            while (true) {
                if (null == aModulePOS) {
                    break;
                }
                Validations.check(null == mainPF, new OmCode(retCodeConfig.getNotFoundProcessFlow(), ""));
                ProcessDefinition outMainPD = mainPF.getRootProcessDefinition();
                Validations.check(null == outMainPD, new OmCode(retCodeConfig.getMsgNotFoundPd(), ""));
                com.fa.cim.newcore.bo.pd.CimProcessDefinition aMainProcessDefinition = (com.fa.cim.newcore.bo.pd.CimProcessDefinition) outMainPD;
                String outMainPDId = outMainPD.getIdentifier();
                String outOpeNo = null;
                String outModuleOpeNo = aModulePOS.getOperationNumber();
                if(!CimStringUtils.isEmpty(moduleNo) && !CimStringUtils.isEmpty(outModuleOpeNo)){
                    outOpeNo = moduleNo + "." + outModuleOpeNo;
                }
                if (outMainPDId.equals(targetMainPDId) && CimStringUtils.equals(outOpeNo,targetOpeNo)) {
                    break;
                }
                String nextMainPDID = aMainProcessDefinition.getIdentifier();
                if (!CimStringUtils.equals(mainPDID, nextMainPDID)) {
                    mainPDID = nextMainPDID;
                    Infos.FutureHoldSearchKey futureHoldSearchKey1 = new Infos.FutureHoldSearchKey();
                    futureHoldSearchKey1.setLotID(lotID);
                    futureHoldSearchKey1.setRouteID(new ObjectIdentifier(mainPDID));
                    try {
                        aTmpFutureHoldList = lotFutureHoldListbyKeyDR(objCommon, futureHoldSearchKey1, 0);
                    }catch (ServiceException e) {
                        if (!Validations.isEquals(retCodeConfig.getNotFoundFtholdEntW(), e.getCode())) {
                            throw e;
                        } else {
                            aTmpFutureHoldList = e.getData(List.class);
                        }
                    }
                }
                for (Infos.FutureHoldListAttributes attributes : aTmpFutureHoldList) {
                    Validations.check(CimStringUtils.equals(attributes.getOperationNumber(), outOpeNo),
                            new OmCode(retCodeConfig.getNotFutureholdInLocate(), mainPDID, outOpeNo));
                }
                //RetCode<Outputs.ProcessOperationSpecificationForOut> out3 = cimProcessFlowContext.getNextProcessOperationSpecificationForOld(aFlowContext, mainPF, moduleNo, modulePF, aModulePOS, inSeqNo);
                AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainPFInner = new AtomicReference<>();
                AtomicReference<String> outModuleNoInner = new AtomicReference<>();
                AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outModulePFInner = new AtomicReference<>();
                inseqno = outseqno.get();
                aModulePOS = aFlowContext.getNextProcessOperationSpecificationFor(mainPF, moduleNo, modulePF, aModulePOS,
                        outMainPFInner, outModuleNoInner, outModulePFInner, inseqno, outseqno);
                mainPF = outMainPFInner.get();
                moduleNo = outModuleNoInner.get();
                modulePF = outModulePFInner.get();
            }
        }
    }


    /**
     * description:
     * check for STBCancelled lot
     * 1) Source lot Type
     * 2) lot Hold
     * 3) Future Hold
     * 4) lot inventory state
     * 5) lot state
     * 6) lot process state
     * 7) monitor group existance
     * 8) postProcess Flag
     * 9) lot family's lot state
     * 10) next prodReq existance
     * 11) flowBatch
     * 12) check for stb cancelled wafers
     * 1> scrap wafer check
     * 2> check PSM registration
     * 3> check lot DOC registration
     * 13) check for cassette
     * 1> check if lot is in a cassette
     * 2> check for transferState
     * 3> check available condition of cassette
     * 4> check carrier has controlJob or not
     * 5> check sortjob of cassette
     * 6> check postProcessFlag of cassette
     * 7> check dispatch reservation condition of cassette
     * 8> check SLMReserveEquipment of cassette
     * 14) other checks
     * 1> check request type for generating lot
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param objCommon
     * @param checkIn   -
     * @return com.fa.cim.dto.other.RetCode
     * @author Bear
     * @date 2018/6/12
     */
    @Override
    public void lotSTBCancelCheck(Infos.ObjCommon objCommon, Inputs.ObjLotSTBCancelCheckIn checkIn) {

        // input parameter
        int nLen = CimArrayUtils.isEmpty(checkIn.getStbCancelInfoList()) ? 0 : checkIn.getStbCancelInfoList().size();
        if (0 == nLen) {
            log.info("[error]the size of STBCancelInfoList is 0...");
            throw new ServiceException(retCodeConfig.getInvalidInputParam());
        }

        ObjectIdentifier stbCancelledLotID = checkIn.getStbCancelledLotID();
        ObjectIdentifier startBankID = checkIn.getStartBankID();
        ObjectIdentifier cassetteID = checkIn.getStbCancelInfoList().get(0).getNewLotAttributes().getCassetteID();

        log.info("check lot process state...");
        CimLot lot = baseCoreFactory.getBO(CimLot.class, stbCancelledLotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(stbCancelledLotID)));
        //【step1】check source lot type
        log.info("【step1】check source lot type...");
        switch (lot.getLotType()) {
            case "Production":
            case "Engineering":
            case "Process Monitor":
            case "Auto Monitor":
            case "Dummy":
            case "Recycle":
                break;
            default:
                log.info(String.format("lot State is '%s'", lot.getLotType()));
                throw new ServiceException(retCodeConfig.getInvalidLotType());
        }

        //【step2】check lot hold
        log.info("【step2】check lot hold...");
        if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, lot.getLotHoldState())) {
            List<ProductDTO.HoldRecord> holdRecordList = lot.allHoldRecords();
            if (CimArrayUtils.isEmpty(holdRecordList)) {
                log.info("Not found hold record...");
            } else {
                for (ProductDTO.HoldRecord holdRecord : holdRecordList) {
                    String holdType = holdRecord.getHoldType();
                    String reasonCodeID = ObjectIdentifier.fetchValue(holdRecord.getReasonCode());
                    log.info(String.format("this holdType is '%s'", holdType));
                    log.info(String.format("this reasonCodeID is '%s'", reasonCodeID));
                    if (CimStringUtils.equals(BizConstant.SP_HOLDTYPE_LOTHOLD, holdType) && CimStringUtils.equals(BizConstant.SP_REASON_STBCANCELHOLD, reasonCodeID)) {
                        log.info("holdReason is 'STBC'. continue...");
                        continue;
                    } else {
                        //throw new ServiceException(retCodeConfig.getLotHoldForHoldType());
                        throw new ServiceException(new OmCode(retCodeConfig.getLotHoldForHoldType(), stbCancelledLotID.getValue(), holdType));
                    }
                }
            }
        }

        //【step3】check future hold - lot_STBCancel_Check.cpp:220 - 262
        log.info("【step3】check future hold");
        List<ProductDTO.FutureHoldRecord> futureHoldRecordList = lot.allFutureHoldRecords();
        for (int i = 0; i < CimArrayUtils.getSize(futureHoldRecordList); i++) {
            ProductDTO.FutureHoldRecord futureHoldRecord = futureHoldRecordList.get(i);
            Validations.check(!CimStringUtils.equals(BizConstant.SP_HOLDTYPE_FUTUREHOLD, futureHoldRecord.getHoldType()), new OmCode(retCodeConfig.getLotHoldForHoldType(), ObjectIdentifier.fetchValue(stbCancelledLotID), futureHoldRecord.getHoldType()));
        }

        //【step4】check lot inventory state
        log.info("【step4】check lot inventory state");
        if (!CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR, lot.getLotInventoryState())) {
            log.info(String.format("inventoryState != SP_Lot_InventoryState_OnFloor, The inventoryState is '%s'", lot.getLotInventoryState()));
            Validations.check(retCodeConfig.getInvalidLotInventoryStat(), ObjectIdentifier.fetchValue(stbCancelledLotID),
                    lot.getLotInventoryState());
        }

        //【step5】check lot state
        log.info("【step5】check lot state");
        if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_ACTIVE, lot.getLotState())) {
            log.info("lotState != CIMFW_Lot_State_Active");
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotStat(), lot.getLotState()));
        }

        //【step6】check lot process state
        log.info("step6】check lot process state");
        if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING, lot.getLotProcessState())) {
            log.info("lotState == SP_Lot_ProcState_Processing");
            throw new ServiceException(retCodeConfig.getLotStatusProcessing());
        }

        //【step7】check monitor group existence
        log.info("check monitor group existence");
        List<Infos.MonitorGroups> monitorGroupInfo = monitorGroupMethod.monitorGroupGetDR(objCommon, stbCancelledLotID);
        int monGroupSize = CimArrayUtils.getSize(monitorGroupInfo);
        log.info(String.format("monitor group size:%d", monGroupSize));
        if (monGroupSize > 0) {
            log.info("monGroupSize > 0");
            throw new ServiceException(new OmCode(retCodeConfig.getAlreadyExistMonitorGroup(), stbCancelledLotID.getValue()));
        }

        //【step8】check postProcess Flag
        log.info("【step8】check postProcess Flag");
        if (CimBooleanUtils.isTrue(lot.isPostProcessFlagOn())) {
            log.info("TRUE == lot::lostProcFlag");
            throw new ServiceException(new OmCode(retCodeConfig.getLotInPostProcess(), ObjectIdentifier.fetchValue(stbCancelledLotID)));
        }

        //【step9】check lot family's lot state if STBCancelled lot is original lot
        log.info("【step9】check lot family's lot state if STBCancelled lot is original lot...");
        log.info("check lot family...");
        CimLotFamily lotFamily = lot.getLotFamily();
        if (null == lotFamily) {
            log.info("null == lotFamily");
            throw new ServiceException(retCodeConfig.getNotFoundLotFamily());
        }
        String originalLotID = lotFamily.getIdentifier();
        log.info(String.format("original lot ID is '%s'", originalLotID));
        CimLot originalLot = (CimLot) lotFamily.originalLot();
        if (null == originalLot) {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundLot(), "*****"));
        }

        if (ObjectIdentifier.equalsWithValue(originalLotID, stbCancelledLotID)) {
            log.info("strSTBCancelledLotID == OrgLotID");
            List<Lot> currentLotList = lotFamily.currentLots();
            List<Lot> archiveList = lotFamily.archive();
            int currentLotSize = CimArrayUtils.isEmpty(currentLotList) ? 0 : currentLotList.size();
            int archiveSize = CimArrayUtils.isEmpty(archiveList) ? 0 : archiveList.size();
            for (int j = 0; j < currentLotSize; j++) {
                String familyLotIDStr = currentLotList.get(j).getIdentifier();
                if (!CimStringUtils.equals(originalLotID, familyLotIDStr)) {
                    log.info("[error] the original lot ID != lot Family ID");
                    throw new ServiceException(retCodeConfig.getChildLotNotEmptied());
                }
            }
            for (int j = 0; j < archiveSize; j++) {
                Boolean bEmptiedFlag = archiveList.get(j).isEmptied();
                Validations.check(CimBooleanUtils.isFalse(bEmptiedFlag), retCodeConfig.getChildLotNotEmptied());
            }
        }// end if (originalLotID.equals(stbCancelledLotID) {}


        //【step10】check if STB cancelled lot is scheduled for next lot by product request
        log.info("【step10】check if STB cancelled lot is suchedulled for next lot by product request");
        ObjectIdentifier out = null;
        try{
            out = this.sourceLotProductRequestGetDR(objCommon, stbCancelledLotID);
            Validations.check(ObjectIdentifier.isNotEmptyWithValue(out), new OmCode(retCodeConfig.getExistProductRequest(), ""));
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getNotFoundProductRequestForSourceLot(), e.getCode())) {
                throw e;
            }
        }

        //【step11】check lot flowbatch
        log.info("【step11】check lot flowbatch");
        com.fa.cim.newcore.bo.dispatch.CimFlowBatch flowBatch = lot.getFlowBatch();
        if (null != flowBatch) {
            log.info("flowbatch isn't null...");
            throw new ServiceException(new OmCode(retCodeConfig.getLotRegisteredToFlowBatch(), ObjectIdentifier.fetchValue(stbCancelledLotID)));
        }

        // STB Cancelled lot check end
        log.info("STB Cancelled lot check end");
        log.info("this lot's condition is good for STB Cancel!!!");

        //【step12】check for STB cancelled wafers
        log.info("【step12】check for STB cancelled wafers");
        //  get lot's wafer ID
        log.info("get lot's ID...");
        Inputs.ObjLotWafersGetIn in = new Inputs.ObjLotWafersGetIn(stbCancelledLotID, false);
        List<Infos.LotWaferAttributes>  lotWafersGetOut = this.lotWafersGetDR(objCommon, in);

        int lotWaferSize = CimArrayUtils.getSize(lotWafersGetOut);
        log.info(String.format("lot wafer size:%d", lotWaferSize));
        List<ObjectIdentifier> lotWaferIDList = new ArrayList<>();
        for (int i = 0; i < lotWaferSize; i++) {
            ObjectIdentifier waferID = lotWafersGetOut.get(i).getWaferID();
            lotWaferIDList.add(waferID);

            //【step12-1】check if wafer isn't scrap
            log.info("【step12-1】check if wafer isn't scrap");
            CimWafer wafer = baseCoreFactory.getBO(CimWafer.class, waferID);
            if (null == wafer) {
                throw new ServiceException(new OmCode(retCodeConfig.getNotFoundWafer(), ObjectIdentifier.fetchValue(waferID)));
            }

            Validations.check(CimBooleanUtils.isTrue(wafer.isScrap()), new OmCode(retCodeConfig.getLotInPostProcess(), ObjectIdentifier.fetchValue(waferID)));
        }
        // 【step12-2】check psm lot registration - lot_STBCancel_Check.cpp: 622 - 691
        log.info("【step12-2】check psm lot registration - lot_STBCancel_Check.cpp: 622 - 691");
        log.info("Get MainPD(mainRouteID) by sourceLotID,{},{}",objCommon, stbCancelledLotID);
        /*--------------------------------------------*/
        /*   2. Check experimental lot registration   */
        /*--------------------------------------------*/
        // Get MainPD(mainRouteID) by lotID
        ObjectIdentifier mainRouteID = this.lotMainRouteIDGet(objCommon, stbCancelledLotID);
        log.info("mainRouteID,{}", mainRouteID.getValue());

        //Get PSM definition
        log.info("Get PSM definition. call experimental_lotList_GetDR()");
        List<Infos.ExperimentalLotInfo> experimentalLotListGetDRRetCode = experimentalMethod.experimentalLotListGetDR(objCommon, lotFamily.getIdentifier(), "", "", mainRouteID.getValue(), "", true, true);

        // Check if STB cancelled wafer is not registered in PSM
        log.info("Check if STB cancelled wafer is not registered in PSM");
        int lenPSM = CimArrayUtils.getSize(experimentalLotListGetDRRetCode);
        log.info("lenPSM:{}",lenPSM);
        int psmDetailLen = 0;
        if (0 < lenPSM){
            log.info("0 < lenPSM");
            for (int i = 0; i < lenPSM; i++) {
                log.info("Round i,{}",i);
                psmDetailLen = CimArrayUtils.getSize(experimentalLotListGetDRRetCode.get(i).getStrExperimentalLotDetailInfoSeq());
                log.info("PSMdetailLen,{}",psmDetailLen);
                for (int j = 0; j < psmDetailLen; j++) {
                    log.info("Round j,{}",j);
                    List<ObjectIdentifier> psmWaferIds = new ArrayList<>();
                    psmWaferIds = experimentalLotListGetDRRetCode.get(i).getStrExperimentalLotDetailInfoSeq().get(j).getWaferIDs();
                    log.info("PSMWaferLen,{}",psmDetailLen);
                    int psmWaferLen = CimArrayUtils.getSize(psmWaferIds);
                    for (int k = 0; k < psmWaferLen; k++) {
                        for (int l = 0; l < lotWaferSize; l++) {
                            if (ObjectIdentifier.equalsWithValue(psmWaferIds.get(k), lotWaferIDList.get(l))){
                                log.info("PSMWaferID == lotWaferID,{}",lotWaferIDList.get(l).getValue());
                                throw new ServiceException(new OmCode(retCodeConfig.getWaferPsmReserved(),lotWaferIDList.get(l).getValue()));
                            }
                        }
                    }
                }
            }
        }

        //Get FSM definition
        log.info("Get PSM definition. call experimental_lotList_GetDR()");
        List<com.fa.cim.fsm.Infos.ExperimentalFutureLotInfo> experimentalFutureLotInfos = experimentalForFutureMethod.experimentalFutureLotListGetDR(objCommon, lotFamily.getIdentifier(), "", "", mainRouteID.getValue(), "", true, true);
        // Check if STB cancelled wafer is not registered in FSM
        log.info("Check if STB cancelled wafer is not registered in PSM");
        int lenFSM = CimArrayUtils.getSize(experimentalFutureLotInfos);
        log.info("lenPSM:{}",lenFSM);
        int fsmDetailLen = 0;
        if (0 < lenPSM){
            log.info("0 < lenFSM");
            for (int i = 0; i < lenPSM; i++) {
                log.info("Round i,{}",i);
                fsmDetailLen = CimArrayUtils.getSize(experimentalLotListGetDRRetCode.get(i).getStrExperimentalLotDetailInfoSeq());
                log.info("FSMdetailLen,{}",fsmDetailLen);
                for (int j = 0; j < fsmDetailLen; j++) {
                    log.info("Round j,{}",j);
                    List<ObjectIdentifier> fsmWaferIds = new ArrayList<>();
                    fsmWaferIds = experimentalLotListGetDRRetCode.get(i).getStrExperimentalLotDetailInfoSeq().get(j).getWaferIDs();
                    log.info("PSMWaferLen,{}",fsmDetailLen);
                    int fsmWaferLen = CimArrayUtils.getSize(fsmWaferIds);
                    for (int k = 0; k < fsmWaferLen; k++) {
                        for (int l = 0; l < lotWaferSize; l++) {
                            if (ObjectIdentifier.equalsWithValue(fsmWaferIds.get(k), lotWaferIDList.get(l))){
                                log.info("PSMWaferID == lotWaferID,{}",lotWaferIDList.get(l).getValue());
                                throw new ServiceException(new OmCode(retCodeConfigEx.getFsmWaferReserved(),lotWaferIDList.get(l).getValue()));
                            }
                        }
                    }
                }
            }
        }
        //【step12-3】check lot DOC registration -  lot_STBCancel_Check.cpp: 695 - 758
        log.info("todo - 【step12-3】check lot DOC registration -  lot_STBCancel_Check.cpp: 695 - 758");
        //【step12-3】check lot DOC registration
        log.info("【step12-3】check lot DOC registration");
        Inputs.ObjFPCListGetDRIn objFPCListGetDRIn = new Inputs.ObjFPCListGetDRIn();
        objFPCListGetDRIn.setFpcIDs(null);
        objFPCListGetDRIn.setLotID(stbCancelledLotID);
        objFPCListGetDRIn.setLotFamilyID(null);
        objFPCListGetDRIn.setMainPDID(null);
        objFPCListGetDRIn.setMainOperNo("");
        objFPCListGetDRIn.setOrgMainPDID(null);
        objFPCListGetDRIn.setOrgOperNo("");
        objFPCListGetDRIn.setSubMainPDID(null);
        objFPCListGetDRIn.setSubOperNo("");
        objFPCListGetDRIn.setWaferIDInfoGetFlag(true);
        objFPCListGetDRIn.setRecipeParmInfoGetFlag(false);
        objFPCListGetDRIn.setReticleInfoGetFlag(false);
        objFPCListGetDRIn.setDcSpecItemInfoGetFlag(false);
        List<Infos.FPCInfo> fpcInfoList = fpcMethod.fpcListGetDR(objCommon, objFPCListGetDRIn);


        // Check if STB cancelled wafer is not registered in DOC
        log.info("Check if STB cancelled wafer is not registered in DOC");
        if (!CimObjectUtils.isEmpty(fpcInfoList)) {
            for (Infos.FPCInfo fpcInfo: fpcInfoList) {
                List<Infos.LotWaferInfo> fpcWafers = fpcInfo.getLotWaferInfoList();
                for (Infos.LotWaferInfo fpcWafer : fpcWafers) {
                    for (ObjectIdentifier lotWafer : lotWaferIDList) {
                        if (ObjectIdentifier.equalsWithValue(fpcWafer.getWaferID(), lotWafer)) {
                            log.error("PSMWaferID == lotWaferID {}", lotWafer.getValue());
                            throw new ServiceException(new OmCode(retCodeConfig.getWaferFPCRegistered(), lotWafer.getValue()));
                        }
                    }
                }
            }
        }

        //【step13】check for cassette
        //【step13-1】check if lot is in a cassette
        log.info("【step13-1】check if lot is in a cassette");

        Validations.check(ObjectIdentifier.isEmptyWithValue(cassetteID), new OmCode(retCodeConfigEx.getLotOutOfCassette(), ObjectIdentifier.fetchValue(stbCancelledLotID)));

        CimCassette cassette = baseCoreFactory.getBO(CimCassette.class, cassetteID);
        Validations.check(null == cassette, new OmCode(retCodeConfig.getNotFoundCassette(), cassetteID.getValue()));

        String lotOperationEICheck = StandardProperties.OM_CARRIER_CHK_EI_FOR_LOT_OPERATION.getValue();
        if ("1".equals(lotOperationEICheck)) {
            //【step13-2】check for transferState
            log.info(String.format("【step13-2】check for transferState, the transferState:%s", cassette.getTransportState()));
            //------------------------------------------------------
            //BUG-1208
            if (CimStringUtils.equals(BizConstant.SP_TRANSSTATE_EQUIPMENTIN, cassette.getTransportState())) {
                throw new ServiceException(new OmCode(retCodeConfig.getInvalidCassetteTransferState(), cassette.getTransportState(), cassetteID.getValue()));
            }
        }
        //【step13-3】check available condition of cassette
        log.info("【step13-3】check available condition of cassette");
        String cassetteState = cassette.getDurableState();  //cassette State = durable State
        log.info(String.format("cassetteState:%s", cassetteState));
        if (!CimStringUtils.equals(CIMStateConst.CIM_DURABLE_AVAILABLE, cassetteState)) {
            log.info("cassette state not available...");
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidCassetteState(), cassetteState, cassetteID.getValue()));
        }
        if ("1".equals(lotOperationEICheck)) {
            //【step13-4】check carrier has controlJob or not - lot_STBCancel_Check.cpp: 851 - 870
            log.info("【step13-4】check carrier has controlJob or not - lot_STBCancel_Check.cpp: 851 - 870");
            CimControlJob cimControlJobBO = cassette.getControlJob();
            Validations.check(null != cimControlJobBO, retCodeConfig.getNotClearedControlJob());
        }
        //【step13-5】check sorterJob of cassette - lot_STBCancel_Check.cpp:876 - 899
        log.info("【step13-5】check sorterJob of cassette");
        com.fa.cim.sorter.Params.ObjSorterJobListGetDRIn objSorterJobListGetDRIn = new com.fa.cim.sorter.Params.ObjSorterJobListGetDRIn();
        objSorterJobListGetDRIn.setCarrierID(cassetteID);
        List<Info.SortJobListAttributes>  sortJobListAttributesList = sorterMethod.sorterJobListGetDR(objCommon, objSorterJobListGetDRIn);
        if (CimArrayUtils.isNotEmpty(sortJobListAttributesList)) {
            throw new ServiceException(new OmCode(retCodeConfigEx.getExistSorterjobForCassette() , cassetteID.getValue(), ObjectIdentifier.fetchValue(sortJobListAttributesList.get(0).getSorterJobID())));
        }


        //【step13-6】check postProcessFlag of cassette
        log.info("【step13-6】check postProcessFlag of cassette");
        Validations.check(CimBooleanUtils.isTrue(cassette.isPostProcessFlagOn()), new OmCode(retCodeConfig.getCassetteNotInPostProcess(), cassetteID.getValue()));

        if ("1".equals(lotOperationEICheck)) {
            //【step13-7】Check dispatch reservation condition of cassette
            log.info("【step13-7】Check dispatch reservation condition of cassette");
            if (CimBooleanUtils.isTrue(cassette.isDispatchReserved())) {
                throw new ServiceException(retCodeConfig.getAlreadyDispatchReservedCassette());
            }
        }
        //【step13-8】check SLM ReServe EquipmentID of cassette
        log.info("【step13-8】check SLM ReServe EquipmentID of cassette");
        CimMachine slmReservedMachine = cassette.getSLMReservedMachine();
        if (null != slmReservedMachine) {
            log.info(String.format("Error Because the specified cassette is SLM reserved. the cassetteID:%s", cassetteID));
            throw new ServiceException(new OmCode(retCodeConfig.getAlreadyReservedCassetteSlm(), cassetteID.getValue()));
        }
        log.info("this lot's cassette conditions are good for STB cancel!!!!!");

        //【step14】other checks
        log.info("【step14】other checks");
        //【step14-1】check request type for generating lot
        log.info("【step14-1】check request type for generating lot");
        //get object reference of posBank
        CimBank bank = baseCoreFactory.getBO(CimBank.class, startBankID);
        Validations.check(null == bank, new OmCode(retCodeConfig.getNotFoundBank(), ObjectIdentifier.fetchValue(startBankID)));
        int createdLotSize = CimArrayUtils.getSize(checkIn.getStbCancelInfoList());
        for (int i = 0; i < createdLotSize; i++) {
            Infos.STBCancelInfo stbCancelInfo = checkIn.getStbCancelInfoList().get(i);
            String lotType = stbCancelInfo.getNewPreparedLotInfo().getLotType();

            switch (lotType) {
                case "Engineering":
                case "Vendor":
                    if (CimBooleanUtils.isFalse(bank.isProductionBank())) {
                        throw new ServiceException(new OmCode(retCodeConfig.getInvalidBankData(), lotType, startBankID.getValue()));
                    }
                    break;
                case "Process Monitor":
                case "Auto Monitor":
                case "Dummy":
                case "Recycle":
                    if (CimBooleanUtils.isFalse(bank.isControlWaferBank())) {
                        throw new ServiceException(new OmCode(retCodeConfig.getInvalidBankData(), lotType, startBankID.getValue()));
                    }
                    break;
                default:
                    throw new ServiceException(retCodeConfig.getInvalidInputParam());
            }
        }

    }


    @Override
    public Outputs.ObjLotSTBCancelOut lotSTBCancel(Infos.ObjCommon objCommon, Inputs.ObjLotSTBCancelIn lotSTBCancelIn) {
        // input parameter
        ObjectIdentifier stbCancelledLotID = lotSTBCancelIn.getStbCancelledLotID();
        ObjectIdentifier startBankID = lotSTBCancelIn.getStartBankID();
        List<Infos.STBCancelInfo> stbCancelInfoList = lotSTBCancelIn.getStbCancelInfoList();
        // get object reference
        log.info(String.format("get stb cancelled lot object reference.LotID is '%s'", stbCancelledLotID.getValue()));
        CimLot aSourceLot = baseCoreFactory.getBO(CimLot.class, stbCancelledLotID);
        Validations.check(null == aSourceLot, new OmCode(retCodeConfig.getNotFoundLot(), stbCancelledLotID.getValue()));
        //【step1】get bank reference
        log.info("【step1】get bank reference");
        com.fa.cim.newcore.bo.factory.CimBank aPosBank = baseCoreFactory.getBO(com.fa.cim.newcore.bo.factory.CimBank.class, startBankID);
        Validations.check(null == aPosBank, new OmCode(retCodeConfig.getNotFoundBank(), startBankID.getValue()));
        int nLen = CimArrayUtils.getSize(stbCancelInfoList);
        List<Infos.PreparedLotInfo> preparedLotInfoList=new ArrayList<>();
        for (int i = 0; i < nLen; i++) {
            Infos.STBCancelInfo stbCancelInfo = stbCancelInfoList.get(i);
            int newWaferAttrSize = CimArrayUtils.getSize(stbCancelInfo.getNewLotAttributes().getNewWaferAttributesList());
            Validations.check(0 == newWaferAttrSize, retCodeConfig.getInvalidInputParam());
            //【step2】get product request object reference
            log.info("【step2】get product request object reference");
            com.fa.cim.newcore.bo.planning.CimProductRequest aProdReq = baseCoreFactory.getBO(com.fa.cim.newcore.bo.planning.CimProductRequest.class, stbCancelInfo.getProductReqID());
            Validations.check(aProdReq == null, new OmCode(retCodeConfig.getNotFoundProductRequest(), stbCancelInfo.getProductReqID().getValue()));
            //【step3】create new lot
            log.info("【step3】create new lot");
            CimLot newLot = productManager.createLotUsing(aProdReq);
            Validations.check(newLot == null, new OmCode(retCodeConfig.getNotFoundLot(), "*****"));
            ObjectIdentifier newLotID = new ObjectIdentifier(newLot.getIdentifier(), newLot.getPrimaryKey());
            //adjust split number
            log.info("【step4】get lotFamily reference");
            CimLotFamily aLotFamily = newLot.getLotFamily();
            Validations.check(aLotFamily == null, new OmCode(retCodeConfig.getNotFoundLotFamily()));
            ObjectIdentifier lotFamilyID = new ObjectIdentifier(aLotFamily.getIdentifier(), aLotFamily.getPrimaryKey());
            //【step5】check lotFamily duplication
            log.info("【step5】check lotFamily duplication");
            // Eric-BUG-6382
            /*String duplicationAllowableFlag = environmentVariableManager.getValue(EnvConst.OM_DUPLICATE_FAMILY_LOT_ENABLE);
            if (StringUtils.equals(duplicationAllowableFlag, "0")) {
                lotFamilyMethod.lotFamilyDuplicationCheckDR(objCommon, lotFamilyID);
            }*/
            // Eric-BUG-6382
            //【step6】adjust lotFamily split number
            log.info("【step6】adjust lotFamily split number");
            lotFamilyMethod.lotFamilySplitNoAdjust(objCommon, lotFamilyID);
            log.info("【step7】delete qtime info");
            this.lotQtimeDeleteDR(objCommon, stbCancelledLotID);

            //【step8】retrieve vendor lot information
            log.info("【step8】retrieve vendor lot information");
            String vendorLotID = aSourceLot.getVendorLot();
            String vend = aSourceLot.getVendor();
            //【step9】set lot info
            log.info("【step9】set lot info");
            newLot.setAllStatesForVendorLot();
            newLot.setBank(aPosBank);
            newLot.refreshQuantity();
            newLot.setVendorLot(vendorLotID);
            newLot.setVendor(vend);
            newLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
            Validations.check(aPerson == null, new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
            newLot.setLastClaimedPerson(aPerson);
            newLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            newLot.setStateChangedPerson(aPerson);
            newLot.setInventoryStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            newLot.setInventoryStateChangedPerson(aPerson);
            String lotType = newLot.getLotType();
            String subLotType = newLot.getSubLotType();
            com.fa.cim.newcore.bo.prodspec.CimProductSpecification aProductSpecification = newLot.getProductSpecification();
            ObjectIdentifier productID = new ObjectIdentifier(aProductSpecification.getIdentifier(), aProductSpecification.getPrimaryKey());
            newLot.makeWaitUse();
            /*-----------------------*/
            /*   Update wafer info   */
            /*-----------------------*/
            //【step10】update wafer info
            log.info("【step10】update wafer info");
            List<Infos.NewWaferAttributes> newWaferAttributesList = stbCancelInfo.getNewLotAttributes().getNewWaferAttributesList();
            int waferSize = CimArrayUtils.getSize(newWaferAttributesList);
            for (int j = 0; j < waferSize; j++) {
                ObjectIdentifier sourceWaferID = newWaferAttributesList.get(j).getSourceWaferID();
                CimWafer aWafer = baseCoreFactory.getBO(CimWafer.class, sourceWaferID);
                Validations.check(aWafer == null, new OmCode(retCodeConfig.getNotFoundWafer(), sourceWaferID.getValue()));
                //【step10-1】Reduce wafers' STBed count
                log.info("【step10-1】Reduce wafers' STBed count");
                int stbedCount = (null == aWafer.getSTBedCount() ? 0 : aWafer.getSTBedCount());
                aWafer.setSTBedCount(stbedCount - 1);
                //【step10-2】Clear STB source lot info
                log.info("【step10-2】Clear STB source lot info");
                List<ProductDTO.STBInfo> strSTBInfoSeq = aWafer.getSTBInfo();
                ProductDTO.STBInfo stbInfo = strSTBInfoSeq.get(0);
                stbInfo.setSTBSourceLotID("");
                aWafer.setSTBInfo(strSTBInfoSeq);
            }
            //【step10-3】wafer assigned lot change
            log.info("【step10-3】wafer assigned lot change");
            Infos.NewLotAttributes tmpNewLotAttributes = stbCancelInfo.getNewLotAttributes();
            for (int j = 0; j < newWaferAttrSize; j++) {
                tmpNewLotAttributes.getNewWaferAttributesList().get(j).setNewLotID(newLotID);
            }
            waferMethod.waferAssignedLotChangeForSTBCancel(objCommon, tmpNewLotAttributes.getNewWaferAttributesList());
            // get quantity
            int quantity = newLot.getQuantity() == null ? 0 : newLot.getQuantity();
            /*------------------------------*/
            /*   Prepare output structure   */
            /*------------------------------*/
            Infos.PreparedLotInfo preparationCancelledLotInfo = new Infos.PreparedLotInfo();
            preparationCancelledLotInfo.setLotID(newLotID);
            preparationCancelledLotInfo.setLotType(lotType);
            preparationCancelledLotInfo.setSubLotType(subLotType);
            preparationCancelledLotInfo.setProductID(productID);
            preparationCancelledLotInfo.setWaferCount((long)quantity);
            preparedLotInfoList.add(preparationCancelledLotInfo);

            log.info(String.format("newLotID:%s", newLotID));
            log.info(String.format("sourceLotType:%s", lotType));
            log.info(String.format("subLotType:%s", subLotType));
            log.info(String.format("productID:%s", productID));
            log.info(String.format("runWaferCount:%s", newLot.getQuantity()));

        }
        Outputs.ObjLotSTBCancelOut objLotSTBCancelOut = new Outputs.ObjLotSTBCancelOut();
        objLotSTBCancelOut.setPreparedLotInfoList(preparedLotInfoList);
        //【step11】make STBCancelled lot emptied
        log.info("【step11】make STBCancelled lot emptied");
        aSourceLot.makeEmptied();
        log.info("【step12】create event queue recode (poDelQueue_PutDR)");
        String envEventCreateTypeStr = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
        int envEventCreateType = CimStringUtils.isEmpty(envEventCreateTypeStr) ? 0 : Integer.parseInt(envEventCreateTypeStr);
        if (envEventCreateType == BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED
            || envEventCreateType == BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED){
            com.fa.cim.newcore.bo.pd.CimProcessOperation aCurrentPO = aSourceLot.getProcessOperation();
            if (aCurrentPO != null){
                processMethod.poDelQueuePutDR(objCommon, stbCancelledLotID);
            }
        }
        return objLotSTBCancelOut;
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param objCommon
     * @param strChangedLotAttributes
     * @return com.fa.cim.dto.RetCode<java.lang.Object>
     * @author Ho
     * @date 2018/11/23 17:39:27
     */
    @Override
    public void lotChangeOrder(Infos.ObjCommon objCommon, Infos.ChangedLotAttributes strChangedLotAttributes) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, strChangedLotAttributes.getLotID());
        Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(strChangedLotAttributes.getLotID())));
        if( !CimStringUtils.isEmpty( strChangedLotAttributes.getCustomerCode() ) ) {
            CimCustomer aCustomer = productSpecificationManager.findCustomerNamed(strChangedLotAttributes.getCustomerCode());
            Validations.check(null == aCustomer, new OmCode(retCodeConfigEx.getNotFoundCustomer(), strChangedLotAttributes.getCustomerCode()));
            aLot.setCustomer(aCustomer);
        }

        if( !CimStringUtils.isEmpty(strChangedLotAttributes.getManufacturingOrderNumber()) ) {
            aLot.setOrderNumber(strChangedLotAttributes.getManufacturingOrderNumber());
        }

        if(!ObjectIdentifier.isEmptyWithValue(strChangedLotAttributes.getLotOwner())) {
            CimPerson aOwner = baseCoreFactory.getBO(CimPerson.class, strChangedLotAttributes.getLotOwner());
            Validations.check(null == aOwner, new OmCode(retCodeConfig.getNotFoundPerson(), strChangedLotAttributes.getLotOwner().getValue()));
            aLot.setLotOwner(aOwner);
        }

        if (!CimStringUtils.isEmpty(strChangedLotAttributes.getExternalPriority())) {
            Integer extPriority = Integer.valueOf(strChangedLotAttributes.getExternalPriority());
            aLot.setPriority(extPriority);
        }

        if(!CimStringUtils.isEmpty(strChangedLotAttributes.getLotComment()) ) {
            aLot.removeLotComment();
            CimLotComment aLotComment = aLot.createLotComment();
            Validations.check(null == aLotComment, new OmCode(retCodeConfig.getNotFoundLotcomment(), ""));
            aLotComment.setContents(strChangedLotAttributes.getLotComment());
            aLotComment.setLastUpdateTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());

            CimPerson aPerson = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
            Validations.check(null == aPerson, new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
            aLotComment.setPerson(aPerson);
        }

        if(!CimStringUtils.isEmpty(strChangedLotAttributes.getSubLotType())) {
            // step1 - lot_subLotType_GetDetailInfoDR
            Outputs.LotSubLotTypeGetDetailInfoDR strLotSubLotTypeGetDetailInfoDROut = lotSubLotTypeGetDetailInfoDR(objCommon, strChangedLotAttributes.getSubLotType());
            String tmpLotType = aLot.getLotType();

            if( !CimStringUtils.isEmpty(strLotSubLotTypeGetDetailInfoDROut.getLotType())
             && !CimStringUtils.equals(strLotSubLotTypeGetDetailInfoDROut.getLotType(), tmpLotType ) ) {
                aLot.setLotType(strLotSubLotTypeGetDetailInfoDROut.getLotType());
            }
            aLot.setSubLotType( strChangedLotAttributes.getSubLotType());
        }
    }

    @Override
    public Infos.FlowBatchLotInfo lotFlowBatchSectionInfoGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Infos.FlowBatchLotInfo flowBatchLotInfo = new Infos.FlowBatchLotInfo();
        CimLotDO example = new CimLotDO();
        example.setLotID(ObjectIdentifier.fetchValue(lotID));
        CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        flowBatchLotInfo.setLotID(lotID);
        flowBatchLotInfo.setSubLotType(lot.getSubLotType());
        flowBatchLotInfo.setLotStatus(lot.getLotState());
        flowBatchLotInfo.setPriorityClass(String.valueOf(lot.getPriorityClass()));
        flowBatchLotInfo.setProductID(new ObjectIdentifier(lot.getProductSpecificationID(),lot.getProductSpecificationObj()));

        //------------------------------
        // Get cassette information
        //------------------------------
        CimLotMaterialContainerDO cimLotMaterialContainerExample = new CimLotMaterialContainerDO();
        cimLotMaterialContainerExample.setReferenceKey(lot.getId());
        List<CimLotMaterialContainerDO> lotMaterialContainers = cimJpaRepository.findAll(Example.of(cimLotMaterialContainerExample));
        if (!CimArrayUtils.isEmpty(lotMaterialContainers)) {
            flowBatchLotInfo.setCarrierID(new ObjectIdentifier(lotMaterialContainers.get(0).getMaterialContainerID(),lotMaterialContainers.get(0).getMaterialContainerObj()));
        }

        //Get current operation information
        Outputs.ObjLotCurrentOperationInfoGetDROut lotcurrOperaOut = this.lotCurrentOperationInfoGetDR(objCommon, lotID);

        String modulePF = lotcurrOperaOut.getModulePF();
        String moduleOpeNo = lotcurrOperaOut.getModuleOpeNo();

        Outputs.ObjProcessFlowBatchDefinitionGetDROut flowBatchOut = processMethod.processFlowBatchDefinitionGetDR(objCommon, lotcurrOperaOut.getModulePOS());

        List<Infos.FlowBatchSection> flowBatchSections = new ArrayList<>();
        Infos.FlowBatchControl flowBatchControl = flowBatchOut.getFlowBatchControl();
        int operationCount = 0;
        long flowBatchSectionCount = null == flowBatchControl ? 0 : flowBatchControl.getOperationCount();

        if (0 != flowBatchSectionCount) {
            flowBatchLotInfo.setFlowBatchControl(flowBatchControl);
            flowBatchSections.add(flowBatchOut.getFlowBatchSection());
            operationCount++;
        }

        for (; operationCount < flowBatchSectionCount; operationCount++){
            // Get next operation information
            Outputs.ObjProcessNextOperationInModuleGetDROut moduleOut = null;
            try {
                moduleOut = processMethod.processNextOperationInModuleGetDR(objCommon, modulePF, moduleOpeNo);
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getNotFoundNextOperation(),e.getCode())) {
                    break;
                } else {
                    throw e;
                }
            }
            // Get flow batch information
            Outputs.ObjProcessFlowBatchDefinitionGetDROut flowBatchDefinitionOut = processMethod.processFlowBatchDefinitionGetDR(objCommon, moduleOut.getModulePOS());
            // Set flow batch information to output parameter
            flowBatchSections.add(flowBatchDefinitionOut.getFlowBatchSection());
            modulePF = moduleOut.getModulePF();
            moduleOpeNo = moduleOut.getModuleOpeNo();
        }
        flowBatchLotInfo.setFlowBatchSectionList(flowBatchSections);
        return flowBatchLotInfo;
    }

    @Override
    public Outputs.ObjLotPreparationCancelInfoGetDROut lotPreparationCancelInfoGetDR(Infos.ObjCommon objCommon, ObjectIdentifier preparationCancelledLotID) {
        // prepare output
        Outputs.ObjLotPreparationCancelInfoGetDROut objLotPreparationCancelInfoGetDROut = new Outputs.ObjLotPreparationCancelInfoGetDROut();

        log.info("in-param [preparationCancelledLotID]: {}", preparationCancelledLotID);
        // step1 - get lot information
        CimLotDO example = new CimLotDO();
        example.setLotID(ObjectIdentifier.fetchValue(preparationCancelledLotID));
        CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
        Validations.check(lot==null, retCodeConfig.getNotFoundLot(), preparationCancelledLotID.getValue());

        Infos.PreparationCancelledLotInfo tmpPreparationCancelledLotInfo = new Infos.PreparationCancelledLotInfo();
        tmpPreparationCancelledLotInfo.setLotID(new ObjectIdentifier(lot.getLotID(), lot.getId()));
        tmpPreparationCancelledLotInfo.setLotType(lot.getLotType());
        tmpPreparationCancelledLotInfo.setSubLotType(lot.getSubLotType());
        tmpPreparationCancelledLotInfo.setLotStatus(lot.getLotState());
        tmpPreparationCancelledLotInfo.setProductID(new ObjectIdentifier(lot.getProductSpecificationID(), lot.getProductSpecificationObj()));
        tmpPreparationCancelledLotInfo.setBankID(new ObjectIdentifier(lot.getBankID(), lot.getBankObj()));
        tmpPreparationCancelledLotInfo.setWaferCount(lot.getWaferCount());

        // step2 - get cassette information
        CimLotMaterialContainerDO cimLotMaterialContainerExample = new CimLotMaterialContainerDO();
        cimLotMaterialContainerExample.setReferenceKey(lot.getId());
        cimLotMaterialContainerExample.setSequenceNumber(0);
        CimLotMaterialContainerDO lotMaterialContainers = cimJpaRepository.findOne(Example.of(cimLotMaterialContainerExample)).orElse(null);

        // Bug-3251: if lot is not in a carrier, it's ok.
        if(lotMaterialContainers == null) {
            tmpPreparationCancelledLotInfo.setCassetteID(new ObjectIdentifier());
            tmpPreparationCancelledLotInfo.setLotID(preparationCancelledLotID);
            objLotPreparationCancelInfoGetDROut.setPreparationCancelledLotInfo(tmpPreparationCancelledLotInfo);
           // return objLotPreparationCancelInfoGetDROut;
        } else {
            // only one cassette is OK.
            tmpPreparationCancelledLotInfo.setCassetteID(ObjectIdentifier.build(lotMaterialContainers.getMaterialContainerID(),
                    lotMaterialContainers.getMaterialContainerObj()));
        }

        // step3 - get wafers in lot
        List<Infos.NewVendorLotInfo> tmpNewVendorLotInfoList = new ArrayList<>();
        List<Infos.PreparationCancelledWaferInfo> tmpPreparationCancelledWaferInfoList = new ArrayList<>();
        Inputs.ObjLotWaferIDListGetDRIn objLotWaferIDListGetDRIn = new Inputs.ObjLotWaferIDListGetDRIn();

        objLotWaferIDListGetDRIn.setLotID(preparationCancelledLotID);
        objLotWaferIDListGetDRIn.setScrapCheckFlag(false);

        List<ObjectIdentifier> waferIDs = this.lotWaferIDListGetDR(objCommon, objLotWaferIDListGetDRIn);


        for (ObjectIdentifier waferID : waferIDs) {
            Validations.check(ObjectIdentifier.isEmptyWithValue(waferID), retCodeConfig.getReceivedVendorLot());

            Infos.PreparationCancelledWaferInfo preparationCancelledWaferInfo = new Infos.PreparationCancelledWaferInfo();
            preparationCancelledWaferInfo.setWaferID(waferID);
            tmpPreparationCancelledWaferInfoList.add(preparationCancelledWaferInfo);
        }

        for (Infos.PreparationCancelledWaferInfo preparationCancelledWaferInfo : tmpPreparationCancelledWaferInfoList) {

            Object[] stbCount= cimJpaRepository.queryOne("SELECT  LOT_START_COUNT\n" +
                    "                     FROM   OMWAFER\n" +
                    "                     WHERE  WAFER_ID = ?", preparationCancelledWaferInfo.getWaferID().getValue());
            if (CimObjectUtils.isEmpty(stbCount) || CimObjectUtils.isEmpty(stbCount[0]) ) {
                preparationCancelledWaferInfo.setStbCount(0L);
            }else{
                preparationCancelledWaferInfo.setStbCount(Long.parseLong(CimObjectUtils.toString(stbCount[0])));
            }

            // step3-1 get original vendor lot
            CimWaferStbInfoDO cimWaferStbInfoExample = new CimWaferStbInfoDO();
            cimWaferStbInfoExample.setReferenceKey(ObjectIdentifier.fetchReferenceKey(preparationCancelledWaferInfo.getWaferID()));
            List<CimWaferStbInfoDO> waferStbInfoList = cimJpaRepository.findAll(Example.of(cimWaferStbInfoExample));

            for (CimWaferStbInfoDO waferStbInfo : waferStbInfoList) {
                // step3-2 set vendor lot
                String tmpVendorLotID = waferStbInfo.getVendLotID();        // get the VEND_LOT_ID, not the VEND_VENDOR_LOT_ID
                preparationCancelledWaferInfo.setOriginalVendorLotID(new ObjectIdentifier(tmpVendorLotID));

                // step3-3 get original vendor lot info sequence (no duplicate)
                boolean addLotFlag = true;
                int originalVendorLotSize = CimArrayUtils.getSize(tmpNewVendorLotInfoList);
                for (int i = 0; i < originalVendorLotSize; i++) {
                    Infos.NewVendorLotInfo newVendorLotInfo = tmpNewVendorLotInfoList.get(i);
                    if (!CimStringUtils.isEmpty(tmpVendorLotID)
                     && CimStringUtils.equals(tmpVendorLotID, newVendorLotInfo.getOriginalVendorLotID())) {
                        addLotFlag = false;
                        int waferCount = (null == newVendorLotInfo.getWaferCount() ? 0 : newVendorLotInfo.getWaferCount());
                        newVendorLotInfo.setWaferCount(waferCount + 1);
                        break;
                    }
                }

                if (addLotFlag) {
                    Infos.NewVendorLotInfo newVendorLotInfo = new Infos.NewVendorLotInfo();
                    newVendorLotInfo.setOriginalVendorLotID(tmpVendorLotID);
                    newVendorLotInfo.setSubLotType(waferStbInfo.getVendSubLotType());
                    newVendorLotInfo.setProductID(new ObjectIdentifier(waferStbInfo.getVendProductID(), waferStbInfo.getVendProductObj()));
                    newVendorLotInfo.setVendorLotID(waferStbInfo.getVendVendorLotID());
                    newVendorLotInfo.setVendorName(waferStbInfo.getVendVendorLotID());
                    newVendorLotInfo.setWaferCount(1);
                    tmpNewVendorLotInfoList.add(newVendorLotInfo);
                }
                break;   // only one vendor lotID is ok
            }

        }


        objLotPreparationCancelInfoGetDROut.setPreparationCancelledLotInfo(tmpPreparationCancelledLotInfo);
        objLotPreparationCancelInfoGetDROut.setNewVendorLotInfoList(tmpNewVendorLotInfoList);
        objLotPreparationCancelInfoGetDROut.setPreparationCancelledWaferInfoList(tmpPreparationCancelledWaferInfoList);

        return objLotPreparationCancelInfoGetDROut;
    }

    @Override
    public void lotPreparationCancelCheck(Infos.ObjCommon objCommon, Inputs.ObjLotPreparationCancelCheckIn objLotPreparationCancelCheckIn) {

        ObjectIdentifier preparationCancelledLotID = objLotPreparationCancelCheckIn.getPreparationCancelledLoID();
        ObjectIdentifier bankID = objLotPreparationCancelCheckIn.getBankID();
        List<Infos.NewVendorLotInfo> newVendorLotInfoList = objLotPreparationCancelCheckIn.getNewVendorLotInfoList();
        List<Infos.PreparationCancelledWaferInfo> preparationCancelledWaferInfoList = objLotPreparationCancelCheckIn.getPreparationCancelledWaferInfoList();

        log.info("[in-param] preparationCancelledLotID:{}", preparationCancelledLotID);
        log.info("[in-param] bankID:{}", bankID);

        /*------------------------------------------------------------------------------*/
        /*   Check for preparation cancelled lot                                        */
        /*   1.  Source lot Type                                                        */
        /*   2.  Lot inventory state                                                    */
        /*   3.  Input bankID                                                           */
        /*   4.  Hold State                                                             */
        /*   5.  If lot state is Finished or not                                        */
        /*   6.  Lot finish state                                                       */
        /*   7.  Lot process state                                                      */
        /*   8.  Lot family's lot state(if preparation cancelled lot is original lot)   */
        /*   9.  Existence check of ProdReq using cancelled lot                         */
        /*   10. If lot isn't in the cassette                                           */
        /*   11. Check if lot doesn't have route information                            */
        /*------------------------------------------------------------------------------*/

        // get lot object
        CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, preparationCancelledLotID);
        if (CimObjectUtils.isEmpty(aPosLot)) {
            log.info("not found lot which sourceLotID is {} in OMLOT table", preparationCancelledLotID);
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundLot(), preparationCancelledLotID.getValue()));
        }

        // step1- check source lot type
        String lotType = aPosLot.getLotType();
        log.info("1. check source lot type: {}", lotType);
        if (!CimStringUtils.equals(BizConstant.SP_LOT_TYPE_VENDORLOT, lotType)
                && !CimStringUtils.equals(BizConstant.SP_LOT_TYPE_ENGINEERINGLOT, lotType)
                && !CimStringUtils.equals(BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT, lotType)
                && !CimStringUtils.equals(BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT, lotType)
                && !CimStringUtils.equals(BizConstant.SP_LOT_TYPE_DUMMYLOT, lotType)
                && !CimStringUtils.equals(BizConstant.SP_LOT_TYPE_RECYCLELOT, lotType)) {
            log.info("sourceLotType which is {} is invalid", lotType);
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotType(), lotType));
        }

        // step2 - check lot inventory state
        String inventoryState = aPosLot.getLotInventoryState();
        log.info("2. check lot inventory state: {}", inventoryState);
        if (!CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_INBANK, inventoryState)) {
            log.info("LotInventoryState != {}", BizConstant.SP_LOT_INVENTORYSTATE_INBANK);
            Validations.check(retCodeConfig.getInvalidLotInventoryStat(), ObjectIdentifier.fetchValue(preparationCancelledLotID),
                    inventoryState);
        }

        // step3 - check input bankID
        log.info("3. Check input bankID:");
        com.fa.cim.newcore.bo.factory.CimBank aBank= aPosLot.getBank();
        if (null == aBank) {
            log.info("invalid bankID:");
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidBankId(), "***"));
        }

        String bankIDStr = aBank.getIdentifier();
        if (!CimStringUtils.equals(bankIDStr, bankID.getValue())) {
            log.info("invalid bankID:{}", bankIDStr);
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidBankId(), bankIDStr));
        }

        // step4 - check hold state
        log.info("4. check hold state: ");
        String holdState = aPosLot.getLotHoldState();
        if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, holdState)) {
           List<ProductDTO.HoldRecord> holdRecordList = aPosLot.allHoldRecords();

            if (CimArrayUtils.isEmpty(holdRecordList)) {
                log.info("Not found hold record.");
            }else{
                String holdType = holdRecordList.get(0).getHoldType();
                throw new ServiceException(new OmCode(retCodeConfig.getLotHoldForHoldType(), preparationCancelledLotID.getValue(), holdType));
            }
        }

        // step5 - check if lot state is finished or not
        log.info("5. check if lot state is finished or not...");
        String lotState = aPosLot.getLotState();
        if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_FINISHED, lotState)) {
            log.info("the lotState != {}", CIMStateConst.CIM_LOT_STATE_FINISHED);
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotStat(), lotState));
        }

        // step6 - check lot finish state
        log.info("6. check lot finish state...");
        String finishedState = aPosLot.getLotFinishedState();
        if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_FINISHED_STATE_COMPLETED, finishedState)) {
            log.info("lotFinishedState != {}", CIMStateConst.CIM_LOT_FINISHED_STATE_COMPLETED);
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotFinishStat(), finishedState));
        }

        // step7 - check lot process state
        log.info("7. check lot process state...");
        String processState = aPosLot.getLotProcessState();
        if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_PROCESS_STATE_PROCESSED, processState)) {
            log.info("lotProcessState != {}",CIMStateConst.CIM_LOT_PROCESS_STATE_PROCESSED);
            Validations.check(retCodeConfig.getInvalidLotProcessState(), ObjectIdentifier.fetchValue(aPosLot.getLotID()), processState);
        }

        // step8 - check lot family's lot state
        log.info("8. check lot family's lot state...");
        CimLotFamily aLotFamily = aPosLot.getLotFamily();
        if (CimObjectUtils.isEmpty(aLotFamily)) {
            log.info("not found lotFamily...");
            throw new ServiceException(retCodeConfig.getNotFoundLotFamily());
        }
        Lot originalLot = aLotFamily.originalLot();
        if (CimObjectUtils.isEmpty(originalLot)) {
            log.info("not found the original lot...");
            throw new ServiceException(retCodeConfig.getNotFoundLot());
        }
        String originalLotID = originalLot.getIdentifier();
        if (ObjectIdentifier.equalsWithValue(preparationCancelledLotID, originalLotID)) {
            log.info("preparationCancelledLotID == originalLotID");
            String familyLotIDStr;
            boolean bEmptiedFlag;

            List<Lot> aCurrentLotList = aLotFamily.currentLots();
            List<Lot> anArchiveLotList = aLotFamily.archive();

            for (Lot lotFamilyCurrentLot : aCurrentLotList) {
                familyLotIDStr = lotFamilyCurrentLot.getIdentifier();
                if (!CimStringUtils.equals(originalLotID, familyLotIDStr)) {
                    throw new ServiceException(retCodeConfig.getChildLotNotEmptied());
                }
            }

            for (Lot lotFamilyArchive : anArchiveLotList) {
                bEmptiedFlag = lotFamilyArchive.isEmptied();
                if (!bEmptiedFlag) {
                    throw new ServiceException(retCodeConfig.getChildLotNotEmptied());
                }
            }

        }

        // step9 - existence check of prodReq using cancelled lot
        ObjectIdentifier out = null;
        try {
            out = this.sourceLotProductRequestGetDR(objCommon, preparationCancelledLotID);
        }catch(ServiceException ex){
            if(ex.getCode() != retCodeConfig.getNotFoundProductRequestForSourceLot().getCode())
                throw ex;
            // if not found. it's Ok.
        }
        if(ObjectIdentifier.isEmpty(out)){
            log.info("Not found productRequest whose source lot = {}", preparationCancelledLotID.getValue());
        } else if(CimStringUtils.isNotEmpty(out.getValue())){
            throw new ServiceException(new OmCode(retCodeConfig.getExistProductRequest(), out.getValue()));
        }


        // step10 - check if lot isn't in the cassette
       /*
        //【2019/10/14】note by bear, because of the requirement needn't follow the R18.
        log.info("check if lot isn't in the cassette");
        List<CimCassetteLotDO> lotMtrlcontnrsList = cimLot.findLotMaterialContainersByLotID(lot.getLotID());
        if (!ArrayUtils.isEmpty(lotMtrlcontnrsList)) {
            throw new ServiceException(new OmCode(retCodeConfig.getLotInCassette(), lot.getLotID()));
        }*/

        // step11 - check if lot doesn't have route information
        log.info("11. check if lot doesn't have route information...");
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aProcessDefinition = aPosLot.getMainProcessDefinition();

        if (!CimObjectUtils.isEmpty(aProcessDefinition)) {
            throw new ServiceException(retCodeConfig.getLotOnRoute());
        }


        // step12 - preparation cancelled lot check end
        log.info("**********************************************************");
        log.info("*this lot's condition is good for lot preparation cancel!*");
        log.info("**********************************************************");

        /*---------------------------------------------*/
        //   Check for preparation cancelled wafers
        //   1. Check if wafer isn't scrap
        /*---------------------------------------------*/
        // step12-1 - get lot's wafer identifiers
        Inputs.ObjLotWaferIDListGetDRIn objLotWafersGetIn = new Inputs.ObjLotWaferIDListGetDRIn();
        objLotWafersGetIn.setLotID(preparationCancelledLotID);
        objLotWafersGetIn.setScrapCheckFlag(false);
        List<ObjectIdentifier>  lotWaferIDList = this.lotWaferIDListGetDR(objCommon, objLotWafersGetIn);

        // step12-2 check if wafer isn't scrap
        log.info("check if wafer isn't scrap...");
        for (ObjectIdentifier lotWaferID : lotWaferIDList) {
            CimWafer aWafer = baseCoreFactory.getBO(CimWafer.class, lotWaferID);
            if (null == aWafer) {
                throw new ServiceException(retCodeConfig.getNotFoundWafer());
            }

            boolean bScrapFlag = aWafer.isScrap();
            if (bScrapFlag) {
                throw new ServiceException(retCodeConfig.getFoundScrap());
            }
        }


        log.info("this lot's wafer's condition is good for lot preparation cancel!");
        log.info(" All checks are done !!");

    }

    @Override
    public Outputs.ObjLotHoldReleaseOut lotHoldRelease(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier releaseReasonCodeID, List<Infos.LotHoldReq> holdReqList) {
        Outputs.ObjLotHoldReleaseOut result = new Outputs.ObjLotHoldReleaseOut();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        if (CimObjectUtils.isEmpty(lot)) {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundLot(),lotID.getValue()));
        }
        Long holdListResp = 0L;
        List<ProductDTO.HoldRecord> holdRecords = lot.allHoldRecords();
        if (0 < CimArrayUtils.getSize(holdRecords)) {
            for (ProductDTO.HoldRecord holdRecord : holdRecords) {
                if (holdRecord.isResponsibleOperationFlag()) {
                    holdListResp++;
                }
            }
        }

        com.fa.cim.newcore.bo.pd.CimProcessDefinition processDefinition = lot.getMainProcessDefinition();
        if (CimObjectUtils.isEmpty(processDefinition)) {
            throw new ServiceException(retCodeConfig.getMsgNotFoundPd());
        }
        String operationNumber = lot.getOperationNumber();

        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        if (CimObjectUtils.isEmpty(person)) {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
        }


        ProductDTO.HoldRecord holdRecord = new ProductDTO.HoldRecord();
        ProductDTO.HoldRecord aHoldRecordOut = null;
        Long relListRespCounter = 0L;
        List<Infos.HoldHistory> holdHistories = new ArrayList<>();
        List<Infos.LotHoldReq> holdList = new ArrayList<>();
        for (int i = 0; i < holdReqList.size(); i++) {
            Infos.HoldHistory holdHistory = new Infos.HoldHistory();
            holdRecord.setHoldType(holdReqList.get(i).getHoldType());
            //holdRecord.setHoldType(holdReqList.get(i).getHoldType());
            //aHoldRecordKey.reasonCode  = strLotHoldReleaseReqList[i].holdReasonCodeID ;
            holdRecord.setReasonCode(holdReqList.get(i).getHoldReasonCodeID());
            holdRecord.setHoldPerson(holdReqList.get(i).getHoldUserID());
            holdRecord.setRelatedLot(holdReqList.get(i).getRelatedLotID());

            aHoldRecordOut= lot.findHoldRecord(holdRecord);
            if(CimObjectUtils.isEmpty(aHoldRecordOut)){
                Validations.check(retCodeConfig.getNotExistHold(),holdReqList.get(i).getHoldType(),ObjectIdentifier.fetchValue(holdReqList.get(i).getHoldReasonCodeID()),ObjectIdentifier.fetchValue(holdReqList.get(i).getHoldUserID()));
                //throw new ServiceException(retCodeConfig.getNotExistHold());              //bug-6233

            } else {
                if (aHoldRecordOut.isResponsibleOperationFlag()) {
                    relListRespCounter++;
                }
                if (0L == holdListResp) {
                    holdHistory.setMovementFlag(false);
                } else {
                    if (aHoldRecordOut.isResponsibleOperationFlag()) {
                        if (Objects.equals(relListRespCounter, holdListResp)) {
                            holdHistory.setMovementFlag(true);
                        } else {
                            holdHistory.setMovementFlag(false);
                        }
                    } else {
                        holdHistory.setMovementFlag(false);
                    }
                }
                if (0L == holdListResp) {
                    holdHistory.setResponsibleOperationExistFlag(false);
                } else {
                    if (aHoldRecordOut.isResponsibleOperationFlag()) {
                        holdHistory.setResponsibleOperationExistFlag(true);
                     //   2569 【千岛QA】Lot history数据releaseHoldLot显示重复
                      //  holdHistories.add(i, holdHistory);
                    } else {
                        if (Objects.equals(relListRespCounter, holdListResp)) {
                            holdHistory.setResponsibleOperationExistFlag(false);
                        } else {
                            holdHistory.setResponsibleOperationExistFlag(true);
                        }
                    }
                }
                holdHistory.setChangeStateFlag(false);
                holdHistory.setHoldType(aHoldRecordOut.getHoldType());
                holdHistory.setHoldReasonCode(aHoldRecordOut.getReasonCode());
                holdHistory.setHoldPerson(aHoldRecordOut.getHoldPerson());
                holdHistory.setHoldTime(aHoldRecordOut.getHoldTimeStamp());
                holdHistory.setResponsibleOperationFlag(aHoldRecordOut.isResponsibleOperationFlag());
                holdHistory.setHoldClaimMemo(aHoldRecordOut.getHoldClaimMemo());
                holdHistory.setReleaseReasonCode(releaseReasonCodeID);
                holdHistory.setReleaseTime(objCommon.getTimeStamp().getReportTimeStamp());
                holdHistory.setReleasePerson(objCommon.getUser().getUserID());
                holdHistory.setReleaseClaimMemo(holdReqList.get(i).getClaimMemo());
                holdHistory.setDepartmentNamePlate(String.join(BizConstant.DOT, holdReqList.get(i).getDepartment(), holdReqList.get(i).getSection()));
                lot.removeHoldRecord(holdRecord);
                holdHistories.add(i, holdHistory);
                Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                if (!ObjectIdentifier.isEmpty(holdReqList.get(i).getRouteID())
                        && !CimStringUtils.isEmpty(holdReqList.get(i).getOperationNumber())
                        && !CimStringUtils.equals(BizConstant.SP_HOLDTYPE_LOTHOLD, holdReqList.get(i).getHoldType())
                        && !CimStringUtils.equals(BizConstant.SP_HOLDTYPE_FUTUREHOLD, holdReqList.get(i).getHoldType())) {
                    lotHoldReq.setHoldType(holdReqList.get(i).getHoldType());
                    lotHoldReq.setHoldReasonCodeID(holdReqList.get(i).getHoldReasonCodeID());
                    lotHoldReq.setHoldUserID(holdReqList.get(i).getHoldUserID());
                    lotHoldReq.setResponsibleOperationMark(holdReqList.get(i).getResponsibleOperationMark());

                    if(processDefinition != null){
                        lotHoldReq.setRouteID(ObjectIdentifier.build(processDefinition.getIdentifier(), processDefinition.getPrimaryKey()));
                    }else {
                        lotHoldReq.setRouteID(new ObjectIdentifier("",""));
                    }
//                    lotHoldReq.setRouteID(processDefinition.getReferenceKey());
                    lotHoldReq.setOperationNumber(operationNumber);
                    lotHoldReq.setRelatedLotID(holdReqList.get(i).getRelatedLotID());
                    lotHoldReq.setClaimMemo(holdReqList.get(i).getClaimMemo());
                    holdList.add(lotHoldReq);
                }
            }
        }
        result.setHoldHistoryList(holdHistories);
        result.setHoldList(holdList);
        if (CimArrayUtils.getSize(holdRecords) == CimArrayUtils.getSize(holdReqList)) {
            lot.makeNotOnHold();
            if (CimStringUtils.equals(BizConstant.SP_REASON_LOTLOCKRELEASE, releaseReasonCodeID.getValue())
                    && "OPOSW001".equals(objCommon.getTransactionID())
                    || "OPOSW007".equals(objCommon.getTransactionID())
                    || "OPOSW008".equals(objCommon.getTransactionID())) {
                List<CimMachine> equipments = lot.getHoldQueuedMachines();
                if (0 == CimArrayUtils.getSize(equipments)) {
                    com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = lot.getProcessOperation();
                    if (CimObjectUtils.isEmpty(processOperation)) {
                        throw new ServiceException(retCodeConfig.getNotFoundProcessOperation());

                    }
                    Boolean flowBatchEntryFlag = processOperation.isFlowBatchEntryOperation();
                    if (CimBooleanUtils.isTrue(flowBatchEntryFlag)) {
                        com.fa.cim.newcore.bo.dispatch.CimFlowBatch flowBatch = lot.getFlowBatch();
                        if (CimObjectUtils.isEmpty(flowBatch)) {
                            dispatchingManager.addToQueue(lot);
                        }
                    }

                } else {
                    dispatchingManager.moveToWIPQueue(lot);
                }
            } else {
                dispatchingManager.removeFromHoldQueue(lot);
                dispatchingManager.addToQueue(lot);
            }
            lot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            lot.setStateChangedPerson(person);
        } else if (CimArrayUtils.getSize(holdRecords) > CimArrayUtils.getSize(holdReqList)) {
            String lotHoldEqpUpdateFlag = StandardProperties.OM_EQP_HOLD_UPDATE_MODE.getValue();
            if ("-1".equals(lotHoldEqpUpdateFlag)) {
                List<ProductDTO.HoldRecord> holdRecords1 = lot.allHoldRecords();
                Boolean isFindFlag = false;
                for (ProductDTO.HoldRecord record : holdRecords1) {
                    if (!CimStringUtils.equals(BizConstant.SP_REASON_LOTLOCK, record.getReasonCode().getValue())) {
                        isFindFlag = true;
                        break;
                    }
                }
                if (!isFindFlag) {
                    dispatchingManager.removeFromHoldQueue(lot);
                    dispatchingManager.addToQueue(lot);
                }
            }
        }
        List<ProductDTO.HoldRecord> anAfterHoldRecord = lot.allHoldRecords();
        for (ProductDTO.HoldRecord record : anAfterHoldRecord) {
            if (record.isResponsibleOperationFlag()) {
                lot.makeResponsibleOperation();
                break;
            }
        }
        if (CimArrayUtils.getSize(anAfterHoldRecord) == CimArrayUtils.getSize(holdRecords)) {
            lot.makeNotResponsibleOperation();
        }
        lot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        lot.setLastClaimedPerson(person);

        return result;
    }

    @Override
    public List<Infos.LotHoldListAttributes> lotFillInTxTRQ005DR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        List<ProductDTO.HoldRecord> strHoldRecords = aLot.allHoldRecords();
        int hrLen = CimArrayUtils.getSize(strHoldRecords);
        if (hrLen == 0){
            throw new ServiceException(retCodeConfig.getNotFoundEntry());
        }
        List<Infos.LotHoldListAttributes> lotHoldListAttributesList = new ArrayList<>();
        com.fa.cim.newcore.bo.code.CimCategory aCategory = codeManager.findCategoryNamed(BizConstant.SP_REASONCAT_LOTHOLD);
        Validations.check(aCategory == null, retCodeConfig.getNotFoundCategory());
        com.fa.cim.newcore.bo.code.CimCategory aCategory_FH = codeManager.findCategoryNamed(BizConstant.SP_REASONCAT_FUTUREHOLD);
        Validations.check(aCategory_FH == null, retCodeConfig.getNotFoundCategory());
        com.fa.cim.newcore.bo.code.CimCategory aCategory_PH = codeManager.findCategoryNamed(BizConstant.SP_REASONCAT_PROCESSHOLD);
        Validations.check(aCategory_PH == null, retCodeConfig.getNotFoundCategory());
        com.fa.cim.newcore.bo.code.CimCategory aCategory_BH = codeManager.findCategoryNamed(BizConstant.SP_REASONCAT_BANKHOLD);
        Validations.check(aCategory_BH == null, retCodeConfig.getNotFoundCategory());
        for (int i = 0; i < hrLen; i++){
            ProductDTO.HoldRecord holdRecord = strHoldRecords.get(i);
            Infos.LotHoldListAttributes lotHoldListAttributes = new Infos.LotHoldListAttributes();
            lotHoldListAttributesList.add(lotHoldListAttributes);
            lotHoldListAttributes.setHoldType(holdRecord.getHoldType());
            ObjectIdentifier reasonCode = holdRecord.getReasonCode();
            lotHoldListAttributes.setReasonCodeID(reasonCode);
            lotHoldListAttributes.setRelatedLotID(holdRecord.getRelatedLot());
            CimCode aReasonCode;
            if (CimStringUtils.equals(lotHoldListAttributes.getHoldType(), BizConstant.SP_REASONCAT_FUTUREHOLD)){
                aReasonCode = codeMethod.convertCodeIDToCodeOr(aCategory_FH, reasonCode);
            } else if (CimStringUtils.equals(lotHoldListAttributes.getHoldType(), BizConstant.SP_REASONCAT_PROCESSHOLD)){
                aReasonCode = codeMethod.convertCodeIDToCodeOr(aCategory_PH, reasonCode);
            } else if (CimStringUtils.equals(lotHoldListAttributes.getHoldType(), BizConstant.SP_REASONCAT_BANKHOLD)){
                aReasonCode = codeMethod.convertCodeIDToCodeOr(aCategory_BH, reasonCode);
            } else {
                aReasonCode = codeMethod.convertCodeIDToCodeOr(aCategory, reasonCode);
            }
            lotHoldListAttributes.setCodeDescription(aReasonCode.getDescription());
            lotHoldListAttributes.setUserID(holdRecord.getHoldPerson());
            com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, holdRecord.getHoldPerson());
            if(aPerson != null){
                lotHoldListAttributes.setUserName(aPerson.getFullName());
            }
            lotHoldListAttributes.setHoldTimeStamp(holdRecord.getHoldTimeStamp());
            com.fa.cim.newcore.bo.pd.CimProcessOperation aResponsibleProcessOperation = null;
            if (!holdRecord.isResponsibleOperationFlag()){
                lotHoldListAttributes.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                // The current PO is responsible operation.
                aResponsibleProcessOperation = aLot.getProcessOperation();
            } else {
                lotHoldListAttributes.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                com.fa.cim.newcore.bo.pd.CimProcessFlowContext aProcessFlowContext = aLot.getProcessFlowContext();
                Validations.check(aProcessFlowContext == null, new OmCode(retCodeConfig.getNotFoundPfx(), ""));
                aResponsibleProcessOperation = aProcessFlowContext.getPreviousProcessOperation();
            }
            if (aResponsibleProcessOperation != null){
                com.fa.cim.newcore.bo.pd.CimProcessDefinition aMainProcessDefinition = aResponsibleProcessOperation.getMainProcessDefinition();
                lotHoldListAttributes.setResponsibleRouteID(new ObjectIdentifier(aMainProcessDefinition.getIdentifier(), aMainProcessDefinition.getPrimaryKey()));
                lotHoldListAttributes.setResponsibleOperationNumber(aResponsibleProcessOperation.getOperationNumber());
                lotHoldListAttributes.setResponsibleOperationName(aResponsibleProcessOperation.getProcessDefinitionName());
            }
            lotHoldListAttributes.setClaimMemo(holdRecord.getHoldClaimMemo());

            String departmentNamePlate = holdRecord.getDepartmentNamePlate();
            if (CimStringUtils.isNotEmpty(departmentNamePlate)) {
                List<String> departmentAndSection = Arrays.stream(departmentNamePlate.split("\\.", 2)).collect(Collectors.toList());
                if (CimNumberUtils.eq(departmentAndSection.size(), 2)) {
                    lotHoldListAttributes.setDepartment(departmentAndSection.get(0));
                    lotHoldListAttributes.setSection(departmentAndSection.get(1));
                }
            }
        }
        return lotHoldListAttributesList;
    }

    @Override
    public Outputs.ObjLotProcessJobExecFlagValidCheckOut lotProcessJobExecFlagValidCheck(Infos.ObjCommon objCommon, List<Infos.StartCassette> startCassetteList) {
        Outputs.ObjLotProcessJobExecFlagValidCheckOut result = new Outputs.ObjLotProcessJobExecFlagValidCheckOut();

        //【step1】check wafer's processJobExecFlag
        log.debug("【step1】check wafer's processJobExecFlag");
        boolean existFlag = false;
        for (Infos.StartCassette startCassette : startCassetteList) {
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            if (!CimArrayUtils.isEmpty(lotInCassetteList)){
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    Boolean operationStartFlag = lotInCassette.getMoveInFlag();
                    if (CimBooleanUtils.isFalse(operationStartFlag)) {
                        continue;
                    }
                    log.debug("TRUE == operationStartFlag");
                    existFlag = false;
                    for (Infos.LotWafer lotWafer : lotInCassette.getLotWaferList()) {
                        if (CimBooleanUtils.isTrue(lotWafer.getProcessJobExecFlag())) {
                            existFlag = true;
                            break;
                        }
                    }
                    if (!existFlag) {
                        log.debug("FALSE == existFlag");
                        result.setStartCassetteList(startCassetteList);
                        result.setLotID(lotInCassette.getLotID());
                        throw new ServiceException(new OmCode(retCodeConfig.getNoProcessJobExecFlag(), lotInCassette.getLotID().getValue()),result);
                    }
                }
            }
        }
        result.setStartCassetteList(startCassetteList);
        return result;
    }

    @Override
    public void lotCheckConditionForOperation(Infos.ObjCommon objCommon, ObjectIdentifier eqpID, String portGroupID,
                                              List<Infos.StartCassette> startCassetteList, String operation) {

        int startCassetteListSize = CimArrayUtils.getSize(startCassetteList);
        //【step1】check condition for controlJobID, equipmentID, lotXxxxState, entityInhibition, minWaferCount
        log.debug("【step1】check condition for controlJobID, equipmentID, lotXxxxState, entityInhibition, minWaferCount");

        //get pmcmg object for recipe check
        log.debug("get pmcmg object for recipe check");
        CimMachine equipment = baseCoreFactory.getBO(CimMachine.class, eqpID);
        Validations.check(null == equipment, new OmCode(retCodeConfig.getNotFoundEqp(), eqpID.getValue()));

        int i = 0, j = 0;
        if (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)
                || CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)
                || CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation)
                || CimStringUtils.equals(BizConstant.SP_OPERATION_NPWCARRIERXFER, operation)) {
            // check InPostProcessFlag
            log.debug("check InPostProcessFlag");
            for (i = 0; i < startCassetteListSize; i++) {
                Infos.StartCassette startCassetteObj = startCassetteList.get(i);
                // get InPostProcessFlag of cassette
                log.debug("get InPostProcessFlag of cassette");
                Boolean cassetteInPostProcessFlag = cassetteMethod.cassetteInPostProcessFlagGet(objCommon, startCassetteObj.getCassetteID());
                // if cassette is in post process, returns error
                log.debug("if cassette is in post process, returns error");
                Validations.check(cassetteInPostProcessFlag, new OmCode(retCodeConfig.getCassetteInPostProcess(), startCassetteObj.getCassetteID().getValue()));
                // check cassette interfabXfer state
                log.debug("check cassette interFabXfer state");
                String interFabXferState = cassetteMethod.cassetteInterFabXferStateGet(objCommon, startCassetteObj.getCassetteID());
                Validations.check(CimStringUtils.equals(BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING, interFabXferState),
                        new OmCode(retCodeConfig.getInterfabInvalidLotXferstateForReq(), startCassetteObj.getCassetteID().getValue(), interFabXferState));
                int lotInCasetteListSize = CimArrayUtils.getSize(startCassetteObj.getLotInCassetteList());
                for (j = 0; j < lotInCasetteListSize; j++) {
                    Infos.LotInCassette lotInCassetteObj = startCassetteObj.getLotInCassetteList().get(j);
                    if (CimBooleanUtils.isFalse(lotInCassetteObj.getMoveInFlag())) {
                        continue;
                    }
                    // check for interFabXfer state
                    log.debug("check for interFabXfer state");
                    interFabXferState = this.lotInterFabXferStateGet(objCommon, lotInCassetteObj.getLotID());
                    if (CimStringUtils.equals(interFabXferState, BizConstant.SP_INTERFAB_XFERSTATE_REQUIRED)
                            || CimStringUtils.equals(interFabXferState, BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING)) {
                        throw new ServiceException(new OmCode(retCodeConfig.getInterfabInvalidLotXferstateForReq(), lotInCassetteObj.getLotID().getValue(), interFabXferState));
                    }
                }
            }
        }

        /**************************************************************************************************************/
        /* 【step2】check for NPWCarrierXfer                                                                          */
        /*  The foolowing condition is checked.                                                                       */
        /*    - holdState: NotOnHold                                                                                  */
        /*    - inventoryState: InBank                                                                                */
        /*    - finishedState: Completed                                                                              */
        /*    - lot's BankID: same as eqp-defined CtrlBank                                                            */
        /**************************************************************************************************************/
        log.debug("【step2】check for NPWCarrierXfer");
        if (CimStringUtils.equals(BizConstant.SP_OPERATION_NPWCARRIERXFER, operation)) {
            //get eqp's port information
            log.debug("get eqp's port information, the eqpID:%s", eqpID);
            Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, eqpID);
            //get eqp's controlBank information
            log.debug("get eqp's controlBank information");
            Outputs.ObjEquipmentBankIDGetOut bankIDGetOut = equipmentMethod.equipmentBankIDGet(objCommon, eqpID);
            for (i = 0; i < startCassetteListSize; i++) {
                Infos.StartCassette startCassetteObj = startCassetteList.get(i);
                // get assigned port's loadPurposeType
                log.debug("get assigned port's loadPurposeType");
                String portLoadPurposeType = null;
                int eqpPortStatusSize = CimArrayUtils.getSize(eqpPortInfo.getEqpPortStatuses());
                int p = 0;
                for (p = 0; p < eqpPortStatusSize; p++) {
                    Infos.EqpPortStatus eqpPortStatus = eqpPortInfo.getEqpPortStatuses().get(p);
                    if (CimStringUtils.equals(startCassetteObj.getLoadPortID().getValue(), eqpPortStatus.getPortID().getValue())) {
                        portLoadPurposeType = eqpPortStatus.getLoadPurposeType();
                        break;
                    }
                }
                if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_OTHER, portLoadPurposeType)) {
                    continue;
                }
                if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_PROCESSLOT, portLoadPurposeType)
                        || CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT, portLoadPurposeType)
                        || CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE, portLoadPurposeType)
                        || CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_ANY, portLoadPurposeType)) {
                    if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_PROCESSLOT, portLoadPurposeType)
                            && CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING, startCassetteObj.getLoadPurposeType())) {
                        continue;
                    }
                    throw new ServiceException(new OmCode(retCodeConfig.getInvalidPortLoadPurposeForNpwTransfer(), portLoadPurposeType));
                } else {
                    Validations.check(!CimStringUtils.equals(portLoadPurposeType, startCassetteObj.getLoadPurposeType()),
                            new OmCode(retCodeConfig.getNotSameLoadPurpose(), startCassetteObj.getCassetteID().getValue(), startCassetteObj.getLoadPurposeType(), startCassetteObj.getLoadPortID().getValue(), portLoadPurposeType));
                    int lotInCassetteListSize = CimArrayUtils.getSize(startCassetteObj.getLotInCassetteList());
                    for (j = 0; j < lotInCassetteListSize; j++) {
                        Infos.LotInCassette lotInCassetteObj = startCassetteObj.getLotInCassetteList().get(j);
                        //get lot object
                        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotInCassetteObj.getLotID());
                        Validations.check(lot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotInCassetteObj.getLotID().getValue()));
                        //  get and check lot's XXXstate
                        // check holdState
                        log.debug("check holdState");
                        String holdState = lot.getLotHoldState();
                        if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, holdState)) {
                            ObjectIdentifier lotID = new ObjectIdentifier(lot.getIdentifier(), lot.getPrimaryKey());
                            throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotHoldStat(), lotID.getValue(), holdState));
                        }
                        // check inventoryState
                        log.debug("check inventoryState");
                        String inventoryState = lot.getLotInventoryState();
                        if (!CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_INBANK, inventoryState)) {
                            ObjectIdentifier lotID = new ObjectIdentifier(lot.getIdentifier(), lot.getPrimaryKey());
                            Validations.check(retCodeConfig.getInvalidLotInventoryStat(), ObjectIdentifier.fetchValue(lotID),
                                    inventoryState);
                        }
                        // check finishState
                        log.debug("check finishState");
                        String finishedState = lot.getLotFinishedState();
                        if (!CimStringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_COMPLETED, finishedState)) {
                            throw new ServiceException(new OmCode(retCodeConfig.getInvalidFinishedStat(), finishedState));
                        }
                        // get and check lot's bankID
                        log.debug("get and check lot's bankID");
                        com.fa.cim.newcore.bo.factory.CimBank bank = lot.getBank();
                        Validations.check(bank == null, new OmCode(retCodeConfig.getNotFoundBank(), ""));

                        ObjectIdentifier lotBankID = new ObjectIdentifier(bank.getIdentifier(), bank.getPrimaryKey());
                        if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT, startCassetteObj.getLoadPurposeType())) {
                            Validations.check(!ObjectIdentifier.equalsWithValue(lotBankID, bankIDGetOut.getSideDummyBankID()),
                                    new OmCode(retCodeConfig.getLotBankDifferent(), lotBankID.getValue(), bankIDGetOut.getSideDummyBankID().getValue()));
                        } else if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY, startCassetteObj.getLoadPurposeType())) {
                            Validations.check(!ObjectIdentifier.equalsWithValue(lotBankID, bankIDGetOut.getFillerDummyBankID()),
                                    new OmCode(retCodeConfig.getLotBankDifferent(), lotBankID.getValue(), bankIDGetOut.getFillerDummyBankID().getValue()));
                        } else if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT, startCassetteObj.getLoadPurposeType())) {
                            Validations.check(!ObjectIdentifier.equalsWithValue(lotBankID, bankIDGetOut.getMonitorBankID()),
                                    new OmCode(retCodeConfig.getLotBankDifferent(), lotBankID.getValue(), bankIDGetOut.getMonitorBankID().getValue()));
                        } else {
                            throw new ServiceException(retCodeConfig.getInvalidInputParam());
                        }
                    }
                }
            } // end for for (i = 0; i < startCassetteListSize; i++) {...}

            // check eqp availability
            log.debug("check eqp availability");
            equipmentMethod.equipmentCheckAvail(objCommon, eqpID);
            log.debug("eqp is now available. Go ahead!!");
            //--------------------------------------------------------
            //   Lot related check for NPWCarrierXfer is Finished
            //   return to caller with RC_OK ...
            //--------------------------------------------------------
            return;
        }
        //【step4】get eqp's multiRecipeCapability for recipe check
        String multiRecipeCapability = equipment.getMultipleRecipeCapability();
        log.debug("【step4】get eqp's multiRecipeCapability for recipe check");
        Outputs.ObjEquipmentProcessBatchConditionGetOut conditionGetOut = equipmentMethod.equipmentProcessBatchConditionGet(objCommon, eqpID);
        //【step5】get eqp's reserved control Job ID
        log.debug("【step5】get eqp's reserved control Job ID");
        List<Infos.StartReservedControlJobInfo> startReservedControlJobInfos = equipmentMethod.equipmentReservedControlJobIDGet(objCommon, eqpID);
        int reservedControlJobInfoSize = CimArrayUtils.getSize(startReservedControlJobInfos);

        ObjectIdentifier eqpControlJobID = null;
        for (i = 0; i < reservedControlJobInfoSize; i++) {
            ObjectIdentifier controlJobID = startReservedControlJobInfos.get(i).getControlJobID();
            String tmpPortGroupID = startReservedControlJobInfos.get(i).getPortGroupID();
            if (CimStringUtils.equals(tmpPortGroupID, portGroupID)) {
                eqpControlJobID = controlJobID;
                break;
            }
        }

        // get eqp category
        String eqpCategory = equipment.getCategory();

        //【step6】check lot condition
        log.debug("【step6】check lot condition");
        long totalWaferCount = 0;
        long operationLotCount = 0;

        boolean baseRecipeSetFlag = false;
        String baseLogicalRecipeID = null;
        String baseMachineRecipeID = null;
        for (i = 0; i < startCassetteListSize; i++) {
            int lotInCassetteListSize = CimArrayUtils.isEmpty(startCassetteList.get(i).getLotInCassetteList())
                    ? 0 : startCassetteList.get(i).getLotInCassetteList().size();
            for (j = 0; j < lotInCassetteListSize; j++) {
                Infos.LotInCassette lotInCassetteObj = startCassetteList.get(i).getLotInCassetteList().get(j);
                // check OpeStartFlag for Batch-Type Eqp
                log.debug("check OpeStartFlag for Batch-Type Eqp");
                if (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation)) {
                    if (CimStringUtils.equals(BizConstant.SP_EQP_MULTIRECIPECAPABILITY_BATCH, multiRecipeCapability)
                            && !lotInCassetteObj.getMoveInFlag()) {
                        throw new ServiceException(retCodeConfig.getNeedToSpecifyAllLotInCassette());
                    }
                }
                //omit not process lot
                log.debug("omit not process lot");
                if (!lotInCassetteObj.getMoveInFlag()) {
                    log.debug("operationStartFlag == FALSE, continue");
                    continue;
                }
                CimLot lot = baseCoreFactory.getBO(CimLot.class, lotInCassetteObj.getLotID());
                Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), lotInCassetteObj.getLotID().getValue()));
                CimControlJob controlJob = lot.getControlJob();
                if (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)) {
                    ObjectIdentifier lotControlJobID = CimObjectUtils.isEmpty(controlJob) ? null : new ObjectIdentifier(controlJob.getIdentifier(), controlJob.getPrimaryKey());
                    Validations.check(!ObjectIdentifier.equalsWithValue(lotControlJobID, eqpControlJobID), retCodeConfig.getLotPortControlJobUnMatch());
                } else {
                    if (null != controlJob) {
                        ObjectIdentifier lotID = new ObjectIdentifier(lot.getIdentifier(), lot.getPrimaryKey());
                        ObjectIdentifier jobID = new ObjectIdentifier(controlJob.getIdentifier(), controlJob.getPrimaryKey());
                        throw new ServiceException(new OmCode(retCodeConfig.getLotControlJobidFilled(), lotID.getValue(), jobID.getValue()));
                    }
                }
                // get and check lot's state
                log.debug("get and check lot's state");
                String holdState = lot.getLotHoldState();
                String processState = lot.getLotProcessState();
                String inventoryState = lot.getLotInventoryState();
                if (!CimStringUtils.equals(BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL, operation)
                        && !CimStringUtils.equals(BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE, operation)
                        && !CimStringUtils.equals(BizConstant.SP_OPERATION_NPWCARRIERXFER, operation)) {
                    if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, holdState)) {
                        ObjectIdentifier lotID = new ObjectIdentifier(lot.getIdentifier(), lot.getPrimaryKey());
                        throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotHoldStat(), lotID.getValue(), holdState));
                    }
                }
                if (CimStringUtils.equals(BizConstant.SP_OPERATION_NPWCARRIERXFER, operation)) {
                    if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING, processState)) {
                        ObjectIdentifier lotID = new ObjectIdentifier(lot.getIdentifier(), lot.getPrimaryKey());
                        throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotProcessState(), lotID.getValue(), processState));
                    }
                } else {
                    if (!CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_WAITING, processState)) {
                        Validations.check(retCodeConfig.getInvalidLotProcessState(), lot.getIdentifier(), processState);
                    }
                    if (!CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR, inventoryState)) {
                        Validations.check(retCodeConfig.getInvalidLotInventoryStat(), lot.getIdentifier(), inventoryState);
                    }
                }

                //【step7】check EqpMonitor Job for CassetteDelivery/StartReservation/OpeStart
                log.debug("【step7】check EqpMonitor Job for CassetteDelivery/StartReservation/OpeStart");
                String eqpMonitorSwitch = StandardProperties.OM_AUTOMON_FLAG.getValue();
                if (CimStringUtils.equals(eqpMonitorSwitch, "1")
                        && (CimStringUtils.equals(BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT, lotInCassetteObj.getLotType())
                        || CimStringUtils.equals(BizConstant.SP_LOT_TYPE_DUMMYLOT, lotInCassetteObj.getLotType()))
                        && (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation))) {
                    log.debug("checking EqpMonitor Job.");
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut objEquipmentMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassetteObj.getLotID());
                    if (CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR, objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel())) {
                        log.debug("operation label is Monitor");
                        ProductDTO.EqpMonitorJobLotInfo equipmentMonitorJobLotInfo = lot.getEqpMonitorJobLotInfo();
                        if (!ObjectIdentifier.equalsWithValue(eqpID, equipmentMonitorJobLotInfo.getEquipmentID())) {
                            throw new ServiceException(new OmCode(retCodeConfig.getDiffEquipmentMonitorJobEquipmentID(), lotInCassetteObj.getLotID().getValue()));

                        }
                        ObjectIdentifier eqpMonitorID = equipmentMonitorJobLotInfo.getEqpMonitorID();
                        ObjectIdentifier eqpMonitorJobID = equipmentMonitorJobLotInfo.getEqpMonitorJobID();
                        Long startSequenceNo = equipmentMonitorJobLotInfo.getStartSeqNo();
                        CimEqpMonitor eqpMonitor = baseCoreFactory.getBO(CimEqpMonitor.class, eqpMonitorID);
                        Validations.check(eqpMonitor == null, new OmCode(retCodeConfig.getNotFoundEqpMonitor(), eqpMonitorID.getValue()));
                        CimEqpMonitorJob eqpMonitorJob = baseCoreFactory.getBO(CimEqpMonitorJob.class, eqpMonitorJobID);
                        Validations.check(eqpMonitorJob == null, new OmCode(retCodeConfig.getNotFoundEqpMonitorJob(), eqpMonitorJobID.getValue()));
                        String eqpMonitorJobStatus = eqpMonitorJob.getMonitorJobStatus();
                        if (!CimStringUtils.equals(BizConstant.SP_EQPMONITORJOB_STATUS_READY, eqpMonitorJobStatus)
                                && !CimStringUtils.equals(BizConstant.SP_EQPMONITORJOB_STATUS_EXECUTING, eqpMonitorJobStatus)) {
                            log.error("EqpMonitorJobStatus is not Ready or Executing");
                            throw new ServiceException(new OmCode(retCodeConfig.getInvalidEqpMonitorJobStatus(), eqpMonitorJobStatus));
                        }
                        // check start Sequences
                        List<MachineDTO.EqpMonitorLotInfo> eqpMonitorJobLotInfoList = eqpMonitorJob.allEqpMonitorLots();
                        if (!CimArrayUtils.isEmpty(eqpMonitorJobLotInfoList)) {
                            for (MachineDTO.EqpMonitorLotInfo eqpMonitorJobLotInfo : eqpMonitorJobLotInfoList) {
                                if (CimStringUtils.equals(BizConstant.SP_EQPMONITORJOB_STATUS_RESERVED, eqpMonitorJobLotInfo.getMonitorLotStatus())) {
                                    log.debug("monitor lot status is Reserved.");
                                    //startSeqNo should be the minimum value
                                    long startSeqNo = null == eqpMonitorJobLotInfo.getStartSeqNo() ? 0 : eqpMonitorJobLotInfo.getStartSeqNo();
                                    if (startSequenceNo > startSeqNo) {
                                        log.error("startSeqNo is not the minimum value.");
                                        throw new ServiceException(retCodeConfig.getMismatchEqpMonitorStartSeq());
                                    }
                                }
                            }
                        }
                    }
                } // end if ("1".equals(..) {...}

                //【step8】check start eqp for opeStart/StartReservation
                log.debug("【step8】check start eqp for opeStart/StartReservation");
                if (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation)) {
                    log.debug("operation is [OpeStart] or [StartReserve] or [CassetteDelivery]");
                    // get queued pmcmg
                    log.debug("get queued pmcmg");
                    List<CimMachine> machineSequence = lot.getQueuedMachines();
                    //check eqp ID
                    boolean matchFlag = false;
                    if (CimArrayUtils.isEmpty(machineSequence)) {
                        throw new ServiceException(retCodeConfig.getNotCorrectEqpForOperationStart());
                    }
                    for (CimMachine lotEquipment : machineSequence) {
                        if (ObjectIdentifier.equalsWithValue(eqpID, lotEquipment.getIdentifier())) {
                            matchFlag = true;
                            break;
                        }
                    }

                    if (!matchFlag) {
                        throw new ServiceException(retCodeConfig.getNotCorrectEqpForOperationStart());
                    }
                    //add by Neyo
                    /*--------------------------------------------------------*/
                    /*   Check Current Operation is Bank-In Operation or Not  */
                    /*--------------------------------------------------------*/
                    boolean bankInFlag = lot.isBankInRequired();
                    if (bankInFlag) {
                        throw new ServiceException(retCodeConfig.getBankinOperation());
                    }
                }
                //【step9】check eqp availability
                log.debug("【step9】check eqp availability");
                if (!CimStringUtils.equals(BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL, operation)
                        && !CimStringUtils.equals(BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE, operation)
                        && !CimStringUtils.equals(BizConstant.SP_OPERATION_NPWCARRIERXFER, operation)) {
                    // get and check eqp availability for lot
                    List<ObjectIdentifier> checkLotIDList = new ArrayList<>();
                    checkLotIDList.add(lotInCassetteObj.getLotID());
                    equipmentMethod.equipmentCheckAvailForLot(objCommon, eqpID, checkLotIDList);

                    // save total wafer count
                    totalWaferCount += lotInCassetteObj.getLotWaferList().size();
                }
                //【step10】check condition for logical recipe /pmcmg recipe
                log.debug("【step10】check condition for logical recipe /pmcmg recipe");
                if (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation)) {
                    log.debug("operation is [OpeStart] or [StartReserve] or [CassetteDelivery]");
                    if (!CimStringUtils.equals(BizConstant.SP_EQP_MULTIRECIPECAPABILITY_MULTIPLERECIPE, multiRecipeCapability)) {
                        if (!baseRecipeSetFlag) {
                            baseLogicalRecipeID = lotInCassetteObj.getStartRecipe().getLogicalRecipeID().getValue();
                            baseMachineRecipeID = lotInCassetteObj.getStartRecipe().getMachineRecipeID().getValue();
                            baseRecipeSetFlag = true;
                        } else {
                            ObjectIdentifier logicalRecipeID = lotInCassetteObj.getStartRecipe().getLogicalRecipeID();
                            ObjectIdentifier machineRecipeID = lotInCassetteObj.getStartRecipe().getMachineRecipeID();
                            if (ObjectIdentifier.equalsWithValue(baseMachineRecipeID, machineRecipeID)
                                    && ObjectIdentifier.equalsWithValue(baseLogicalRecipeID, logicalRecipeID)) {
                                log.debug("logicalRecipe / MachineRecipe is same as baseRecipe");
                            } else {
                                log.debug("logicalRecipe / MachineRecipe is not same as baseRecipe");
                                throw new ServiceException(retCodeConfig.getInvalidRecipeConditionForEqp());
                            }
                        }
                    }
                    // check if the recipe ia available on eqp. this check is skipped when recipe is overwritten by DOC.
                    log.debug("check if the recipe ia available on eqp. this check is skipped when recipe is overwritten by DOC.");
                    String tmp = StandardProperties.OM_DOC_ENABLE_FLAG.getValue();
                    long tmpFPCAdopFlag = CimNumberUtils.intValue(tmp);
                    boolean fpcFlag = false;
                    if (1 == tmpFPCAdopFlag) {
                        Outputs.ObjLotEffectiveFPCInfoGetOut fpcInfoGetOut = this.lotEffectiveFPCInfoGet(objCommon,
                                BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEINFO, eqpID, lotInCassetteObj.getLotID());
                        if (fpcInfoGetOut.isMachineRecipeActionRequiredFlag()) {
                            fpcFlag = true;
                        }
                    }
                    if (!fpcFlag) {
                        com.fa.cim.newcore.bo.recipe.CimMachineRecipe aMachineRecipe = baseCoreFactory.getBO(com.fa.cim.newcore.bo.recipe.CimMachineRecipe.class, lotInCassetteObj.getStartRecipe().getMachineRecipeID());
                        Validations.check(aMachineRecipe == null, new OmCode(retCodeConfig.getNotFoundMachineRecipe()));
                        boolean usedFlag = aMachineRecipe.isUsedBy(equipment);
                        Validations.check(!usedFlag, new OmCode(retCodeConfig.getInvalidRecipeForEqp(), lotInCassetteObj.getStartRecipe().getMachineRecipeID().getValue(), eqpID.getValue()));
                    }
                    //【step10】check condition for recipe/chamber
                    log.debug("【step10】check condition for recipe/chamber");
                    String chamberCheckPolicyStr = StandardProperties.OM_CHAMBER_CHK_RULE.getValue();
                    int tempChamberCheckPolicy = CimNumberUtils.intValue(chamberCheckPolicyStr);
                    if (1 == tempChamberCheckPolicy) {
                        //check chamber condition for logical recipe and recipe, 1)chamber status 2)conditional available
                        log.debug("check chamber condition for logical recipe and recipe. 1)chamber status 2)conditional available");
                        Inputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn in = new Inputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn();
                        in.setLotID(lotInCassetteObj.getLotID());
                        in.setEquipmentID(eqpID);
                        in.setLogicalRecipeID(lotInCassetteObj.getStartRecipe().getLogicalRecipeID());
                        in.setMachineRecipeID(lotInCassetteObj.getStartRecipe().getMachineRecipeID());
                        in.setInhibitCheckFlag(false);
                        Outputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut objLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut = logicalRecipeMethod.logicalRecipeCandidateChamberInfoGetByMachineRecipe(objCommon, in);
                        if (objLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut.isMultiChamberFlag()) {
                            // multiple chamber case
                            if (objLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut.isRecipeDefinedFlag() && CimArrayUtils.isEmpty(objLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut.getCandidateChamberList())) {
                                log.debug("pmcmg recipe is defined in logical recipe, but there is no available chamber");
                                throw new ServiceException(new OmCode(retCodeConfig.getChamberNotAvailableForLot(), lotInCassetteObj.getLotID().getValue()));
                            }
                        } else {
                            // Following 2 cases
                            // 1. Machine recipe isn't defined in logical recipe.
                            // 2. Machine recipe is defined in logical recipe and chambers are found which meets following condition
                            //    - Chamber Status
                            //    - Conditional available
                            log.debug("recipe/chamber check OK");
                        }
                    } else {
                        log.debug("not multiple chamber");
                    }
                }
                //【step11】check validity of In-Parm's route/operationNumber/logicalRecipe - (line:1520)
                log.debug("【step11】check validity of In-Parm's route/operationNumber/logicalRecipe");
                if (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation)) {
                    log.debug("operation is [OpeStart] or [StartReserve] or [CassetteDelivery]");
                    if (!ObjectIdentifier.isEmptyWithValue(lotInCassetteObj.getStartOperationInfo().getProcessFlowID())
                            && !CimStringUtils.isEmpty(lotInCassetteObj.getStartOperationInfo().getOperationNumber())) {
                        Outputs.ObjLotCurrentOperationInfoGetOut infoGetDROut = this.lotCurrentOperationInfoGet(objCommon, lotInCassetteObj.getLotID());
                        if (ObjectIdentifier.equalsWithValue(lotInCassetteObj.getStartOperationInfo().getProcessFlowID(), infoGetDROut.getRouteID())
                                && CimStringUtils.equals(lotInCassetteObj.getStartOperationInfo().getOperationNumber(), infoGetDROut.getOperationNumber())) {
                            log.debug("Route/Operation check OK. Go ahead...");
                        } else {
                            log.debug("Route/Operation check NG.");
                            throw new ServiceException(retCodeConfig.getInvalidInputParam());
                        }
                    } else {
                        log.debug("Route/Operation check skipped. Go ahead...");
                    }

                    //【step12】check logical recipe
                    log.debug("【step12】check logical recipe");
                    if (!ObjectIdentifier.isEmptyWithValue(lotInCassetteObj.getStartRecipe().getLogicalRecipeID())) {
                        Outputs.ObjLotRecipeGetOut recipeGetOut = this.lotRecipeGet(objCommon, eqpID, lotInCassetteObj.getLotID());
                        Validations.check(!ObjectIdentifier.equalsWithValue(lotInCassetteObj.getStartRecipe().getLogicalRecipeID(), recipeGetOut.getLogicalRecipeId()),
                                retCodeConfig.getInvalidInputParam());
                    } else {
                        log.debug("logicalrecipe check skipped. Go ahead...");
                    }
                }

                //【step13】check lot condition in Bonding Flow Section
                log.debug("【step13】check lot condition in Bonding Flow Section");
                if (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)
                        || CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation)) {
                    log.debug("operation is [OpeStart] or [StartReserve]");
                    // get Bonding Flow Section Name
                    String bondFlowName = lot.getBondingFlowName();
                    if (!CimStringUtils.isEmpty(bondFlowName)) {
                        //get bonding groupID
                        String bondingGroupID = this.lotBondingGroupIDGetDR(objCommon, lotInCassetteObj.getLotID());
                        if (CimStringUtils.isEmpty(bondingGroupID)) {
                            log.error("#### Error ### lot should be reserved to one Bonding Group.");
                            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundBondingGroupForLot(), lotInCassetteObj.getLotID().getValue()));
                        } else {
                            log.debug("#### lot is reserved to Bonding Group.");
                            com.fa.cim.newcore.bo.pd.CimProcessOperation aPosPO = lot.getProcessOperation();
                            Validations.check(aPosPO == null, new OmCode(retCodeConfig.getNotFoundProcessOperation(), "", lotInCassetteObj.getLotID().getValue()));
                            // check target operation of bonding flow section
                            String operationNo = aPosPO.getOperationNumber();
                            boolean validEqpForBondingFlow = true;
                            // check for target operation
                            // if lot is in target operation in bonding flow section. eqp category should be SP_Mc_Category_WaferBonding
                            if (aPosPO.isBondingFlowSectionTargetOperation()
                                    && !CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERBONDING, eqpCategory)) {
                                validEqpForBondingFlow = false;
                            }
                            if (!aPosPO.isBondingFlowSectionTargetOperation()
                                    && CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERBONDING, eqpCategory)) {
                                validEqpForBondingFlow = false;
                            } else {
                                log.debug("OK. bValidEqpForBndFlow = TRUE");
                            }
                            if (!validEqpForBondingFlow) {
                                throw new ServiceException(new OmCode(retCodeConfig.getBondGroupInvalidEqp(), lotInCassetteObj.getLotID().getValue(), eqpID.getValue(), operationNo));
                            }
                        }
                    }
                }
            }
        }
        if (!CimStringUtils.equals(BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL, operation)
                && !CimStringUtils.equals(BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE, operation)
                && !CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)
                && !CimStringUtils.equals(BizConstant.SP_OPERATION_NPWCARRIERXFER, operation)) {
            // check minium wafer count
            if (conditionGetOut.getMinWaferSize() > totalWaferCount) {
                throw new ServiceException(retCodeConfig.getInvalidInputWaferCount());
            }
        }
        //【step14】get and check entity inhibition for opeStart /StartReservation
        log.debug("【step14】get and check entity inhibition for opeStart /StartReservation");
        if (CimStringUtils.equals(BizConstant.SP_OPERATION_OPESTART, operation)
                || CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)
                || CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation)) {
            log.debug("operation is [OpeStart] or [StartReserve] or [CassetteDelivery]");
            boolean inhibitCheck = true;
            if (CimStringUtils.equals(BizConstant.SP_OPERATION_CASSETTEDELIVERY, operation)) {
                String inhibitCheckDeliveryFlag = StandardProperties.OM_CONSTRAINT_CHK_FOR_DELIVERY.getValue();
                if ("0".equals(inhibitCheckDeliveryFlag)) {
                    inhibitCheck = false;
                }
            }
            if (inhibitCheck) {
                List<ObjectIdentifier> checkLotIDList = new ArrayList<>();
                for (int k = 0; k < startCassetteListSize; k++) {
                    Infos.StartCassette startCassette = startCassetteList.get(k);
                    int size = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                    for (int l = 0; l < size; l++) {
                        Infos.LotInCassette lotInCassette = startCassetteList.get(k).getLotInCassetteList().get(l);
                        if (lotInCassette.getMoveInFlag()) {
                            checkLotIDList.add(lotInCassette.getLotID());
                        }
                    }
                }
                equipmentMethod.equipmentCheckInhibitForLotWithMachineRecipe(objCommon, eqpID, checkLotIDList, startCassetteList);
            }
        }
    }

    @Override
    public List<ObjectIdentifier> lotWaferIDListGetDR(Infos.ObjCommon objCommon, Inputs.ObjLotWaferIDListGetDRIn objLotWaferIDListGetDRIn) {
        List<ObjectIdentifier> waferIDs = new ArrayList<>();
        boolean scrapCheckFlag = objLotWaferIDListGetDRIn.getScrapCheckFlag();
        String lotId = objLotWaferIDListGetDRIn.getLotID().getValue();
        int hCount;
        if (scrapCheckFlag) {
            String querySql = String.format("SELECT COUNT(ID)\n" +
                    "                     FROM   OMWAFER\n" +
                    "                     WHERE  LOT_ID = '%s'\n" +
                    "                       AND  SCRAP_STATE <> '%s'\n" +
                    "                       AND  SCRAP_STATE <> '%s'",
                    lotId, BizConstant.SP_SCRAPSTATE_SCRAP, BizConstant.SP_SCRAPSTATE_GARBAGE);
            hCount = (int)cimJpaRepository.count(querySql);
        } else {
            String querySql = String.format("SELECT COUNT(ID)\n" +
                    "                     FROM   OMWAFER\n" +
                    "                     WHERE  LOT_ID = '%s'", lotId);
            hCount = (int)cimJpaRepository.count(querySql);
        }

        if (hCount <= 0){
            // there's no wafer found in the Lot_ID
            log.info("wafer count <= 0");
        }else{
            String querySql;
            if (scrapCheckFlag){
                querySql = String.format("SELECT ID,\n" +
                                "                           WAFER_ID\n" +
                                "                    FROM OMWAFER\n" +
                                "                    WHERE  LOT_ID = '%s'\n" +
                                "                      AND  SCRAP_STATE <> '%s'\n" +
                                "                      AND  SCRAP_STATE <> '%s'\n" +
                                "                    ORDER BY POSITION",
                        lotId, BizConstant.SP_SCRAPSTATE_SCRAP, BizConstant.SP_SCRAPSTATE_GARBAGE);
            } else {
                querySql = String.format(" SELECT ID,\n" +
                        "                           WAFER_ID\n" +
                        "                    FROM OMWAFER\n" +
                        "                    WHERE  LOT_ID = '%s'\n" +
                        "                    ORDER BY POSITION", lotId);
            }
            List<CimWaferDO> waferList = cimJpaRepository.query(querySql, CimWaferDO.class);

            for (CimWaferDO cimWafer : waferList){
                waferIDs.add(new ObjectIdentifier(cimWafer.getWaferID(), cimWafer.getId()));
                log.info("{} waferID =  {}", waferIDs.size(), cimWafer.getWaferID());
            }

        }

        if (CimArrayUtils.getSize(waferIDs) <= 0){
            int quantity;

            Object[] sqlResult = cimJpaRepository.queryOne("SELECT QTY\n" +
                    "                     FROM OMLOT\n" +
                    "                     WHERE LOT_ID = ?", lotId);

            quantity = Integer.parseInt(CimObjectUtils.toString(sqlResult[0]));

            if (quantity > 0){
                /*--------------------------*/
                /*   Get max wafer in lot   */
                /*--------------------------*/
                int compValue;
                int lMaxWfr = StandardProperties.OM_MAX_WAFER_COUNT_FOR_LOT.getIntValue();
                if (lMaxWfr > 0){
                    compValue = lMaxWfr;
                } else {
                    compValue = BizConstant.SP_LOT_MAXIMUMWAFERSINALOT;
                }
                quantity = Math.min(quantity, compValue);
                for (int cnt = 0; cnt < quantity; cnt++){
                    waferIDs.add(new ObjectIdentifier());
                }
            }
        }
        return waferIDs;
    }

    @Deprecated
    private Infos.WhatNextEquipmentInfoInfo whatNextEquipmentInfo(CimEquipmentDO equipment) {
        // result init
        Infos.WhatNextEquipmentInfoInfo out = new Infos.WhatNextEquipmentInfoInfo();

        out.setEquipmentID(new ObjectIdentifier(equipment.getEquipmentID(), equipment.getId()));
        out.setEquipmentCategory(equipment.getEquipmentCategory());
        String cimEnvironmentVariableBO = StandardProperties.OM_UPDATE_LAST_USED_RECIPE.getValue();
        String environmentVariable = cimEnvironmentVariableBO;
        log.info("environmentVariable = {}", environmentVariable);

        if (!BizConstant.CONSTANT_QUANTITY_ONE.equals(environmentVariable)) {
            log.info("set recipeID");
            out.setLastRecipeID(new ObjectIdentifier(equipment.getUsedRecipeID(), equipment.getUsedRecipeObj()));
        }
        out.setProcessRunSizeMaximum(equipment.getBatchSizeMax());
        out.setProcessRunSizeMinimum(equipment.getBatchSizeMin());
        Boolean bondingEqpFlag = false;
        if (CIMStateConst.CIM_MC_CATEGORY_WAFER_BONDING.equals(equipment.getEquipmentCategory())) {
            log.info("Equipment Category is SP_Mc_Category_WaferBonding");
            bondingEqpFlag = true;
        }
        out.setBondingEqpFlag(bondingEqpFlag);
        return out;
    }

    @Override
    public Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut lotFutureHoldRequestsDeleteEffectedByCondition(Infos.ObjCommon objCommon, ObjectIdentifier lotID, Infos.EffectCondition effectCondition) {

        Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut out = new Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(lot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        //------------------------------------------------------------------------------
        // Check if the future hold request exits. If it doesn't exist, return RC_OK.
        //------------------------------------------------------------------------------
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aProcessDefinition = lot.getMainProcessDefinition();
        Validations.check(aProcessDefinition == null, new OmCode(retCodeConfig.getNotFoundProcessDefinition()));
        List<ProductDTO.FutureHoldRecord> aFutureHoldRecordSequence = lot.findFutureHoldRecordsFor(aProcessDefinition, lot.getOperationNumber());
        out.setLotID(lotID);
        if (!CimArrayUtils.isEmpty(aFutureHoldRecordSequence)) {
            Boolean postFlag = false;
            Boolean singleTriggerFlag = false;
            String phase = effectCondition.getPhase();
            String triggerLevel = effectCondition.getTriggerLevel();
            if (BizConstant.SP_FUTUREHOLD_POST.equals(phase)) {
                postFlag = true;
            }
            if (BizConstant.SP_FUTUREHOLD_SINGLE.equals(triggerLevel)) {
                singleTriggerFlag = true;
            }
            List<Infos.LotHoldReq> lotHoldReqs = new ArrayList<>();
            for (ProductDTO.FutureHoldRecord lotFutureHold : aFutureHoldRecordSequence) {
                if ((BizConstant.SP_FUTUREHOLD_ALL.equals(phase) || postFlag.equals(lotFutureHold.isPostFlag()))
                        && (BizConstant.SP_FUTUREHOLD_ALL.equals(triggerLevel) || singleTriggerFlag.equals(lotFutureHold.isSingleTriggerFlag()))) {
                    Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                    lotHoldReq.setHoldType(lotFutureHold.getHoldType());
                    lotHoldReq.setHoldReasonCodeID(lotFutureHold.getReasonCode());
                    lotHoldReq.setHoldUserID(lotFutureHold.getRequestPerson());
                    lotHoldReq.setRouteID(lotFutureHold.getMainProcessDefinition());
                    lotHoldReq.setOperationNumber(lot.getOperationNumber());
                    lotHoldReq.setRelatedLotID(lotFutureHold.getRelatedLot());
                    lotHoldReq.setClaimMemo(lotFutureHold.getClaimMemo());
                    lotHoldReqs.add(lotHoldReq);
                }
            }
            out.setStrFutureHoldReleaseReqList(lotHoldReqs);
        }
        return out;
    }

    @Override
    public Outputs.ObjLotFutureHoldRequestsEffectByConditionOut lotFutureHoldRequestsEffectByCondition
            (Infos.ObjCommon objCommon, ObjectIdentifier lotID, Infos.EffectCondition effectCondition) {

        Outputs.ObjLotFutureHoldRequestsEffectByConditionOut out = new Outputs.ObjLotFutureHoldRequestsEffectByConditionOut();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(lot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aProcessDefinition = lot.getMainProcessDefinition();
        Validations.check(aProcessDefinition == null, new OmCode(retCodeConfig.getNotFoundProcessDefinition()));
        String operationNumber = lot.getOperationNumber();
        //aFutureHoldRecordSequence = aLot->findFutureHoldRecordsFor(aProcessDefinition, OperationNumber) ;
        List<ProductDTO.FutureHoldRecord> aFutureHoldRecordSequence = lot.findFutureHoldRecordsFor(aProcessDefinition, operationNumber);
        out.setLotID(lotID);
        if (!CimArrayUtils.isEmpty(aFutureHoldRecordSequence)) {
            Boolean postFlag = false;
            Boolean singleTriggerFlag = false;
            String phase = effectCondition.getPhase();
            String triggerLevel = effectCondition.getTriggerLevel();
            if (BizConstant.SP_FUTUREHOLD_POST.equals(phase)) {
                postFlag = true;
            }
            if (BizConstant.SP_FUTUREHOLD_SINGLE.equals(triggerLevel)) {
                singleTriggerFlag = true;
            }
            List<Infos.LotHoldReq> lotHoldReqs = new ArrayList<>();

            for (ProductDTO.FutureHoldRecord lotFutureHold : aFutureHoldRecordSequence) {
                if ((BizConstant.SP_FUTUREHOLD_ALL.equals(phase) || postFlag.equals(lotFutureHold.isPostFlag()))
                        && (BizConstant.SP_FUTUREHOLD_ALL.equals(triggerLevel) || singleTriggerFlag.equals(lotFutureHold.isSingleTriggerFlag()))) {
                    Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                    lotHoldReq.setHoldType(lotFutureHold.getHoldType());
                    lotHoldReq.setHoldReasonCodeID(lotFutureHold.getReasonCode());
                    lotHoldReq.setHoldUserID(lotFutureHold.getRequestPerson());
                    lotHoldReq.setResponsibleOperationMark(CimBooleanUtils.isTrue(lotFutureHold.isPostFlag()) ? BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS : BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                    lotHoldReq.setRelatedLotID(lotFutureHold.getRelatedLot());
                    lotHoldReq.setClaimMemo(lotFutureHold.getClaimMemo());
                    String departmentNamePlate = lotFutureHold.getDepartmentNamePlate();
                    if (CimStringUtils.isNotEmpty(departmentNamePlate)) {
                        List<String> departmentAndSection = Arrays.stream(departmentNamePlate.split("\\.", 2)).collect(Collectors.toList());
                        if (CimNumberUtils.eq(departmentAndSection.size(), 2)) {
                            lotHoldReq.setDepartment(departmentAndSection.get(0));
                            lotHoldReq.setSection(departmentAndSection.get(1));
                        }
                    }
                    lotHoldReqs.add(lotHoldReq);
                }
            }
            out.setStrLotHoldReqList(lotHoldReqs);
        }
        return out;
    }

    @Override
    public boolean lotMonitorRouteFlagGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Outputs.ObjLotMonitorRouteFlagGetOut result = new Outputs.ObjLotMonitorRouteFlagGetOut();

        ObjectIdentifier currentRouteID = this.lotCurrentRouteIDGet(objCommon, lotID);
        CimProcessDefinition cimProcessDefinitionBO = baseCoreFactory.getBO(CimProcessDefinition.class, currentRouteID);
        Validations.check(null == cimProcessDefinitionBO, retCodeConfig.getNotFoundMainRoute());
        return cimProcessDefinitionBO.isMonitorRouteFlagOn();
    }

    @Override
    public String lotCurrentOpeNoGet(Infos.ObjCommon objCommon, ObjectIdentifier lotId) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotId);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotId)));
        return lot.getOperationNumber();
    }



    @Override
    public String lotHoldStateGet(Infos.ObjCommon objCommon, ObjectIdentifier lotId) {
        CimLot lotBO = baseCoreFactory.getBO(CimLot.class, lotId);
        Validations.check(CimObjectUtils.isEmpty(lotBO), new OmCode(retCodeConfig.getNotFoundLot(),lotId.getValue()));
        return lotBO.getLotHoldState();
    }



    @Override
    public Outputs.ObjLotRecipeGetOut lotRecipeGet(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier lotID) {
        Outputs.ObjLotRecipeGetOut out = new Outputs.ObjLotRecipeGetOut();
        String environmentVariableBO = StandardProperties.OM_CONSTRAINT_CHK_WITH_SEARCH.getValue();
        long searchCondition = (null == environmentVariableBO) ? 0 : Long.parseLong(environmentVariableBO);

        //【step1】get lot object
        log.debug("【step1】get lot object");
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));
        //CimLotBO lot =
        //【step2】get pmcmg object
        log.debug("【step2】get pmcmg object");
        CimMachine equipment =  baseCoreFactory.getBO(CimMachine.class, equipmentID);
        Validations.check(null == equipment, new OmCode(retCodeConfig.getNotFoundEqp(), ObjectIdentifier.fetchValue(equipmentID)));
        //【step3】get lot related object
        log.debug("【step3】get lot related object");
        com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = lot.getProcessOperation();
        Validations.check(null == processOperation, new OmCode(retCodeConfig.getNotFoundProcessOperation(), lotID.getValue()));

        //【step4】get product specification
        log.debug("【step4】get product specification");
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification productSpecification = lot.getProductSpecification();
        Validations.check(null == productSpecification, retCodeConfig.getNotFoundProductSpec());

        //【step5】get logical recipe object
        log.debug("【step5】get logical recipe object");
        com.fa.cim.newcore.bo.recipe.CimLogicalRecipe logicalRecipe = processOperation.findLogicalRecipeFor(productSpecification);
        Validations.check(null == logicalRecipe, retCodeConfig.getNotFoundLogicalRecipe());

        Outputs.ObjLotEffectiveFPCInfoGetOut fpcInfoGetOut = this.lotEffectiveFPCInfoGet(objCommon, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEINFO, equipmentID, lotID);

        //【step6】get machine recipe object
        log.debug("【step6】get machine recipe object");
        String subLotType = lot.getSubLotType();
        com.fa.cim.newcore.bo.recipe.CimMachineRecipe mRecipe = (searchCondition == 1) ?
                logicalRecipe.findMachineRecipeFor(lot, equipment):
                logicalRecipe.findMachineRecipeForSubLotType(equipment, subLotType);

        boolean skipFlag = false;
        if (null == mRecipe) {
            if (CimBooleanUtils.isTrue(fpcInfoGetOut.isMachineRecipeActionRequiredFlag())) {
                log.debug("MachineRecipe is overwritten by DOC");
                skipFlag = true;
            } else {
                log.error("not found the machie recipe");
                throw new ServiceException(retCodeConfig.getNotFoundMachineRecipe());

            }
        }
        out.setLogicalRecipeId(logicalRecipe.getLogicalRecipeID());
        if (!skipFlag) {
            out.setMachineRecipeId(mRecipe.getMachineRecipeID());
        }
        return out;
    }

    @Override
    public Boolean lotCheckConditionForPO(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        boolean currentPOFlag = true;
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        CimControlJob controlJob = lot.getControlJob();
        if (controlJob == null) {
            if (log.isDebugEnabled()) {
                log.debug("controlJob of the lot is nil.");
            }
            if (TransactionIDEnum.equals(TransactionIDEnum.OPERATION_COMP_WITH_DATA_REQ, objCommon.getTransactionID())
                    || TransactionIDEnum.equals(TransactionIDEnum.OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ, objCommon.getTransactionID())
                    || TransactionIDEnum.equals(TransactionIDEnum.GATE_PASS_REQ, objCommon.getTransactionID())
                    || TransactionIDEnum.equals(TransactionIDEnum.FORCE_OPERATION_COMP_REQ, objCommon.getTransactionID())
                    || TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ, objCommon.getTransactionID())
                    || TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ, objCommon.getTransactionID())
                    || TransactionIDEnum.equals(TransactionIDEnum.FORCE_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ, objCommon.getTransactionID())) {
                if (log.isDebugEnabled()) {
                    log.debug("set currentPOFlag = FALSE : TxID == {}", objCommon.getTransactionID());
                }

                currentPOFlag = this.checkLotMoveNextRequired(objCommon, lotID);
            }
        } else {
            if ( TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ, objCommon.getTransactionID())
                    || TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ, objCommon.getTransactionID())) {
                if (log.isDebugEnabled()) {
                    log.debug("set currentPOFlag = FALSE : TxID == {}", objCommon.getTransactionID());
                }
                //--------------------------------------------------------------------------
                // Get Process Operation Object
                //--------------------------------------------------------------------------
                CimProcessOperation processOperation = lot.getProcessOperation();
                if (processOperation == null) {
                    throw new ServiceException(new OmCode(retCodeConfig.getNotFoundProcessOperation(), "******", lotID.getValue()));
                }

                //--------------------------------------------------------------------------
                // Get CJ from PO
                //--------------------------------------------------------------------------
                CimControlJob poControlJob = processOperation.getAssignedControlJob();
                if (poControlJob == null) {
                    if (log.isDebugEnabled()) {
                        log.debug( "CurrentPO->getAssignedControlJob is nil. Current PO doesn't have a relation with Control Job.");
                    }
                    currentPOFlag = false;
                }
            } else {
                //---------------------------------
                // CJ has a relation with Machine?
                //---------------------------------
                CimMachine aMachine = controlJob.getMachine();
                if (aMachine == null) {
                    if (log.isDebugEnabled()) {
                        log.info( "aControlJob->aMachine is nil. Control Job doesn't have a relation with Machine.");
                    }
                    currentPOFlag = false;
                }
            }
        }
        if (log.isInfoEnabled()) {
            log.info( "lotCheckConditionForPO, currentPOFlag = {}", (currentPOFlag ? "TRUE" : "FALSE"));
        }
        return currentPOFlag;
    }

    @Override
    public void lotCheckConditionForUnloading(Infos.ObjCommon objCommonIn, Infos.LotListInCassetteInfo lotListInCassetteInfo) {
        //------------------------------------------
        //   For-Loop of strLotListInCassetteInfo
        //------------------------------------------
        int LLICILength = CimArrayUtils.getSize(lotListInCassetteInfo.getLotIDList());
        for (int i = 0; i < LLICILength; i++) {
            ObjectIdentifier lotID = lotListInCassetteInfo.getLotIDList().get(i);
            CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);

            //------------------------------------------
            //   Get and Check lot's State
            //------------------------------------------
            String lotProcessState = lot.getLotProcessState();
            Validations.check(CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING, lotProcessState), new OmCode(retCodeConfig.getInvalidLotProcessState(), ObjectIdentifier.fetchValue(lotID), lotProcessState));
        }
    }

    @Override
    public void lotCheckConditionForOpeComp(Infos.ObjCommon objCommon, List<Infos.StartCassette> startCassettes) {
        /*-------------------------*/
        /*   Check lot Condition   */
        /*-------------------------*/
        for (Infos.StartCassette startCassette : startCassettes) {
            List<Infos.LotInCassette> lotInCassettes = startCassette.getLotInCassetteList();

            for (Infos.LotInCassette lotInCassette : lotInCassettes) {
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }
                CimLot lot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                Validations.check(lot == null,
                        new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotInCassette.getLotID())));

                Validations.check(!lot.isDispatchReady(),
                        new OmCode(retCodeConfig.getLotInPostProcess(), ObjectIdentifier.fetchValue(lotInCassette.getLotID())));
                String processState = lot.getLotProcessState();
                Validations.check(!processState.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING),
                        new OmCode(retCodeConfig.getInvalidLotProcessState(),
                                ObjectIdentifier.fetchValue(lotInCassette.getLotID()), processState));

                String holdState = lot.getLotHoldState();
                Validations.check(!holdState.equals(BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD),
                        new OmCode(retCodeConfig.getInvalidLotHoldStat(), lot.getIdentifier(), holdState));
            }
        }

        /*---------------------------------------*/
        /*   Check cassette InterFabXfer State   */
        /*---------------------------------------*/
        for (Infos.StartCassette startCassette : startCassettes) {
            if (ObjectIdentifier.isEmpty(startCassette.getCassetteID())){
                break;
            }
            String strCassetteInterFabXferState = cassetteMethod.cassetteInterFabXferStateGet(objCommon, startCassette.getCassetteID());

            if (CimStringUtils.equals(BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING, strCassetteInterFabXferState)) {
                Validations.check(true, new OmCode(retCodeConfig.getInterfabInvalidCassetteTransferStateForRequest(),
                        ObjectIdentifier.fetchValue(startCassette.getCassetteID()), strCassetteInterFabXferState));
            }

            List<Infos.LotInCassette> lotInCassettes = startCassette.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassettes) {
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }

                String lotInterFabXferStateGetOut = lotMethod.lotInterFabXferStateGet(objCommon, lotInCassette.getLotID());//?已经实现待测试
                if (CimStringUtils.equals(BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING, lotInterFabXferStateGetOut)
                        || CimStringUtils.equals(BizConstant.SP_INTERFAB_XFERSTATE_REQUIRED, lotInterFabXferStateGetOut)) {
                    Validations.check(true, new OmCode(retCodeConfig.getInterfabInvalidLotXferstateForReq(),
                            ObjectIdentifier.fetchValue(lotInCassette.getLotID()), lotInterFabXferStateGetOut));
                }
            }
        }
    }

    /**
     * lot_CheckConditionForOpeStartCancel
     * @author Ho
     * @param objCommon         objCommon
     * @param startCassetteList startCassetteList
     * @return
     */
    @Override
    public void lotCheckConditionForOpeStartCancel(Infos.ObjCommon objCommon, List<Infos.StartCassette> startCassetteList) {
        for (Infos.StartCassette startCassette : startCassetteList){
            for (Infos.LotInCassette lotInCassette : startCassette.getLotInCassetteList()){
                /*--------------------------*/
                /*   Omit Not-Started lot   */
                /*--------------------------*/
                boolean operationStartFlag = lotInCassette.getMoveInFlag();
                if(!operationStartFlag){
                    continue;
                }

                /*--------------------*/
                /*   Get lot Object   */
                /*--------------------*/
                CimLot lot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                Validations.check(CimObjectUtils.isEmpty(lot), retCodeConfig.getNotFoundLot());
                /*-------------------------------*/
                /*   Get and Check lot's State   */
                /*-------------------------------*/
                String processState = lot.getLotProcessState();
                if(!CimStringUtils.equals(processState, BizConstant.SP_LOT_PROCSTATE_PROCESSING)){
                    ObjectIdentifier lotID = new ObjectIdentifier(lot.getIdentifier(), lot.getPrimaryKey());
                    throw new ServiceException(new OmCode(retCodeConfig.getInvalidLotProcstat(), lotID.getValue(), processState));
                }
                /*-----------------------------------*/
                /*   Get and Check lot's HoldState   */
                /*-----------------------------------*/
                String holdState = lot.getLotHoldState();
                if (!CimStringUtils.equals(holdState, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD)){
                    throw new ServiceException(retCodeConfig.getInvalidLotHoldStat());

                }
            }
        }

    }



    @Override
    public boolean lotCheckConditionForAutoBankIn(Infos.ObjCommon objCommon, ObjectIdentifier lotId) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotId);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotId)));
        String lotType = lot.getLotType();
        if (CimStringUtils.equals(lotType, BizConstant.SP_LOT_TYPE_DUMMYLOT)
                || CimStringUtils.equals(lotType, BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)
                || CimStringUtils.equals(lotType, BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)) {
            //npw lot, check if the last step to add the usage count
            CimProcessFlowContext processFlowContext = lot.getProcessFlowContext();
            Boolean lastOperationForProcessFlow = processFlowContext.isLastOperationForProcessFlow();
            if (lastOperationForProcessFlow) {
                //last step to add the usage count
                List<ProductDTO.WaferInfo> allWaferInfo = lot.getAllWaferInfo();
                for (ProductDTO.WaferInfo waferInfo : allWaferInfo) {
                    ObjectIdentifier waferID = waferInfo.getWaferID();
                    CimWafer aWafer = baseCoreFactory.getBO(CimWafer.class, waferID);
                    aWafer.setUsageCount(aWafer.getUsageCount() + 1);
                }
            }
            // check the usage count
            Integer usageLimit = lot.getUsageLimit();
            LotUsageRecycleCountParams usageRecycleCountByLot = waferMethod.getUsageRecycleCountByLot(objCommon, lot.getLotID().getReferenceKey());
            Integer usageCount = usageRecycleCountByLot.getUsageCount();
            if (usageCount < usageLimit || usageLimit == 0) {
                //doesn't reach the limit, don't bank in
                return false;
            } else {
                //reach the limit, bank in
                return true;
            }
        }
        CimProcessOperation processOperation = lot.getProcessOperation();
        Validations.check(null == processOperation, new OmCode(retCodeConfig.getNotFoundProcessOperation(), ""));
        boolean bankInRequiredFlag = false;
        boolean autoBankInFlag = CimBooleanUtils.isTrue(processOperation.isAutoBankInRequired());

        if (autoBankInFlag) {
            bankInRequiredFlag = CimBooleanUtils.isTrue(lot.isBankInRequired());
        }
        return (autoBankInFlag && bankInRequiredFlag);
    }

    @Override
    public void lotWaferChangeDie(Infos.ObjCommon objCommon, ObjectIdentifier lotId, List<Infos.LotWaferAttributes> lotWaferAttributesList) {

        int foundCount = 0;

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotId);
        Validations.check(CimObjectUtils.isEmpty(lot), retCodeConfig.getNotFoundLot());

        List<ProductDTO.WaferInfo> allWaferInfo = lot.getAllWaferInfo();
        for (ProductDTO.WaferInfo wafer : allWaferInfo) {
            for (Infos.LotWaferAttributes lotWaferAttributes : lotWaferAttributesList) {
                if (wafer.getLotID().equals(lotWaferAttributes.getWaferID())) {
                    wafer.setGoodDiceQuantity(lotWaferAttributes.getGoodUnitCount());
                    wafer.setRepairedDiceQuantity(lotWaferAttributes.getRepairUnitCount());
                    wafer.setBadDiceQuantity(lotWaferAttributes.getFailUnitCount());
                    foundCount++;
                    break;
                }
            }
            if (foundCount == CimArrayUtils.getSize(lotWaferAttributesList)) {
                break;
            }
        }

        Validations.check(foundCount != CimArrayUtils.getSize(lotWaferAttributesList), retCodeConfig.getNotFoundWafer());
    }

    @Override
    public Outputs.ObjLotFutureHoldEffectedProcessConversionOut lotFutureHoldEffectedProcessConversion(Infos.ObjCommon objCommon, ObjectIdentifier lotId, List<Infos.LotHoldReq> lotHoldReqList) {
        Outputs.ObjLotFutureHoldEffectedProcessConversionOut resultObj = new Outputs.ObjLotFutureHoldEffectedProcessConversionOut();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotId);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotId)));

        com.fa.cim.newcore.bo.pd.CimProcessDefinition mainPD = lot.getMainProcessDefinition();
        Validations.check(null == mainPD, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), ""));
        ObjectIdentifier routeId = new ObjectIdentifier(mainPD.getIdentifier(), mainPD.getPrimaryKey());
        com.fa.cim.newcore.bo.pd.CimProcessOperation aTmpPO = lot.getProcessOperation();
        Validations.check(null == aTmpPO, new OmCode(retCodeConfig.getNotFoundProcessOperation(), ""));

        String operationNumber= aTmpPO.getOperationNumber();
        for (Infos.LotHoldReq lotHoldReq : lotHoldReqList) {
            lotHoldReq.setRouteID(routeId);
            lotHoldReq.setOperationNumber(operationNumber);
        }
        resultObj.setLotHoldReqList(lotHoldReqList);
        return resultObj;
    }

    @Override
    public void lotRemoveFromMonitorGroup(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot(), lotID);
        lotRemoveFromMonitorGroup(objCommon, lot);
    }

    @Override
    public void lotRemoveFromMonitorGroup(Infos.ObjCommon objCommon, CimLot lot) {
        /*-----------------------------------------------------*/
        /*   Is Lot(InParam) representation of MonitorGroup?   */
        /*-----------------------------------------------------*/
        if (log.isInfoEnabled())
            log.info("Is Lot(InParam) representation of MonitorGroup?");
        CimMonitorGroup aMonitorGroup = lot.getControlMonitorGroup();
        Validations.check(aMonitorGroup != null, retCodeConfigEx.getLotHasMonitorGroup(), lot.getLotID());
        /*--------------------------------------*/
        /*   How many Lots are MonitorGroups?   */
        /*--------------------------------------*/
        List<CimMonitorGroup> aPosMonitorGroups = lot.allMonitorGroups();
        for (CimMonitorGroup aPosMonitorGroup : aPosMonitorGroups) {
            if (!CimObjectUtils.isEmpty(aPosMonitorGroup)){
                ObjectIdentifier monitorGroupID = ObjectIdentifier.build(aPosMonitorGroup.getIdentifier(),
                        aPosMonitorGroup.getPrimaryKey());
                //  object_Lock
                objectLockMethod.objectLock(objCommon, CimMonitorGroup.class, monitorGroupID);
            }
            List<ProductDTO.MonitoredLot> monitoredLots = aPosMonitorGroup.allLots();
            if (1 >= CimArrayUtils.getSize(monitoredLots)) {
                // if there are only two Lot of MonitorGroup then It is not cancellable.
                // The reason currently checked by 1 here, It is a premise that Lot is in one FRMONITORGRP.
                throw new ServiceException(new OmCode(retCodeConfigEx.getLotHasMonitorGroup(), lot.getIdentifier()));
            } else {
                if (log.isInfoEnabled())
                    log.info("PosMonitorGroup::removeLot(aLot)");
                aPosMonitorGroup.removeLot(lot);
            }
        }
    }


    /**
     * lot_futureHoldRequests_EffectForOpeStartCancel
     *
     * Get of the FutureHold information by ImmediateHold for OperationStartCancel.
     * @author Ho
     * @param objCommon objCommon
     * @param lotID     lotID
     * @return
     */
    @Override
    public Outputs.ObjLotFutureHoldRequestsEffectForOpeStartCancelOut lotFutureHoldRequestsEffectForOpeStartCancel(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        log.debug("lotFutureHoldRequestsEffect4OpeStartCancel(): enter lotFutureHoldRequestsEffect4OpeStartCancel");

        Outputs.ObjLotFutureHoldRequestsEffectForOpeStartCancelOut out = new Outputs.ObjLotFutureHoldRequestsEffectForOpeStartCancelOut();


        out.setLotID(lotID);
        List<Infos.LotHoldReq> futureHoldReleaseReqList = new ArrayList<>();
        out.setFutureHoldReleaseReqList(futureHoldReleaseReqList);
        List<Infos.LotHoldReq> lotHoldReqList = new ArrayList<>();
        out.setLotHoldReqList(lotHoldReqList);

        String phase = BizConstant.SP_FUTUREHOLD_POST,
                triggerLevel = BizConstant.SP_FUTUREHOLD_POST;

        // lot_futureHoldRequests_DeleteEffectedByCondition
        Infos.EffectCondition effectCondition = new Infos.EffectCondition();
        effectCondition.setPhase(phase);
        effectCondition.setTriggerLevel(triggerLevel);
        Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut deleteEffectedByConditionOut = this.lotFutureHoldRequestsDeleteEffectedByCondition(objCommon, lotID, effectCondition);


        // Existence check of the FutureHold request by the Q-Time over
        List<Infos.LotHoldReq> strFutureHoldReleaseReqList = deleteEffectedByConditionOut.getStrFutureHoldReleaseReqList();
        List<Infos.LotHoldReq> strLotHoldReqListOfQTimeOver = new ArrayList<>();
        if (!CimArrayUtils.isEmpty(strFutureHoldReleaseReqList)) {
            for (Infos.LotHoldReq lotHoldReq : strFutureHoldReleaseReqList) {

                // Exist future hold request for Q-Time
                if (CimStringUtils.equals(BizConstant.SP_HOLDTYPE_QTIMEOVERHOLD, lotHoldReq.getHoldType())) {
                    strLotHoldReqListOfQTimeOver.add(lotHoldReq);
                }
            }
        }

        // FutureHold request does not exist
        if (CimArrayUtils.isEmpty(strLotHoldReqListOfQTimeOver)) {
            return out;
        }

        // Get the target lot's object
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lot), retCodeConfig.getNotFoundLot());

        // Get the target lot's current operation
        com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = lot.getProcessOperation();
        Validations.check(processOperation == null, retCodeConfig.getNotFoundProcessOperation());

        // Get the target lot's current route
        com.fa.cim.newcore.bo.pd.CimProcessDefinition processDefinition = processOperation.getMainProcessDefinition();
        Validations.check(CimObjectUtils.isEmpty(processDefinition), retCodeConfig.getNotFoundProcessDefinition());

        String currentRouteID = processDefinition.getIdentifier();

        // Get the target lot's current operation number
        String currentOperationNumber = processOperation.getOperationNumber();

        // Get the target lot's process flow context
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext processFlowContext = lot.getProcessFlowContext();
        Validations.check(CimObjectUtils.isEmpty(processFlowContext), retCodeConfig.getNotFoundPfx());

        //------------------------------------------------------------------------------------------------
        // The registration by the FutureHold action or the registration by the ImmediateHold action
        // cannot be distinguished only in FutureHold registration information.
        // Finished Q-Time action information is used to distinguish this.
        //------------------------------------------------------------------------------------------------

        // Get the target lot's Q-Time
        List<com.fa.cim.newcore.bo.pd.CimQTimeRestriction> aQTimeList = null;
        if (CimArrayUtils.binarySearch(new String[]{"OEQPW012", "OEQPW024"}, objCommon.getTransactionID())) {
            aQTimeList = lot.allQTimeRestrictionsWithWaferLevelQTime();
        } else {
            int aQTimeListForWaferCount = lot.getWaferLevelQTimeCount();
            if (aQTimeListForWaferCount > 0) {
                aQTimeList = lot.allQTimeRestrictionsWithWaferLevelQTime();
            } else {
                aQTimeList = lot.allQTimeRestrictions();
            }
        }

        // Finished ImmediateHold and FutureHold are checked
        List<String> immediateHoldReasonCodeList = new ArrayList<>(),
                futureHoldReasonCodeList = new ArrayList<>();
        for (com.fa.cim.newcore.bo.pd.CimQTimeRestriction qTimeRestriction : aQTimeList) {
            // Get the target lot's Q-Time information
            ProcessDTO.QTimeRestrictionInfo aQTimeInfo = qTimeRestriction.getQTimeRestrictionInfo();
            Validations.check(aQTimeInfo == null || CimStringUtils.isEmpty(aQTimeInfo.getTriggerOperationNumber()), retCodeConfig.getNotFoundQtime());

            // Get the Q-Time's actions into
            //TODO:WIND List<QTimeAction> qTimeActions=qTimeActionDao.findAllByQtimeID(qTimeRestriction.getQTimeRestriction_RID());
            List<ProcessDTO.QTimeRestrictionAction> qTimeActions = aQTimeInfo.getActions();
            for (ProcessDTO.QTimeRestrictionAction qTimeAction : qTimeActions) {

                // Finished action
                if (CimBooleanUtils.isTrue(qTimeAction.getActionDone())) {
                    String reasonCode = ObjectIdentifier.fetchValue(qTimeAction.getReasonCode());

                    // ImmediateHold
                    if (CimStringUtils.equals(qTimeAction.getAction(), BizConstant.SP_QTIMERESTRICTION_ACTION_IMMEDIATEHOLD)) {
                        if (!immediateHoldReasonCodeList.contains(reasonCode)) {
                            immediateHoldReasonCodeList.add(reasonCode);
                        }
                    }

                    // FutureHold
                    if (CimStringUtils.equals(qTimeAction.getAction(), BizConstant.SP_QTIMERESTRICTION_ACTION_FUTUREHOLD)
                            && CimStringUtils.equals(qTimeAction.getTiming(), BizConstant.SP_FUTUREHOLD_POST)
                            && ObjectIdentifier.equalsWithValue(qTimeAction.getActionRouteID(), currentRouteID)
                            && CimStringUtils.equals(qTimeAction.getOperationNumber(), currentOperationNumber)) {
                        if (!futureHoldReasonCodeList.contains(reasonCode)) {
                            futureHoldReasonCodeList.add(reasonCode);
                        }
                    }
                }
            }
        }

        // Finished ImmediateHold action does not exist
        if (CimArrayUtils.isEmpty(immediateHoldReasonCodeList)) {

            // There is not FutureHold(POST) registered by ImmediateHold.
            // Because there is not the FutureHold registration by ImmediateHold, nothing is done.
            return out;
        }

        //-------------------------
        // Set output parameters
        //-------------------------

        // FutureHold Release Request List
        List<Infos.LotHoldReq> strFutureHoldReleaseReqList2 = new ArrayList<>(),
                strImmediateHoldReqList = new ArrayList<>();

        for (Infos.LotHoldReq lotHoldReq : strLotHoldReqListOfQTimeOver) {
            String reasonCode = lotHoldReq.getHoldReasonCodeID().getValue();

            // Finished FutureHold action does not exist
            if (!futureHoldReasonCodeList.contains(reasonCode)) {
                strFutureHoldReleaseReqList2.add(lotHoldReq);
            }

            // Finished ImmediateHold action exists
            if (immediateHoldReasonCodeList.contains(reasonCode)) {
                strImmediateHoldReqList.add(lotHoldReq);
            }
        }

        // FutureHold(POST) registered by ImmediateHold action is released.
        out.setFutureHoldReleaseReqList(strFutureHoldReleaseReqList2);
        out.setLotHoldReqList(strImmediateHoldReqList);
        return out;
    }

    @Override
    public String lotRequiredCassetteCategoryGetForNextOperation(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        log.debug("lotRequiredCassetteCategoryGetForNextOperation(): enter lotRequiredCassetteCategoryGetForNextOperation");

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        //Get Next Operation requiredCassetteCategory
        //String processFlowContextID = lot.getProcessFlowContextObj();
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext processFlowContext = lot.getProcessFlowContext();
        Validations.check(processFlowContext == null, new OmCode(retCodeConfig.getNotFoundPfx(), ""));

        //getNextProcessOperationSpecificationOld
        AtomicReference<String> outModuleNumber = new AtomicReference<>();
        AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainProcessFlow = new AtomicReference<>(), outModuleProcessFlow = new AtomicReference<>();
        com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aNextModulePOS = processFlowContext.getNextProcessOperationSpecification(outMainProcessFlow, outModuleNumber, outModuleProcessFlow);
        Validations.check(aNextModulePOS == null, new OmCode(retCodeConfig.getNotFoundPos(), "*****", lotID.getValue()));
        String aModuleOpeNo = aNextModulePOS.getOperationNumber();
        Validations.check(null == outMainProcessFlow, new OmCode(retCodeConfig.getNotFoundProcessFlow(), ""));
        String opeNo = String.format("%s.%s", outModuleNumber, aModuleOpeNo);

        ProcessDefinition aPD = outMainProcessFlow.get().getRootProcessDefinition();
        Validations.check(null == aPD, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), ""));
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aPosProcessDefinition = (com.fa.cim.newcore.bo.pd.CimProcessDefinition)aPD;
        com.fa.cim.newcore.bo.pd.CimProcessFlow aPosProcessFlow = aPosProcessDefinition.getActiveProcessFlow();
        Validations.check(null == aPosProcessFlow, new OmCode(retCodeConfig.getNotFoundProcessFlow(), ""));
        com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aNextProcessOpSpec = aPosProcessFlow.findProcessOperationSpecificationOnDefault(opeNo);
        return !CimObjectUtils.isEmpty(aNextProcessOpSpec) ? aNextProcessOpSpec.getRequiredCassetteCategory() : null;
    }

    @Override
    public void lotCheckConditionForLoading(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier lotID) {
        //--------------------
        //   Get lot Object
        //--------------------
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));
        //-----------------------------
        //   Check Start eqp
        //-----------------------------
        List<CimMachine> aMachineSeq = aLot.getQueuedMachines();
        boolean matchFlag = false;
        int lenMachine = CimArrayUtils.getSize(aMachineSeq);
        for (int k = 0; k < lenMachine; k++){
            ObjectIdentifier qEquipmentID = new ObjectIdentifier(aMachineSeq.get(k).getIdentifier(), aMachineSeq.get(k).getPrimaryKey());
            if (ObjectIdentifier.equalsWithValue(qEquipmentID, equipmentID)){
                matchFlag = true;
                break;
            }
        }
        if (!matchFlag) {
            throw new ServiceException(retCodeConfig.getNotCandidateLotForOperationStart());
        }
        //-------------------------------------------------------------
        //   Check Current Operation is bank-In Operation or Not
        //-------------------------------------------------------------
        boolean bankInFlag = aLot.isBankInRequired();
        Validations.check(bankInFlag, retCodeConfig.getBankinOperation());
        //----------------------------------------
        //   Get and Check lot's State
        //----------------------------------------
        String holdState = aLot.getLotHoldState();
        String processState = aLot.getLotProcessState();
        String inventoryState = aLot.getLotInventoryState();
        Validations.check(!CimStringUtils.equals(holdState, CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD),
                new OmCode(retCodeConfig.getNotCandidateLotForOperationStart(), lotID.getValue(), holdState));
        Validations.check(!CimStringUtils.equals(processState, BizConstant.SP_LOT_PROCSTATE_WAITING),
                new OmCode(retCodeConfig.getNotCandidateLotForOperationStart(), lotID.getValue(), processState));
        Validations.check(!CimStringUtils.equals(inventoryState, BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR),
                retCodeConfig.getInvalidLotInventoryStat(), ObjectIdentifier.fetchValue(lotID), inventoryState);
        //---------------------------------------------------
        //   Get and Check eqp Availability for lot
        //---------------------------------------------------
        List<ObjectIdentifier> checkLotIDs = new ArrayList<>();
        checkLotIDs.add(lotID);
        try {
            equipmentMethod.equipmentCheckAvailForLot(objCommon, equipmentID, checkLotIDs);
        } catch (ServiceException e){
            if (Validations.isEquals(e.getCode(), retCodeConfig.getEquipmentNotAvailableStat())){
                throw new ServiceException(retCodeConfig.getNotCandidateLotForOperationStart(), e.getMessage());
            } else if(Validations.isEquals(e.getCode(), retCodeConfig.getEquipmentNotAvailableStatForLot())){
                throw new ServiceException(new OmCode(retCodeConfig.getNotCandidateLotForOperationStart(), lotID.getValue()), e.getMessage());
            } else {
                throw e;
            }
        }
        //-------------------------------------------------------------------------
        //   Get and Check Entity Inhibition for OpeStart / StartReservation
        //-------------------------------------------------------------------------
        ObjectIdentifier controlJobID = this.lotControlJobIDGet(objCommon, lotID);
        if (!ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            Outputs.ObjControlJobStartReserveInformationOut reserveInformationOut = controlJobMethod.controlJobStartReserveInformationGet(objCommon, controlJobID, false);
            CimMachine aMachine = baseCoreFactory.getBO(CimMachine.class, equipmentID);
            Validations.check(aMachine == null, new OmCode(retCodeConfig.getNotFoundEqp(), equipmentID.getValue()));
            int tmpChamberCheckPolicy = StandardProperties.OM_CHAMBER_CHK_RULE.getIntValue();
            List<Infos.StartCassette> startCassettes = reserveInformationOut.getStartCassetteList();
            int SCLength = CimArrayUtils.getSize(startCassettes);
            if (SCLength > 0){
                for (Infos.StartCassette startCassette : startCassettes) {
                    List<Infos.LotInCassette> lotInCassettes = startCassette.getLotInCassetteList();
                    for (Infos.LotInCassette lotInCassette : lotInCassettes) {
                        //---------------------------
                        //   Omit Not Process lot
                        //---------------------------
                        boolean bOperationStartFlag = CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag());
                        if (!bOperationStartFlag) continue;
                        //------------------------------------------------------------------------------------------------------------
                        //   Check if the recipe is available on Eqp. This check is skipped when recipe is overwritten by DOC.
                        //------------------------------------------------------------------------------------------------------------
                        int tmpFPCAdoptFlag = StandardProperties.OM_DOC_ENABLE_FLAG.getIntValue();
                        boolean bFPCFlag = false;
                        if (1 == tmpFPCAdoptFlag) {
                            Outputs.ObjLotEffectiveFPCInfoGetOut effectiveFPCInfoOut = this.lotEffectiveFPCInfoGet(objCommon, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEINFO, equipmentID, lotInCassette.getLotID());
                            if (effectiveFPCInfoOut.isMachineRecipeActionRequiredFlag()) bFPCFlag = true;
                        }
                        if (!bFPCFlag) {
                            com.fa.cim.newcore.bo.recipe.CimMachineRecipe aMachineRecipe = baseCoreFactory.getBO(com.fa.cim.newcore.bo.recipe.CimMachineRecipe.class, lotInCassette.getStartRecipe().getMachineRecipeID());
                            Validations.check(aMachineRecipe == null, retCodeConfig.getNotFoundMachineRecipe());
                            boolean bUsedFlag = aMachineRecipe.isUsedBy(aMachine);
                            Validations.check(!bUsedFlag, new OmCode(retCodeConfig.getInvalidRecipeForEqp(), lotInCassette.getStartRecipe().getMachineRecipeID().getValue(), equipmentID.getValue()));
                        }
                        //-----------------------------------------
                        //   Check condition for recipe / chamber
                        //-----------------------------------------
                        if (1 == tmpChamberCheckPolicy) {
                            Inputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn = new Inputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn();
                            strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setLotID(lotInCassette.getLotID());
                            strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setEquipmentID(equipmentID);
                            strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setLogicalRecipeID(lotInCassette.getStartRecipe().getLogicalRecipeID());
                            strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setMachineRecipeID(lotInCassette.getStartRecipe().getMachineRecipeID());
                            strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setInhibitCheckFlag(false);
                            Outputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut candidateChamberInfoGetByMachineRecipeOut = logicalRecipeMethod.logicalRecipeCandidateChamberInfoGetByMachineRecipe(objCommon, strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn);
                            if (candidateChamberInfoGetByMachineRecipeOut.isMultiChamberFlag()) {
                                // Multi chamber case
                                if (candidateChamberInfoGetByMachineRecipeOut.isRecipeDefinedFlag()
                                        && 0 == CimArrayUtils.getSize(candidateChamberInfoGetByMachineRecipeOut.getCandidateChamberList())) {
                                    // machine recipe is defined in logical recipe, but there is no available chamber
                                    throw new ServiceException(new OmCode(retCodeConfig.getChamberNotAvailableForLot(), lotInCassette.getLotID().getValue()));
                                } else {
                                    // Following 2 cases
                                    // 1. Machine recipe isn't defined in logical recipe.
                                    // 2. Machine recipe is defined in logical recipe and chambers are found which meets following condition
                                    //     - Chamber Status
                                    //     - Conditional available
                                    log.info("recipe/chamber check OK");
                                }
                            }
                        }
                    }
                }
            }
            //equipment_CheckInhibitForLotWithMachineRecipe
            try {
                equipmentMethod.equipmentCheckInhibitForLotWithMachineRecipe(objCommon, equipmentID, checkLotIDs, startCassettes);
            } catch (ServiceException e){
                if (Validations.isEquals(e.getCode(), retCodeConfig.getInhibitLot())){
                    throw new ServiceException(retCodeConfig.getNotCandidateLotForOperationStart(), e.getMessage());
                } else {
                    throw e;
                }
            }
        } else {
            int tmpFPCAdoptFlag = StandardProperties.OM_DOC_ENABLE_FLAG.getIntValue();
            if (1 == tmpFPCAdoptFlag) {
                List<Infos.FPCInfo> strFPCInfoList = this.lotCurrentFPCInfoGet(objCommon, lotID, equipmentID, false, false, false, false);
                int fpclen = CimArrayUtils.getSize(strFPCInfoList);
                Validations.check(0 < fpclen, new OmCode(retCodeConfig.getFpcRequireStartReserve(), lotID.getValue()));
            }
            //equipment_CheckInhibitForLot
            try {
                equipmentMethod.equipmentCheckInhibitForLot(objCommon, equipmentID, checkLotIDs);
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getInhibitLot(), e.getCode())){
                    throw new ServiceException(retCodeConfig.getNotCandidateLotForOperationStart(), e.getMessage());
                } else {
                    throw e;
                }
            }
            //---------------------------------
            // Check lot interFabXferState
            //---------------------------------
            String interfabTransferState = lotMethod.lotInterFabXferStateGet(objCommon, lotID);
            //----------------------
            // "Transferring"
            //----------------------
            Validations.check(CimStringUtils.equals(interfabTransferState, BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING),
                    new OmCode(retCodeConfig.getInterfabInvalidLotXferstateForReq(), lotID.getValue(), interfabTransferState));
            String eqpmonitorSwitchFlag = StandardProperties.OM_AUTOMON_FLAG.getValue();
            if (CimStringUtils.equals(eqpmonitorSwitchFlag, "1")) {
                String lotType = aLot.getLotType();
                if (CimStringUtils.equals(BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT, lotType) || CimStringUtils.equals(BizConstant.SP_LOT_TYPE_DUMMYLOT, lotType)) {
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut monitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotID);
                    if (CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR, monitorSectionInfoGetForJobOut.getOperationLabel())) {
                        List<Infos.EqpMonitorJobInfo> eqpMonitorJobInfos = equipmentMethod.eqpMonitorJobInfoGet(objCommon, monitorSectionInfoGetForJobOut.getEquipmentMonitorID(), monitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());

                        Infos.EqpMonitorJobInfo eqpMonitorJobInfo = eqpMonitorJobInfos.get(0);
                        String monitorJobStatus = eqpMonitorJobInfo.getMonitorJobStatus();
                        ObjectIdentifier monitorEquipmentID = eqpMonitorJobInfo.getEquipmentID();
                        //Check eqp Monitor Job status
                        if (!CimStringUtils.equals(BizConstant.SP_EQPMONITORJOB_STATUS_READY, monitorJobStatus)
                                && !CimStringUtils.equals(BizConstant.SP_EQPMONITORJOB_STATUS_EXECUTING, monitorJobStatus)) {
                            throw new ServiceException(new OmCode(retCodeConfig.getInvalidEqpMonitorJobStatus(), monitorJobStatus));
                        }
                        //Check eqp
                        if (!ObjectIdentifier.equalsWithValue(equipmentID, monitorEquipmentID)) {
                            throw new ServiceException(new OmCode(retCodeConfig.getDiffEquipmentMonitorJobEquipmentID(), lotID.getValue()));
                        }
                        //Check Start Sequence
                        Integer startSeqNo = 0;
                        List<Infos.EqpMonitorLotInfo> eqpMonitorLotInfos = eqpMonitorJobInfo.getStrEqpMonitorLotInfoSeq();
                        for (Infos.EqpMonitorLotInfo eqpMonitorLotInfo : eqpMonitorLotInfos) {
                            if (ObjectIdentifier.equalsWithValue(eqpMonitorLotInfo.getLotID(), lotID)) {
                                startSeqNo = eqpMonitorLotInfo.getStartSeqNo();
                                break;
                            }
                        }
                        for (Infos.EqpMonitorLotInfo eqpMonitorLotInfo : eqpMonitorLotInfos) {
                            if (CimStringUtils.equals(BizConstant.SP_EQPMONITORJOB_STATUS_RESERVED, eqpMonitorLotInfo.getMonitorLotStatus())) {
                                //startSeqNo should be the minimum value
                                Validations.check(startSeqNo > eqpMonitorLotInfo.getStartSeqNo(), retCodeConfig.getMismatchEqpMonitorStartSeq());
                            }
                        }
                    }
                }
            }
        }
    }

    @Override
    public void lotProcessJobExecFlagValidCheckForOpeStart(Infos.ObjCommon objCommon, List<Infos.StartCassette> startCassetteList, boolean processJobPauseFlag) {
        /*
         author:PlayBoy
         */
        log.debug("lotProcessJobExecFlagValidCheckForOpeStart(): enter lotProcessJobExecFlagValidCheckForOpeStart");

        //Check wafer's processJobExecFlag
        AtomicBoolean existFlag = new AtomicBoolean(false);
        AtomicBoolean existInCJFlag = new AtomicBoolean(false);
        if (!CimArrayUtils.isEmpty(startCassetteList)){
            for (Infos.StartCassette startCassette : startCassetteList){
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                if (!CimArrayUtils.isEmpty(lotInCassetteList)){
                    lotInCassetteList.stream()
                            .filter(Infos.LotInCassette::getMoveInFlag)
                            .forEach(lotInCassette -> {
                                List<Infos.LotWafer> lotWaferList = lotInCassette.getLotWaferList();
                                if (lotWaferList != null) {
                                    for (Infos.LotWafer lotWafer : lotWaferList) {
                                        if (CimBooleanUtils.isTrue(lotWafer.getProcessJobExecFlag())) {
                                            existFlag.set(true);
                                            existInCJFlag.set(true);
                                            break;
                                        }
                                    }
                                }

                                if (CimBooleanUtils.isFalse(existFlag.get()) && CimBooleanUtils.isTrue(existInCJFlag.get())) {
                                    throw new ServiceException(retCodeConfig.getNoProcessJobExecFlag());

                                }
                                //Validations.check(!existFlag.get() && !existInCJFlag.get(), retCodeConfig.getNoProcessJobExecFlag(), objCommon.getTransactionID());
                            });
                }
            }
        }
        if (CimBooleanUtils.isFalse(existFlag.get()) && CimBooleanUtils.isTrue(existInCJFlag.get())) {
            throw new ServiceException(retCodeConfig.getNoProcessJobExecFlag());
        }
    }

    @Override
    public void lotCassetteCategoryCheckForContaminationControl(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier cassetteID, ObjectIdentifier equipmentID, ObjectIdentifier loadPortID) {
        log.debug("checkLotCassetteCategoryForContaminationControl");
        String requiredCassetteCategory = null;
        //for empty cassette
        if (!ObjectIdentifier.isEmpty(lotID)) {
            CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, lotID);
            Validations.check(aPosLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
            requiredCassetteCategory = aPosLot.getRequiredCassetteCategory();
            if (StandardProperties.OM_EXCHANGE_CARRIER_CATEGORY_CHK_MODE.isOn()){
                if (CimStringUtils.isNotEmpty(requiredCassetteCategory)){
                    if (requiredCassetteCategory.contains("2")){
                        String[] split = requiredCassetteCategory.split("2",2);
                        if (CimStringUtils.isEmpty(split[0]) || CimStringUtils.isEmpty(split[1])){
                            Validations.check(retCodeConfigEx.getReqCastCategoryNotAllowed(),requiredCassetteCategory);
                        }
                        requiredCassetteCategory = split[0];
                    }
                }
            }
        }
        /*---------------------------------------------*/
        /* Get PosCassette Object And cassetteCategory,carrier=FOSB跳过验证 */
        /*---------------------------------------------*/
        com.fa.cim.newcore.bo.durable.CimCassette aPosCassette = baseCoreFactory.getBO(com.fa.cim.newcore.bo.durable.CimCassette.class, cassetteID);

        if (SorterHandler.containsFOSB(cassetteID)) {
            return;
        }
        Validations.check(aPosCassette == null, new OmCode(retCodeConfig.getNotFoundCassette(), cassetteID.getValue()));
        String cassetteCategory = aPosCassette.getCassetteCategory();
        //--------------------//
        // for empty cassette //
        //--------------------//
        if (ObjectIdentifier.isEmpty(lotID) || CimStringUtils.isEmpty(requiredCassetteCategory)){
            requiredCassetteCategory = cassetteCategory;
        }
        //-----------------------------------------------------------//
        // Get PosPortResource Object And cassetteCategoryCapability //
        //-----------------------------------------------------------//
        CimMachine aPosMachine = baseCoreFactory.getBO(CimMachine.class, equipmentID);
        Validations.check(aPosMachine == null, new OmCode(retCodeConfig.getNotFoundEqp(), equipmentID.getValue()));
        PortResource portResource = aPosMachine.findPortResourceNamed(ObjectIdentifier.fetchValue(loadPortID));
        com.fa.cim.newcore.bo.machine.CimPortResource aPort = (com.fa.cim.newcore.bo.machine.CimPortResource) portResource;
        Validations.check(CimObjectUtils.isEmpty(aPort), retCodeConfig.getInvalidCategoryCheck());
        List<String> categoryCapabilities = aPort.getCassetteCategoryCapability();
        //It is checked whether a category is the same
        boolean category = false;
        boolean lotCassetteCategoryUnmatch = false;
        boolean cassettePortCategoryUnmatch = false;
        // Pattern A [In the case of the justice which is undecided]
        if (CimStringUtils.isEmpty(requiredCassetteCategory) && CimArrayUtils.isEmpty(categoryCapabilities)) {
            category = true;
        }
        // Pattern B [When requiredCassetteCategory is defined]
        if (!CimStringUtils.isEmpty(requiredCassetteCategory) && CimArrayUtils.isEmpty(categoryCapabilities)) {
            if (requiredCassetteCategory.equals(cassetteCategory)) {
                category = true;
            } else {
                lotCassetteCategoryUnmatch = true;
            }
        }
        // Pattern C [When cassetteCategoryCapability is defined]
        if (CimStringUtils.isEmpty(requiredCassetteCategory) && !CimArrayUtils.isEmpty(categoryCapabilities)) {
            for (String categoryCapability : categoryCapabilities) {
                if (cassetteCategory.equals(categoryCapability)) {
                    category = true;
                    break;
                }
            }
            if (!category) {
                cassettePortCategoryUnmatch = true;
            }
        }
        // Pattern D [When both define]
        if (!CimStringUtils.isEmpty(requiredCassetteCategory) && !CimArrayUtils.isEmpty(categoryCapabilities)) {
            if (requiredCassetteCategory.equals(cassetteCategory)) {
                for (String categoryCapability : categoryCapabilities) {
                    if (cassetteCategory.equals(categoryCapability)) {
                        category = true;
                        break;
                    }
                }
                if (!category) {
                    cassettePortCategoryUnmatch = true;
                }
            } else {
                lotCassetteCategoryUnmatch = true;
            }
        }
        if (!category) {
            if (lotCassetteCategoryUnmatch) {
                throw new ServiceException(new OmCode(new OmCode(retCodeConfig.getInvalidCategoryCheck().getCode(), retCodeConfig.getLotCarrierCategoryUnmatch().getMessage()), requiredCassetteCategory, cassetteCategory));
            }
            if (cassettePortCategoryUnmatch) {
                throw new ServiceException(new OmCode(new OmCode(retCodeConfig.getInvalidCategoryCheck().getCode(), retCodeConfig.getCarrierPortCarrierCategoryUnmatch().getMessage()), cassetteCategory, ObjectIdentifier.fetchValue(equipmentID), aPort.getIdentifier()));
            }
        }
    }

    @Override
    public void lotProcessStateMakeProcessing(Infos.ObjCommon objCommon, List<Infos.StartCassette> startCassetteList) {
        log.debug("makeLotProcessing4ProcessState(): enter makeLotProcessing4ProcessState");

        //Get person Object
        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == aPerson, new OmCode(retCodeConfig.getNotFoundPerson(), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        Predicate<Infos.StartCassette> loadPurposeTypeFilter = startCassette -> !CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE, startCassette.getLoadPurposeType());
        Predicate<Infos.LotInCassette> operationStartFilter = lotInCassette -> lotInCassette.getMoveInFlag() != null && lotInCassette.getMoveInFlag();
        startCassetteList.stream()
                .filter(loadPurposeTypeFilter)
                .forEach(startCassette -> startCassette.getLotInCassetteList().stream()
                        .filter(operationStartFilter)
                        .forEach(lotInCassette -> {
                            CimLot lot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                            Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), lotInCassette.getLotID().getValue()));
                            lot.makeProcessing();
                            lot.setLastClaimedPerson(aPerson);
                            lot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
                            lot.setStateChangedPerson(aPerson);
                            lot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
                        }));
    }

    @Override
    public ObjectIdentifier lotTestTypeIDGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {

         /*--------------------*/
        /*   Get Lot Object   */
        /*--------------------*/
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        /*-------------------*/
        /*   Get PO Object   */
        /*-------------------*/
        com.fa.cim.newcore.bo.pd.CimProcessOperation aPPO = aLot.getProcessOperation();
        Validations.check(null == aPPO, new OmCode(retCodeConfig.getNotFoundProcessOperation(),"*****",
                ObjectIdentifier.fetchValue(lotID)));
        /*-------------------------------*/
        /*   Get Product Specification   */
        /*-------------------------------*/
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification productSpecification = aLot.getProductSpecification();
        Validations.check(productSpecification == null, new OmCode(retCodeConfig.getNotFoundProductSpec()));

        com.fa.cim.newcore.bo.recipe.CimLogicalRecipe targetLr = aPPO.findLogicalRecipeFor(productSpecification);
        Validations.check(targetLr == null, new OmCode(retCodeConfig.getNotFoundLogicRecipe()));

        /*-------------------*/
        /*   Get Test Type   */
        /*-------------------*/
        CimTestType aTestType = targetLr.getTestType();
        Validations.check(aTestType == null, new OmCode(retCodeConfig.getNotFoundTestType()));
        ObjectIdentifier objectIdentifier = new ObjectIdentifier(aTestType.getIdentifier(), aTestType.getPrimaryKey());

        return objectIdentifier;
    }

    @Override
    public Infos.FutureHoldHistory lotFutureHoldRequestsMakeEntry(Infos.ObjCommon objCommon, Params.FutureHoldReqParams params) {
        final int holdTypeMaxLen = 20;

        ObjectIdentifier lotID = params.getLotID();
        String holdType = params.getHoldType();
        ObjectIdentifier routeID = params.getRouteID();
        String operationNumber = params.getOperationNumber();
        ObjectIdentifier reasonCodeID = params.getReasonCodeID();
        ObjectIdentifier relatedLotID = params.getRelatedLotID();
        String claimMemo = params.getClaimMemo();
        ObjectIdentifier userID = objCommon.getUser().getUserID();
        boolean postFlag = params.isPostFlag(); //false加工前暂停 true加工后暂停
        boolean singleTriggerFlag = params.isSingleTriggerFlag(); //false每次到此工步都暂停 true只暂停一次

        CimLot lotBO = baseCoreFactory.getBO(CimLot.class, lotID);
        /*-----   Check Input Parameter   -----*/
        Validations.check(CimObjectUtils.isEmpty(lotBO), retCodeConfig.getNotFoundLot());
        Validations.check(CimObjectUtils.isEmpty(holdType),retCodeConfig.getInvalidFtholdType() );
        Validations.check(holdTypeMaxLen < holdType.length(), retCodeConfig.getInvalidHoldtypeLength());
        Validations.check(ObjectIdentifier.isEmpty(reasonCodeID) ||
                        ObjectIdentifier.isEmpty(userID) ||
                        ObjectIdentifier.isEmpty(routeID) ||
                        CimObjectUtils.isEmpty(operationNumber)
                , retCodeConfig.getInvalidInputParam());

        //Check MainPD & Operation Number
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aMainPD = lotBO.getMainProcessDefinition();
        Validations.check(CimObjectUtils.isEmpty(aMainPD), retCodeConfig.getNotFoundProcessDefinition());
        String mainPdMainPdid = aMainPD.getIdentifier();
        String lotOperationNumber = lotBO.getOperationNumber();
        //如果是加工后暂停就不能多次暂停
        Validations.check(postFlag && !singleTriggerFlag, retCodeConfig.getInvalidFtholdType());


        if (ObjectIdentifier.equalsWithValue(routeID, mainPdMainPdid) && operationNumber.equals(lotOperationNumber) && CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_TYPE_FUTUREHOLD, holdType)) {
            if (!postFlag) { //如果lot是当前工序工步则不能在加工前FutureHold
                throw new ServiceException(retCodeConfig.getInvalidFtholdType());
            }
        }

        if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_TYPE_FUTUREHOLD, holdType)) {
            /*-----   Call process_OperationListForLot   -----*/
            Inputs.ObjProcessOperationProcessRefListForLotIn in = new Inputs.ObjProcessOperationProcessRefListForLotIn();
            in.setSearchDirection(true);
            in.setPosSearchFlag(false);
            in.setSearchCount(9999);
            in.setSearchRouteID(routeID);
            in.setSearchOperationNumber(operationNumber);
            in.setCurrentFlag(true);
            in.setLotID(lotID);

            List<Infos.OperationProcessRefListAttributes> operationProcessRefListAttributesList = processMethod.processOperationProcessRefListForLot(objCommon, in);
            Validations.check(CimArrayUtils.isEmpty(operationProcessRefListAttributesList), "OperationProcessRefListAttributes is null");
            String tempOperationNo = null;
            int operationCount = operationProcessRefListAttributesList.size();
            Infos.OperationProcessRefListAttributes lastOperationNameAttributes = operationProcessRefListAttributesList.get(operationCount-1);

            if (!ObjectIdentifier.equalsWithValue(routeID, lastOperationNameAttributes.getRouteID())
                    || !CimStringUtils.equals(operationNumber, lastOperationNameAttributes.getOperationNumber())){
                throw new ServiceException(new OmCode(retCodeConfig.getNotFoundRouteOpe(), ObjectIdentifier.fetchValue(routeID), operationNumber));
            }
            CimProcessDefinition tmpPosPD = null;
            if (postFlag) {
                //===== Get the target operation's next operation =====//
                //----- The target operation's main process flow
                Infos.ProcessRef processRef = lastOperationNameAttributes.getProcessRef();
                com.fa.cim.newcore.bo.pd.CimProcessFlow aMainPF = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessFlow.class, processRef.getMainProcessFlow());
                Validations.check(CimObjectUtils.isEmpty(aMainPF), retCodeConfig.getNotFoundPfx());

                //----- The target operation's module number
                String moduleNo = processRef.getModuleNumber();

                //----- The target operation's module profess flow
                com.fa.cim.newcore.bo.pd.CimProcessFlow aModulePF = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessFlow.class, processRef.getModuleProcessFlow());
                Validations.check(CimObjectUtils.isEmpty(aModulePF), retCodeConfig.getNotFoundPfx());

                //----- The target operation's module profess operation specification
                com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aModulePOS = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification.class, processRef.getModulePOS());
                Validations.check(CimObjectUtils.isEmpty(aModulePOS), retCodeConfig.getNotFoundPos());

                //----- The target lot's process flow context begins ------//
                com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = lotBO.getProcessFlowContext();
                Validations.check (CimObjectUtils.isEmpty(aPFX), retCodeConfig.getNotFoundPfx());

                // prepare out parameters
                AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> aMainPFOut = new AtomicReference<>(null);;
                AtomicReference<String> moduleNoOut = new AtomicReference<>(null);
                AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> aModulePFOut = new AtomicReference<>(null);;
                AtomicReference<Integer> seqNoOut = new AtomicReference<>(0);
                com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aModulePOSOut = aPFX.getNextProcessOperationSpecificationFor(aMainPF,   moduleNo,   aModulePF,  aModulePOS, aMainPFOut, moduleNoOut, aModulePFOut, 0, seqNoOut);

                String moduleNum = moduleNoOut.get();
                if(CimObjectUtils.isEmpty(aModulePOSOut)){
                    log.info( "The target operation is same as the lot's final operation, so the duplication is not checked.");
                } else{
                    String moduleOpeNo = aModulePOSOut.getOperationNumber();
                    tempOperationNo = BaseStaticMethod.convertModuleOpeNoToOpeNo(moduleNum, moduleOpeNo);
                    log.info("The target operation's next operation is checked about the duplication.");

                    Validations.check(CimObjectUtils.isEmpty(aMainPFOut.get()), retCodeConfig.getNotFoundProcessFlow());

                    tmpPosPD = aMainPFOut.get().getRootProcessDefinition();
                    Validations.check(CimObjectUtils.isEmpty(tmpPosPD), retCodeConfig.getNotFoundProcessDefinition());
                }
                //----- The target lot's process flow context ends ------//
            } else {
                if (operationCount < 2 ) {
                    log.info("The target operation is same as the lot's current operation, so the duplication is not checked.");
                }else{
                    Infos.OperationProcessRefListAttributes operationProcessRefListAttributes = operationProcessRefListAttributesList.get(operationCount - 1);
                    tempOperationNo = operationProcessRefListAttributes.getOperationNumber();
                    ObjectIdentifier opeRouteID = operationProcessRefListAttributes.getRouteID();
                    if (!ObjectIdentifier.equalsWithValue(opeRouteID, mainPdMainPdid)) {
                        tmpPosPD = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessDefinition.class, opeRouteID);
                    } else {
                        tmpPosPD = aMainPD;
                    }
                }
            }
            // Get FutureHold List
            if (!CimStringUtils.isEmpty(tempOperationNo)) {
                List<ProductDTO.FutureHoldRecord> aFutureHoldRecords= lotBO.findFutureHoldRecordsFor(tmpPosPD, tempOperationNo);

                /*-----   Check FutureHold List   -----*/
                for(int i=0; i < aFutureHoldRecords.size(); i++){
                    ProductDTO.FutureHoldRecord tmpFutureHoldRecord = aFutureHoldRecords.get(i);
                    if (tmpFutureHoldRecord.getHoldType().equals(holdType)
                            && ObjectIdentifier.equalsWithValue(tmpFutureHoldRecord.getReasonCode(), reasonCodeID) &&
                            ObjectIdentifier.equalsWithValue(tmpFutureHoldRecord.getRequestPerson(), objCommon.getUser().getUserID()) &&
                            ObjectIdentifier.equalsWithValue(tmpFutureHoldRecord.getRelatedLot(), relatedLotID)) {

                        if (postFlag) {
                            if (!CimBooleanUtils.isTrue(tmpFutureHoldRecord.isPostFlag())) {
                                throw new ServiceException(retCodeConfig.getDuplicateFtholdEntry());

                            }
                        } else {
                            if (CimBooleanUtils.isTrue(tmpFutureHoldRecord.isPostFlag())) {
                                throw new ServiceException(retCodeConfig.getDuplicateFtholdEntry());

                            }
                        }
                    }
                }
            }
        }

        ProductDTO.FutureHoldRecord futureHoldRecord = new ProductDTO.FutureHoldRecord();
        futureHoldRecord.setHoldType(holdType);
        futureHoldRecord.setReasonCode(reasonCodeID);
        futureHoldRecord.setRequestPerson(userID);
        futureHoldRecord.setMainProcessDefinition(routeID);
        futureHoldRecord.setOperationNumber(operationNumber);
        futureHoldRecord.setRelatedLot(relatedLotID);
        futureHoldRecord.setClaimMemo(claimMemo);
        futureHoldRecord.setClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp().toString());
        futureHoldRecord.setPostFlag(postFlag);
        futureHoldRecord.setSingleTriggerFlag(singleTriggerFlag);
        String department = params.getDepartment();
        String section = params.getSection();
        if (CimStringUtils.isNotEmpty(department) && CimStringUtils.isNotEmpty(section)) {
            futureHoldRecord.setDepartmentNamePlate(department + BizConstant.DOT + section);
        }

        try {
            lotBO.addFutureHoldRecord(futureHoldRecord);
        } catch (DuplicateRecordException e) {
            throw new ServiceException(retCodeConfig.getDuplicateFtholdEntry());

        }

        Infos.FutureHoldHistory futureHoldHistory = new Infos.FutureHoldHistory();
        futureHoldHistory.setHoldType(holdType);
        futureHoldHistory.setReasonCode(reasonCodeID);
        futureHoldHistory.setPerson(userID);
        futureHoldHistory.setRouteID(routeID);
        futureHoldHistory.setOperationNumber(operationNumber);
        futureHoldHistory.setRelatedLotID(relatedLotID);
        futureHoldHistory.setPostFlag(postFlag);
        futureHoldHistory.setSingleTriggerFlag(singleTriggerFlag);
        futureHoldHistory.setClaimMemo(claimMemo);

        return futureHoldHistory;
    }

    @Override
    public List<Infos.FutureHoldHistory> lotFutureHoldRequestsDeleteEntry(Infos.ObjCommon objCommon, Params.FutureHoldCancelReqParams params) {
        ObjectIdentifier lotID = params.getLotID();
        String entryType = params.getEntryType();
        List<Infos.LotHoldReq> lotHoldList = params.getLotHoldList();

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(lot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));

        List<Infos.FutureHoldHistory> futureHoldHistories = new ArrayList<>();
        for (Infos.LotHoldReq lotHold : lotHoldList) {
            ProductDTO.FutureHoldRecord lotFutureHold = new ProductDTO.FutureHoldRecord();
            lotFutureHold.setHoldType(lotHold.getHoldType());
            lotFutureHold.setReasonCode(lotHold.getHoldReasonCodeID());
            lotFutureHold.setRequestPerson(lotHold.getHoldUserID());
            lotFutureHold.setMainProcessDefinition(lotHold.getRouteID());
            lotFutureHold.setOperationNumber(lotHold.getOperationNumber());
            lotFutureHold.setRelatedLot(lotHold.getRelatedLotID());
            lotFutureHold.setSingleTriggerFlag(false);

            boolean postFlag;
            boolean singleTriggerFlag;
            ProductDTO.FutureHoldRecord aFutureHold = lot.findFutureHoldRecord(lotFutureHold);
            if (CimObjectUtils.isEmpty(aFutureHold)) {
                continue;
            }
            else {
                Validations.check(CimStringUtils.isEmpty(aFutureHold.getHoldType()), new OmCode(retCodeConfig.getFtholdNotFound(),
                        lotFutureHold.getOperationNumber(), lotFutureHold.getMainProcessDefinition().getValue(), lotID.getValue()));
                postFlag = CimBooleanUtils.isTrue(aFutureHold.isPostFlag());
                singleTriggerFlag = CimBooleanUtils.isTrue(aFutureHold.isSingleTriggerFlag());
            }
            lot.removeFutureHoldRecord(lotFutureHold);
            Infos.FutureHoldHistory futureHoldHistory = new Infos.FutureHoldHistory();
            futureHoldHistory.setEntryType(entryType);
            futureHoldHistory.setHoldType(lotFutureHold.getHoldType());
            futureHoldHistory.setReasonCode(lotFutureHold.getReasonCode());
            futureHoldHistory.setPerson(lotFutureHold.getRequestPerson());
            futureHoldHistory.setRouteID(lotFutureHold.getMainProcessDefinition());
            futureHoldHistory.setOperationNumber(lotFutureHold.getOperationNumber());
            futureHoldHistory.setPostFlag(postFlag);
            futureHoldHistory.setSingleTriggerFlag(singleTriggerFlag);
            futureHoldHistory.setRelatedLotID(lotFutureHold.getRelatedLot());
            futureHoldHistory.setClaimMemo(lotFutureHold.getClaimMemo());
            futureHoldHistories.add(futureHoldHistory);
        }
        return futureHoldHistories;
    }


    @Override
    //@Transactional
    public List<Infos.ReceivedLotInfo> lotPreparationCancel(Infos.ObjCommon objCommon, Inputs.ObjLotPreparationCancelIn objLotPreparationCancelIn) {


        // step1 - input parameter
        log.debug("[step-1]  input parameter");
        ObjectIdentifier preparationCancelledLotID = objLotPreparationCancelIn.getPreparationCancelledLoID();
        ObjectIdentifier bankID = objLotPreparationCancelIn.getBankID();
        List<Infos.NewVendorLotInfo> newVendorLotInfoList = objLotPreparationCancelIn.getNewVendorLotInfoList();
        log.debug("[in-param] preparationCancelledLotID: {}", preparationCancelledLotID);
        log.debug("[in-param] bankID: {}", bankID);

        // step2 - check input parameter
        log.debug("[step-2]  check input parameter");
        CimLot aCancelledLot = baseCoreFactory.getBO(CimLot.class, preparationCancelledLotID);
        log.trace("null == aCancelledLot : {}", null == aCancelledLot);
        if (null == aCancelledLot) {
            log.error("not found lot which sourceLotID is {} in OMLOT table", preparationCancelledLotID);
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundLot(), preparationCancelledLotID.getValue()));
        }

        com.fa.cim.newcore.bo.factory.CimBank aBank = aCancelledLot.getBank();
        log.trace("null == aBank : {}", null == aBank);
        if (null == aBank) {
            log.error("not found bank which bankID  in OMBANK table");
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundBank(), "****"));
        }

        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        log.trace("null == aPerson : {}", null == aPerson);
        if (null == aPerson) {
            log.error("not found user which userID is {} in OMUSER table", objCommon.getUser().getUserID());
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
        }

        // step2 - new vendor lot creation
        log.debug("[step-3]  new vendor lot creation");
        List<Infos.ReceivedLotInfo> tmpReceivedLotInfoList = new ArrayList<>();
        for (Infos.NewVendorLotInfo newVendorLotInfo : newVendorLotInfoList) {
            com.fa.cim.newcore.bo.prodspec.CimProductSpecification aPosProdSpec = baseCoreFactory.getBO(com.fa.cim.newcore.bo.prodspec.CimProductSpecification.class, newVendorLotInfo.getProductID());
            log.trace("null == aPosProdSpec : {}", null == aPosProdSpec);
            if (null == aPosProdSpec) {
                throw new ServiceException(retCodeConfig.getInvalidProdId());
            }
            log.trace("StringUtils.isEmpty(newVendorLotInfo.getSubLotType()) : {}", CimStringUtils.isEmpty(newVendorLotInfo.getSubLotType()));
            if (CimStringUtils.isEmpty(newVendorLotInfo.getSubLotType())) {
                throw new ServiceException(retCodeConfig.getNotFoundSubLotType());
            }

            // step2-1 create new lot
            log.debug("[step-2-1]  new vendor lot creation");
            com.fa.cim.newcore.bo.planning.CimProductRequest productRequest;
            Results.LotTypeLotIDAssignResult lotTypeLotIDAssignResult = new Results.LotTypeLotIDAssignResult();
            int retryCount = 0;

            while (true) {
                // Get a brand new LotID
                while(true) {
                    String assignedNewLotID = this.lotTypeLotIDAssign(objCommon, BizConstant.SP_LOT_TYPE_VENDORLOT, newVendorLotInfo.getProductID(), newVendorLotInfo.getSubLotType());

                    // Check Existence of lot that was specified systematically
                    CimLot aLot = productManager.findLotNamed(assignedNewLotID);
                    log.trace("ObjectUtils.isEmpty(aLot) : {}", CimObjectUtils.isEmpty(aLot));
                    if (CimObjectUtils.isEmpty(aLot)) {
                        log.info("Unassigned LotID");
                        lotTypeLotIDAssignResult.setAssignedLotID(assignedNewLotID);
                        break;
                    }

                    log.debug("Assigned LotID {} found, Continue...", assignedNewLotID);
                }

                // Create ProductRequest for Vendor Lot
                try {
                    productRequest = planManager.createProductRequestNamed(lotTypeLotIDAssignResult.getAssignedLotID(), aPosProdSpec);
                    break;
                } catch (Exception e) {
                    //  e.printStackTrace();
                    log.error("Retry count: {}", ++retryCount);
                }
            }

            log.trace("null == productRequest : {}", null == productRequest);
            if (null == productRequest) {
                throw new ServiceException(retCodeConfig.getNotFoundSystemObj());
            }

            //step2-3 set productRequest info
            log.debug("[step-2-3] Set Product Request Info");
            productRequest.setAllStatesForVendorLot();
            productRequest.setProductSpecification(aPosProdSpec);
            productRequest.setStartBank(aBank);
            productRequest.setEndBank(aBank);
            productRequest.setLotType(BizConstant.SP_LOT_TYPE_VENDORLOT);
            productRequest.setSubLotType(newVendorLotInfo.getSubLotType());
            productRequest.setProductQuantity(newVendorLotInfo.getWaferCount());
            productRequest.setDeliveryDateTime(CimObjectUtils.toString(objCommon.getTimeStamp().getReportTimeStamp()));
            productRequest.setPlanReleaseDateTime(CimObjectUtils.toString(objCommon.getTimeStamp().getReportTimeStamp()));


            CimLot newLot = productManager.createLotUsing(productRequest);
            // PS: Framework exception check is in core layer.
            log.trace("null == newLot : {}", null == newLot);
            if (null == newLot) {
                throw new ServiceException(retCodeConfig.getNotFoundLot());
            }

            //  step2-4 set new lot info
            log.debug("[step-2-4] set new lot info");
            newLot.setAllStatesForVendorLot();
            newLot.setVendorLot(newVendorLotInfo.getVendorLotID());
            newLot.setVendor(newVendorLotInfo.getVendorName());
            newLot.setVendorLotQuantity(newVendorLotInfo.getWaferCount());
            newLot.setBank(aBank);
            newLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            newLot.setLastClaimedPerson(aPerson);
            newLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            newLot.setStateChangedPerson(aPerson);
            newLot.setInventoryStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            newLot.setInventoryStateChangedPerson(aPerson);
            newLot.makeWaitUse();

            // get new lot information to set output
            log.debug("[step-2-5] Get new lot information to set output...");
            Infos.ReceivedLotInfo receivedLotInfo = new Infos.ReceivedLotInfo();
            receivedLotInfo.setNewLotID(newLot.getLotID());
            receivedLotInfo.setSubLotType(newLot.getSubLotType());
            receivedLotInfo.setWaferCount(newLot.getQuantity());
            receivedLotInfo.setOriginalVendorLotID(newVendorLotInfo.getOriginalVendorLotID());
            log.debug("[step-2-6] New vendor lot is created. New vendor sourceLotID is  {}", newLot.getLotID());
            tmpReceivedLotInfoList.add(receivedLotInfo);
        }

        // step3 - update cancelled lot's quantity info
        log.debug("[step-3] update cancelled lot's quantity info...");
        aCancelledLot.setProductQuantity(0);
        aCancelledLot.setControlQuantity(0);
        aCancelledLot.setVendorLotQuantity(0);

        // step4 - change lot to archive
        log.debug("[step-4] change lot to archive");
        CimLotFamily aLotFamily = aCancelledLot.getLotFamily();
        log.trace("null == aLotFamily : {}", null == aLotFamily);
        if (null == aLotFamily) {
            throw new ServiceException(retCodeConfig.getNotFoundLotFamily());
        }

        String sourceLotID = aCancelledLot.getIdentifier();
        String lotFamilyID = aLotFamily.getIdentifier();
        List<Lot> aCurrentLotList = aLotFamily.currentLots();
        List<Lot> anArchiveLotList = aLotFamily.archive();
        boolean sourceLotFoundInCurrentLots = false;
        boolean sourceLotFoundInArchiveLots = false;

        for (Lot tmpLot : aCurrentLotList) {
            log.trace("StringUtils.equals(tmpLot.getIdentifier(), sourceLotID) : {}", CimStringUtils.equals(tmpLot.getIdentifier(), sourceLotID));
            if (CimStringUtils.equals(tmpLot.getIdentifier(), sourceLotID)) {
                sourceLotFoundInCurrentLots = true;
                break;
            }
        }

        for (Lot tmpLot : anArchiveLotList) {
            log.trace("StringUtils.equals(tmpLot.getIdentifier(), sourceLotID) : {}", CimStringUtils.equals(tmpLot.getIdentifier(), sourceLotID));
            if (CimStringUtils.equals(tmpLot.getIdentifier(), sourceLotID)) {
                sourceLotFoundInArchiveLots = true;
                break;
            }
        }
        log.trace("sourceLotFoundInCurrentLots && !sourceLotFoundInArchiveLots : {}", sourceLotFoundInCurrentLots && !sourceLotFoundInArchiveLots);
        if (sourceLotFoundInCurrentLots && !sourceLotFoundInArchiveLots) {
            log.debug("preparation cancelled lot is in currentLots list of lot family!");
            aLotFamily.archiveLot(aCancelledLot);
            aLotFamily.removeCurrentLot(aCancelledLot);
        } else {
            throw new ServiceException(retCodeConfig.getLotLotFamilyDataInvalid());
        }

        // step5 - make lot state emptied
        log.debug("[step-5] make lot state emptied...");
        aCancelledLot.makeEmptied();

        String envEventCreateTypeString = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
        int envEventCreateType = envEventCreateTypeString == null ? 0 : Integer.parseInt(envEventCreateTypeString);
        log.trace("BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED == envEventCreateType\n" +
                        "                || BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED == envEventCreateType : {}",
                BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED == envEventCreateType
                        || BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED == envEventCreateType);
        if (BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED == envEventCreateType
                || BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED == envEventCreateType) {
            com.fa.cim.newcore.bo.pd.CimProcessOperation aCurrentPO = aCancelledLot.getProcessOperation();
            log.trace("ObjectUtils.isEmpty(aCurrentPO) : {}", CimObjectUtils.isEmpty(aCurrentPO));
            if (CimObjectUtils.isEmpty(aCurrentPO)) {
                processMethod.poDelQueuePutDR(objCommon, preparationCancelledLotID);
            }
        }

        // update last claimed info
        log.debug("[step-6] update last claimed info...");
        aCancelledLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aCancelledLot.setLastClaimedPerson(aPerson);

      /*
        //【bear】new demand: in the newest siview , it must keep the lot not in cassette(in other Tx realize)
        // before call vendor lot prepared cancel, but now. to make the function available, we delete the cassette-lot info directly.
        // 2019/10/23 Wafer Info will be deleted in another method!!!!!!!!!!!!!!!
        log.info("delete Cassette info");

        //step6 - get lot's wafer info
        List<Infos.WaferInfo> waferInfoList= aCancelledLot.getAllWaferInfo();

        for (Infos.WaferInfo wafer : waferInfoList) {
            com.fa.cim.newcore.bo.durable.CimCassette cassette = baseCoreFactory.getBO(com.fa.cim.newcore.bo.durable.CimCassette.class, wafer.getMaterialContainer());
            log.info("delete cassette - wafer info");
            cassette.removeWaferFromPosition(wafer.getPosition());
        }
        //delete OMCARRIER_LOT info
        aCancelledLot.removeAllCassettes();
     */
        return tmpReceivedLotInfoList;
    }

    @Override
    public void lotRecipeCombinationCheckForLoading(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, List<Infos.StartCassette> startCassettes, String loadPurposeType) {
        int strSearchCondition = StandardProperties.OM_CONSTRAINT_CHK_WITH_SEARCH.getIntValue();
        /*-----------------------------------------*/
        /*   Get Machine Object for Recipe Check   */
        /*-----------------------------------------*/
        CimMachine aMachine = baseCoreFactory.getBO(CimMachine.class, equipmentID);
        Validations.check(aMachine == null, new OmCode(retCodeConfig.getNotFoundEqp(), equipmentID.getValue()));
        /*----------------------------------------*/
        /*   Check machineRecipe vs logicalRecipe */
        /*   <condition>                          */
        /*    - MultiLotSingleRecipe              */
        /*    - SingleLotSingleRecipe             */
        /*    - MultiChamberType                  */
        /*    - machineRecipe = all Lot Recipe    */
        /*----------------------------------------*/
        String multiRecipeCapability = aMachine.getMultipleRecipeCapability();
        String equipmentCategory = aMachine.getCategory();
        List<ProcessResource> aProcessResourceSeq = aMachine.allProcessResources();
        int pResourceLen = CimArrayUtils.getSize(aProcessResourceSeq);
        for (int i = 0; i < CimArrayUtils.getSize(startCassettes); i++) {
            Infos.StartCassette startCassette = startCassettes.get(i);
            com.fa.cim.newcore.bo.durable.CimCassette aCassette = baseCoreFactory.getBO(com.fa.cim.newcore.bo.durable.CimCassette.class, startCassette.getCassetteID());
            Validations.check(aCassette == null, new OmCode(retCodeConfig.getNotFoundCassette(), startCassette.getCassetteID().getValue()));
            String multiLotType = aCassette.getMultiLotType();
            if (pResourceLen > 0 && (CimStringUtils.equals(multiLotType, BizConstant.SP_CAS_MULTILOTTYPE_MULTILOTSINGLERECIPE)
                    || CimStringUtils.equals(multiLotType, BizConstant.SP_CAS_MULTILOTTYPE_SINGLELOTSINGLERECIPE))) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                int lotLen = CimArrayUtils.getSize(lotInCassetteList);
                String baseMachineRecipeID = null;
                String baseLogicalRecipeID = null;
                for (int j = 0; j < lotLen; j++) {
                    Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                    if (lotInCassette.getMoveInFlag()) {
                        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotInCassette.getLotID().getValue()));
                        com.fa.cim.newcore.bo.pd.CimProcessOperation aPO = aLot.getProcessOperation();
                        Validations.check(aPO == null, new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****", aLot.getIdentifier()));
                        com.fa.cim.newcore.bo.prodspec.CimProductSpecification aProdSpec = aLot.getProductSpecification();
                        Validations.check(aProdSpec == null, retCodeConfig.getNotFoundProductSpec());
                        /*------------------------*/
                        /*   Get Logical Recipe   */
                        /*------------------------*/
                        com.fa.cim.newcore.bo.recipe.CimLogicalRecipe aLogicalRecipe = aPO.findLogicalRecipeFor(aProdSpec);
                        Validations.check(aLogicalRecipe == null, retCodeConfig.getNotFoundLogicalRecipe());
                        /*------------------------*/
                        /*   Get Machine Recipe   */
                        /*------------------------*/
                        String subLotType = aLot.getSubLotType();
                        com.fa.cim.newcore.bo.recipe.CimMachineRecipe aMachineRecipe = null;
                        if (strSearchCondition == 1){
                            aMachineRecipe = aLogicalRecipe.findMachineRecipeFor(aLot, aMachine);
                        } else {
                            aMachineRecipe = aLogicalRecipe.findMachineRecipeForSubLotType(aMachine, subLotType);
                        }
                        Validations.check(aMachineRecipe == null, retCodeConfig.getNotFoundMachineRecipe());
                        /*---------------------------------------------*/
                        /*   Compare Logical Recipe / Machine Recipe   */
                        /*---------------------------------------------*/
                        String logicalRecipeID = aLogicalRecipe.getIdentifier();
                        String machineRecipeID = aMachineRecipe.getIdentifier();
                        //-- store logicalRecipe for compare
                        if (CimStringUtils.isEmpty(baseLogicalRecipeID)){
                            baseLogicalRecipeID = logicalRecipeID;
                        }
                        //-- store machineRecipe for compare
                        if (CimStringUtils.isEmpty(baseMachineRecipeID)){
                            baseMachineRecipeID = machineRecipeID;
                        }
                        Validations.check(!CimStringUtils.equals(machineRecipeID, baseMachineRecipeID) || !CimStringUtils.equals(logicalRecipeID, baseLogicalRecipeID),
                                retCodeConfig.getInvalidRecipeConditionForEqp());
                    }
                }
            }
        }
    }

    @Override
    public List<Infos.LotWaferAttributes> lotMaterialsGetWafers(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        List<Infos.LotWaferAttributes> lotWaferAttributes = new ArrayList<>();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());
        List<ProductDTO.WaferInfo> waferInfoList = lot.getAllWaferInfo();
        if (CimObjectUtils.isEmpty(waferInfoList)) {
            Integer aQuantity = lot.getQuantity();
            /*--------------------------*/
            /*   Get max wafer in lot   */
            /*--------------------------*/
            Integer lMaxWfr = 0;
            Integer compValue = 0;
            String environmentLotValue = StandardProperties.OM_MAX_WAFER_COUNT_FOR_LOT.getValue();
            Integer sMaxWfr = Integer.parseInt(CimObjectUtils.isEmpty(environmentLotValue) ? "0" : environmentLotValue);
            lMaxWfr = sMaxWfr;
            if (lMaxWfr > 0L){
                compValue = lMaxWfr;
            } else {
                compValue = Integer.parseInt(CimObjectUtils.isEmpty(environmentLotValue) ? "0" : environmentLotValue);
            }
            aQuantity = ((aQuantity < compValue) ? aQuantity : compValue);
            com.fa.cim.newcore.bo.prodspec.CimProductSpecification aProductSpecification = lot.getProductSpecification();
            Validations.check(null == aProductSpecification, retCodeConfig.getNotFoundProductSpec());
            for (int i = 0; i < aQuantity; i++) {
                Infos.LotWaferAttributes lotWaferAttribute = new Infos.LotWaferAttributes();
                lotWaferAttribute.setWaferID(new ObjectIdentifier("",""));
                lotWaferAttribute.setProductID(new ObjectIdentifier(aProductSpecification.getIdentifier(), aProductSpecification.getPrimaryKey()));
                lotWaferAttribute.setControlWaferFlag(false);
                lotWaferAttribute.setSTBAllocFlag(false);
                lotWaferAttribute.setSlotNumber(i+1);
                lotWaferAttribute.setGrossUnitCount(0);
                lotWaferAttribute.setGoodUnitCount(0);
                lotWaferAttribute.setRepairUnitCount(0);
                lotWaferAttribute.setFailUnitCount(0);
                lotWaferAttributes.add(lotWaferAttribute);
            }
        } else {
            for (ProductDTO.WaferInfo waferInfo : waferInfoList) {
                Infos.LotWaferAttributes lotWaferAttribute = new Infos.LotWaferAttributes();
                lotWaferAttribute.setWaferID(waferInfo.getWaferID());
                lotWaferAttribute.setSlotNumber(waferInfo.getPosition());
                lotWaferAttribute.setProductID(waferInfo.getProductSpecification());
                lotWaferAttribute.setGrossUnitCount(waferInfo.getTotalDiceQuantity());
                lotWaferAttribute.setGoodUnitCount(waferInfo.getGoodDiceQuantity());
                lotWaferAttribute.setRepairUnitCount(waferInfo.getRepairedDiceQuantity());
                lotWaferAttribute.setFailUnitCount(waferInfo.getBadDiceQuantity());
                lotWaferAttribute.setControlWaferFlag(waferInfo.getControlWafer());
                lotWaferAttribute.setSTBAllocFlag(waferInfo.getStbAllocated());
                lotWaferAttributes.add(lotWaferAttribute);
            }
        }
        // Sort by waferID
        lotWaferAttributes.sort(Comparator.comparing(waferInfo -> waferInfo.getWaferID().getValue()));
        return lotWaferAttributes;
    }

    @Override
    public List<Infos.LotWaferInfoAttributes> lotWaferInfoListGetDR(Infos.ObjCommon objCommon, Inputs.ObjLotWafersGetIn objLotWafersGetIn) {

        List<Infos.LotWaferInfoAttributes> lotWaferInfoAttributesList = new ArrayList<>();
        String querySql = null;
        ObjectIdentifier lotID = objLotWafersGetIn.getLotID();
        String sql = "SELECT ID,\n" +
                "                           WAFER_ID,\n" +
                "                           CARRIER_ID,\n" +
                "                           CARRIER_RKEY,\n" +
                "                           POSITION,\n" +
                "                           PROD_ID,\n" +
                "                           PROD_RKEY,\n" +
                "                           TOTAL_DICE_QTY,\n" +
                "                           GOOD_DICE_QTY,\n" +
                "                           REPAIRED_DICE_QTY,\n" +
                "                           BAD_DICE_QTY,\n" +
                "                           NPW_FLAG,\n" +
                "                           LOT_START_ALLOCATED,\n" +
                "                           ALIAS_WAFER_NAME,\n" +
                "                           AM_USED_COUNT\n" +
                "                    FROM OMWAFER\n" +
                "                    WHERE  LOT_ID = '%s'";

        if (objLotWafersGetIn.getScrapCheckFlag()) {
            sql = sql +  " AND SCRAP_STATE <> '%s' AND  SCRAP_STATE <> '%s' ORDER BY POSITION";
            querySql = String.format(sql, lotID.getValue(), BizConstant.SP_SCRAPSTATE_SCRAP, BizConstant.SP_SCRAPSTATE_GARBAGE);
        }else {
            sql = sql + " ORDER BY POSITION";
            querySql = String.format(sql, lotID.getValue());
        }
        List<CimWafer> wafers = baseCoreFactory.getBOListByCustom(CimWafer.class, querySql);
        if (!CimArrayUtils.isEmpty(wafers)) {
            for(CimWafer wafer : wafers){
                Infos.LotWaferInfoAttributes lotWaferInfoAttributes = new Infos.LotWaferInfoAttributes();
                lotWaferInfoAttributesList.add(lotWaferInfoAttributes);
                lotWaferInfoAttributes.setWaferID(new ObjectIdentifier(wafer.getIdentifier(), wafer.getPrimaryKey()));
                if (null != wafer.getMaterialContainer()) {
                    lotWaferInfoAttributes.setCassetteID(new ObjectIdentifier(wafer.getMaterialContainer().getIdentifier(), wafer.getMaterialContainer().getPrimaryKey()));
                }
                lotWaferInfoAttributes.setAliasWaferName(wafer.getAliasWaferName());
                lotWaferInfoAttributes.setSlotNumber(wafer.getPosition());
                lotWaferInfoAttributes.setProductID(new ObjectIdentifier(wafer.getProductSpecification().getIdentifier(), wafer.getProductSpecification().getPrimaryKey()));
                lotWaferInfoAttributes.setGrossUnitCount(wafer.getTotalDiceQuantity());
                lotWaferInfoAttributes.setGoodUnitCount(wafer.getGoodDiceQuantity());
                lotWaferInfoAttributes.setRepairUnitCount(wafer.getRepairedDiceQuantity() == null ? 0 : wafer.getRepairedDiceQuantity());
                lotWaferInfoAttributes.setFailUnitCount(wafer.getBadDiceQuantity() == null ? 0 : wafer.getBadDiceQuantity());
                lotWaferInfoAttributes.setControlWaferFlag(wafer.isControlWafer());
                lotWaferInfoAttributes.setSTBAllocFlag(wafer.isSTBAllocated());
                lotWaferInfoAttributes.setEqpMonitorUsedCount(wafer.getEquipmentMonitorUsedCount() == null ? 0 : wafer.getEquipmentMonitorUsedCount());
            }
        }
        if (CimArrayUtils.getSize(lotWaferInfoAttributesList) == 0){
            CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
            int quantity = lot.getQuantity();
            if (quantity > 0){
                /*--------------------------*/
                /*   Get max wafer in lot   */
                /*--------------------------*/
                int lMaxWfr = 0;
                int compValue = 0;
                String sMaxWfr = StandardProperties.OM_MAX_WAFER_COUNT_FOR_LOT.getValue();
                lMaxWfr = CimNumberUtils.intValue(sMaxWfr);
                if (lMaxWfr > 0){
                    compValue = lMaxWfr;
                } else {
                    compValue = BizConstant.SP_LOT_MAXIMUMWAFERSINALOT;
                }
                quantity = (quantity < compValue) ? quantity : compValue;
                for (int cnt = 0; cnt < quantity; cnt++){
                    Infos.LotWaferInfoAttributes lotWaferInfoAttributes = new Infos.LotWaferInfoAttributes();
                    lotWaferInfoAttributesList.add(lotWaferInfoAttributes);
                    lotWaferInfoAttributes.setWaferID(new ObjectIdentifier());
                    lotWaferInfoAttributes.setCassetteID(new ObjectIdentifier());
                    lotWaferInfoAttributes.setAliasWaferName("");
                    lotWaferInfoAttributes.setSlotNumber(cnt + 1);
                    lotWaferInfoAttributes.setProductID(new ObjectIdentifier(lot.getProductSpecification().getIdentifier(), lot.getProductSpecification().getPrimaryKey()));
                    lotWaferInfoAttributes.setGrossUnitCount(0);
                    lotWaferInfoAttributes.setGoodUnitCount(0);
                    lotWaferInfoAttributes.setRepairUnitCount(0);
                    lotWaferInfoAttributes.setFailUnitCount(0);
                    lotWaferInfoAttributes.setControlWaferFlag(false);
                    lotWaferInfoAttributes.setSTBAllocFlag(false);
                    lotWaferInfoAttributes.setEqpMonitorUsedCount(0);
                }
            }
        }

        return lotWaferInfoAttributesList;
    }

    @Override
    public Outputs.ObjLotCheckConditionForPOByControlJobOut lotCheckConditionForPOByControlJob(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier controlJobID) {
        Outputs.ObjLotCheckConditionForPOByControlJobOut out = new Outputs.ObjLotCheckConditionForPOByControlJobOut();

        boolean checkPrevFlag = true;
        out.setCurrentPOFlag(true);
        //------------------
        // Get lot Object
        //------------------
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        //--------------------------------------------------------------------------
        // Get Process Operation Object
        //--------------------------------------------------------------------------
        com.fa.cim.newcore.bo.pd.CimProcessOperation aPosPO = lot.getProcessOperation();
        if (aPosPO == null){
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****"));

        }
        //--------------------------------------------------------------------------
        // Get CJ from Current PO
        //--------------------------------------------------------------------------
        CimControlJob aPOControlJob = aPosPO.getAssignedControlJob();
        if (aPOControlJob != null){
            String tmpControlJobID = aPOControlJob.getIdentifier();
            //---------------------------------------
            // Check ControlJobID form Current PO
            //---------------------------------------
            if(CimStringUtils.equals(controlJobID.getValue(), tmpControlJobID)){
                out.setCurrentPOFlag(true);
                checkPrevFlag = false;
            }
        }
        if (checkPrevFlag){
            //--------------------------------------------------------------------------
            // Get PO from Previous Operation.
            //--------------------------------------------------------------------------
            com.fa.cim.newcore.bo.pd.CimProcessOperation aPrevPosPO = lot.getPreviousProcessOperation();
            if (aPrevPosPO == null){
                out.setCurrentPOFlag(true);
            } else {
                //--------------------------------------------------------------------------
                // Get CJ from Previous PO
                //--------------------------------------------------------------------------
                CimControlJob aPrevPOControlJob = aPrevPosPO.getAssignedControlJob();
                if (aPrevPOControlJob != null){
                    String tmpPrevControlJobID = aPrevPOControlJob.getIdentifier();
                    //----------------------------------------
                    // Check ControlJobID form Previous PO
                    //----------------------------------------
                    if (CimStringUtils.equals(controlJobID.getValue(), tmpPrevControlJobID)){
                        out.setCurrentPOFlag(false);
                    } else {
                        out.setCurrentPOFlag(true);
                    }
                } else {
                    out.setCurrentPOFlag(true);
                }
            }
        }
        return out;
    }

    @Override
    public void lotCheckFlowBatchConditionForRework(Infos.ObjCommon objCommon, Inputs.ObjLotCheckFlowBatchConditionForReworkIn reworkIn) {
        Validations.check((null == reworkIn || null == reworkIn.getReworkReq()), "【lotCheckFlowBatchConditionForRework】invalid paramter");
        ObjectIdentifier lotID = reworkIn.getReworkReq().getLotID();
        String returnOperationNumber = reworkIn.getReworkReq().getReturnOperationNumber();
        String currentOperationNumber = reworkIn.getReworkReq().getCurrentOperationNumber();
        ObjectIdentifier currentRouteID = reworkIn.getReworkReq().getCurrentRouteID();
        ObjectIdentifier subRouteID = reworkIn.getReworkReq().getSubRouteID();

        /**************************************************************************************************************/
        /* check the return point of the rework-route steps over the target or not                                    */
        /* check the return point of the rework operation is in a flowbatch Section or not                            */
        /* check the flowBatched lots go out from the flowbatch Section or not.                                       */
        /**************************************************************************************************************/

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);

        //【step1】get process flow context for lot
        log.debug("【step1】get process flow context by lotID:%s", lotID);
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = lot.getProcessFlowContext();
        Validations.check(null == aPFX, retCodeConfig.getNotFoundPfx());

        Boolean isAfter = aPFX.isAfterOperationNumber(returnOperationNumber, currentOperationNumber);

        //call processOperationProcessRefListForLot()
        log.debug("【TODO-NOTIMPL】【step2】call processOperationProcessRefListForLot()");
        Inputs.ObjProcessOperationProcessRefListForLotIn in = new Inputs.ObjProcessOperationProcessRefListForLotIn();
        in.setSearchDirection(isAfter);
        in.setPosSearchFlag(true);
        in.setSearchCount(9999);
        in.setSearchRouteID(currentRouteID);
        in.setSearchOperationNumber(returnOperationNumber);
        in.setCurrentFlag(true);
        in.setLotID(lotID);
        List<Infos.OperationProcessRefListAttributes> refListForLotOut = processMethod.processOperationProcessRefListForLot(objCommon, in);

        //【step3】check lot flow batch locate
        log.debug("【step3】check lot flow batch locate");
        int operationCountForLot = CimArrayUtils.getSize(refListForLotOut);
        Infos.ProcessRef processRef = operationCountForLot < 1 ? null : refListForLotOut.get(operationCountForLot - 1).getProcessRef();
        this.lotFlowBatchCheckLocate(objCommon, isAfter, lotID, processRef);

        // check the flowBatched lots move to the rework route with a flow batch section or not.
        log.debug("check the flowBatched lots move to the rework route with a flow batch section or not.");
        com.fa.cim.newcore.bo.dispatch.CimFlowBatch flowBatch = lot.getFlowBatch();
        if (null != flowBatch) {
            log.debug("the input lot has a flowBatchID, the lotID:%s", lotID);
            int searchCount = -1;
            Inputs.ProcessOperationListForRoute processOperationListForRoute = new Inputs.ProcessOperationListForRoute();
            processOperationListForRoute.setRouteID(subRouteID);
            processOperationListForRoute.setSearchCount(searchCount);
            List<Infos.OperationNameAttributes> operationListForRouteRetCode = processMethod.processOperationListForRoute(objCommon, processOperationListForRoute);

            Boolean sectionFoundFlag = false;
            int operationCountForRouteSize = CimArrayUtils.getSize(operationListForRouteRetCode);
            for (int i = 0; i < operationCountForRouteSize; i++) {
                Infos.OperationNameAttributes operationNameAttributes = operationListForRouteRetCode.get(i);
                String modulePOS = (null == operationNameAttributes.getProcessRef()) ? null: operationNameAttributes.getProcessRef().getModulePOS();
                Outputs.ObjProcessFlowBatchDefinitionGetDROut flowBatchDefinitionGetDROutRetCode = processMethod.processFlowBatchDefinitionGetDR(objCommon, modulePOS);

                String name = (null == flowBatchDefinitionGetDROutRetCode.getFlowBatchControl()) ? null : flowBatchDefinitionGetDROutRetCode.getFlowBatchControl().getName();
                if (!CimStringUtils.isEmpty(name)) {
                    Boolean entryOperationFlag = (null == flowBatchDefinitionGetDROutRetCode.getFlowBatchSection()) ? null : flowBatchDefinitionGetDROutRetCode.getFlowBatchSection().getEntryOperationFlag();
                    if (CimBooleanUtils.isTrue(entryOperationFlag)) {
                        log.debug("flow batch section is found.");
                        sectionFoundFlag = true;
                        break;
                    }
                }
            }
            Validations.check(CimBooleanUtils.isTrue(sectionFoundFlag), retCodeConfig.getNotReworkBatchOpe());
            log.debug("the rework route does not have a flow batch section.");
        }
    }

    @Override
    public void lotCheckBondingFlowSectionForRework(Infos.ObjCommon objCommon, Infos.ReworkReq reworkReq) {

        ObjectIdentifier lotID = reworkReq.getLotID();
        String returnOperationNumber = reworkReq.getReturnOperationNumber();
        String currentOperationNumber = reworkReq.getCurrentOperationNumber();
        ObjectIdentifier currentRouteID = reworkReq.getCurrentRouteID();
        ObjectIdentifier subRouteID = reworkReq.getSubRouteID();

        /**************************************************************************************************************/
        /* check the return point of the rework-route steps over the target or not                                    */
        /* check the return point of the rework operation is in a flowbatch Section or not                            */
        /* check the flowBatched lots go out from the flowbatch Section or not.                                       */
        /**************************************************************************************************************/
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        //【step1】get process flow context for lot
        log.debug("【step1】get process flow context by lotID:%s", lotID);
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext pfx = lot.getProcessFlowContext();
        Validations.check(null == pfx, retCodeConfig.getNotFoundPfx());

        Boolean isAfter = pfx.isAfterOperationNumber(returnOperationNumber, currentOperationNumber);

        //call processOperationProcessRefListForLot()
        log.debug("【TODO-NOTIMPL】【step2】call processOperationProcessRefListForLot()");
        Inputs.ObjProcessOperationProcessRefListForLotIn in = new Inputs.ObjProcessOperationProcessRefListForLotIn();
        in.setSearchDirection(isAfter);
        in.setPosSearchFlag(true);
        in.setSearchCount(9999);
        in.setSearchRouteID(currentRouteID);
        in.setSearchOperationNumber(returnOperationNumber);
        in.setCurrentFlag(true);
        in.setLotID(lotID);
        List<Infos.OperationProcessRefListAttributes> refListForLotOut = processMethod.processOperationProcessRefListForLot(objCommon, in);

        //【step3】check lot flow batch locate
        log.debug("【step3】check lot flow batch locate");
        int operationCountForLot = CimArrayUtils.getSize(refListForLotOut);
        Infos.ProcessRef processRef = operationCountForLot < 1 ? null : refListForLotOut.get(operationCountForLot - 1).getProcessRef();
        this.lotBondingFlowSectionCheckLocate(objCommon, lotID, processRef);

        // check the flowBatched lots move to the rework route with a flow batch section or not.
        log.debug(" Check the lots move to the rework route with a FlowBatch section or not .");
        String getDROutRetCode = this.lotBondingGroupIDGetDR(objCommon, lotID);

        if (CimStringUtils.isNotEmpty(getDROutRetCode)) {
            int searchCount = -1;
            Inputs.ProcessOperationListForRoute processOperationListForRoute = new Inputs.ProcessOperationListForRoute();
            processOperationListForRoute.setRouteID(subRouteID);
            processOperationListForRoute.setOperationID(new ObjectIdentifier(""));
            processOperationListForRoute.setOperationNumber("");
            processOperationListForRoute.setPdType("");
            processOperationListForRoute.setSearchCount(searchCount);
            List<Infos.OperationNameAttributes> operationListForRouteRetCode = processMethod.processOperationListForRoute(objCommon, processOperationListForRoute);

            int operationCountForRouteSize = CimArrayUtils.getSize(operationListForRouteRetCode);
            for (int i = 0; i < operationCountForRouteSize; i++) {
                Infos.OperationNameAttributes operationNameAttributes = operationListForRouteRetCode.get(i);
                String modulePOS = (null == operationNameAttributes.getProcessRef()) ? null: operationNameAttributes.getProcessRef().getModulePOS();
                Outputs.ObjProcessFlowBatchDefinitionGetDROut flowBatchDefinitionGetDROutRetCode = processMethod.processFlowBatchDefinitionGetDR(objCommon, modulePOS);

                String name = (null == flowBatchDefinitionGetDROutRetCode.getFlowBatchControl()) ? null : flowBatchDefinitionGetDROutRetCode.getFlowBatchControl().getName();
                if (!CimStringUtils.isEmpty(name)) {
                    throw new ServiceException(retCodeConfig.getNotReworkBondingFlow());
                }
            }
        } else{
            log.debug("The input lot does not have a bondingGroupID.");
        }

    }

    @Override
    public ObjectIdentifier lotCurrentRouteIDGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, retCodeConfig.getNotFoundLot());
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aPD = aLot.getMainProcessDefinition();
        Validations.check(CimObjectUtils.isEmpty(aPD),retCodeConfig.getNotFoundProcessDefinition(),"");
        if (CimObjectUtils.isEmpty(aPD)){
            return new ObjectIdentifier("","");
        }else {
            return new ObjectIdentifier(aPD.getIdentifier(),aPD.getPrimaryKey());
        }
    }

    @Override
    public Outputs.ObjLotWaferCreateOut lotWaferCreate(Infos.ObjCommon objCommon, ObjectIdentifier lotID, String newWaferID) {
        Outputs.ObjLotWaferCreateOut createOut = new Outputs.ObjLotWaferCreateOut();
        CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aPosLot == null, retCodeConfig.getNotFoundLot());
        //  check condition of lot
        int nTotalQuantity = aPosLot.getQuantity() == null ? 0 : aPosLot.getQuantity();
        int nProductQuantity = aPosLot.getProductQuantity() == null ? 0 : aPosLot.getProductQuantity();
        int nControlQuantity = aPosLot.getControlQuantity() == null ? 0 : aPosLot.getControlQuantity();
        if (0 == nTotalQuantity || ((nProductQuantity + nControlQuantity) >= nTotalQuantity)) {
            throw new ServiceException(new OmCode(retCodeConfig.getLotProductQuantityFull(), lotID.getValue()));
        }
        // create new wafer
        CimWafer aPosWafer = null;
        try {
            aPosWafer = productManager.createWafer(newWaferID);
        } catch (DuplicateRecordException e) {
            CimWafer cimWafer = productManager.findWaferNamed(newWaferID);
            Validations.check(null == cimWafer, retCodeConfig.getNotFoundWafer());
            Lot lot = cimWafer.getLot();
            Validations.check(null == lot, retCodeConfig.getNotFoundLot());
            throw new ServiceException(new OmCode(retCodeConfig.getDuplicateWafer(), newWaferID, lot.getIdentifier()));
        } catch (CoreFrameworkException | ServiceException ex) {
            throw ex;
        }
        // create relation between lot-wafer
        Validations.check(aPosWafer == null, retCodeConfig.getNotFoundWafer());
        aPosLot.addMaterial(aPosWafer);
        //---------------------------------------------
        // Update lot information
        //---------------------------------------------
        int nCurrentProductQuantity = aPosLot.getProductQuantity() == null ? 0 : aPosLot.getProductQuantity();
        aPosLot.setProductQuantity(nCurrentProductQuantity + 1);
        //---------------------------------------------
        // Set initial data into created wafer
        //---------------------------------------------
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification aPosProductSpec = aPosLot.getProductSpecification();
        aPosWafer.setProductSpecification(aPosProductSpec);
        // make wafer not allocated
        aPosWafer.makeNotSTBAllocated();
        // set wafer original name (this is same as waferID)
        aPosWafer.setOriginalIdentifier(newWaferID);
        // make Active
        aPosWafer.makeActive();
        // make control false
        aPosWafer.makeNotControlWafer();
        // Vendor lot info
        /*
        String tmpPreparationCancelEnv = environmentVariableManager.getValue(EnvConst.SP_LOT_PREPARECANCEL);
        if (StringUtils.equals(tmpPreparationCancelEnv, BizConstant.SP_LOT_PREPARECANCEL_ON)){
            List<Infos.STBInfo> stbInfoList = new ArrayList<>();
            Infos.STBInfo stbInfo = new Infos.STBInfo();
            stbInfoList.add(stbInfo);
            String subLotType = aPosLot.getSubLotType();
            com.fa.cim.newcore.bo.prodspec.CimProductSpecification aProdSpec = aPosLot.getProductSpecification();
            ObjectIdentifier tmpProdSpec = new ObjectIdentifier(aProdSpec.getIdentifier(), aProdSpec.getPrimaryKey());
            String vendorLotID = aPosLot.getVendorLot();
            String vendorName = aPosLot.getVendor();
            stbInfo.setVendorLotID(lotID.getValue());
            stbInfo.setVendorLotSubLotType(subLotType);
            stbInfo.setVendorLotProdSpecID(tmpProdSpec);
            stbInfo.setVendorVendLotID(vendorLotID);
            stbInfo.setVendorVendName(vendorName);
            aPosWafer.setSTBInfo(stbInfoList);
        }
        */
        List<ProductDTO.STBInfo> stbInfoList = new ArrayList<>();
        ProductDTO.STBInfo stbInfo = new ProductDTO.STBInfo();
        stbInfoList.add(stbInfo);
        String subLotType = aPosLot.getSubLotType();
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification aProdSpec = aPosLot.getProductSpecification();
        ObjectIdentifier tmpProdSpec = new ObjectIdentifier(aProdSpec.getIdentifier(), aProdSpec.getPrimaryKey());
        String vendorLotID = aPosLot.getVendorLot();
        String vendorName = aPosLot.getVendor();
        stbInfo.setVendorLotID(lotID.getValue());
        stbInfo.setVendorLotSubLotType(subLotType);
        stbInfo.setVendorLotProdSpecID(tmpProdSpec);
        stbInfo.setVendorVendLotID(vendorLotID);
        stbInfo.setVendorVendName(vendorName);
        aPosWafer.setSTBInfo(stbInfoList);
        // set wafer last claimed timestamp
        aPosWafer.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        // set wafer last claimed person
        com.fa.cim.newcore.bo.person.CimPerson aPosPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(aPosPerson == null, new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
        aPosWafer.setLastClaimedPerson(aPosPerson);
        // set lot last claimed timestamp
        aPosLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        // set lot last claimed person
        aPosLot.setLastClaimedPerson(aPosPerson);
        //---------------------------------------------
        // Prepare return structure
        //---------------------------------------------
        createOut.setLotID(new ObjectIdentifier(aPosLot.getIdentifier(), aPosLot.getPrimaryKey()));
        createOut.setNewWaferID(new ObjectIdentifier(aPosWafer.getIdentifier(), aPosWafer.getPrimaryKey()));
        return createOut;
    }

    @Override
    public String lotTransferStateGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot(), lotID);
        return lotTransferStateGet(objCommon, baseCoreFactory.getBO(CimLot.class, lotID));
    }

    @Override
    public String lotTransferStateGet(Infos.ObjCommon objCommon, CimLot lot) {
        List<MaterialContainer> aMaterialContainerList = lot.materialContainers();
        Validations.check(CimArrayUtils.isEmpty(aMaterialContainerList), retCodeConfig.getSystemError());
        CimCassette aCassette = (CimCassette) aMaterialContainerList.get(0);
        Validations.check(aCassette == null, new OmCode(retCodeConfig.getNotFoundCassette(), ""));
        return aCassette.getTransportState();
    }

    @Override
    public void lotMaterialsCheckExistance(Infos.ObjCommon objCommon, ObjectIdentifier lotID, List<Infos.ScrapWafers> scrapWafersList) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        if (!CimArrayUtils.isEmpty(scrapWafersList)){
            Material aMaterialTemp = null;
            for (Infos.ScrapWafers scrapWafers : scrapWafersList) {
                aMaterialTemp = aLot.findMaterialNamed(scrapWafers.getWaferID().getValue());
                Validations.check(null == aMaterialTemp, retCodeConfig.getNotFoundWafer());
            }
        }
    }

    @Override
    public void lotMaterialsScrapByWafer(Infos.ObjCommon objCommon, ObjectIdentifier lotID, List<Infos.ScrapWafers> scrapWafersList) {
        log.info("ObjCommon = {}, lotID = {}, List<Infos.ScrapWafers> = {}", objCommon, lotID, scrapWafersList);

        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, retCodeConfig.getNotFoundPerson());

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        List<MaterialContainer> lotMaterialContainers = lot.materialContainers();
        boolean bInCast = true;
        com.fa.cim.newcore.bo.durable.CimCassette cassette = null;
        if (CimObjectUtils.isEmpty(lotMaterialContainers)) {
            bInCast = false;
        } else {
            cassette = (com.fa.cim.newcore.bo.durable.CimCassette) lotMaterialContainers.get(0);

        }
        if (CimObjectUtils.isEmpty(cassette)) {
            Validations.check(bInCast, retCodeConfig.getSystemError());
        }
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        Integer waferCount = lot.getQuantity();
        Integer productWaferCount = lot.getProductQuantity();
        Integer controlWaferCount = lot.getControlQuantity();
        waferCount = CimObjectUtils.isEmpty(waferCount) ? 0 : waferCount;
        productWaferCount = CimObjectUtils.isEmpty(productWaferCount) ? 0 : productWaferCount;
        controlWaferCount = CimObjectUtils.isEmpty(controlWaferCount) ? 0 : controlWaferCount;
        log.info("waferCount = {}, productWaferCount = {}, controlWaferCount = {}", waferCount, productWaferCount, controlWaferCount);
        CimLotFamily lotFamily = lot.getLotFamily();
        Validations.check(null == lotFamily, retCodeConfig.getNotFoundLotFamily());

        int scrapWaferCount = scrapWafersList.size();
        if (waferCount == scrapWaferCount) {
            com.fa.cim.newcore.bo.pd.CimProcessDefinition processDefinition = lot.getMainProcessDefinition();
            if (!CimObjectUtils.isEmpty(processDefinition)) {
                String lotHoldState = lot.getLotHoldState();
                if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, lotHoldState)) {
                    dispatchingManager.removeFromHoldQueue(lot);
                } else {
                    dispatchingManager.removeFromQueue(lot);
                }
            }
            lot.makeScrapped();
            String envEventCreateType = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
            if (CimStringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED), envEventCreateType) ||
                    CimStringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED), envEventCreateType)) {

                com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = lot.getProcessOperation();
                if (!CimObjectUtils.isEmpty(processOperation)) {
                    processMethod.poDelQueuePutDR(objCommon, lotID);
                }
            }
            lot.setStateChangedTimeStamp(reportTimeStamp);
            lot.setStateChangedPerson(person);
        }
        int scrapControlNo = 0;
        int scrapProductNo = 0;
        List<Product> wafers = new ArrayList<>();
        for (Infos.ScrapWafers scrapWafers : scrapWafersList) {
            CimWafer wafer = baseCoreFactory.getBO(CimWafer.class, scrapWafers.getWaferID());
            Validations.check(null == wafer, retCodeConfig.getNotFoundWafer());
            wafer.makeScrap();
            if (CimBooleanUtils.isTrue(wafer.isControlWafer())) {
                scrapControlNo++;
            } else {
                scrapProductNo++;
            }
            wafer.setPreviousLot(lot);
            lot.removeMaterial(wafer);
            if (bInCast) {
                int slotPosition = wafer.getPosition();
                Material tempWaferOut = cassette.contentsOfPosition(slotPosition);

                CimWafer tempWafer = (CimWafer) tempWaferOut;
                Validations.check(null == tempWafer, retCodeConfig.getNotFoundWafer());

                if (ObjectIdentifier.equalsWithValue(scrapWafers.getWaferID(), tempWafer.getIdentifier())) {
                    wafers.add(wafer);
                }
            } else {
                wafers.add(wafer);
            }
            wafer.setLastClaimedTimeStamp(reportTimeStamp);
            wafer.setLastClaimedPerson(person);
        }

        if (waferCount != scrapWaferCount) {
            lotFamily.addProductUnitsScrapped(wafers);
        }
        lot.setLastClaimedTimeStamp(reportTimeStamp);
        lot.setLastClaimedPerson(person);
        lot.setVendorLotQuantity(waferCount - scrapWaferCount);
        lot.setProductQuantity(productWaferCount - scrapProductNo);
        lot.setControlQuantity(controlWaferCount - scrapControlNo);
        Validations.check(waferCount == scrapWaferCount, retCodeConfig.getAllScraped());
    }

    @Override
    public void lotWaferLotHistoryPointerUpdate(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot(), lotID);
        lotWaferLotHistoryPointerUpdate(objCommon, lot);
    }

    @Override
    public void lotWaferLotHistoryPointerUpdate(Infos.ObjCommon objCommon, CimLot lot) {
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        lot.setWaferHistoryTimeStamp(reportTimeStamp);
        lot.setLastClaimedTimeStamp(reportTimeStamp);
        CimPerson aPerson = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(aPerson == null, new OmCode(retCodeConfig.getNotFoundPerson(),
                objCommon.getUser().getUserID().getValue()));
        lot.setLastClaimedPerson(aPerson);
    }

    @Override
    public void lotFutureHoldRequestsCheckSplit(Infos.ObjCommon objCommon, ObjectIdentifier lotID, String mergedOperationNumber, String returnOperationNumber) {

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lot),retCodeConfig.getNotFoundLot());
        com.fa.cim.newcore.bo.pd.CimProcessDefinition processDefinition = lot.getMainProcessDefinition();
        Validations.check(null == processDefinition, retCodeConfig.getNotFoundProcessDefinition());
        String mainPDID = processDefinition.getIdentifier();

        com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = lot.getProcessOperation();
        Validations.check(null == processOperation, retCodeConfig.getNotFoundProcessOperation());

        String currentOperationNumber = processOperation.getOperationNumber();

        List<ProductDTO.FutureHoldRecord> aFutureHoldRecordSequence = lot.findFutureHoldRecordsFor(processDefinition, currentOperationNumber);
        Boolean postFutureHoldFlag = false;
        for (int i = 0; i < CimArrayUtils.getSize(aFutureHoldRecordSequence); i++) {
            if (aFutureHoldRecordSequence.get(i).isPostFlag()) {
                postFutureHoldFlag = true;
            }
        }
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext processFlowContext = lot.getProcessFlowContext();
        Validations.check(null == processFlowContext, retCodeConfig.getNotFoundMainRoute());

        if (CimObjectUtils.isEmpty(mergedOperationNumber) && CimObjectUtils.isEmpty(returnOperationNumber)) {
            return;
        }
        Boolean mergeCheckFlag  = true;
        Boolean returnCheckFlag = true;
        Boolean isAfterFlag  ;
        if (CimObjectUtils.isEmpty(mergedOperationNumber)) {
            mergeCheckFlag = false;
        } else {
            isAfterFlag = false;
            isAfterFlag = processFlowContext.isAfterOperationNumber(mergedOperationNumber,currentOperationNumber);
            if (CimBooleanUtils.isFalse(isAfterFlag)) {
                mergeCheckFlag = false;
            }
        }
        if (CimObjectUtils.isEmpty(returnOperationNumber)) {
            returnCheckFlag = false;
        } else {
            isAfterFlag = false;
            isAfterFlag = processFlowContext.isAfterOperationNumber(returnOperationNumber,currentOperationNumber);
            if (CimBooleanUtils.isFalse(isAfterFlag)) {
                returnCheckFlag = false;
            }
        }
        Validations.check(CimBooleanUtils.isTrue(postFutureHoldFlag) && CimBooleanUtils.isTrue(returnCheckFlag)
                , new OmCode(retCodeConfig.getNotFutureholdInSplit(), ObjectIdentifier.fetchValue(lotID), mainPDID, currentOperationNumber));

        if (CimBooleanUtils.isFalse(mergeCheckFlag) && CimBooleanUtils.isFalse(returnCheckFlag)) {
            //ok
            return;
        } else {

            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainProcessFlow =  new AtomicReference<>();
            AtomicReference<String> outModuleNumber = new AtomicReference<>();
            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outModuleProcessFlow = new AtomicReference<>();

            com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification moulePOS
                    = processFlowContext.getNextProcessOperationSpecificationOnCurrentRoute(outMainProcessFlow, outModuleNumber, outModuleProcessFlow);

            com.fa.cim.newcore.bo.pd.CimProcessFlow mianPF = outMainProcessFlow.get();
            String mouduleNumber = outModuleNumber.get();
            com.fa.cim.newcore.bo.pd.CimProcessFlow modulePF = outModuleProcessFlow.get();

            //===== Search an operation's future hold request =======//
            Infos.FutureHoldSearchKey futureHoldSearchKey1 = new Infos.FutureHoldSearchKey();
            futureHoldSearchKey1.setLotID(lotID);
            futureHoldSearchKey1.setRouteID(new ObjectIdentifier(mainPDID));
            futureHoldSearchKey1.setHoldType("");
            futureHoldSearchKey1.setReasonCodeID(new ObjectIdentifier(""));
            futureHoldSearchKey1.setUserID(new ObjectIdentifier(""));
            futureHoldSearchKey1.setOperationNumber("");
            futureHoldSearchKey1.setRelatedLotID(new ObjectIdentifier(""));
            futureHoldSearchKey1.setPhase("");
            futureHoldSearchKey1.setTriggerLevel("");
            List<Infos.FutureHoldListAttributes> keyOut = null;
            try {
                keyOut = this.lotFutureHoldListbyKeyDR(objCommon, futureHoldSearchKey1,0);
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getNotFoundFtholdEntW(), e.getCode())){
                    log.info("No futureHold exists.");
                    //ok
                    return;
                }else {
                    throw e;
                }
            }


            while (true) {
                if (null == moulePOS) {
                    break;
                }
                String aOperationNumber = BaseStaticMethod.convertModuleOpeNoToOpeNo(mouduleNumber, moulePOS.getOperationNumber());
                if (aOperationNumber.equals(returnOperationNumber)) {
                    returnCheckFlag = false;
                }
                if (CimStringUtils.equals(aOperationNumber,mergedOperationNumber)) {
                    mergeCheckFlag = false;
                    break;
                }
                if (CimBooleanUtils.isFalse(mergeCheckFlag) && CimBooleanUtils.isFalse(returnCheckFlag)) {
                    break;
                }
                //Bug-2803 2803 【PSM】PSM的split point和merge point中间的step有一个futrue hold，lot到了PSM的split point仍然分批了
                for (int i = 0; i < CimArrayUtils.getSize(keyOut); i++) {
                    if (!aOperationNumber.equals(keyOut.get(i).getOperationNumber())) {
                        continue;
                    }
                    if (CimStringUtils.equals(BizConstant.SP_HOLDTYPE_MERGEHOLD,keyOut.get(i).getHoldType())
                            || CimStringUtils.equals(BizConstant.SP_HOLDTYPE_REWORKHOLD,keyOut.get(i).getHoldType())) {
                        Lot aParentLot = lot.mostRecentlySplitFrom();
                        if (null == aParentLot) {
                            continue;
                        }
                        Validations.check(ObjectIdentifier.equalsWithValue(aParentLot.getIdentifier(), keyOut.get(i).getRelatedLotID()), retCodeConfig.getMergedBeforeMergepoint());
                    } else if (CimBooleanUtils.isTrue(returnCheckFlag)) {
                        Validations.check(true, new OmCode(retCodeConfig.getNotFutureholdInSplit(), ObjectIdentifier.fetchValue(lotID), mainPDID, aOperationNumber));
                    }
                }
                moulePOS = processFlowContext.getNextProcessOperationSpecificationOnCurrentRouteFor(mianPF, mouduleNumber, modulePF, moulePOS,
                        outMainProcessFlow, outModuleNumber, outModuleProcessFlow);
                 mianPF = outMainProcessFlow.get();
                 mouduleNumber = outModuleNumber.get();
                 modulePF = outModuleProcessFlow.get();
            }
        }

    }

    @Override
    public ObjectIdentifier lotSplitWaferLot(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID, List<ObjectIdentifier> childWaferID) {
        // Get environment variable
        String requeueFlag = StandardProperties.OM_SPLIT_LOT_REQUEUE_FLAG.getValue();
        log.info(requeueFlag);
        CimLot aParentLot = baseCoreFactory.getBO(CimLot.class, parentLotID);

        //--------------------------------------------
        // Check real lot wafer quantity and
        //  input parameter is consistent or not
        //--------------------------------------------
        log.info("Check real lot wafer quantity and input parameter is consistent or not");
        int parentLotTotalQuantity = aParentLot.getQuantity();
        int parentLotProductQuantity = aParentLot.getProductQuantity();
        int parentLotControlQuantity = aParentLot.getControlQuantity();
        log.info("aParentLot->getQuantity {}", parentLotTotalQuantity);
        log.info("aParentLot->getProductQuantity {}", parentLotProductQuantity);
        log.info("aParentLot->getControlQuantity {}", parentLotControlQuantity);

        String tmpControlUseState = aParentLot.getControlUseState();
        int tmpUsageCount = aParentLot.getUsedCount();
        log.info("aParentLot->getUsageCount {}", tmpUsageCount);
        log.info("aParentLot->tmpControlUseState {}", tmpControlUseState);

        //----------------------------------
        // Check Wafer attributes
        //----------------------------------
        log.info("Check Wafer attributes");
        log.info("Get all wafer information of parent lot before split.");
        List<ProductDTO.WaferInfo> parentLotWaferInfo = aParentLot.getAllWaferInfo();
        Validations.check(CimObjectUtils.isEmpty(parentLotWaferInfo), retCodeConfig.getProductCountZero());

        // Check childWaferID of in-parameter in Wafer Attributes.
        log.info("Check childWaferID of in-parameter in Wafer Attributes");
        for (ObjectIdentifier childWafer : childWaferID) {
            boolean foundFlag = false;
            for (ProductDTO.WaferInfo waferInfo : parentLotWaferInfo) {
                if (ObjectIdentifier.equalsWithValue(childWafer, waferInfo.getWaferID())) {
                    foundFlag = true;
                    break;
                }
            }
            Validations.check(CimBooleanUtils.isFalse(foundFlag), retCodeConfig.getInvalidDataContents());
        }

        //----------------------------------
        // Parent lot remove from queue
        //----------------------------------
        log.info("Parent lot remove from queue");
        String aParentLotState = aParentLot.getLotState();
        String aParentLotHoldState = aParentLot.getLotHoldState();

        Boolean isParentLotStateFinished = true;
        if (!CimStringUtils.equals(aParentLotState, BizConstant.CIMFW_LOT_STATE_FINISHED)) {
            isParentLotStateFinished = false;
            if (!CimStringUtils.equals(aParentLotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD)) {
                if (CimStringUtils.equals(requeueFlag, "1")) {
                    log.info("OM_SPLIT_LOT_REQUEUE_FLAG is ON.");
                    dispatchingManager.removeFromQueue(aParentLot);
                }
            }
        }

        //----------------------------------
        // Set wafer to productSequence.
        // In parameter lot is only one.
        //----------------------------------
        log.info("Set wafer to productSequence");
        List<ProductDTO.LotSpliteData> productToSplit = new ArrayList<>();
        ProductDTO.LotSpliteData lotSpliteData = new ProductDTO.LotSpliteData();
        productToSplit.add(lotSpliteData);
        List<ProductDTO.WaferInfo> splitProducts = new ArrayList<>();
        lotSpliteData.setSplitProducts(splitProducts);
        int cntChildProductWafer = 0;
        int cntChildControlWafer = 0;
        Boolean controlWaferFlag = false;
        for (ObjectIdentifier childWafer : childWaferID) {
            CimWafer aWafer = baseCoreFactory.getBO(CimWafer.class, childWafer);
            splitProducts.add(aWafer.getWaferInfo());
            controlWaferFlag = aWafer.isControlWafer();
            if (controlWaferFlag) {
                cntChildControlWafer++;
            } else {
                cntChildProductWafer++;
            }
        }

        //-------------------------------
        // Set length of output structure
        //-------------------------------
        Boolean bInCast = true;
        List<MaterialContainer> aCassetteSequence = aParentLot.materialContainers();
        if (CimObjectUtils.isEmpty(aCassetteSequence)) {
            bInCast = false;
        }

        com.fa.cim.newcore.bo.durable.CimCassette aCassette = null;
        if (bInCast) {
            aCassette = (com.fa.cim.newcore.bo.durable.CimCassette) aCassetteSequence.get(0);
            Validations.check(CimObjectUtils.isEmpty(aCassette), retCodeConfig.getNotFoundCassette());
            for (ProductDTO.WaferInfo waferInfo : parentLotWaferInfo) {
                // Get obj ref and change state of wafer//
                // try {
                Wafer tmpWafer = aCassette.removeWaferFromPosition(waferInfo.getPosition());
//                } catch (PositionInvalidSignal | PositionEmptySignal e)
//                {
//                    Validations.check(true, new OmCode(retCodeConfig.getInvalidCassettePosition(), String.valueOf(waferInfo.getPosition())));
//                }
            }
        } else {
            log.info("The Lot is not in a cassette. Skip Cassette::removeWafer_fromPosition()");
        }

        // Assign lot ID for child
        ObjectIdentifier lotIDAssign = lotIDAssign(objCommon, parentLotID);
        productToSplit.get(0).setNewLotID(lotIDAssign.getValue());

        //----------------------------------
        // Set wafer to productSequence.
        //----------------------------------
        String currentFabID = StandardProperties.OM_SPLIT_SUFFIX_FAB_ID.getValue();
        if (!CimObjectUtils.isEmpty(currentFabID)) {
            log.info("Environment variable OM_SPLIT_SUFFIX_FAB_ID is set. ==> {}", currentFabID);
            String newLotID = productToSplit.get(0).getNewLotID();
            productToSplit.get(0).setNewLotID(newLotID + BizConstant.SP_INTERFAB_SPLIT_FABID_SUFFIX + currentFabID);
        }

        // Create new lot(chaild lot)
        // createSplitLotsFrom is overridden in PosProductManager
        List<CimLot> aLotSequence = productManager.createSplitLotsFrom(aParentLot, productToSplit);
        // Return child lot.
        CimLot aChildLot = null;
        if (!CimObjectUtils.isEmpty(aLotSequence)) {
            aChildLot = aLotSequence.get(0);
        }
        Validations.check(CimObjectUtils.isEmpty(aChildLot), retCodeConfig.getNotFoundLot());
        if (bInCast) {
            for (ProductDTO.WaferInfo waferInfo : parentLotWaferInfo) {
                // Get obj ref and change state of wafer
                CimWafer aWafer = baseCoreFactory.getBO(CimWafer.class, waferInfo.getWaferID());
                //try {}
                aCassette.addWaferAtPosition(aWafer, waferInfo.getPosition());
                //catch (WaferSizeInvalidSignal) {} catch (PositionOccupiedSignal) {} catch(PositionInvalidSignal) {}
            }
        } else {
            log.info("The Lot is not in a cassette. Skip Cassette::removeWafer_fromPosition()");
        }

        //----------------------------------------------------------------------------------------------------
        // change total wafer quantity of both parent lot and child lot.
        //  ParentLot.theQuantity   <= parentLotTotalQuantity - the length of childWaferID sequence of in-parameter.
        //  ChildLot.theQuantity    <= the length of childLotWaferCount of in-parameter.
        //----------------------------------------------------------------------------------------------------
        log.info("change total wafer quantity of both parent lot and child lot");
        int lenChildWafer = CimArrayUtils.getSize(childWaferID);
        int newTotalQuantity = parentLotTotalQuantity - lenChildWafer;
        Validations.check(newTotalQuantity == 0, retCodeConfig.getPlotEmptySplit());
        aParentLot.setVendorLotQuantity(newTotalQuantity);
        aChildLot.setVendorLotQuantity(lenChildWafer);
        //----------------------------------------------------------------------------------------------------
        // Set reticle set ID
        //----------------------------------------------------------------------------------------------------
        com.fa.cim.newcore.bo.durable.CimReticleSet aReticleSet = aParentLot.getReticleSet();
        if (!CimObjectUtils.isEmpty(aReticleSet)) {
            log.info("Set reticle set ID into Child Lot.");
            aChildLot.setReticleSet(aReticleSet);
        } else {
            log.info("Parent lot has no reticle set ID.");
        }

        CimControlJob aControlJob = aParentLot.getControlJob();
        aChildLot.setControlJob(aControlJob);
        if (!CimObjectUtils.isEmpty(aControlJob)) {
            ObjectIdentifier aChildLotID = new ObjectIdentifier(aChildLot.getIdentifier(), aChildLot.getPrimaryKey());
            // Get Lot List In ControlJob Object
            List<ProductDTO.LotInControlJobInfo> aPosLotInControlJobInfoSeq = aControlJob.allControlJobLots();
            if (!CimObjectUtils.isEmpty(aPosLotInControlJobInfoSeq)) {
                for (ProductDTO.LotInControlJobInfo lotInControlJobInfo : aPosLotInControlJobInfoSeq) {
                    if (ObjectIdentifier.equalsWithValue(parentLotID, lotInControlJobInfo.getLotID())) {
                        lotInControlJobInfo.setLotID(aChildLotID);
                        aControlJob.addControlJobLot(lotInControlJobInfo);
                    }
                }
            }
        }
        //----------------------------------------------------------------------------------------------------
        // change the number of wafer which has waferID in itself.
        //  ParentLot.theProductQuantity <= parentLotTotalQuantity - the length of childWaferID sequence of in-parameter.
        //  ChildLot.theProductQuantity  <= the length of childWaferID of in-parameter.
        //----------------------------------------------------------------------------------------------------
        log.info("change the number of wafer which has waferID in itself");
        aParentLot.setProductQuantity(parentLotProductQuantity - cntChildProductWafer);
        aParentLot.setControlQuantity(parentLotControlQuantity - cntChildControlWafer);
        aChildLot.setProductQuantity(cntChildProductWafer);
        aChildLot.setControlQuantity(cntChildControlWafer);
        aParentLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        aParentLot.setLastClaimedPerson(aPerson);
        // Set claim information for child lot.
        aChildLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aChildLot.setLastClaimedPerson(aPerson);
        aChildLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aChildLot.setStateChangedPerson(aPerson);
        aChildLot.setInventoryStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aChildLot.setInventoryStateChangedPerson(aPerson);
        aChildLot.setLastClaimAllWafers(objCommon.getTimeStamp().getReportTimeStamp(), aPerson);

        //--------------------------------------------------
        //  Set parent Lot InterFab Xfer Plan  to Child Lot
        //--------------------------------------------------
        //TODO-NOTIMPL: interFab_xferPlanList_GetDR

        ObjectIdentifier tmpChildLotID = new ObjectIdentifier(aChildLot.getIdentifier(), aChildLot.getPrimaryKey());
        //-------------------------------------------------------
        //  Set parent Lot Auto Dispatch Control to Child Lot
        //-------------------------------------------------------
        List<ProductDTO.AutoDispatchControlRecord> autoDispatchControlRecordSeq = aParentLot.allAutoDispatchControlRecords();
        aChildLot.setAutoDispatchControlRecords(autoDispatchControlRecordSeq);
        // autoDispatchControlEvent_Make
        int dataLen = CimArrayUtils.getSize(autoDispatchControlRecordSeq);
        if (dataLen > 0){
            for (ProductDTO.AutoDispatchControlRecord autoDispatchControlRecord : autoDispatchControlRecordSeq){
                //===================================================================================
                // Make event for Auto Dispatch Control Information Update.
                //===================================================================================
                Inputs.AutoDispatchControlEventMakeIn autoDispatchControlEventMakeIn = new Inputs.AutoDispatchControlEventMakeIn();
                autoDispatchControlEventMakeIn.setLotID(tmpChildLotID);
                Infos.AutoDispatchControlUpdateInfo autoDispatchControlUpdateInfo = new Infos.AutoDispatchControlUpdateInfo();
                autoDispatchControlEventMakeIn.setAutoDispatchControlUpdateInfo(autoDispatchControlUpdateInfo);
                autoDispatchControlUpdateInfo.setUpdateMode(BizConstant.SP_AUTODISPATCHCONTROL_CREATE);
                autoDispatchControlUpdateInfo.setRouteID(autoDispatchControlRecord.getRouteID());
                autoDispatchControlUpdateInfo.setOperationNumber(autoDispatchControlRecord.getOperationNumber());
                autoDispatchControlUpdateInfo.setSingleTriggerFlag(autoDispatchControlRecord.isSingleTriggerFlag());
                autoDispatchControlUpdateInfo.setDescription(autoDispatchControlRecord.getDescription());
                eventMethod.autoDispatchControlEventMake(objCommon, autoDispatchControlEventMakeIn);
            }
        }

        String eqpMonitorSwitch = StandardProperties.OM_AUTOMON_FLAG.getValue();
        if (CimStringUtils.equals("1",eqpMonitorSwitch)) {
            log.info("1 == OM_AUTOMON_FLAG");
            String tmpLotType = aParentLot.getLotType();
            if (CimStringUtils.equals(tmpLotType, BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT) || CimStringUtils.equals(tmpLotType, BizConstant.SP_LOT_TYPE_DUMMYLOT)) {
                log.info("tmpLotType is Auto Monitor or Dummy");
                //Acquire EqpMonitor Job Info of Lot
                ProductDTO.EqpMonitorJobLotInfo aEqpMonitorJobLotInfo = aParentLot.getEqpMonitorJobLotInfo();

                if (null != aEqpMonitorJobLotInfo && !ObjectIdentifier.isEmpty(aEqpMonitorJobLotInfo.getEqpMonitorJobID())) {
                    //Lock EqpMonitor job object
                    objectLockMethod.objectLockForEqpMonitorJob(objCommon, aEqpMonitorJobLotInfo.getEqpMonitorID(), aEqpMonitorJobLotInfo.getEqpMonitorJobID());

                    //Add the record of Child Lot to FREQPMONJOB_LOT. (copy parent lot's record)
                    MachineDTO.EqpMonitorLotInfo aEqpMonitorLotInfo = new MachineDTO.EqpMonitorLotInfo();
                    aEqpMonitorLotInfo.setLotID(tmpChildLotID);
                    aEqpMonitorLotInfo.setMonitorLotStatus(aEqpMonitorJobLotInfo.getMonitorLotStatus());
                    aEqpMonitorLotInfo.setStartSeqNo(CimObjectUtils.isEmpty(aEqpMonitorJobLotInfo.getStartSeqNo()) ? 0 : aEqpMonitorJobLotInfo.getStartSeqNo().intValue());
                    aEqpMonitorLotInfo.setMonitorOpeKey(aEqpMonitorJobLotInfo.getMonitorOpeKey());
                    aEqpMonitorLotInfo.setExitFlag(aEqpMonitorJobLotInfo.getExitFlag());
                    aEqpMonitorLotInfo.setResult(CimObjectUtils.isEmpty(aEqpMonitorJobLotInfo.getResult()) ? 0 : aEqpMonitorJobLotInfo.getResult().intValue());
                    CimEqpMonitorJob anEqpMonitorJob = baseCoreFactory.getBO(CimEqpMonitorJob.class, aEqpMonitorJobLotInfo.getEqpMonitorJobID());
                    anEqpMonitorJob.addEqpMonitorLot(aEqpMonitorLotInfo);

                    //Create EqpMonitor Job History Event
                    Inputs.EqpMonitorJobChangeEventMakeParams strEqpMonitorJobChangeEventMakeIn = new Inputs.EqpMonitorJobChangeEventMakeParams();
                    strEqpMonitorJobChangeEventMakeIn.setOpeCategory(BizConstant.SP_EQPMONITORJOB_OPECATEGORY_EQPMONSTART);
                    strEqpMonitorJobChangeEventMakeIn.setEqpMonitorID(aEqpMonitorJobLotInfo.getEqpMonitorID());
                    strEqpMonitorJobChangeEventMakeIn.setEqpMonitorJobID(aEqpMonitorJobLotInfo.getEqpMonitorJobID());
                    Infos.EqpMonitorLotInfo eqpMonitorLotInfo = new Infos.EqpMonitorLotInfo();
                    eqpMonitorLotInfo.setLotID(tmpChildLotID);
                    eqpMonitorLotInfo.setStartSeqNo(aEqpMonitorJobLotInfo.getStartSeqNo().intValue());
                    List<Infos.EqpMonitorLotInfo> eqpMonitorLotInfos = new ArrayList<>();
                    eqpMonitorLotInfos.add(eqpMonitorLotInfo);
                    strEqpMonitorJobChangeEventMakeIn.setEqpMonitorLotInfoList(eqpMonitorLotInfos);
                    eventMethod.eqpMonitorJobChangeEventMake(objCommon, strEqpMonitorJobChangeEventMakeIn);
                }
            }
        }
        Outputs.ObjLotControlUseInfoChangeOut lotControlUseInfoChange = lotControlUseInfoChange(objCommon, tmpChildLotID, tmpControlUseState, tmpUsageCount);
        // qTimeChangeEvent_Make__180
        List<com.fa.cim.newcore.bo.pd.CimQTimeRestriction> aChildQTimeSeq = aChildLot.allQTimeRestrictions();
        for (com.fa.cim.newcore.bo.pd.CimQTimeRestriction aChildQTime : aChildQTimeSeq) {
            /*----------------------------*/
            /*   Get Q-Time information   */
            /*----------------------------*/
            ProcessDTO.QTimeRestrictionInfo aChildQTimeInfo = aChildQTime.getQTimeRestrictionInfo();
            Infos.QtimeInfo qtimeInfo = new Infos.QtimeInfo();
            qtimeInfo.setQTimeType(aChildQTimeInfo.getQTimeType());
            qtimeInfo.setWaferID(aChildQTimeInfo.getWaferID());
            qtimeInfo.setPreTrigger(aChildQTimeInfo.getPreTrigger());
            qtimeInfo.setOriginalQTime(aChildQTimeInfo.getOriginalQTime());
            qtimeInfo.setProcessDefinitionLevel(aChildQTimeInfo.getProcessDefinitionLevel());
            qtimeInfo.setRestrictionTriggerRouteID(aChildQTimeInfo.getTriggerMainProcessDefinition());
            qtimeInfo.setRestrictionTriggerOperationNumber(aChildQTimeInfo.getTriggerOperationNumber());
            qtimeInfo.setRestrictionTriggerBranchInfo(aChildQTimeInfo.getTriggerBranchInfo());
            qtimeInfo.setRestrictionTriggerReturnInfo(aChildQTimeInfo.getTriggerReturnInfo());
            qtimeInfo.setRestrictionTriggerTimeStamp(aChildQTimeInfo.getTriggerTimeStamp());
            qtimeInfo.setRestrictionTargetRouteID(aChildQTimeInfo.getTargetMainProcessDefinition());
            qtimeInfo.setRestrictionTargetOperationNumber(aChildQTimeInfo.getTargetOperationNumber());
            qtimeInfo.setRestrictionTargetBranchInfo(aChildQTimeInfo.getTargetBranchInfo());
            qtimeInfo.setRestrictionTargetReturnInfo(aChildQTimeInfo.getTargetReturnInfo());
            qtimeInfo.setRestrictionTargetTimeStamp(aChildQTimeInfo.getTargetTimeStamp());
            qtimeInfo.setPreviousTargetInfo(aChildQTimeInfo.getPreviousTargetInfo());
            qtimeInfo.setSpecificControl(aChildQTimeInfo.getControl());
            if (aChildQTimeInfo.getWatchdogRequired()){
                qtimeInfo.setWatchDogRequired("Y");
            } else {
                qtimeInfo.setWatchDogRequired("N");
            }
            if (aChildQTimeInfo.getActionDone()){
                qtimeInfo.setActionDoneFlag("Y");
            } else {
                qtimeInfo.setActionDoneFlag("N");
            }
            qtimeInfo.setManualCreated(aChildQTimeInfo.getManualCreated());
            List<ProcessDTO.QTimeRestrictionAction> qTimeActions = aChildQTimeInfo.getActions();
            int actionLength = CimArrayUtils.getSize(qTimeActions);
            List<Infos.QTimeActionInfo> qTimeActionInfoList = new ArrayList<>();
            qtimeInfo.setStrQtimeActionInfoList(qTimeActionInfoList);
            if (actionLength != 0){
                for (ProcessDTO.QTimeRestrictionAction qTimeRestrictionAction : qTimeActions){
                    Infos.QTimeActionInfo qTimeActionInfo = new Infos.QTimeActionInfo();
                    qTimeActionInfoList.add(qTimeActionInfo);
                    qTimeActionInfo.setQrestrictionTargetTimeStamp(qTimeRestrictionAction.getTargetTimeStamp());
                    qTimeActionInfo.setQrestrictionAction(qTimeRestrictionAction.getAction());
                    qTimeActionInfo.setReasonCodeID(qTimeRestrictionAction.getReasonCode());
                    qTimeActionInfo.setActionRouteID(qTimeRestrictionAction.getActionRouteID());
                    qTimeActionInfo.setActionOperationNumber(qTimeRestrictionAction.getOperationNumber());
                    qTimeActionInfo.setFutureHoldTiming(qTimeRestrictionAction.getTiming());
                    qTimeActionInfo.setReworkRouteID(qTimeRestrictionAction.getMainProcessDefinition());
                    qTimeActionInfo.setMessageID(qTimeRestrictionAction.getMessageDefinition());
                    qTimeActionInfo.setCustomField(qTimeRestrictionAction.getCustomField());
                    if (qTimeRestrictionAction.getWatchdogRequired()) {
                        qTimeActionInfo.setWatchDogRequired("Y");
                    } else {
                        qTimeActionInfo.setWatchDogRequired("N");
                    }
                    if (qTimeRestrictionAction.getActionDone()) {
                        qTimeActionInfo.setActionDoneFlag("Y");
                    } else {
                        qTimeActionInfo.setActionDoneFlag("N");
                    }
                }
            }
            Inputs.QTimeChangeEventMakeParams params = new Inputs.QTimeChangeEventMakeParams();
            params.setUpdateMode(BizConstant.SP_QRESTTIME_OPECATEGORY_CREATE);
            params.setLotID(tmpChildLotID);
            params.setQtimeInfo(qtimeInfo);
            params.setClaimMemo("");
            eventMethod.qTimeChangeEventMake(objCommon, params);
        }

        for (ObjectIdentifier childWafer : childWaferID) {
            CimWafer aChildWafer = baseCoreFactory.getBO(CimWafer.class, childWafer);
            List<com.fa.cim.newcore.bo.pd.CimQTimeRestriction> aChildWaferQTimeSeq = aChildWafer.allQTimeRestrictions();
            if(!CimObjectUtils.isEmpty(aChildWaferQTimeSeq)){
                for (com.fa.cim.newcore.bo.pd.CimQTimeRestriction aChildWaferQTime : aChildWaferQTimeSeq){
                    /*----------------------------*/
                    /*   Get Q-Time information   */
                    /*----------------------------*/
                    ProcessDTO.QTimeRestrictionInfo aChildWaferQTimeInfo = aChildWaferQTime.getQTimeRestrictionInfo();
                    aChildWaferQTime.setLot(aChildLot);
                    //----------------------------------------------------------------
                    // Make event
                    //----------------------------------------------------------------
                    Infos.QtimeInfo qtimeInfo = new Infos.QtimeInfo();
                    qtimeInfo.setQTimeType(aChildWaferQTimeInfo.getQTimeType());
                    qtimeInfo.setWaferID(aChildWaferQTimeInfo.getWaferID());
                    qtimeInfo.setPreTrigger(aChildWaferQTimeInfo.getPreTrigger());
                    qtimeInfo.setOriginalQTime(aChildWaferQTimeInfo.getOriginalQTime());
                    qtimeInfo.setProcessDefinitionLevel(aChildWaferQTimeInfo.getProcessDefinitionLevel());
                    qtimeInfo.setRestrictionTriggerRouteID(aChildWaferQTimeInfo.getTriggerMainProcessDefinition());
                    qtimeInfo.setRestrictionTriggerOperationNumber(aChildWaferQTimeInfo.getTriggerOperationNumber());
                    qtimeInfo.setRestrictionTriggerBranchInfo(aChildWaferQTimeInfo.getTriggerBranchInfo());
                    qtimeInfo.setRestrictionTriggerReturnInfo(aChildWaferQTimeInfo.getTriggerReturnInfo());
                    qtimeInfo.setRestrictionTriggerTimeStamp(aChildWaferQTimeInfo.getTriggerTimeStamp());
                    qtimeInfo.setRestrictionTargetRouteID(aChildWaferQTimeInfo.getTargetMainProcessDefinition());
                    qtimeInfo.setRestrictionTargetOperationNumber(aChildWaferQTimeInfo.getTargetOperationNumber());
                    qtimeInfo.setRestrictionTargetBranchInfo(aChildWaferQTimeInfo.getTargetBranchInfo());
                    qtimeInfo.setRestrictionTargetReturnInfo(aChildWaferQTimeInfo.getTargetReturnInfo());
                    qtimeInfo.setRestrictionTargetTimeStamp(aChildWaferQTimeInfo.getTargetTimeStamp());
                    qtimeInfo.setPreviousTargetInfo(aChildWaferQTimeInfo.getPreviousTargetInfo());
                    qtimeInfo.setSpecificControl(aChildWaferQTimeInfo.getControl());
                    if (aChildWaferQTimeInfo.getWatchdogRequired()){
                        qtimeInfo.setWatchDogRequired("Y");
                    } else {
                        qtimeInfo.setWatchDogRequired("N");
                    }
                    if (aChildWaferQTimeInfo.getActionDone()){
                        qtimeInfo.setActionDoneFlag("Y");
                    } else {
                        qtimeInfo.setActionDoneFlag("N");
                    }
                    qtimeInfo.setManualCreated(aChildWaferQTimeInfo.getManualCreated());
                    List<ProcessDTO.QTimeRestrictionAction> qTimeActions = aChildWaferQTimeInfo.getActions();
                    int actionLength = CimArrayUtils.getSize(qTimeActions);
                    List<Infos.QTimeActionInfo> qTimeActionInfoList = new ArrayList<>();
                    qtimeInfo.setStrQtimeActionInfoList(qTimeActionInfoList);
                    if (actionLength != 0){
                        for (ProcessDTO.QTimeRestrictionAction qTimeRestrictionAction : qTimeActions){
                            Infos.QTimeActionInfo qTimeActionInfo = new Infos.QTimeActionInfo();
                            qTimeActionInfoList.add(qTimeActionInfo);
                            qTimeActionInfo.setQrestrictionTargetTimeStamp(qTimeRestrictionAction.getTargetTimeStamp());
                            qTimeActionInfo.setQrestrictionAction(qTimeRestrictionAction.getAction());
                            qTimeActionInfo.setReasonCodeID(qTimeRestrictionAction.getReasonCode());
                            qTimeActionInfo.setActionRouteID(qTimeRestrictionAction.getActionRouteID());
                            qTimeActionInfo.setActionOperationNumber(qTimeRestrictionAction.getOperationNumber());
                            qTimeActionInfo.setFutureHoldTiming(qTimeRestrictionAction.getTiming());
                            qTimeActionInfo.setReworkRouteID(qTimeRestrictionAction.getMainProcessDefinition());
                            qTimeActionInfo.setMessageID(qTimeRestrictionAction.getMessageDefinition());
                            qTimeActionInfo.setCustomField(qTimeRestrictionAction.getCustomField());
                            if (qTimeRestrictionAction.getWatchdogRequired()) {
                                qTimeActionInfo.setWatchDogRequired("Y");
                            } else {
                                qTimeActionInfo.setWatchDogRequired("N");
                            }
                            if (qTimeRestrictionAction.getActionDone()) {
                                qTimeActionInfo.setActionDoneFlag("Y");
                            } else {
                                qTimeActionInfo.setActionDoneFlag("N");
                            }
                        }
                    }
                    Inputs.QTimeChangeEventMakeParams params = new Inputs.QTimeChangeEventMakeParams();
                    params.setUpdateMode(BizConstant.SP_QRESTTIME_OPECATEGORY_UPDATE);
                    params.setLotID(tmpChildLotID);
                    params.setQtimeInfo(qtimeInfo);
                    params.setClaimMemo("");
                    eventMethod.qTimeChangeEventMake(objCommon, params);
                }
            }
        }

        //  Add aParentLot and aChildLot to the queue.
        log.info("Add aParentLot and aChildLot to the queue");
        if (!isParentLotStateFinished) {
            if (!CimStringUtils.equals(aParentLot.getLotHoldState(), BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD)) {
                if (CimStringUtils.equals(requeueFlag,"1")) {
                    dispatchingManager.addToQueue(aParentLot);
                }
            }
            dispatchingManager.addToQueue(aChildLot);
        }

        // Min Q-Time of sub Lot inheriting parent Lot
        minQTimeMethod.lotSplit(parentLotID, tmpChildLotID);

        return tmpChildLotID;
    }

    @Override
    public void lotMaterialsScrapCancelByWafer(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier cassetteID, List<Infos.ScrapCancelWafers> scrapCancelWafersList) {

        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        CimLotFamily lotFamily = lot.getLotFamily();
        Validations.check(null == lotFamily, retCodeConfig.getNotFoundLotFamily());

        com.fa.cim.newcore.bo.durable.CimCassette cassette = null;
        if (lot.isScrapped()) {
            if (!ObjectIdentifier.isEmpty(cassetteID)) {
                cassette = baseCoreFactory.getBO(com.fa.cim.newcore.bo.durable.CimCassette.class, cassetteID);
                Validations.check(null == cassette, retCodeConfig.getNotFoundCassette());

            }
        } else {
            List<MaterialContainer> lotMaterialContainers = lot.materialContainers();
            if (!CimObjectUtils.isEmpty(lotMaterialContainers)) {
                cassette = (com.fa.cim.newcore.bo.durable.CimCassette) lotMaterialContainers.get(0);
            }
        }

        boolean bMrgLotInCast = true;
        if (CimObjectUtils.isEmpty(cassette)) {
            bMrgLotInCast = false;
        }

        Integer waferCount = lot.getQuantity();
        Integer productWaferCount = lot.getProductQuantity();
        Integer controlWaferCount = lot.getControlQuantity();
        waferCount = CimObjectUtils.isEmpty(waferCount) ? 0 : waferCount;
        productWaferCount = CimObjectUtils.isEmpty(productWaferCount) ? 0 : productWaferCount;
        controlWaferCount = CimObjectUtils.isEmpty(controlWaferCount) ? 0 : controlWaferCount;

        CimProductSpecification productSpecification = lot.getProductSpecification();
        Validations.check(null == productSpecification, retCodeConfig.getNotFoundProductSpec());

        String productSpecIDOfLot = productSpecification.getIdentifier();
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        boolean isControlWaferFlag;
        int scrapControlNo = 0;
        int scrapProductNo = 0;
        List<String> lotIDSeq = new ArrayList<>();
        int scrapCancelWaferCount = scrapCancelWafersList.size();
        for (Infos.ScrapCancelWafers scrapCancelWafers : scrapCancelWafersList) {
            boolean scrapCancelToDiffLot = false;
            CimWafer wafer = baseCoreFactory.getBO(CimWafer.class, scrapCancelWafers.getWaferID());
            Validations.check(null == wafer, retCodeConfig.getNotFoundWafer());
            //-------------------------------------------
            // Scrap Cancel For Child lot
            //-------------------------------------------
            Lot aPosLot = wafer.getLot();
            if (!CimObjectUtils.isEmpty(aPosLot)) {
                String tempLotID = aPosLot.getIdentifier();
                boolean bFindFlag = false;
                for (String lotIDT : lotIDSeq) {
                    if (lotIDT.equals(tempLotID)) {
                        bFindFlag = true;
                        break;
                    }
                }
                if (!bFindFlag) {
                    lotIDSeq.add(tempLotID);
                }
                //---------------------------------------------------------
                // Judgement of Scrap Cancel for lotID of wafer is having or
                // Specified lotID.
                //---------------------------------------------------------
                if (!ObjectIdentifier.equalsWithValue(tempLotID, lotID)) {
                    scrapCancelToDiffLot = true; //判断是否存在子批报废晶圆
                }
            }

            isControlWaferFlag = wafer.isControlWafer();
            if (isControlWaferFlag) {
                scrapControlNo++;
            } else {
                scrapProductNo++;
            }
            ProductSpecification aProductSpecificationOfWafer = wafer.getProductSpecification();
            Validations.check(null == aProductSpecificationOfWafer, retCodeConfig.getNotFoundProductSpec());


            String productSpecIDOfWafer = aProductSpecificationOfWafer.getIdentifier();
            Validations.check(!productSpecIDOfLot.equals(productSpecIDOfWafer), retCodeConfig.getProductSpecUnMatch());

            wafer.makeActive();
            lotFamily.removeProductUnitScrapped(wafer);
            wafer.setLastClaimedTimeStamp(reportTimeStamp);
            wafer.setLastClaimedPerson(person);

            //----------------------------------------
            // Case of Scrap Cancel to Specified lotID,
            // subtract wafer count on OMCARRIER_ID
            //----------------------------------------
            if (scrapCancelToDiffLot) { //如果报废取消包含子批报废晶圆
                if (bMrgLotInCast) { //如果批次存在晶舟
                    cassette.removeWaferFromPosition(scrapCancelWafers.getSlotNumber());
                }
            }

            //----------------------------------------
            // Case of Scrap Cancel to Specified lotID,
            // subtract wafer count on OMCARRIER_LOT
            //----------------------------------------
            if (scrapCancelToDiffLot) {
                List<com.fa.cim.newcore.bo.pd.CimQTimeRestriction> cimQTimeRestrictions = wafer.allQTimeRestrictions();
                for (com.fa.cim.newcore.bo.pd.CimQTimeRestriction aWaferQTime : cimQTimeRestrictions) {
                    /*----------------------------*/
                    /*   Get Q-Time information   */
                    /*----------------------------*/
                    ProcessDTO.QTimeRestrictionInfo aWaferQTimeInfo = aWaferQTime.getQTimeRestrictionInfo();
                    aWaferQTime.setLot(lot);
                    //----------------------------------------------------------------
                    // Make event
                    //----------------------------------------------------------------
                    Infos.QtimeInfo strQtimeInfo = new Infos.QtimeInfo();
                    strQtimeInfo.setWaferID(aWaferQTimeInfo.getWaferID());
                    strQtimeInfo.setQTimeType(aWaferQTimeInfo.getQTimeType());
                    strQtimeInfo.setPreTrigger(aWaferQTimeInfo.getPreTrigger());
                    strQtimeInfo.setOriginalQTime(aWaferQTimeInfo.getOriginalQTime());
                    strQtimeInfo.setProcessDefinitionLevel(aWaferQTimeInfo.getProcessDefinitionLevel());
                    strQtimeInfo.setRestrictionTriggerRouteID(aWaferQTimeInfo.getTriggerMainProcessDefinition());
                    strQtimeInfo.setRestrictionTriggerOperationNumber(aWaferQTimeInfo.getTriggerOperationNumber());
                    strQtimeInfo.setRestrictionTriggerBranchInfo(aWaferQTimeInfo.getTriggerBranchInfo());
                    strQtimeInfo.setRestrictionTriggerReturnInfo(aWaferQTimeInfo.getTriggerReturnInfo());
                    strQtimeInfo.setRestrictionTriggerTimeStamp(aWaferQTimeInfo.getTriggerTimeStamp());
                    strQtimeInfo.setRestrictionTargetRouteID(aWaferQTimeInfo.getTargetMainProcessDefinition());
                    strQtimeInfo.setRestrictionTargetOperationNumber(aWaferQTimeInfo.getTargetOperationNumber());
                    strQtimeInfo.setRestrictionTargetBranchInfo(aWaferQTimeInfo.getTargetBranchInfo());
                    strQtimeInfo.setRestrictionTargetReturnInfo(aWaferQTimeInfo.getTargetReturnInfo());
                    strQtimeInfo.setRestrictionTargetTimeStamp(aWaferQTimeInfo.getTargetTimeStamp());
                    strQtimeInfo.setPreviousTargetInfo(aWaferQTimeInfo.getPreviousTargetInfo());
                    strQtimeInfo.setSpecificControl(aWaferQTimeInfo.getControl());
                    strQtimeInfo.setWatchDogRequired(CimBooleanUtils.isTrue(aWaferQTimeInfo.getWatchdogRequired()) ? "Y" : "N");
                    strQtimeInfo.setActionDoneFlag(CimBooleanUtils.isTrue(aWaferQTimeInfo.getActionDone()) ? "Y" : "N");
                    strQtimeInfo.setManualCreated(aWaferQTimeInfo.getManualCreated());
                    List<ProcessDTO.QTimeRestrictionAction> actions = aWaferQTimeInfo.getActions();
                    List<Infos.QTimeActionInfo> qTimeActionInfos = new ArrayList<>();
                    strQtimeInfo.setStrQtimeActionInfoList(qTimeActionInfos);
                    if (!CimObjectUtils.isEmpty(actions)) {
                        for (ProcessDTO.QTimeRestrictionAction action : actions) {
                            Infos.QTimeActionInfo qTimeActionInfo = new Infos.QTimeActionInfo();
                            qTimeActionInfos.add(qTimeActionInfo);
                            qTimeActionInfo.setQrestrictionTargetTimeStamp(action.getTargetTimeStamp());
                            qTimeActionInfo.setQrestrictionAction(action.getAction());
                            qTimeActionInfo.setReasonCodeID(action.getReasonCode());
                            qTimeActionInfo.setActionRouteID(action.getActionRouteID());
                            qTimeActionInfo.setActionOperationNumber(action.getOperationNumber());
                            qTimeActionInfo.setFutureHoldTiming(action.getTiming());
                            qTimeActionInfo.setReworkRouteID(action.getMainProcessDefinition());
                            qTimeActionInfo.setMessageID(action.getMessageDefinition());
                            qTimeActionInfo.setCustomField(action.getCustomField());
                            qTimeActionInfo.setWatchDogRequired(CimBooleanUtils.isTrue(action.getWatchdogRequired()) ? "Y" : "N");
                            qTimeActionInfo.setActionDoneFlag(CimBooleanUtils.isTrue(action.getActionDone()) ? "Y" : "N");
                        }
                    }
                    Inputs.QTimeChangeEventMakeParams qTimeChangeEventMakeParams = new Inputs.QTimeChangeEventMakeParams();
                    qTimeChangeEventMakeParams.setUpdateMode(BizConstant.SP_QRESTTIME_OPECATEGORY_UPDATE);
                    qTimeChangeEventMakeParams.setLotID(lotID);
                    qTimeChangeEventMakeParams.setQtimeInfo(strQtimeInfo);
                    eventMethod.qTimeChangeEventMake(objCommon, qTimeChangeEventMakeParams);
                }

            }

            lot.addMaterial(wafer);
            //----------------------------------------
            // Case of Scrap Cancel to Specified lotID,
            // addition wafer count on OMCARRIER_LOT
            //----------------------------------------
            if (scrapCancelToDiffLot) {
                if (bMrgLotInCast) {
                    cassette.addWaferAtPosition(wafer, scrapCancelWafers.getSlotNumber());
                }
            }

            String lotState = lot.getLotFinishedState();
            if (CimStringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_EMPTIED, lotState)
                    || CimStringUtils.equals(BizConstant.SP_LOT_FINISHED_STATE_SCRAPPED, lotState)) {
                lot.makeScrapCancel();
                String prevLotState = lot.getPreviousLotState();
                if (CimStringUtils.equals(BizConstant.CIMFW_LOT_STATE_ACTIVE, prevLotState)) {
                    lotState = lot.getLotHoldState();
                    if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, lotState)) {
                        com.fa.cim.newcore.bo.pd.CimProcessDefinition processDefinition = lot.getMainProcessDefinition();
                        if (!CimObjectUtils.isEmpty(processDefinition)) {
                            dispatchingManager.addToQueue(lot);
                        }
                    }
                }
                lot.setStateChangedTimeStamp(reportTimeStamp);
                lot.setStateChangedPerson(person);
            }
            lot.setVendorLotQuantity(waferCount + scrapCancelWaferCount);
            lot.setProductQuantity(productWaferCount + scrapProductNo);
            lot.setControlQuantity(controlWaferCount + scrapControlNo);
            lot.setLastClaimedTimeStamp(reportTimeStamp);
            lot.setLastClaimedPerson(person);

            if (bMrgLotInCast) {

                for (String tempLotID : lotIDSeq) {
                    CimLot tempLot = baseCoreFactory.getBO(CimLot.class, new ObjectIdentifier(tempLotID));
                    Validations.check(null == tempLot, retCodeConfig.getNotFoundLot());
                    List<Material> lotMaterials = cassette.containedMaterial();
                    Validations.check(null == lotMaterials, retCodeConfig.getCastNotEmpty());

                    boolean bRemainFlag = false;
                    for (Material lotMaterial : lotMaterials) {
                        CimWafer aMaterialWafer = (CimWafer) lotMaterial;
                        Validations.check(null == aMaterialWafer, retCodeConfig.getNotFoundWafer());

                        Lot aMaterialLot = aMaterialWafer.getLot();
                        if (tempLotID.equals(aMaterialLot.getIdentifier())) {
                            bRemainFlag = true;
                            break;
                        }
                    }

                    if (!bRemainFlag) {
                        String tmpLotState = tempLot.getLotFinishedState();
                        if (CimStringUtils.equals(BizConstant.SP_LOT_FINISHED_STATE_EMPTIED, tmpLotState)) continue;
                        tempLot.makeScrapCancel();
                        tempLot.makeEmptied();

                        String envEventCreateType = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
                        if (CimStringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED), envEventCreateType)
                                || CimStringUtils.equals(String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED), envEventCreateType)) {
                            com.fa.cim.newcore.bo.pd.CimProcessOperation currentProcessOperation = tempLot.getProcessOperation();
                            if (null != currentProcessOperation) {
                                // poDelQueue_PutDR
                                processMethod.poDelQueuePutDR(objCommon, new ObjectIdentifier(tempLotID));
                            }
                        }
                        cassette.removeLot(tempLot);
                        tempLot.setStateChangedTimeStamp(reportTimeStamp);
                        tempLot.setStateChangedPerson(person);
                    }
                }
            }
        }
    }

    @Override
    public Outputs.ObjLotControlUseInfoChangeOut lotControlUseInfoChange(Infos.ObjCommon objCommon, ObjectIdentifier lotID, String controlUseState, Integer usageCount) {
        Outputs.ObjLotControlUseInfoChangeOut result = new Outputs.ObjLotControlUseInfoChangeOut();

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        lot.setUsedCount(usageCount);
        if (CimStringUtils.equals(BizConstant.SP_LOT_CONTROLUSESTATE_WAITUSE,controlUseState)) {
            lot.makeWaitUse();
        } else if (CimStringUtils.equals(BizConstant.SP_LOT_CONTROLUSESTATE_INUSE,controlUseState)) {
            lot.makeInUse();
        } else if (CimStringUtils.equals(BizConstant.SP_LOT_CONTROLUSESTATE_WAITRECYCLE,controlUseState)) {
            lot.makeWaitRecycle();
        } else if (CimStringUtils.equals(BizConstant.SP_LOT_CONTROLUSESTATE_INRECYCLE,controlUseState)) {
            lot.makeInRecycle();
        }
        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        lot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        lot.setLastClaimedPerson(person);
        lot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        lot.setStateChangedPerson(person);
        result.setControlUseState(controlUseState);
        result.setUsageCount(usageCount);
        return result;
    }

    @Override
    public Infos.LotBackupInfo lotBackupInfoGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot(), lotID);
        return lotBackupInfoGet(objCommon, lot);
    }

    @Override
    public Infos.LotBackupInfo lotBackupInfoGet(Infos.ObjCommon objCommon, CimLot lot) {
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());
        Infos.LotBackupInfo data = new Infos.LotBackupInfo();

        //Get lot backup information
        data.setBackupProcessingFlag(lot.isBackupProcessingFlagOn());
        data.setCurrentLocationFlag(lot.isCurrentLocationFlagOn());
        data.setTransferFlag(lot.isTransferFlagOn());

        final ProductDTO.BackupAddress backupAddress = lot.getBornSiteAddress();
        if (null != backupAddress) {
            Infos.BackupAddress bornSiteAddress = new Infos.BackupAddress();
            bornSiteAddress.setHostName(backupAddress.getHostName());
            bornSiteAddress.setReserve(backupAddress.getReserve());
            bornSiteAddress.setItDaemonPort(backupAddress.getItDaemonPort());
            bornSiteAddress.setServerName(backupAddress.getServerName());
            data.setBornSiteAddress(bornSiteAddress);
        }

        List<Infos.LotBackupData> lotBackupSourceDataList = Optional.ofNullable(lot.allLotBackupSourceData()).map(sourceData -> sourceData.stream().map(lotBackupData -> {
            Infos.LotBackupData backupData = new Infos.LotBackupData();
            backupData.setBackupState(lotBackupData.getBackupState());
            backupData.setReserve(lotBackupData.getReserve());
            final ProductDTO.BackupAddress addressTmp = lotBackupData.getBackupAddress();
            if (null != addressTmp) {
                Infos.BackupAddress address = new Infos.BackupAddress();
                address.setServerName(addressTmp.getServerName());
                address.setReserve(addressTmp.getReserve());
                address.setItDaemonPort(addressTmp.getItDaemonPort());
                address.setHostName(addressTmp.getHostName());
                backupData.setBackupAddress(address);
            }
            final ProductDTO.BackupProcess backupProcessTmp = lotBackupData.getBackupProcess();
            if (null != backupProcessTmp) {
                Infos.BackupProcess backupProcess = new Infos.BackupProcess();
                backupProcess.setEntryRouteId(backupProcessTmp.getEntryRouteId());
                backupProcess.setEntryOperationNumber(backupProcessTmp.getEntryOperationNumber());
                backupProcess.setExitOperationNumber(backupProcessTmp.getExitOperationNumber());
                backupProcess.setExitRouteId(backupProcessTmp.getExitRouteId());
                backupData.setBackupProcess(backupProcess);
            }
            return backupData;
        }).collect(Collectors.toList())).orElseGet(Collections::emptyList);
        data.setLotBackupSourceDataList(lotBackupSourceDataList);


        List<Infos.LotBackupData> lotBackupDatas = Optional.ofNullable(lot.allLotBackupDestinationData()).map(sourceData -> sourceData.stream().map(lotBackupData -> {
            Infos.LotBackupData backupData = new Infos.LotBackupData();
            backupData.setBackupState(lotBackupData.getBackupState());
            backupData.setReserve(lotBackupData.getReserve());
            final ProductDTO.BackupAddress addressTmp = lotBackupData.getBackupAddress();
            if (null != addressTmp) {
                Infos.BackupAddress address = new Infos.BackupAddress();
                address.setServerName(addressTmp.getServerName());
                address.setReserve(addressTmp.getReserve());
                address.setItDaemonPort(addressTmp.getItDaemonPort());
                address.setHostName(addressTmp.getHostName());
                backupData.setBackupAddress(address);
            }
            final ProductDTO.BackupProcess backupProcessTmp = lotBackupData.getBackupProcess();
            if (null != backupProcessTmp) {
                Infos.BackupProcess backupProcess = new Infos.BackupProcess();
                backupProcess.setEntryRouteId(backupProcessTmp.getEntryRouteId());
                backupProcess.setEntryOperationNumber(backupProcessTmp.getEntryOperationNumber());
                backupProcess.setExitOperationNumber(backupProcessTmp.getExitOperationNumber());
                backupProcess.setExitRouteId(backupProcessTmp.getExitRouteId());
                backupData.setBackupProcess(backupProcess);
            }
            return backupData;
        }).collect(Collectors.toList())).orElseGet(Collections::emptyList);
        data.setLotBackupDestDataList(lotBackupDatas);
        return data;
    }

    @Override
    public void lotMaterialContainerChange(ObjectIdentifier newCassetteID, Infos.PLot pLot) {

        //retrieve object reference of cassette
        boolean cassetteFound = false;
        com.fa.cim.newcore.bo.durable.CimCassette newCassette = baseCoreFactory.getBO(com.fa.cim.newcore.bo.durable.CimCassette.class, newCassetteID);
        //Check cassette Status
        if (newCassette != null) {
            String durableState = newCassette.getDurableState();
            Validations.check(!CimStringUtils.equals(durableState, CIMStateConst.CIM_DURABLE_AVAILABLE)
                    && !CimStringUtils.equals(durableState, CIMStateConst.CIM_DURABLE_INUSE), retCodeConfig.getInvalidCassetteState());
        }
        //retrieve object reference of lot ,object reference must be retrieved
        CimLot lot = baseCoreFactory.getBO(CimLot.class, pLot.getLotID());
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        //LotMaterial
        List<Product> productList = lot.allProducts();
        List<CimWafer> localWaferList = new ArrayList<>();
        List<CimWafer> waferList = new ArrayList<>();
        if (!CimArrayUtils.isEmpty(productList)) {
            for (Product product : productList) {
                CimWafer wafer = (CimWafer) product;
                waferList.add(wafer);
                localWaferList.add(wafer);
            }
        }

        //Check input parameter
        Validations.check(productList.size() != pLot.getWaferList().size(), retCodeConfig.getInvalidInputParam());

        boolean waferExistFlag = false;
        boolean inWaferFoundFlag = false;
        if (!CimArrayUtils.isEmpty(waferList)) {
            for (int i = 0; i < waferList.size(); i++) {
                String tmpWaferID = waferList.get(i).getIdentifier();
                for (int j = 0; j < pLot.getWaferList().size(); j++) {
                    if (ObjectIdentifier.equalsWithValue(tmpWaferID, pLot.getWaferList().get(j).getWaferID())) {
                        localWaferList.set(j,waferList.get(i));
                        waferExistFlag = true;
                        inWaferFoundFlag = true;
                        break;
                    }
                }
                Validations.check(!waferExistFlag || !inWaferFoundFlag, retCodeConfig.getInvalidInputParam());

            }
        }
        //retrieve object reference of old carrier

        List<MaterialContainer> allMaterialContainers = lot.materialContainers();
        /*
         cancel relation between old carrier and lot / wafer
         By using this method, both of carrier-wafer relation
         and carrier-lot relation is canceled.
          */
        com.fa.cim.newcore.bo.durable.CimCassette oldCassette = null;
        if (!CimArrayUtils.isEmpty(allMaterialContainers)) {
            oldCassette = (com.fa.cim.newcore.bo.durable.CimCassette) allMaterialContainers.get(0);
            Validations.check(oldCassette == null, retCodeConfig.getNotFoundCassette());

            List<ProductDTO.WaferInfo> waferInfoList = lot.getAllWaferInfo();
            Validations.check ( CimArrayUtils.getSize(pLot.getWaferList()) != CimArrayUtils.getSize(waferInfoList) , retCodeConfig.getInvalidInputParam());

            for (ProductDTO.WaferInfo waferInfo : waferInfoList) {
                oldCassette.removeWaferFromPosition(waferInfo.getPosition());
            }
        }
        if (newCassette != null) {
            if (!CimArrayUtils.isEmpty(localWaferList)) {
                for (int i = 0; i < localWaferList.size(); i++) {
                    try {
                        newCassette.addWaferAtPosition(localWaferList.get(i), pLot.getWaferList().get(i).getSlotNumber());
                    } catch (CoreFrameworkException e) {
                        if (e.getCode() == 2984){
                            //NOMINAL_SIZE error
                            throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(), "Invalid NominalSize"));
                        }else {
                            throw e;
                        }
                    }
                }
            }
        }
    }

    @Override
    public void lotMaterialsScrapWaferNotOnRoute(Infos.ObjCommon objCommon, ObjectIdentifier lotID, Integer waferCount) {
        log.info("lotID = {}, waferCount = {}", lotID, waferCount);
        ObjectIdentifier userID = objCommon.getUser().getUserID();
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, userID);
        Validations.check(null == person, retCodeConfig.getNotFoundPerson());

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        //----------------------------------------------------------------------//
        // Get current wafer count                                              //
        //----------------------------------------------------------------------//
        Integer lotWaferCount = lot.getQuantity();
        int currentWaferCount = CimObjectUtils.isEmpty(lotWaferCount) ? 0 : lotWaferCount;

        //----------------------------------------------------------------------//
        // Get scrapped wafer count of input parameter                          //
        //----------------------------------------------------------------------//
        int inputWaferCount = CimObjectUtils.isEmpty(waferCount) ? 0 : waferCount;

        //----------------------------------------------------------------------//
        // Verify scrapped wafer count does not exceeds current wafer quantity  //
        //----------------------------------------------------------------------//
        Validations.check(inputWaferCount > currentWaferCount, retCodeConfig.getCountUnderZero());
        //----------------------------------------------------------------------//
        // Scrap lot when scrapped wafer quantity equals to current wafer lot   //
        // quantity                                                             //
        //----------------------------------------------------------------------//
        if (currentWaferCount == inputWaferCount) {
            log.info("currentWaferCount == inputWaferCount, currentWaferCount = {}", currentWaferCount);
            lot.makeScrapped();
            lot.setStateChangedTimeStamp(reportTimeStamp);
            lot.setStateChangedPerson(person);
        }
        //----------------------------------------------------------------------//
        // Update wafer quantity of lot                                         //
        //----------------------------------------------------------------------//
        lot.setVendorLotQuantity(currentWaferCount - inputWaferCount);

        //----------------------------------------------------------------------//
        // Update claimed timestamp / pserson                                   //
        //----------------------------------------------------------------------//
        lot.setLastClaimedTimeStamp(reportTimeStamp);
        lot.setLastClaimedPerson(person);
        Validations.check(currentWaferCount == inputWaferCount, retCodeConfig.getAllScraped());
    }

    @Override
    public void lotMaterialsScrapWaferNotOnRouteCancel(Infos.ObjCommon objCommon, ObjectIdentifier lotID, Integer waferCount) {

        ObjectIdentifier userID = objCommon.getUser().getUserID();
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, userID);
        Validations.check(null == person, retCodeConfig.getNotFoundPerson());

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        //----------------------------------------------------------------------//
        // Get current wafer count                                              //
        //----------------------------------------------------------------------//
        Integer currentNo = lot.getQuantity();
        int currentWaferCount = CimObjectUtils.isEmpty(currentNo) ? 0 : currentNo;

        //----------------------------------------------------------------------//
        // Get scrapped wafer count of input parameter                          //
        //----------------------------------------------------------------------//
        Integer inputWaferCount = CimObjectUtils.isEmpty(waferCount) ? 0 : waferCount;

        //----------------------------------------------------------------------//
        // Get current wafer count                                              //
        //----------------------------------------------------------------------//
        Integer originalNo = lot.getOriginalQuantity();
        int originalWaferCount = CimObjectUtils.isEmpty(originalNo) ? 0 : originalNo;

        //----------------------------------------------------------------------//
        // Verify scrap canceled wafer count does not exceeds original wafer    //
        // quantity                                                             //
        //----------------------------------------------------------------------//
        Validations.check((currentWaferCount + inputWaferCount) > originalWaferCount, retCodeConfig.getCountMismatch());

        //----------------------------------------------------------------------//
        // Restore a lot when it is scrapped or emptied                         //
        //----------------------------------------------------------------------//
        String lotState = lot.getLotFinishedState();
        if (CimStringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_EMPTIED, lotState) || CimStringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_SCRAPPED, lotState)) {
            lot.makeScrapCancel();
            lot.setStateChangedTimeStamp(reportTimeStamp);
            lot.setStateChangedPerson(person);
        }

        //----------------------------------------------------------------------//
        // Update wafer quantity of lot                                         //
        //----------------------------------------------------------------------//
        lot.setVendorLotQuantity(currentWaferCount + inputWaferCount);

        //----------------------------------------------------------------------//
        // Update claimed timestamp / pserson                                   //
        //----------------------------------------------------------------------//
        lot.setLastClaimedTimeStamp(reportTimeStamp);
        lot.setLastClaimedPerson(person);
    }

    @Override
    public void lotBankIn(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        ObjectIdentifier userID = objCommon.getUser().getUserID();
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, userID);
        Validations.check(null == person, retCodeConfig.getNotFoundPerson());

        com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = lot.getProcessOperation();
        Validations.check(null == processOperation, retCodeConfig.getNotFoundOperation());

        com.fa.cim.newcore.bo.pd.CimProcessDefinition processDefinition = processOperation.getMainProcessDefinition();
        Validations.check(null == processDefinition, retCodeConfig.getNotFoundProcessDefinition());

        com.fa.cim.newcore.bo.factory.CimBank bank = processDefinition.getEndBank();
        Validations.check(null == bank, retCodeConfig.getNotFoundBank());

        Boolean isBankInBank = CimBooleanUtils.isTrue(bank.isBankInBank());
        Validations.check(CimBooleanUtils.isFalse(isBankInBank), retCodeConfig.getInvalidBankType());

        lot.setBank(bank);
        lot.makeProcessing();
        lot.makeProcessed();
        lot.makeCompleted();
        lot.makeInBank();

        lot.setLastClaimedTimeStamp(reportTimeStamp);
        lot.setLastClaimedPerson(person);
        lot.setStateChangedTimeStamp(reportTimeStamp);
        lot.setStateChangedPerson(person);

        //theDispatchingManager->removeFromQueue(aLot);
        dispatchingManager.removeFromQueue(lot);

        Boolean isRecycleBank = CimBooleanUtils.isTrue(bank.isRecycleBank());
        Boolean isControlWaferBank = CimBooleanUtils.isTrue(bank.isControlWaferBank());
        if (CimBooleanUtils.isTrue(isRecycleBank)) {
            if (CimStringUtils.equals(lot.getLotType(),BizConstant.SP_LOT_TYPE_RECYCLELOT)){
                lot.makeWaitUse();
            }else {
                lot.makeWaitRecycle();
            }
        } else if (CimBooleanUtils.isTrue(isControlWaferBank)) {
            lot.makeWaitUse();
        }

        //---------------------------------------------
        // blank is set on setRequiredCassetteCategory.
        //---------------------------------------------
        lot.makeNotBankInRequired();
        lot.setRequiredCassetteCategory("");
    }

    @Override
    public void lotCheckBankInCancel(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lot),retCodeConfig.getNotFoundLot());
        /*------------------------------------------------------------------------*/
        /*   Get BankID                                                           */
        /*------------------------------------------------------------------------*/
        CimBank bank = lot.getBank();
        Validations.check(null == bank, retCodeConfig.getNotFoundBank());

        /*------------------------------------------------------------------------*/
        /*   Check Route                                                          */
        /*------------------------------------------------------------------------*/
        CimProcessDefinition processDefinition = lot.getMainProcessDefinition();
        Validations.check(null == processDefinition, retCodeConfig.getNotFoundProcessDefinition());
        String routeID = processDefinition.getIdentifier();

        String envStr = StandardProperties.OM_CANCEL_BANK_IN_PRODUCT_CHK.getValue();
        if (CimStringUtils.equals("0", CimObjectUtils.isEmpty(envStr) ? "0" : envStr)) {
            return;
        }
        /*-----   Get MainPD ( Product )   -----*/
        CimProductSpecification productSpecification = lot.getProductSpecification();
        Validations.check(null == productSpecification, retCodeConfig.getNotFoundProductSpec());

        CimProcessDefinition aProdSpecMainPD = (CimProcessDefinition) productSpecification.getProcessDefinition();
        Validations.check(null == aProdSpecMainPD, retCodeConfig.getNotFoundProcessDefinition());

        String prodSpecMainPD = aProdSpecMainPD.getIdentifier();
        /*-----   Check RouteID   -----*/
        if (!CimStringUtils.equals(routeID, prodSpecMainPD)) {
            /*-----   Get MultiMainPD   -----*/

            List<ProductSpecDTO.PosMultiMainPD> multiMainPDS = productSpecification.allMultiPD();
            boolean discordFlag = true;
            for (ProductSpecDTO.PosMultiMainPD multiMainPD : multiMainPDS) {
                if (CimStringUtils.equals(routeID, multiMainPD.getMainProcessDefinition().getValue())) {
                    discordFlag = false;
                }
            }
            Validations.check(CimBooleanUtils.isTrue(discordFlag), retCodeConfig.getInvalidRouteId());
        }

        /*-----   Check Last Operation   -----*/
        CimProcessFlowContext processFlowContext = lot.getProcessFlowContext();
        Validations.check(null == processFlowContext, retCodeConfig.getNotFoundPfx());

        AtomicReference<CimProcessFlow> aOutMainProcessFlow = new AtomicReference<>();
        AtomicReference<CimProcessFlow> aOutModuleProcessFlow = new AtomicReference<>();
        AtomicReference<String> outModuleNumber = new AtomicReference<>();
        CimProcessOperationSpecification nextPOSOut = processFlowContext.getNextProcessOperationSpecification(aOutMainProcessFlow, outModuleNumber, aOutModuleProcessFlow);
        Validations.check(!CimObjectUtils.isEmpty(nextPOSOut), retCodeConfig.getNotBankInOperation());

        /*------------------------------------------------------------------------*/
        /*   Check Route   &   bank ID relation                                   */
        /*------------------------------------------------------------------------*/

        CimBank endBank = processDefinition.getEndBank();
        Validations.check(null == endBank, retCodeConfig.getNotFoundBank());

        /*-----   Check Route  &  bank Relation   -----*/
        Validations.check(!CimStringUtils.equals(endBank.getIdentifier(), bank.getIdentifier()), retCodeConfig.getNotInSameBank());
    }

    @Override
    public void lotBankInCancel(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lot), retCodeConfig.getNotFoundLot());

        CimLotFamily lotFamily = lot.getLotFamily();
        Validations.check(CimObjectUtils.isEmpty(lotFamily), retCodeConfig.getNotFoundLotFamily());

        lotFamily.removeArchive(lot);
        lotFamily.addLot(lot);

        if (!CimStringUtils.equals(BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING, CimDateUtils.convertToSpecString(lotFamily.actualCompletionTime()))) {
            lotFamily.setActualCompletionTime(CimDateUtils.convertToOrInitialTime(BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING));
        }

        lot.setAllStateForBankInCancel();
        CimBank bank = lot.getBank();
        Validations.check(null == bank, retCodeConfig.getNotFoundBank());

        lot.setPreviousBank(bank);
        lot.setBank(null);
        ObjectIdentifier userID = objCommon.getUser().getUserID();
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        lot.setLastClaimedTimeStamp(reportTimeStamp);
        CimPerson person = baseCoreFactory.getBO(CimPerson.class, userID);
        Validations.check(CimObjectUtils.isEmpty(person),retCodeConfig.getNotFoundPerson());
        lot.setLastClaimedPerson(person);
        lot.setStateChangedTimeStamp(reportTimeStamp);
        lot.setStateChangedPerson(person);

        dispatchingManager.addToQueue(lot);

        CimProcessOperation processOperation = lot.getProcessOperation();
        Validations.check(null == processOperation, retCodeConfig.getNotFoundProcessOperation());

        String requiredCassetteCategory = processOperation.getRequiredCassetteCategory();
        if (!CimObjectUtils.isEmpty(requiredCassetteCategory)) {
            lot.setRequiredCassetteCategory(requiredCassetteCategory);
        }
    }

    @Override
    public void lotNonProBankIn(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier bankID) {

       //  Bug 2146
        com.fa.cim.newcore.bo.factory.CimBank aBank = baseCoreFactory.getBO(com.fa.cim.newcore.bo.factory.CimBank.class, bankID);
        Validations.check(null == aBank, retCodeConfig.getNotFoundBank());
        Validations.check(CimBooleanUtils.isTrue(aBank.isProductionBank()), retCodeConfig.getNotNonProductBank());

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));

        lot.setBank(aBank);
        lot.setPreviousBank(null);
        lot.makeNonProBank();
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        lot.setLastClaimedTimeStamp(reportTimeStamp);
        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, new OmCode(retCodeConfig.getNotFoundPerson(), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));
        lot.setLastClaimedPerson(person);
        lot.setStateChangedTimeStamp(reportTimeStamp);
        lot.setStateChangedPerson(person);
    }

    @Override
    public String lotHoldListCheckMerge(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID, ObjectIdentifier childLotID) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, childLotID);
        CimLot aParentLot = baseCoreFactory.getBO(CimLot.class, parentLotID);
        //--- Get ProcessFlowContext
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aParentPFX = aParentLot.getProcessFlowContext();
        Validations.check(null == aParentPFX, retCodeConfig.getNotFoundPfx());

        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aChildPFX = aLot.getProcessFlowContext();
        Validations.check(null == aChildPFX, retCodeConfig.getNotFoundPfx());

        List<ProcessDTO.BackupOperation> backupSeqParent = aParentPFX.allBackupOperations();
        int nLenParentPrePO = CimArrayUtils.getSize(backupSeqParent);
        List<ProcessDTO.BackupOperation> backupSeqChild = aChildPFX.allBackupOperations();
        int nLenChildPrePO = CimArrayUtils.getSize(backupSeqChild);
        Validations.check(nLenChildPrePO != nLenParentPrePO, retCodeConfig.getNotSameOperation());

        if (nLenParentPrePO > 0){
            for (ProcessDTO.BackupOperation backupOperation : backupSeqParent){
                CimProcessOperation aParentPrePO = baseCoreFactory.getBO(CimProcessOperation.class, backupOperation.getProcessOperation());
                Validations.check(aParentPrePO == null, retCodeConfig.getNotFoundOperation());

                CimProcessOperation aChildPrePO = baseCoreFactory.getBO(CimProcessOperation.class, backupOperation.getProcessOperation());
                Validations.check(aChildPrePO == null, retCodeConfig.getNotFoundOperation());

                CimProcessDefinition aPosParentProcessDefinition = aParentPrePO.getMainProcessDefinition();
                Validations.check(aPosParentProcessDefinition == null, retCodeConfig.getNotFoundProcessDefinition());

                String aParentRouteID = aPosParentProcessDefinition.getIdentifier();
                String aParentOperationNumber = aParentPrePO.getOperationNumber();
                com.fa.cim.newcore.bo.pd.CimProcessDefinition aPosChildProcessDefinition = aChildPrePO.getMainProcessDefinition();
                Validations.check(aPosChildProcessDefinition == null, retCodeConfig.getNotFoundProcessDefinition());

                String aChildRouteID = aPosChildProcessDefinition.getIdentifier();
                String aChildOperationNumber = aChildPrePO.getOperationNumber();
                Validations.check(!CimStringUtils.equals(aParentRouteID, aChildRouteID), retCodeConfig.getNotSameRoute());

                Validations.check(!CimStringUtils.equals(aParentOperationNumber, aChildOperationNumber), retCodeConfig.getNotSameOperation());
            }
        }
        String theChildLotHoldState = aLot.getLotHoldState();
        String theParentLotHoldState = aLot.getLotHoldState();
        if (CimStringUtils.equals(theParentLotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD)
                && CimStringUtils.equals(theChildLotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD)){
            boolean aBool = aLot.isOriginalLot();
            Validations.check(aBool, retCodeConfig.getOriglotCannotBeChild());

        } else if (CimStringUtils.equals(theParentLotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD)
                    && CimStringUtils.equals(theChildLotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD)){
            Validations.check(true, retCodeConfig.getHoldRecordOfChildOwn());

        } else if (CimStringUtils.equals(theParentLotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD)
                    && CimStringUtils.equals(theChildLotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD)){
        }
        // Check holdRecordList
        List<ProductDTO.HoldRecord> aChildHoldRecords = aLot.allHoldRecords();
        boolean checkSplitOrigin = false;
        int holdRecLen = CimArrayUtils.getSize(aChildHoldRecords);
        if (holdRecLen > 0){
            for (ProductDTO.HoldRecord childHoldRecord : aChildHoldRecords){
                ProductDTO.HoldRecord targetHoldRecord = new ProductDTO.HoldRecord();
                targetHoldRecord.setHoldType(childHoldRecord.getHoldType());
                targetHoldRecord.setReasonCode(childHoldRecord.getReasonCode());
                targetHoldRecord.setHoldPerson(childHoldRecord.getHoldPerson());
                if (!ObjectIdentifier.isEmptyWithValue(childHoldRecord.getRelatedLot())){
                    checkSplitOrigin = true;
                    if (ObjectIdentifier.equalsWithValue(childHoldRecord.getRelatedLot(), parentLotID)){
                        targetHoldRecord.setRelatedLot(childLotID);
                    } else {
                        targetHoldRecord.setRelatedLot(childHoldRecord.getRelatedLot());
                    }
                }
                ProductDTO.HoldRecord holdRecord = aParentLot.findHoldRecord(targetHoldRecord);
                Validations.check(holdRecord == null || CimStringUtils.isEmpty(holdRecord.getHoldType()), retCodeConfig.getHoldRecordOfChildOwn());
            }
        }
        if(checkSplitOrigin){
            Lot aRecentSplitLot = aLot.mostRecentlySplitFrom();
            Validations.check(aRecentSplitLot == null, retCodeConfig.getNotFoundLot());

            String aRecentSplitLotID = aRecentSplitLot.getIdentifier();
            Validations.check(!ObjectIdentifier.equalsWithValue(parentLotID, aRecentSplitLotID), retCodeConfig.getNotNotDirectparent());

        }
        return null;
    }

    @Override
    public List<Infos.LotHoldReq> lotFutureHoldRequestsCheckMerge(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID, ObjectIdentifier childLotID) {

        CimLot childLot = baseCoreFactory.getBO(CimLot.class, childLotID);
        CimLot parentLot = baseCoreFactory.getBO(CimLot.class, parentLotID);
        List<Infos.LotHoldReq> lotHoldReqs = new ArrayList<>();
        //-----------------------------------
        // Get parent lot's main route
        //-----------------------------------
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aParentMainPD = parentLot.getMainProcessDefinition();
        Validations.check(null == aParentMainPD, retCodeConfig.getNotFoundProcessDefinition());

        String mainRouteID = aParentMainPD.getIdentifier();
        List<ProductDTO.FutureHoldRecord> aChildFutureHR = childLot.allFutureHoldRecords();
        for (int i = 0; i < CimArrayUtils.getSize(aChildFutureHR); i++) {
            //CimLotFutureHoldDO aKeyFutureHold = new CimLotFutureHoldDO();
            ProductDTO.FutureHoldRecord aKeyFutureHold = new ProductDTO.FutureHoldRecord();
            aKeyFutureHold.setHoldType(aChildFutureHR.get(i).getHoldType());
            aKeyFutureHold.setReasonCode(aChildFutureHR.get(i).getReasonCode());
            aKeyFutureHold.setRequestPerson(aChildFutureHR.get(i).getRequestPerson());
            aKeyFutureHold.setMainProcessDefinition(aChildFutureHR.get(i).getMainProcessDefinition());
            aKeyFutureHold.setOperationNumber(aChildFutureHR.get(i).getOperationNumber());
            if (ObjectIdentifier.equalsWithValue(parentLot.getLotID(), aChildFutureHR.get(i).getRelatedLot())) {
                aKeyFutureHold.setRelatedLot(childLotID);
            } else {
                aKeyFutureHold.setRelatedLot(aChildFutureHR.get(i).getRelatedLot());
            }
            ProductDTO.FutureHoldRecord aFutureHold = parentLot.findFutureHoldRecord(aKeyFutureHold);
            /*if (null == aFutureHold) {
                continue;
            }*/

            //【2019/05/29】the source code is : if (CIMFWStrLen( aFutureHold->holdType ) == 0) {...}
            // but in FRLOT_FUTUREHOLD, the HOLD_TYPE must not be null!
            // so change the code to if (CIMFWStrLen( aFutureHold->holdType ) == 0) {...}
            //【2019/6/3】 bug-1034 we can't partial rework cancel successfully
            //but if we step in the 'if (CIMFWStrLen( aFutureHold->holdType ) == 0) {...}' the method  processCompareCurrent
            //return the result currentToperationSame ,but i think currentToperationSame we should not return the wrong message
            //so change !StringUtils.isEmpty(aFutureHold.getHoldType()) --> StringUtils.isEmpty(aFutureHold.getHoldType()) temporarilly
            if (aFutureHold == null) {
                if (ObjectIdentifier.equalsWithValue(mainRouteID, aChildFutureHR.get(i).getMainProcessDefinition())) {
                    try {
                        Outputs.ObjProcessCompareCurrentOut objProcessCompareCurrentOut = processMethod.processCompareCurrent(objCommon,
                                parentLotID,
                                aChildFutureHR.get(i).getMainProcessDefinition(),
                                aChildFutureHR.get(i).getOperationNumber());
                    }catch (ServiceException ex){
                        if (retCodeConfig.getCurrentToperationSame().getCode() == ex.getCode()
                                || retCodeConfig.getCurrentToperationEarly().getCode() == ex.getCode()) {
                            Validations.check(retCodeConfig.getConnotMergeFuturehold());
                        }else if (retCodeConfig.getCurrentToperationLate().getCode() == ex.getCode()){

                        }else {
                            throw ex;
                        }
                    }

                } else {
                    Validations.check(retCodeConfig.getConnotMergeFuturehold());
                }
            }
            if (CimStringUtils.equals(BizConstant.SP_HOLDTYPE_MERGEHOLD, aChildFutureHR.get(i).getHoldType())
                    || CimStringUtils.equals(BizConstant.SP_HOLDTYPE_REWORKHOLD, aChildFutureHR.get(i).getHoldType())) {
                Infos.LotHoldReq holdReq = new Infos.LotHoldReq();
                holdReq.setHoldType(aChildFutureHR.get(i).getHoldType());
                holdReq.setHoldReasonCodeID(aChildFutureHR.get(i).getReasonCode());
                holdReq.setHoldUserID(aChildFutureHR.get(i).getRequestPerson());
                holdReq.setResponsibleOperationMark(null);
                holdReq.setOperationNumber(aChildFutureHR.get(i).getOperationNumber());
                holdReq.setRelatedLotID(aChildFutureHR.get(i).getRelatedLot());
                holdReq.setRouteID(aChildFutureHR.get(i).getMainProcessDefinition());
                lotHoldReqs.add(holdReq);
            }
        }
        return lotHoldReqs;
    }

    @Override
    public void lotFutureHoldRequestsCheckBranch(Infos.ObjCommon objCommon, ObjectIdentifier lotID, String returnOperationNumber) {

        //【step1】get current operation number for lot
        log.debug("【step1】get current operation number for lot, the lotID:%s", lotID);
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        String currentOperationNumber = lot.getOperationNumber();
        if (!CimObjectUtils.isEmpty(returnOperationNumber)) {
            //【step2】get main process definition for lot.
            log.debug("【step2】get main process definition for lot. the lotID:%s", lotID);
            com.fa.cim.newcore.bo.pd.CimProcessDefinition currentMainProcessDefinition = lot.getMainProcessDefinition();
            Validations.check(null == currentMainProcessDefinition, retCodeConfig.getNotFoundProcessDefinition());

            String currentMainProcessDefinitionID = currentMainProcessDefinition.getIdentifier();

            //【step3】find future hold records for lot
            log.debug("【step3】find future hold records for lot");
            List<ProductDTO.FutureHoldRecord> lotFutureHoldList = lot.findFutureHoldRecordsFor(currentMainProcessDefinition, currentOperationNumber);
            int futureHoldLen = CimArrayUtils.getSize(lotFutureHoldList);
            Boolean postFutureHoldFlag = false;
            for (int i = 0; i < futureHoldLen; i++) {
                ProductDTO.FutureHoldRecord lotFutureHold = lotFutureHoldList.get(i);
                if (CimBooleanUtils.isTrue(lotFutureHold.isPostFlag())) {
                    postFutureHoldFlag = true;
                }
            }

            //【step4】get process flow context
            log.debug("【step4】get process flow context");
            com.fa.cim.newcore.bo.pd.CimProcessFlowContext aProcessFlowContext = lot.getProcessFlowContext();
            Validations.check(null == aProcessFlowContext, retCodeConfig.getNotFoundPfx());

            Boolean isAfterFlag = aProcessFlowContext.isAfterOperationNumber(returnOperationNumber, currentOperationNumber);
            if (CimBooleanUtils.isFalse(isAfterFlag)) {
                return;
            }
            Validations.check(CimBooleanUtils.isTrue(postFutureHoldFlag), new OmCode(retCodeConfig.getFutureHoldInBranch(), lotID.getValue(), currentMainProcessDefinitionID, currentOperationNumber));

            //【step5】get main process definition
            log.debug("【step5】get main process definition");
            com.fa.cim.newcore.bo.pd.CimProcessDefinition aMainPD = lot.getMainProcessDefinition();
            Validations.check(null == aMainPD, retCodeConfig.getNotFoundProcessDefinition());

            ObjectIdentifier mainProcessDefinitionID = ObjectIdentifier.build(aMainPD.getIdentifier(), aMainPD.getPrimaryKey());

            //【step6】get future hold list by key for lot.
            log.debug("【step6】get future hold list by key for lot.");
            Infos.FutureHoldSearchKey futureHoldSearchKey = new Infos.FutureHoldSearchKey();
            futureHoldSearchKey.setLotID(lotID);
            futureHoldSearchKey.setRouteID(mainProcessDefinitionID);
            int count = 0;
            List<Infos.FutureHoldListAttributes> futureHoldListAttributesList = null;
            try {
                futureHoldListAttributesList = this.lotFutureHoldListbyKeyDR(objCommon,futureHoldSearchKey, count);
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getNotFoundFtholdEntW(), e.getCode())) {
                    return;
                } else {
                    throw e;
                }
            }

            //【step7】get next process operation specification on current route.
            log.debug("【step7】get next process operation specification on current route.");
            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainPF = new AtomicReference<>();
            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outModulePF = new AtomicReference<>();
            AtomicReference<String> outModuleNo = new AtomicReference<>();
            com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aModulePOS = aProcessFlowContext.getNextProcessOperationSpecificationOnCurrentRoute(outMainPF, outModuleNo, outModulePF);

            com.fa.cim.newcore.bo.pd.CimProcessFlow aMainPF = outMainPF.get();
            com.fa.cim.newcore.bo.pd.CimProcessFlow aModulePF = outModulePF.get();
            String aModuleNo = outModuleNo.get();

            while ((null != aModulePOS)) {
                String aModuleOpeNo = aModulePOS.getOperationNumber();
                String aOperationNumber = aModuleNo + "." + aModuleOpeNo;
                if (CimStringUtils.equals(aOperationNumber, returnOperationNumber)) {
                    break;
                }

                futureHoldLen = CimArrayUtils.getSize(futureHoldListAttributesList);
                for (int i = 0; i < futureHoldLen; i++) {
                    Infos.FutureHoldListAttributes lotFutureHold = futureHoldListAttributesList.get(i);
                    Validations.check(CimStringUtils.equals(lotFutureHold.getOperationNumber(), aOperationNumber), new OmCode(retCodeConfig.getFutureHoldInBranch(), lotID.getValue(), aMainPD.getIdentifier(), lotFutureHold.getOperationNumber()));
                }

                //【step8】get next process operation specification on current route for process flow context.
                log.debug("【step8】get next process operation specification on current route for process flow context.");
                aModulePOS = aProcessFlowContext.getNextProcessOperationSpecificationOnCurrentRouteFor(aMainPF, aModuleNo, aModulePF, aModulePOS, outMainPF, outModuleNo, outModulePF);

                aModuleNo = outModuleNo.get();
                aMainPF = outMainPF.get();
                aModulePF = outModulePF.get();
            }
        }


    }

    @Override
    public String lotMergeWaferLot(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID, ObjectIdentifier childLotID) {
        Boolean bInParentCast = true;
        Boolean bInChildCast = true;
        Boolean bInCast = true;

        CimLot parentLot = baseCoreFactory.getBO(CimLot.class, parentLotID);
        CimLot childLot = baseCoreFactory.getBO(CimLot.class, childLotID);
        //--------------------------------------------------------------------
        // Check wafer attributes
        //--------------------------------------------------------------------
        //------------------------------------------------------
        // Get all wafer information of Parent lot
        //------------------------------------------------------
        List<ProductDTO.WaferInfo> parentLotWaferInfo = parentLot.getAllWaferInfo();

        //------------------------------------------------------
        // Get all wafer information of Child lot
        //------------------------------------------------------
        List<ProductDTO.WaferInfo> childLotWaferInfo = childLot.getAllWaferInfo();

        //-------------------------------------------------------------------
        // Check Stacked wafer Information
        // If it is different from Parent lot and Child lot, not allow merge
        //-------------------------------------------------------------------
        Boolean bInvalidStkWfr = false;
        Integer parentStkwaferCount = 0;
        Integer childStkwaferCount = 0;
        if (0 < parentLotWaferInfo.size()) {
            //【jerry】 StackedWafer  is frwafer_stkwfr Is empty in DB2
            parentStkwaferCount = CimArrayUtils.getSize(parentLotWaferInfo.get(0).getStackedWafers());
        }
        if (0 < childLotWaferInfo.size()) {
            //【jerry】StackedWafer  is frwafer_stkwfr Is empty in DB2
            childStkwaferCount = CimArrayUtils.getSize(childLotWaferInfo.get(0).getStackedWafers());
        }
        Validations.check(!Objects.equals(parentStkwaferCount, childStkwaferCount), retCodeConfig.getError());

        //------------------------------------------------------
        // Get Carrier object reference of Parent lot
        //------------------------------------------------------
        List<MaterialContainer> aMaterialContainerSequence = parentLot.materialContainers();
        com.fa.cim.newcore.bo.durable.CimCassette aParentCassette = null;
        if (1 == CimArrayUtils.getSize(aMaterialContainerSequence)) {
            aParentCassette = (com.fa.cim.newcore.bo.durable.CimCassette) aMaterialContainerSequence.get(0);
        } else if (0 == CimArrayUtils.getSize(aMaterialContainerSequence)){
            bInParentCast = false;
        } else {
            Validations.check(true, retCodeConfig.getError());
        }
        Validations.check(null == aParentCassette, retCodeConfig.getNotFoundCassette());

        //------------------------------------------------------
        // Get Carrier object reference of Child lot
        //------------------------------------------------------
        List<MaterialContainer> aChildMaterialContainerSequence = childLot.materialContainers();
        com.fa.cim.newcore.bo.durable.CimCassette aChildCassette = null;
        if (1 == CimArrayUtils.getSize(aChildMaterialContainerSequence)) {
            aChildCassette = (com.fa.cim.newcore.bo.durable.CimCassette) aChildMaterialContainerSequence.get(0);
        } else if (0 == CimArrayUtils.getSize(aChildMaterialContainerSequence)){
            bInChildCast = false;
        } else {
            Validations.check(true, retCodeConfig.getError());

        }
        Validations.check(null == aChildCassette, retCodeConfig.getNotFoundCassette());

        if (CimBooleanUtils.isFalse(bInParentCast) && CimBooleanUtils.isFalse(bInChildCast)) {
            bInCast = false;
        } else if (CimBooleanUtils.isTrue(bInParentCast) && CimBooleanUtils.isTrue(bInChildCast)) {
            bInCast = true;
        } else {
            Validations.check(true, retCodeConfig.getError());

        }
        if (CimBooleanUtils.isTrue(bInCast)) {
            Validations.check(!CimStringUtils.equals(aParentCassette.getIdentifier(), aChildCassette.getIdentifier()), retCodeConfig.getCassetteDifferentForMerge());
            //------------------------------------------------------
            // Remove Lots from Carrier
            //------------------------------------------------------
            for (int i = 0; i < CimArrayUtils.getSize(childLotWaferInfo); i++) {
                aParentCassette.removeWaferFromPosition(childLotWaferInfo.get(i).getPosition() == null ? 0 : childLotWaferInfo.get(i).getPosition());
            }
            //------------------------------------------------------
            // Remove from queue
            //------------------------------------------------------
            String childLotHoldState = childLot.getLotHoldState();
            if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, childLotHoldState)){
                dispatchingManager.removeFromHoldQueue(childLot);
            }else {
                dispatchingManager.removeFromQueue(childLot);
            }

            //--------------------------------------------------
            // Remove parent lot from queue and add to queue
            //----------------------------------------------------
            String aParentLotHoldState = parentLot.getLotHoldState();
            String aParentLotState = parentLot.getLotState();
            if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, aParentLotHoldState)
                    && !CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_FINISHED, aParentLotState)){
                dispatchingManager.removeFromQueue(parentLot);
                dispatchingManager.addToQueue(parentLot);
            }
        }
        //qtime : qTimeChangeEvent_Make__180
        List<com.fa.cim.newcore.bo.pd.CimQTimeRestriction> aChildWaferQTimeList = null;
        int aChildWaferQTimeForWaferCount = childLot.getWaferLevelQTimeCount();
        if (aChildWaferQTimeForWaferCount > 0){
            aChildWaferQTimeList = childLot.allQTimeRestrictionsForWaferLevelQTime();
        }
        if (!CimObjectUtils.isEmpty(aChildWaferQTimeList)){
            for (com.fa.cim.newcore.bo.pd.CimQTimeRestriction cimQTimeDO : aChildWaferQTimeList){
                com.fa.cim.newcore.bo.pd.CimQTimeRestriction aChildWaferQTime = cimQTimeDO;
                /*----------------------------*/
                /*   Get Q-Time information   */
                /*----------------------------*/
                ProcessDTO.QTimeRestrictionInfo aChildWaferQTimeInfo = aChildWaferQTime.getQTimeRestrictionInfo();
                aChildWaferQTime.setLot(parentLot);
                //----------------------------------------------------------------
                // Make event
                //----------------------------------------------------------------
                Infos.QtimeInfo qtimeInfo = new Infos.QtimeInfo();
                qtimeInfo.setQTimeType(aChildWaferQTimeInfo.getQTimeType());
                qtimeInfo.setWaferID(aChildWaferQTimeInfo.getWaferID());
                qtimeInfo.setPreTrigger(aChildWaferQTimeInfo.getPreTrigger());
                qtimeInfo.setOriginalQTime(aChildWaferQTimeInfo.getOriginalQTime());
                qtimeInfo.setProcessDefinitionLevel(aChildWaferQTimeInfo.getProcessDefinitionLevel());
                qtimeInfo.setRestrictionTriggerRouteID(aChildWaferQTimeInfo.getTriggerMainProcessDefinition());
                qtimeInfo.setRestrictionTriggerOperationNumber(aChildWaferQTimeInfo.getTriggerOperationNumber());
                qtimeInfo.setRestrictionTriggerBranchInfo(aChildWaferQTimeInfo.getTriggerBranchInfo());
                qtimeInfo.setRestrictionTriggerReturnInfo(aChildWaferQTimeInfo.getTriggerReturnInfo());
                qtimeInfo.setRestrictionTriggerTimeStamp(aChildWaferQTimeInfo.getTriggerTimeStamp());
                qtimeInfo.setRestrictionTargetRouteID(aChildWaferQTimeInfo.getTargetMainProcessDefinition());
                qtimeInfo.setRestrictionTargetOperationNumber(aChildWaferQTimeInfo.getTargetOperationNumber());
                qtimeInfo.setRestrictionTargetBranchInfo(aChildWaferQTimeInfo.getTargetBranchInfo());
                qtimeInfo.setRestrictionTargetReturnInfo(aChildWaferQTimeInfo.getTargetReturnInfo());
                qtimeInfo.setRestrictionTargetTimeStamp(aChildWaferQTimeInfo.getTargetTimeStamp());
                qtimeInfo.setPreviousTargetInfo(aChildWaferQTimeInfo.getPreviousTargetInfo());
                qtimeInfo.setSpecificControl(aChildWaferQTimeInfo.getControl());
                if (CimBooleanUtils.isTrue(aChildWaferQTimeInfo.getWatchdogRequired())){
                    qtimeInfo.setWatchDogRequired("Y");
                } else {
                    qtimeInfo.setWatchDogRequired("N");
                }
                if (CimBooleanUtils.isTrue(aChildWaferQTimeInfo.getActionDone())){
                    qtimeInfo.setActionDoneFlag("Y");
                } else {
                    qtimeInfo.setActionDoneFlag("N");
                }
                qtimeInfo.setManualCreated(aChildWaferQTimeInfo.getManualCreated());
                int actionLength = CimArrayUtils.getSize(aChildWaferQTimeInfo.getActions());
                List<Infos.QTimeActionInfo> qTimeActionInfoList = new ArrayList<>();
                qtimeInfo.setStrQtimeActionInfoList(qTimeActionInfoList);
                if (actionLength != 0){
                    for (ProcessDTO.QTimeRestrictionAction qTimeRestrictionAction : aChildWaferQTimeInfo.getActions()){
                        Infos.QTimeActionInfo qTimeActionInfo = new Infos.QTimeActionInfo();
                        qTimeActionInfoList.add(qTimeActionInfo);
                        qTimeActionInfo.setQrestrictionTargetTimeStamp(qTimeRestrictionAction.getTargetTimeStamp());
                        qTimeActionInfo.setQrestrictionAction(qTimeRestrictionAction.getAction());
                        qTimeActionInfo.setReasonCodeID(qTimeRestrictionAction.getReasonCode());
                        qTimeActionInfo.setActionRouteID(qTimeRestrictionAction.getActionRouteID());
                        qTimeActionInfo.setActionOperationNumber(qTimeRestrictionAction.getOperationNumber());
                        qTimeActionInfo.setFutureHoldTiming(qTimeRestrictionAction.getTiming());
                        qTimeActionInfo.setReworkRouteID(qTimeRestrictionAction.getMainProcessDefinition());
                        qTimeActionInfo.setMessageID(qTimeRestrictionAction.getMessageDefinition());
                        qTimeActionInfo.setCustomField(qTimeRestrictionAction.getCustomField());
                        if (CimBooleanUtils.isTrue(qTimeRestrictionAction.getWatchdogRequired())) {
                            qTimeActionInfo.setWatchDogRequired("Y");
                        } else {
                            qTimeActionInfo.setWatchDogRequired("N");
                        }
                        if (CimBooleanUtils.isTrue(qTimeRestrictionAction.getActionDone())) {
                            qTimeActionInfo.setActionDoneFlag("Y");
                        } else {
                            qTimeActionInfo.setActionDoneFlag("N");
                        }
                    }
                }
                Inputs.QTimeChangeEventMakeParams params = new Inputs.QTimeChangeEventMakeParams();
                params.setUpdateMode(BizConstant.SP_QRESTTIME_OPECATEGORY_UPDATE);
                params.setLotID(parentLotID);
                params.setQtimeInfo(qtimeInfo);
                params.setClaimMemo("");
                eventMethod.qTimeChangeEventMake(objCommon, params);
            }
        }
        //---------------------------------------
        // Get theQuantity and theProductQuantity
        //---------------------------------------
        Integer aParentLotQuantity = parentLot.getQuantity();
        Integer aChildLotQuantity = childLot.getQuantity();
        Integer aParentLotProductQuantity = parentLot.getProductQuantity();
        Integer aChildLotProductQuantity = childLot.getProductQuantity();
        Integer aParentLotControlQuantity = parentLot.getControlQuantity();
        Integer aChildLotControlQuantity = childLot.getControlQuantity();
        Integer totalQuantity = aParentLotQuantity + aChildLotQuantity;
        Integer totalProductQuantity = aParentLotProductQuantity + aChildLotProductQuantity;
        Integer totalControlQuantity = aParentLotControlQuantity + aChildLotControlQuantity;
        //------------------------------------------------------
        // Call lot merge method of F/W.
        //------------------------------------------------------
        productManager.joinAllInto(childLot,parentLot);
        String envEventCreateType = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
        envEventCreateType = null == envEventCreateType ? "-1" : envEventCreateType;
        if (CimStringUtils.equals(CimObjectUtils.toString(BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED), envEventCreateType)
                || (CimStringUtils.equals(CimObjectUtils.toString(BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED), envEventCreateType))) {
            com.fa.cim.newcore.bo.pd.CimProcessOperation aCurrentPO = childLot.getProcessOperation();
            if (null  != aCurrentPO) {
                // TODO: 2018/10/18 poDelQueue_PutDR
            }
        }
        //------------------------------------------------------
        // Add Lots to Carrier
        //------------------------------------------------------
        if (CimBooleanUtils.isTrue(bInCast)) {
            for (int i = 0; i < childLotWaferInfo.size(); i++) {
                CimWafer tmpWafer = baseCoreFactory.getBO(CimWafer.class, childLotWaferInfo.get(i).getWaferID());
                aParentCassette.addWaferAtPosition(tmpWafer,childLotWaferInfo.get(i).getPosition());
                //cimLot.saveLotToLotMaterial(parentLot, tmpWafer);
            }
        }
        //update recycle/usage limit to min limit
        Integer parentUsageLimit = parentLot.getUsageLimit();
        Integer parentRecycleLimit = parentLot.getRecycleLimit();
        Integer childUsageLimit = childLot.getUsageLimit();
        Integer childRecycleLimit = childLot.getRecycleLimit();
        if (childUsageLimit < parentUsageLimit && childUsageLimit != 0 ){
            parentLot.setUsageLimit(childUsageLimit);
        }else if (parentUsageLimit == 0 && childUsageLimit !=0) {
            parentLot.setUsageLimit(childUsageLimit);
        }
        if (childRecycleLimit < parentRecycleLimit && childRecycleLimit != 0 ){
            parentLot.setRecycleLimit(childRecycleLimit);
        }else if (parentRecycleLimit == 0 && childRecycleLimit !=0) {
            parentLot.setRecycleLimit(childRecycleLimit);
        }

        //---------------------------------------------------------------------
        // change total wafer quantity of both parent lot and child lot.
        //  ParentLot.theQuantity   <= aParentLotQuantity + aChildLotQuantity
        //  ChildLot.theQuantity    <= 0
        //---------------------------------------------------------------------
        parentLot.setVendorLotQuantity(totalQuantity);
        childLot.setVendorLotQuantity(0);
        parentLot.setProductQuantity(totalProductQuantity);
        childLot.setProductQuantity(0);
        parentLot.setControlQuantity(totalControlQuantity);
        childLot.setControlQuantity(0);
        String lagTimeMergeRule = StandardProperties.OM_LAG_INFO_MERGE_RULE.getValue();
        if (CimStringUtils.equals(BizConstant.CONSTANT_QUANTITY_ONE, lagTimeMergeRule)) {
             /*-----------------------------------------------------------*/
            /*   Check PosLot and related CLASS                          */
            /*-----------------------------------------------------------*/
            List<Infos.LotHoldListAttributes> out = this.lotFillInTxTRQ005DR(objCommon, childLotID);

            Boolean bLagTimeHoldFlag = false;
            for (int i = 0; i < CimArrayUtils.getSize(out); i++) {
                 if (ObjectIdentifier.equalsWithValue(BizConstant.SP_REASON_PROCESSLAGTIMEHOLD, out.get(i).getReasonCodeID())) {
                    bLagTimeHoldFlag = true;
                    break;
                 }
            }
            if (CimBooleanUtils.isTrue(bLagTimeHoldFlag)) {
                Timestamp parentProcessLagTime = parentLot.getProcessLagTime();
                Timestamp childProcessLagTime = childLot.getProcessLagTime();
                if (!CimStringUtils.equals(BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING, parentProcessLagTime.toString())
                        && !CimStringUtils.equals(BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING, childProcessLagTime.toString())) {
                    if (CimDateUtils.compare(parentProcessLagTime, childProcessLagTime) <0) {
                        parentLot.setProcessLagTime(childProcessLagTime);
                    } else {
                        parentLot.setProcessLagTime(parentProcessLagTime);
                    }
                }
            }
        }
        if (CimBooleanUtils.isTrue(parentLot.isInProduction())) {
            if (childLot.isInRework()) {
                childLot.makeInProduction();
            }
        }
        //------------------------------------------------------
        // For partial rework cancel operation (END)
        //------------------------------------------------------
        com.fa.cim.newcore.bo.pd.CimProcessOperation aChildPO = childLot.getProcessOperation();
        Validations.check(null == aChildPO, retCodeConfig.getNotFoundProcessOperation());

        ProcessOperationSpecification aProcessOperationSpecification = aChildPO.getProcessOperationSpecification();

        childLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == aPerson, new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
        childLot.setLastClaimedPerson(aPerson);
        childLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        childLot.setStateChangedPerson(aPerson);

        parentLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        parentLot.setLastClaimedPerson(aPerson);
        parentLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        parentLot.setStateChangedPerson(aPerson);
        parentLot.setLastClaimAllWafers(objCommon.getTimeStamp().getReportTimeStamp(),aPerson);
        //parentLot.setWaferCount(totalQuantity);

        return null == aProcessOperationSpecification ? null : aProcessOperationSpecification.getPrimaryKey();
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param lotID
     * @param routeID
     * @param operationNumber
     * @param operationPassCount
     * @param claimTime
     * @param operationCategory
     * @return com.fa.cim.common.support.RetCode<com.fa.cim.dto.Infos.LotOpeHisRParmGetDROut>
     * @exception
     * @author Ho
     * @date 2019/4/26 10:38
     */
    @Override
    public Infos.LotOpeHisRParmGetDROut lotOpeHisRParmGetDR(Infos.ObjCommon strObjCommonIn, String lotID, String routeID, String operationNumber, Long operationPassCount, String claimTime, String operationCategory) {

        int i, j;

        Long nRCPParmSeqLen = 10L;
        String theRCPParmSeqLen = StandardProperties.OM_OPEHIST_RCPPARM_EXTLEN_FOR_INQ.getValue();
        if ( 0 < CimStringUtils.length(theRCPParmSeqLen) ) {
            nRCPParmSeqLen = CimLongUtils.longValue(theRCPParmSeqLen);
        }

        String hFHOPEHS_RPARMLOT_ID= lotID;
        String hFHOPEHS_RPARMMAINPD_ID= routeID;
        String hFHOPEHS_RPARMOPE_NO= operationNumber;
        String hFHOPEHS_RPARMCLAIM_TIME= claimTime;
        String hFHOPEHS_RPARMOPE_CATEGORY= operationCategory;
        Long hFHOPEHS_RPARMOPE_PASS_COUNT = operationPassCount;

        String sql="select RPARAM_NAME, RPARAM_VAL\n" +
                "        from   OHLOTOPE_RPARAM\n" +
                "        where  LOT_ID      = ?\n" +
                "        and PROCESS_ID      = ?\n" +
                "        and OPE_NO         = ?\n" +
                "        and OPE_PASS_COUNT = ?\n" +
                "        and TRX_TIME     = ?\n" +
                "        and OPE_CATEGORY   = ?";

        List<Object[]> cur1 = cimJpaRepository.query(sql, new Object[]{hFHOPEHS_RPARMLOT_ID
                ,hFHOPEHS_RPARMMAINPD_ID
                ,hFHOPEHS_RPARMOPE_NO
                ,hFHOPEHS_RPARMOPE_PASS_COUNT
                ,Timestamp.valueOf(hFHOPEHS_RPARMCLAIM_TIME)
                ,hFHOPEHS_RPARMOPE_CATEGORY} );


        Long lenSeq = nRCPParmSeqLen;
        Long lenOpeHisRParm = 0L;
        List<Infos.OpeHisRecipeParmInfo> strOpeHisRecipeParmInfo=new ArrayList<>();

        for (Object[] obj:cur1) {
            String hFHOPEHS_RPARMRPARM_NAME="";
            String hFHOPEHS_RPARMRPARM_VALUE="";

            hFHOPEHS_RPARMRPARM_NAME=(String) obj[0];
            hFHOPEHS_RPARMRPARM_VALUE=(String) obj[1];


            if ( lenOpeHisRParm >= lenSeq ) {
                lenSeq = lenSeq + nRCPParmSeqLen;
            }

            Infos.OpeHisRecipeParmInfo opeHisRecipeParmInfo=new Infos.OpeHisRecipeParmInfo();
            strOpeHisRecipeParmInfo.add(opeHisRecipeParmInfo);
            opeHisRecipeParmInfo.setRecipeParameterName  ((String) (hFHOPEHS_RPARMRPARM_NAME));
            opeHisRecipeParmInfo.setRecipeParameterValue ((String) (hFHOPEHS_RPARMRPARM_VALUE));
            lenOpeHisRParm++;
        }

        Inputs.ObjLotWaferIDListGetDRIn  strLot_waferIDList_GetDR_in=new Inputs.ObjLotWaferIDListGetDRIn();
        strLot_waferIDList_GetDR_in.setLotID(ObjectIdentifier.buildWithValue(lotID));
        strLot_waferIDList_GetDR_in.setScrapCheckFlag(false);
        // step1 - lot_waferIDList_GetDR
        List<ObjectIdentifier> waferIDs = this.lotWaferIDListGetDR(strObjCommonIn, strLot_waferIDList_GetDR_in);
        int lenWafer = CimArrayUtils.getSize(waferIDs);

        List<Infos.OpeHisRecipeParmWaferInfo> strOpeHisRecipeParmWaferInfo=new ArrayList<>();

        for ( i=0; i < lenWafer; i++ ) {
            Infos.OpeHisRecipeParmWaferInfo opeHisRecipeParmWaferInfo=new Infos.OpeHisRecipeParmWaferInfo();
            strOpeHisRecipeParmWaferInfo.add(opeHisRecipeParmWaferInfo);
            opeHisRecipeParmWaferInfo.setWaferID ( waferIDs.get(i));

            List<Infos.OpeHisRecipeParmInfo> setStrOpeHisRecipeParmInfo=new ArrayList<>();
            opeHisRecipeParmWaferInfo.setStrOpeHisRecipeParmInfo(setStrOpeHisRecipeParmInfo);

            for ( j=0; j < lenOpeHisRParm; j++ ) {
                Infos.OpeHisRecipeParmInfo opeHisRecipeParmInfo=new Infos.OpeHisRecipeParmInfo();
                setStrOpeHisRecipeParmInfo.add(opeHisRecipeParmInfo);
                opeHisRecipeParmInfo.setRecipeParameterName (strOpeHisRecipeParmInfo.get(j).getRecipeParameterName());
                opeHisRecipeParmInfo.setRecipeParameterValue (strOpeHisRecipeParmInfo.get(j).getRecipeParameterValue());
            }
        }


        String hFHOPEHS_RPARM_WAFERLOT_ID = lotID;
        String hFHOPEHS_RPARM_WAFERMAINPD_ID = routeID;
        String hFHOPEHS_RPARM_WAFEROPE_NO = operationNumber;
        String hFHOPEHS_RPARM_WAFERCLAIM_TIME = claimTime;
        String hFHOPEHS_RPARM_WAFEROPE_CATEGORY = operationCategory;
        Long hFHOPEHS_RPARM_WAFEROPE_PASS_COUNT = operationPassCount;

        sql="select WAFER_ID, RPARAM_NAME, RPARAM_VAL\n" +
                "        from   OHLOTOPE_RPARAM_WAFER\n" +
                "        where  LOT_ID         = ?\n" +
                "        and PROCESS_ID      = ?\n" +
                "        and OPE_NO         = ?\n" +
                "        and OPE_PASS_COUNT = ?\n" +
                "        and TRX_TIME     = ?\n" +
                "        and OPE_CATEGORY   = ?";
        List<Object[]> cur2=cimJpaRepository.query(sql,hFHOPEHS_RPARM_WAFERLOT_ID
                ,hFHOPEHS_RPARM_WAFERMAINPD_ID
                ,hFHOPEHS_RPARM_WAFEROPE_NO
                ,hFHOPEHS_RPARM_WAFEROPE_PASS_COUNT
                , CimDateUtils.convertTo(hFHOPEHS_RPARM_WAFERCLAIM_TIME)
                ,hFHOPEHS_RPARM_WAFEROPE_CATEGORY );


        for (Object[] obj:cur2) {
            String hFHOPEHS_RPARM_WAFERWAFER_ID;
            String hFHOPEHS_RPARM_WAFERRPARM_NAME;
            String hFHOPEHS_RPARM_WAFERRPARM_VALUE;

            hFHOPEHS_RPARM_WAFERWAFER_ID = (String) obj[0];
            hFHOPEHS_RPARM_WAFERRPARM_NAME = (String) obj[1];
            hFHOPEHS_RPARM_WAFERRPARM_VALUE = (String) obj[2];


            Boolean bBreak = false;
            for ( i=0; i < lenWafer; i++ ) {
                if ( CimStringUtils.equals(strOpeHisRecipeParmWaferInfo.get(i).getWaferID().getValue(), hFHOPEHS_RPARM_WAFERWAFER_ID) ) {
                    for ( j=0; j < lenOpeHisRParm; j++ ) {
                        if ( CimStringUtils.equals(strOpeHisRecipeParmWaferInfo.get(i).getStrOpeHisRecipeParmInfo().get(j).getRecipeParameterName(),
                                hFHOPEHS_RPARM_WAFERRPARM_NAME) ) {
                            strOpeHisRecipeParmWaferInfo.get(i).getStrOpeHisRecipeParmInfo().get(j).setRecipeParameterValue(hFHOPEHS_RPARM_WAFERRPARM_VALUE);
                            bBreak = true;
                            break;
                        }
                    }
                }
                if ( bBreak ) {
                    break;
                }
            }
        }


        for (i=0; i< CimArrayUtils.getSize(strOpeHisRecipeParmInfo); i++) {
        }

        for (i=0; i< CimArrayUtils.getSize(strOpeHisRecipeParmWaferInfo); i++) {
            for (j=0; j< CimArrayUtils.getSize(strOpeHisRecipeParmWaferInfo.get(i).getStrOpeHisRecipeParmInfo()); j++) {
            }
        }

        Infos.LotOpeHisRParmGetDROut strLot_opeHisRParm_GetDR_out=new Infos.LotOpeHisRParmGetDROut();

        strLot_opeHisRParm_GetDR_out.setStrOpeHisRecipeParmInfo ( strOpeHisRecipeParmInfo);
        strLot_opeHisRParm_GetDR_out.setStrOpeHisRecipeParmWaferInfo ( strOpeHisRecipeParmWaferInfo);



        return strLot_opeHisRParm_GetDR_out;
    }


    @Override
    public void lotAliasWaferNameUpdate(Infos.ObjCommon objCommon, ObjectIdentifier lotID, List<Infos.AliasWaferName> aliasWaferNames) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        if (null == lot) {
            throw new ServiceException(retCodeConfig.getNotFoundLot());
        }
        //----------------------------------
        // Check wafer attributes of lot
        //----------------------------------
        List<ProductDTO.WaferInfo> waferInfos = lot.getAllWaferInfo();
        if (CimArrayUtils.isEmpty(waferInfos)) {
            throw new ServiceException(retCodeConfig.getProductCountZero());
        }
        //----------------------------------------------------
        // Check AliasWaferName attributes of in-parameter.
        //----------------------------------------------------
        boolean foundFlag = false;
        for (Infos.AliasWaferName aliasWaferName : aliasWaferNames) {
            String waferAlias = aliasWaferName.getAliasWaferName();
            if (CimStringUtils.isNotEmpty(waferAlias)){
                CimWaferDO tmpWafer = new CimWaferDO();
                tmpWafer.setAliasWaferName(waferAlias);
                List<CimWaferDO> all = cimJpaRepository.findAll(Example.of(tmpWafer));
                Validations.check(!CimArrayUtils.isEmpty(all),new OmCode(retCodeConfigEx.getRepeatAliasName(), waferAlias));
            }else {
                continue;
            }
            ObjectIdentifier waferID = aliasWaferName.getWaferID();
            //------------------------------------------
            // Set aliasWaferName to each aWafer's
            //------------------------------------------
            CimWafer wafer = baseCoreFactory.getBO(CimWafer.class, waferID);
            wafer.setAliasWaferName(waferAlias);
        }
    }

    @Override
    public String lotNonProBankOut(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));

        com.fa.cim.newcore.bo.factory.CimBank aBank = lot.getBank();
        if (CimObjectUtils.isEmpty(aBank)) {
            throw new ServiceException(retCodeConfig.getNotFoundBank());
        }

        lot.setBank(null);
        lot.setPreviousBank(aBank);
        lot.makeOnFloor();
        Timestamp reportTimeStamp = objCommon.getTimeStamp().getReportTimeStamp();
        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, new OmCode(retCodeConfig.getNotFoundPerson(), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));
        lot.setLastClaimedPerson(person);
        lot.setLastClaimedTimeStamp(reportTimeStamp);
        lot.setStateChangedPerson(person);
        lot.setStateChangedTimeStamp(reportTimeStamp);

        return aBank.getIdentifier();
    }

    @Override
    public Outputs.ObjLotOriginalRouteListGetOut lotOriginalRouteListGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Outputs.ObjLotOriginalRouteListGetOut objLotOriginalRouteListGetOut = new Outputs.ObjLotOriginalRouteListGetOut();
        /*---------------------------*/
        /* Get Process Flow Context  */
        /*---------------------------*/
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = aLot.getProcessFlowContext();
        Validations.check(aPFX == null, new OmCode(retCodeConfig.getNotFoundPfx(), ""));
        /*--------------------------------------*/
        /*   Check Lot is on Main or Sub Route  */
        /*   if return no is 0, MainRoute       */
        /*   if return no >0, SubRoute          */
        /*--------------------------------------*/
        List<ProcessDTO.ReturnOperation> aReturnOperationSequence = aPFX.allReturnOperations();
        int aReturnOperationSequenceLen = CimArrayUtils.getSize(aReturnOperationSequence);
        /* -------------------------------------- */
        /* On SubRoute.                           */
        /* ( aReturnOperationSequenceLen > 0 )    */
        /* -------------------------------------- */
        if(aReturnOperationSequenceLen > 0){
            /* -------------------------------------- */
            /* Get original route sequece data        */
            /* -------------------------------------- */
            List<ObjectIdentifier> originalRouteIDs = new ArrayList<>();
            List<String> returnOperationNumbers = new ArrayList<>();
            objLotOriginalRouteListGetOut.setOriginalRouteID(originalRouteIDs);
            objLotOriginalRouteListGetOut.setReturnOperationNumber(returnOperationNumbers);
            for (int i = 0; i < aReturnOperationSequenceLen; i++) {
                /*------------------------------------------*/
                /*   Get Process Flow of original Route ID  */
                /*------------------------------------------*/
                ProcessDTO.ReturnOperation strPosReturnOperation = aPFX.getReturnOperationFor(i);
                /*---------------------------------------*/
                /*   Get returnOperationNumber           */
                /*---------------------------------------*/
                returnOperationNumbers.add(strPosReturnOperation.getOperationNumber());
                /*---------------------------------------*/
                /*   Get Original Process Definition ID  */
                /*---------------------------------------*/
                com.fa.cim.newcore.bo.pd.CimProcessFlow aPF = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessFlow.class, strPosReturnOperation.getProcessFlow());
                Validations.check(aPF == null, new OmCode(retCodeConfig.getNotFoundProcessFlow(), lotID.getValue()));
                com.fa.cim.newcore.bo.pd.CimProcessDefinition originalRoutePD = aPF.getRootProcessDefinition();
                Validations.check(originalRoutePD == null, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), ""));
                originalRouteIDs.add(new ObjectIdentifier(originalRoutePD.getIdentifier(), originalRoutePD.getPrimaryKey()));
            }
        }
        /* -------------------------------------- */
        /* On MainRoute.                          */
        /* -------------------------------------- */
        else {
            objLotOriginalRouteListGetOut.setOriginalRouteID(new ArrayList<>());
            objLotOriginalRouteListGetOut.setReturnOperationNumber(new ArrayList<>());
        }
        return objLotOriginalRouteListGetOut;
    }

    /*@Override
    public ObjectIdentifier lotIDAssign(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID) {
        //---------------------------------
        //   Get lotfamily SuffixNumber
        //---------------------------------
        String suffixNumber = this.lotFamilySplitNoCreate(objCommon, parentLotID);

        //----------------------
        //   Generate LotID
        //----------------------
        Validations.check(null == suffixNumber, retCodeConfig.getLotIDAssignFail());
        String lotID = ObjectUtils.getObjectValue(parentLotID);
//        String out = String.format("%s.%s", lotID.lastIndexOf(".") > 0 ? lotID.substring(0, lotID.lastIndexOf(".")) :lotID , suffixNumber);

        // bug-6380 Lot Split SuffixNumber Enhancement:Split from a vendor lot with suffix ".0001",Child lot ‘s suffix is incorrect
        String splitNo=suffixNumber;
        String newLotID=null;
        String oldLotID=lotID;
        if((StringUtils.isEmpty(lotID)) || (2!=StringUtils.length(suffixNumber))) {
            log.debug("{}"," #### splitNo length == 0 || oldLotID == NULL ");
        } else {
            log.debug("{}{}{}"," #### oldLotID : splitNo ", oldLotID, splitNo);
            int len = StringUtils.length(lotID);
            String[] buf = splitNo.split("");
            String[] tmpLotID=null;

            int i=len-1;
            for (; i>=0; i--) {
                if (lotID.charAt(i) == '.') {
                    break;
                }
            }
            if ( i != -1 ) {
                int ii = i ;
                tmpLotID=Arrays.copyOf(lotID.split(""),len+3);
                if(tmpLotID.length!=0) {
                    tmpLotID[ii+1] = buf[0] ;
                    tmpLotID[ii+2] = buf[1] ;
                    newLotID = StringUtils.join(tmpLotID,"");
                }
            } else {
                tmpLotID = new String[len+3];
                if( tmpLotID != null ) {
                    tmpLotID=Arrays.copyOf(oldLotID.split(""),len+3);
                    tmpLotID[len]     = ".";
                    tmpLotID[len + 1] = buf[0] ;
                    tmpLotID[len + 2] = buf[1] ;
                    newLotID = StringUtils.join(tmpLotID,"");
                }
            }
        }
        return new ObjectIdentifier(newLotID);
    }*/

    @Override
    public ObjectIdentifier lotIDAssign(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, parentLotID);
        String lotType = aLot.getLotType();
        if (StandardProperties.OM_LOTIDASSIGEN_SWITCH.isOff()
                || CimStringUtils.equals(lotType, BizConstant.SP_LOT_TYPE_DUMMYLOT)
                || CimStringUtils.equals(lotType, BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)
                || CimStringUtils.equals(lotType, BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                || CimStringUtils.equals(lotType, BizConstant.SP_LOT_TYPE_RECYCLELOT)) {
            return lotIDAssignByDef(objCommon, parentLotID);
        } else {
            return lotIDAssignbyEnv(objCommon, parentLotID);
        }
    }

    @Override
    public String lotFamilySplitNoCreate(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        //---------------------------------
        //   Get lotfamily SuffixNumber
        //---------------------------------
        CimLot lot = baseCoreFactory.getBO(CimLot.class,lotID);
        CimLotFamily lotFamily = lot.getLotFamily();
        Validations.check(null == lotFamily, retCodeConfig.getNotFoundLotFamily());

        Integer suffix = 0;
        suffix = lotFamily.newSplitNumber();
        /**********************************************************/
        /*   Keep table.                                          */
        /*   If you want to change SplitSuffix generating rule,   */
        /*   You have to change following definition.             */
        /*                                                        */
        /****** precondition                                      */
        /*  1.Prohibit character is surely alphabet(not number)   */
        /*  2.firstFigure is " 0 to 9 + A to Z"                   */
        /*  3.secondFigure doesn't have alphabet surely.          */
        /**********************************************************/
        Integer figureGrade = 10;
        Integer incrementalGrade = 10;
        String firstFigureTable = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String secondFigureTable = "0123456789";
        //----------------------------------
        //   Prohibit character check
        //----------------------------------
        String prohibitChar = StandardProperties.OM_SPLIT_LOT_SUFFIX_PROHIBIT_CHAR.getValue();
        for (int i = 0; i < prohibitChar.length(); i++) {
            Integer currentFigure = suffix/figureGrade;
            if (currentFigure < firstFigureTable.length()) {
                if (firstFigureTable.charAt(currentFigure) == prohibitChar.charAt(i)) {
                    suffix = ((suffix + incrementalGrade) / figureGrade) * figureGrade;
                    break;
                }
            }
        }
        //--------------------------
        //   The first figure.
        //--------------------------
        Integer firstFigure = suffix / figureGrade;
        Validations.check(firstFigure >= firstFigureTable.length(), retCodeConfig.getReservedMaxSplitCount());

        //--------------------------
        //   The second figure.
        //--------------------------
        Integer secondFigure = suffix % figureGrade;
        Validations.check(secondFigure >= secondFigureTable.length(), retCodeConfig.getReservedMaxSplitCount());

        char tmp = firstFigureTable.charAt(firstFigure);
        //---------------------------
        //   Generate SplitNumber
        //---------------------------
        //--------------------------------------------
        //   Set latest split Number to lotfamily
        //--------------------------------------------
        String str;
        str = String.format("%c%c", tmp, secondFigureTable.charAt(secondFigure));
        lotFamily.setLastSplitNumber(suffix);
        return str;
    }


    @Override
    public Outputs.LotSubLotTypeGetDetailInfoDR lotSubLotTypeGetDetailInfoDR(Infos.ObjCommon objCommon,String subLotType) {

        //Initialize;
        log.info("", "#### Inpara subLotType = ", subLotType);

        // Get SubLotType detail information from FRLOTTYPE_SUBTYPE    */
        String querySql = String.format(
                        "SELECT     a.LOT_TYPE, " +
                        "           a.DESCRIPTION, " +
                        "           b.SUB_LOT_TYPE, " +
                                "   b.DESCRIPTION as DESCRIPTION2, " +
                                "   b.PREFIX_VAL, " +
                                "   b.DURATION " +
                        "FROM   OMLOTTYPE a, OMLOTTYPE_SUBTYPE b " +
                                "WHERE b.LINK_KEY  = '%s' and a.ID = b.REFKEY", subLotType);
        List<Object[]> results = cimJpaRepository.query(querySql);
        Outputs.LotSubLotTypeGetDetailInfoDR info = new Outputs.LotSubLotTypeGetDetailInfoDR();
        if (CimArrayUtils.getSize(results) > 0) {
            Object[] objects = results.get(0);
            info.setLotType((String) objects[0]);
            info.setLotTypeDescription((String)objects[1]);
            info.setSubLotType((String)objects[2]);
            info.setDescription((String)objects[3]);
            info.setDuration(CimNumberUtils.intValue((Number) objects[5]));
        }
        Outputs.LotSubLotTypeGetDetailInfoDR outPuts = info;
        Validations.check(null == outPuts, retCodeConfig.getNotFoundSubLotType());

        log.info("", "#### lotType             = ", outPuts.getLotType());
        log.info("", "#### lotTypeDescription  = ", outPuts.getLotTypeDescription());
        log.info("", "#### subLotType          = ", outPuts.getSubLotType());
        log.info("", "#### description      = ", outPuts.getDescription());
        log.info("", "#### leadingCharacter = ", outPuts.getLeadingCharacter());
        log.info("", "#### duration         = ", outPuts.getDuration());

        return outPuts;
    }

    @Override
    public Outputs.ObjLotAllStateGetOut lotAllStateGet(Infos.ObjCommon objCommonm, ObjectIdentifier lotID) {
        Outputs.ObjLotAllStateGetOut objLotAllStateGetOut = new Outputs.ObjLotAllStateGetOut();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lot),retCodeConfig.getNotFoundLot());

        objLotAllStateGetOut.setLotState(lot.getLotState());
        objLotAllStateGetOut.setProductionState(lot.getLotProductionState());
        objLotAllStateGetOut.setHoldState(lot.getLotHoldState());
        objLotAllStateGetOut.setFinishedState(lot.getLotFinishedState());
        objLotAllStateGetOut.setProcessState(lot.getLotProcessState());
        objLotAllStateGetOut.setInventoryState(lot.getLotInventoryState());
        return objLotAllStateGetOut;
    }

    @Override
    public ObjectIdentifier lotSplitWaferLotNotOnRoute(Infos.ObjCommon objCommon, Params.SplitLotNotOnPfReqParams splitLotNotOnPfReqParams) {

        CimLot aParentLot = baseCoreFactory.getBO(CimLot.class, splitLotNotOnPfReqParams.getParentLotID());
        Integer parentLotTotalQuantity = aParentLot.getQuantity();
        log.info("aParentLot->getQuantity,{}",parentLotTotalQuantity);

        Integer parentLotProductQuantity = aParentLot.getProductQuantity();
        log.info("aParentLot->getProductQuantity,{}",parentLotProductQuantity);

        Integer parentLotControlQuantity = aParentLot.getControlQuantity();
        log.info("aParentLot->getControlQuantity,{}",parentLotControlQuantity);

        String tmpControlUseState = aParentLot.getControlUseState();
        Integer tmpUsageCount = aParentLot.getUsedCount();
        log.info("aParentLot->getUsageCount,{}",tmpUsageCount);
        log.info("aParentLot->tmpControlUseState,{}",tmpControlUseState);

        Integer paramParentLotWaferCount = splitLotNotOnPfReqParams.getParentLotWaferCount();
        Integer paramChildLotWaferCount = splitLotNotOnPfReqParams.getChildLotWaferCount();
        Validations.check(null == paramParentLotWaferCount || null == paramChildLotWaferCount, retCodeConfig.getInvalidParameter());

        Integer inputQuantoty = paramParentLotWaferCount + paramChildLotWaferCount;
        Validations.check(parentLotTotalQuantity.intValue() != inputQuantoty.intValue(), retCodeConfig.getInvalidDataContents());

        Validations.check(parentLotTotalQuantity.intValue() == splitLotNotOnPfReqParams.getChildLotWaferCount().intValue(), retCodeConfig.getPlotEmptySplit());

        CimLot aChildLot = null;
        Integer cntChildProductWafer = 0;
        Integer cntChildControlWafer = 0;
        Boolean controlWaferFlag = false;
        parentLotProductQuantity = null == parentLotProductQuantity ? 0 : parentLotControlQuantity;
        if (CimArrayUtils.isEmpty(splitLotNotOnPfReqParams.getChildWaferIDs())) {
            //------------------------------------------------------------------------------------------------
            // Check childLotWaferCount if childWaferID is not filled.
            //  childLotWaferCount <= Parent lot's ( Total wafer Qty - Qty of Wafers assigned as PosWafer )
            //------------------------------------------------------------------------------------------------
            log.info("Check childLotWaferCount if childWaferID is not filled");
            Integer notAssinedQuantoty = parentLotTotalQuantity - parentLotProductQuantity;
            Validations.check(splitLotNotOnPfReqParams.getChildLotWaferCount() > notAssinedQuantoty, retCodeConfig.getInvalidDataContents());

            //---------------------------------------------------------------------
            // Create new lot(chaild lot)
            // createSplitLotsFrom is overridden in PosProductManager
            //---------------------------------------------------------------------
            log.info("Create new lot(Child lot).");
            // Assign lot ID for child
            ObjectIdentifier assignOut = this.lotIDAssign(objCommon, splitLotNotOnPfReqParams.getParentLotID());

            List<ProductDTO.LotSpliteData> productToSplit = new ArrayList<>();
            ProductDTO.LotSpliteData splitData = new ProductDTO.LotSpliteData();
            splitData.setNewLotID(assignOut.getValue());
            productToSplit.add(splitData);
            List<CimLot> aLotSequence;
            aLotSequence = productManager.createSplitLotsFrom(aParentLot, productToSplit);
            //---------------------------------------------------------------------
            // retrieve child lot from returnvalue of PosProductManager
            //---------------------------------------------------------------------
            log.info("retrieve child lot from returnvalue of PosProductManager");
            Validations.check(CimObjectUtils.isEmpty(aLotSequence.get(0)), retCodeConfig.getNotFoundLot());

            aChildLot = aLotSequence.get(0);

        } else if (!CimArrayUtils.isEmpty(splitLotNotOnPfReqParams.getChildWaferIDs())) {
            //----------------------------------------------------
            // Check wafer attributes and then
            // Set wafer to productSequence for productToSplit.
            // In parameter lot is only one.
            //----------------------------------------------------
            log.info("Check Wafer attributes and then Set wafer to productSequence for productToSplit");

            log.info("Get all wafer information of parent lot before split.");
            List<ProductDTO.WaferInfo> parentLotWaferInfo = aParentLot.getAllWaferInfo();
            Validations.check(CimArrayUtils.isEmpty(parentLotWaferInfo), retCodeConfig.getProductCountZero());

            // Check childWaferID of in-parameter in wafer Attributes.
            log.info("Check childWaferID of in-parameter in Wafer Attributes");
            Boolean foundFlag;
            Boolean STBAlllocFlag;
            String cassetteID = null;
            String tmpCassetteID = null;
            List<ProductDTO.LotSpliteData> productToSplit = new ArrayList<>();
            List<CimWafer> wafers = new ArrayList<>();
            List<ProductDTO.WaferInfo> waferInfoList = new ArrayList<>();
            for (int i = 0; i < CimArrayUtils.getSize(splitLotNotOnPfReqParams.getChildWaferIDs()); i++) {
                CimWafer aWafer = baseCoreFactory.getBO(CimWafer.class, splitLotNotOnPfReqParams.getChildWaferIDs().get(i));
                Validations.check(CimObjectUtils.isEmpty(aWafer),retCodeConfig.getNotFoundWafer());
                controlWaferFlag = aWafer.isControlWafer();
                if (CimBooleanUtils.isTrue(controlWaferFlag)) {
                    log.info("cntChildControlWafer++");
                    cntChildControlWafer++;
                } else {
                    log.info("cntChildProductWafer++");
                    cntChildProductWafer++;
                }
                //--------------------------------------------------------------------------------
                // Check if childWaferID is existed in parentLotWaferInfo.
                // All of childWaferID should be existed.
                //--------------------------------------------------------------------------------
                log.info("Check if childWaferID is existed in parentLotWaferInfo");

                foundFlag = false;
                for (int j = 0; j < CimArrayUtils.getSize(parentLotWaferInfo); j++) {
                    if (ObjectIdentifier.equalsWithValue(splitLotNotOnPfReqParams.getChildWaferIDs().get(i), parentLotWaferInfo.get(j).getWaferID().getValue())) {
                        foundFlag = true;
                        break;
                    }
                }
                Validations.check(!foundFlag, retCodeConfig.getInvalidDataContents());

                //--------------------------------------------------------------------------------
                // Get cassetteID which childWaferID is in by using getMaterialContainer.
                // All of childWaferID should have either the same cassetteID or no cassetteID.
                //--------------------------------------------------------------------------------
                log.info("Get cassetteID which childWaferID is in by using getMaterialContainer");
                MaterialContainer aMaterialContainer = aWafer.getMaterialContainer();
                String tmpMaterialContainer = null;
                if (null != aMaterialContainer) {
                    tmpMaterialContainer = aMaterialContainer.getIdentifier();
                }
                if (0 == i) {
                    log.info("i == 0");
                    if (!CimStringUtils.isEmpty(tmpMaterialContainer)) {
                        log.info("0 != CIMFWStrLen(tmpMaterialContainer)");
                        tmpCassetteID = tmpMaterialContainer;
                    }
                } else {
                    if (!CimStringUtils.isEmpty(tmpMaterialContainer)) {
                        log.info("0 != CIMFWStrLen(tmpMaterialContainer)");
                        cassetteID = tmpMaterialContainer;
                    }
                    cassetteID = null == cassetteID ? "": cassetteID;
                    Validations.check(!CimStringUtils.equals(cassetteID, tmpCassetteID), retCodeConfig.getInvalidLcData());
                }
                //--------------------------------------------------------------------------------
                // All of childWaferID should not be reserved for STB by scheduler.
                //--------------------------------------------------------------------------------
                log.info("All of childWaferID should not be reserved for STB by scheduler");
                Boolean STBAllocFlag;
                STBAllocFlag = aWafer.isSTBAllocated();
                if (CimBooleanUtils.isTrue(STBAllocFlag)){
                    log.info("STBAllocFlag == TRUE");
                    throw new ServiceException(retCodeConfig.getWaferAllocated());
                }
                ProductDTO.WaferInfo waferInfo = aWafer.getWaferInfo();
                waferInfoList.add(waferInfo);
                wafers.add(aWafer);
            }
            ProductDTO.LotSpliteData splitData = new ProductDTO.LotSpliteData();
            splitData.setSplitProducts(waferInfoList);

            //------------------------------------------------------
            // Get Carrier object reference of Parent lot
            //------------------------------------------------------
            List<MaterialContainer> aCassetteSequence = new ArrayList<>();
            Boolean bInCast = true;
            aCassetteSequence = aParentLot.materialContainers();
            if (CimArrayUtils.getSize(aCassetteSequence) == 0){
                log.info("aCassetteSequence->length() == 0");
                bInCast = false;
            }
            com.fa.cim.newcore.bo.durable.CimCassette aCassette = null;
            if (CimBooleanUtils.isTrue(bInCast)){
                aCassette = (com.fa.cim.newcore.bo.durable.CimCassette)(aCassetteSequence.get(0));
                Validations.check(CimObjectUtils.isEmpty(aCassette),retCodeConfig.getNotFoundCassette());

                //------------------------------------------------------
                // Remove Lots from cassette
                //------------------------------------------------------
                for (int i = 0; i < parentLotWaferInfo.size(); i++) {
                    Wafer tmpWafer = aCassette.removeWaferFromPosition(parentLotWaferInfo.get(i).getPosition());
                    Validations.check(CimObjectUtils.isEmpty(tmpWafer),retCodeConfig.getInvalidCassettePosition());
                }
            }else {
                log.info("The Lot is not in a cassette. Skip Cassette::removeWafer_fromPosition()");
            }
            // Assign lot ID for child
            ObjectIdentifier assignOut = this.lotIDAssign(objCommon, splitLotNotOnPfReqParams.getParentLotID());

            splitData.setNewLotID(assignOut.getValue());
            productToSplit.add(splitData);
            //---------------------------------------------------------------------
            // Create new lot(chaild lot)
            // createSplitLotsFrom is overridden in PosProductManager
            //---------------------------------------------------------------------
            log.info("Create new lot(chaild lot).");

            List<CimLot> aLotSequence;
            aLotSequence = productManager.createSplitLotsFrom(aParentLot,productToSplit);
            //---------------------------------------------------------------------
            // retrieve child lot from returnvalue of PosProductManager
            //---------------------------------------------------------------------
            log.info("retrieve child lot from returnvalue of PosProductManager");

            aChildLot = aLotSequence.get(0);
            Validations.check(CimObjectUtils.isEmpty(aChildLot), retCodeConfig.getNotFoundLot());

            //------------------------------------------------------
            // Add Lots to cassette
            //------------------------------------------------------
            if (bInCast) {
                for (int i = 0; i < CimArrayUtils.getSize(parentLotWaferInfo); i++) {
                    // Get obj ref and change state of wafer
                    CimWafer wafer = baseCoreFactory.getBO(CimWafer.class, parentLotWaferInfo.get(i).getWaferID());
                    aCassette.addWaferAtPosition(wafer,parentLotWaferInfo.get(i).getPosition());
                }
            }else {
                log.info("The Lot is not in a cassette. Skip Cassette::addWafer_atPosition()");
            }
        }
        //--------------------------------------------------------------------------------------
        // change total wafer quantity of both parent lot and child lot.
        //  ParentLot.theQuantity   <= parentLotWaferCount of in-parameter.
        //  ChildLot.theQuantity    <= childLotWaferCount of in-parameter.
        //--------------------------------------------------------------------------------------
        log.info("Set Parent lot's wafer quantity.");

        aParentLot.setVendorLotQuantity(splitLotNotOnPfReqParams.getParentLotWaferCount());
        if (!CimArrayUtils.isEmpty(splitLotNotOnPfReqParams.getChildWaferIDs())) {
            log.info("setVendorLotQuantity(lenChildWaferID)");
            aChildLot.setVendorLotQuantity(CimArrayUtils.getSize(splitLotNotOnPfReqParams.getChildWaferIDs()));

        } else {
            log.info("setVendorLotQuantity(childLotWaferCount)");
            aChildLot.setVendorLotQuantity(splitLotNotOnPfReqParams.getChildLotWaferCount());

        }
        //----------------------------------------------------------------------------------------------------
        // Set reticle set ID
        //----------------------------------------------------------------------------------------------------
        com.fa.cim.newcore.bo.durable.CimReticleSet aReticleSet = null;
        aReticleSet = aParentLot.getReticleSet();
        if (!CimObjectUtils.isEmpty(aReticleSet)) {
            log.info("Set reticle set ID into Child Lot.");
            aChildLot.setReticleSet(aReticleSet);
        }else {
            log.info("Parent lot has no reticle set ID.");
        }
        //----------------------------------------------------------------------------------------------------
        // change the number of wafer which has waferID in itself.
        //  ParentLot.theProductQuantity <= parentLotProductQuantity - the # of childWaferID of in-parameter.
        //  ChildLot.theProductQuantity  <= the # of childWaferID of in-parameter.
        //----------------------------------------------------------------------------------------------------
        log.info("change the number of wafer which has waferID in itself");
        if (!CimArrayUtils.isEmpty(splitLotNotOnPfReqParams.getChildWaferIDs())) {
            log.info("lenChildWaferID > 0");
            log.info("aParentLot->setProductQuantity--->{}",parentLotProductQuantity - cntChildProductWafer);
            aParentLot.setProductQuantity(parentLotProductQuantity - cntChildProductWafer);
            log.info("aParentLot->setControlQuantity--->{}",parentLotControlQuantity - cntChildControlWafer);
            aParentLot.setControlQuantity(parentLotControlQuantity - cntChildControlWafer);
        }
        log.info("aChildLot->setProductQuantity--->{}",cntChildProductWafer);
        aChildLot.setProductQuantity(cntChildProductWafer);
        log.info("aChildLot->setControlQuantity--->{}",cntChildControlWafer);
        aChildLot.setControlQuantity(cntChildControlWafer);

        // Set claim information for parent lot.
        log.info("Set claim information for parent lot.");
        aParentLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(CimObjectUtils.isEmpty(aPerson),retCodeConfig.getNotFoundPerson());
        aParentLot.setLastClaimedPerson(aPerson);

        // Set claim information for child lot.
        log.info("Set claim information for child lot.");
        aChildLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aChildLot.setLastClaimedPerson(aPerson);
        aChildLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aChildLot.setStateChangedPerson(aPerson);
        aChildLot.setInventoryStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        aChildLot.setInventoryStateChangedPerson(aPerson);
        aChildLot.setLastClaimAllWafers(objCommon.getTimeStamp().getReportTimeStamp(), aPerson);

        ObjectIdentifier tmpChildLotID = ObjectIdentifier.build(aChildLot.getIdentifier(), aChildLot.getPrimaryKey());

        //-------------------------------------------------------
        //  Set parent lot Auto dispatch Control to Child lot
        //-------------------------------------------------------
        List<ProductDTO.AutoDispatchControlRecord> autoDispatchControlRecords = aParentLot.allAutoDispatchControlRecords();
        aChildLot.setAutoDispatchControlRecords(autoDispatchControlRecords);
        //===================================================================================
        // Make event for Auto Dispatch Control Information Update.
        //===================================================================================
        // autoDispatchControlEvent_Make
        log.info("## Make event for Auto Dispatch Control Information registration. ");
        Infos.ObjCommon tmpObjCommonIn = new Infos.ObjCommon();
        BeanUtils.copyProperties(objCommon, tmpObjCommonIn);
        tmpObjCommonIn.setTransactionID(TransactionIDEnum.AUTO_DISPATCH_CONTROL_UPDATE_REQ.getValue());
        for (ProductDTO.AutoDispatchControlRecord autoDispatchControlRecord : autoDispatchControlRecords){
            Inputs.AutoDispatchControlEventMakeIn autoDispatchControlEventMakeIn = new Inputs.AutoDispatchControlEventMakeIn();
            autoDispatchControlEventMakeIn.setLotID(tmpChildLotID);
            Infos.AutoDispatchControlUpdateInfo autoDispatchControlUpdateInfo = new Infos.AutoDispatchControlUpdateInfo();
            autoDispatchControlEventMakeIn.setAutoDispatchControlUpdateInfo(autoDispatchControlUpdateInfo);
            autoDispatchControlUpdateInfo.setUpdateMode(BizConstant.SP_AUTODISPATCHCONTROL_CREATE);
            autoDispatchControlUpdateInfo.setRouteID(autoDispatchControlRecord.getRouteID());
            autoDispatchControlUpdateInfo.setOperationNumber(autoDispatchControlRecord.getOperationNumber());
            autoDispatchControlUpdateInfo.setSingleTriggerFlag(autoDispatchControlRecord.isSingleTriggerFlag());
            autoDispatchControlUpdateInfo.setDescription(autoDispatchControlRecord.getDescription());
            eventMethod.autoDispatchControlEventMake(tmpObjCommonIn, autoDispatchControlEventMakeIn);
        }
        String eqpMonitorSwitch = StandardProperties.OM_AUTOMON_FLAG.getValue();
        if (CimStringUtils.equals(eqpMonitorSwitch, "1")){
            log.info("1 == OM_AUTOMON_FLAG");
            String tmpLotType = aParentLot.getLotType();
            if(CimStringUtils.equals(tmpLotType, BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                    || CimStringUtils.equals(tmpLotType, BizConstant.SP_LOT_TYPE_DUMMYLOT)){
                log.info("tmpLotType is Auto Monitor or Dummy");
                //Acquire EqpMonitor Job Info of Lot
                ProductDTO.EqpMonitorJobLotInfo aEqpMonitorJobLotInfo = aParentLot.getEqpMonitorJobLotInfo();

                if (null != aEqpMonitorJobLotInfo && !ObjectIdentifier.isEmpty(aEqpMonitorJobLotInfo.getEqpMonitorJobID())) {
                    //Lock EqpMonitor job object
                    objectLockMethod.objectLockForEqpMonitorJob(objCommon, aEqpMonitorJobLotInfo.getEqpMonitorID(), aEqpMonitorJobLotInfo.getEqpMonitorJobID());

                    //Add the record of Child Lot to FREQPMONJOB_LOT. (copy parent lot's record)
                    MachineDTO.EqpMonitorLotInfo aEqpMonitorLotInfo = new MachineDTO.EqpMonitorLotInfo();
                    aEqpMonitorLotInfo.setLotID(tmpChildLotID);
                    aEqpMonitorLotInfo.setMonitorLotStatus(aEqpMonitorJobLotInfo.getMonitorLotStatus());
                    aEqpMonitorLotInfo.setStartSeqNo(CimObjectUtils.isEmpty(aEqpMonitorJobLotInfo.getStartSeqNo()) ? 0 : aEqpMonitorJobLotInfo.getStartSeqNo().intValue());
                    aEqpMonitorLotInfo.setMonitorOpeKey(aEqpMonitorJobLotInfo.getMonitorOpeKey());
                    aEqpMonitorLotInfo.setExitFlag(aEqpMonitorJobLotInfo.getExitFlag());
                    aEqpMonitorLotInfo.setResult(CimObjectUtils.isEmpty(aEqpMonitorJobLotInfo.getResult()) ? 0 : aEqpMonitorJobLotInfo.getResult().intValue());
                    CimEqpMonitorJob anEqpMonitorJob = baseCoreFactory.getBO(CimEqpMonitorJob.class, aEqpMonitorJobLotInfo.getEqpMonitorJobID());
                    anEqpMonitorJob.addEqpMonitorLot(aEqpMonitorLotInfo);

                    //Create EqpMonitor Job History Event
                    Inputs.EqpMonitorJobChangeEventMakeParams strEqpMonitorJobChangeEventMakeIn = new Inputs.EqpMonitorJobChangeEventMakeParams();
                    strEqpMonitorJobChangeEventMakeIn.setOpeCategory(BizConstant.SP_EQPMONITORJOB_OPECATEGORY_EQPMONSTART);
                    strEqpMonitorJobChangeEventMakeIn.setEqpMonitorID(aEqpMonitorJobLotInfo.getEqpMonitorID());
                    strEqpMonitorJobChangeEventMakeIn.setEqpMonitorJobID(aEqpMonitorJobLotInfo.getEqpMonitorJobID());
                    Infos.EqpMonitorLotInfo eqpMonitorLotInfo = new Infos.EqpMonitorLotInfo();
                    eqpMonitorLotInfo.setLotID(tmpChildLotID);
                    eqpMonitorLotInfo.setStartSeqNo(aEqpMonitorJobLotInfo.getStartSeqNo().intValue());
                    List<Infos.EqpMonitorLotInfo> eqpMonitorLotInfos = new ArrayList<>();
                    eqpMonitorLotInfos.add(eqpMonitorLotInfo);
                    strEqpMonitorJobChangeEventMakeIn.setEqpMonitorLotInfoList(eqpMonitorLotInfos);
                    eventMethod.eqpMonitorJobChangeEventMake(objCommon, strEqpMonitorJobChangeEventMakeIn);
                }
            }
        }
        //lot_controlUseInfo_Change
        Outputs.ObjLotControlUseInfoChangeOut lotControlUseInfoChange = lotControlUseInfoChange(objCommon, tmpChildLotID, tmpControlUseState, tmpUsageCount);
        // qTimeChangeEvent_Make__180
        List<com.fa.cim.newcore.bo.pd.CimQTimeRestriction> aChildQTimeSeq = aChildLot.allQTimeRestrictions();
        for (com.fa.cim.newcore.bo.pd.CimQTimeRestriction aChildQTime : aChildQTimeSeq) {
            log.info("loop through child lot QTimeSeq");
            /*----------------------------*/
            /*   Get Q-Time information   */
            /*----------------------------*/
            ProcessDTO.QTimeRestrictionInfo aChildQTimeInfo = aChildQTime.getQTimeRestrictionInfo();
            Infos.QtimeInfo qtimeInfo = new Infos.QtimeInfo();
            qtimeInfo.setQTimeType(aChildQTimeInfo.getQTimeType());
            qtimeInfo.setWaferID(aChildQTimeInfo.getWaferID());
            qtimeInfo.setPreTrigger(aChildQTimeInfo.getPreTrigger());
            qtimeInfo.setOriginalQTime(aChildQTimeInfo.getOriginalQTime());
            qtimeInfo.setProcessDefinitionLevel(aChildQTimeInfo.getProcessDefinitionLevel());
            qtimeInfo.setRestrictionTriggerRouteID(aChildQTimeInfo.getTriggerMainProcessDefinition());
            qtimeInfo.setRestrictionTriggerOperationNumber(aChildQTimeInfo.getTriggerOperationNumber());
            qtimeInfo.setRestrictionTriggerBranchInfo(aChildQTimeInfo.getTriggerBranchInfo());
            qtimeInfo.setRestrictionTriggerReturnInfo(aChildQTimeInfo.getTriggerReturnInfo());
            qtimeInfo.setRestrictionTriggerTimeStamp(aChildQTimeInfo.getTriggerTimeStamp());
            qtimeInfo.setRestrictionTargetRouteID(aChildQTimeInfo.getTargetMainProcessDefinition());
            qtimeInfo.setRestrictionTargetOperationNumber(aChildQTimeInfo.getTargetOperationNumber());
            qtimeInfo.setRestrictionTargetBranchInfo(aChildQTimeInfo.getTargetBranchInfo());
            qtimeInfo.setRestrictionTargetReturnInfo(aChildQTimeInfo.getTargetReturnInfo());
            qtimeInfo.setRestrictionTargetTimeStamp(aChildQTimeInfo.getTargetTimeStamp());
            qtimeInfo.setPreviousTargetInfo(aChildQTimeInfo.getPreviousTargetInfo());
            qtimeInfo.setSpecificControl(aChildQTimeInfo.getControl());
            if (CimBooleanUtils.isTrue(aChildQTimeInfo.getWatchdogRequired())){
                log.info("TRUE == aChildQTimeInfo->watchdogRequired");
                qtimeInfo.setWatchDogRequired("Y");
            } else {
                log.info("FALSE == aChildQTimeInfo->watchdogRequired");
                qtimeInfo.setWatchDogRequired("N");
            }
            if (CimBooleanUtils.isTrue(aChildQTimeInfo.getActionDone())){
                log.info("TRUE == aChildQTimeInfo->actionDone");
                qtimeInfo.setActionDoneFlag("Y");
            } else {
                log.info("FALSE == aChildQTimeInfo->actionDone");
                qtimeInfo.setActionDoneFlag("N");
            }
            qtimeInfo.setManualCreated(aChildQTimeInfo.getManualCreated());
            List<ProcessDTO.QTimeRestrictionAction> qTimeActions = aChildQTimeInfo.getActions();
            int actionLength = CimArrayUtils.getSize(qTimeActions);
            List<Infos.QTimeActionInfo> qTimeActionInfoList = new ArrayList<>();
            qtimeInfo.setStrQtimeActionInfoList(qTimeActionInfoList);
            if (actionLength != 0){
                log.info("actionLength != 0");
                for (ProcessDTO.QTimeRestrictionAction qTimeRestrictionAction : qTimeActions){
                    Infos.QTimeActionInfo qTimeActionInfo = new Infos.QTimeActionInfo();
                    qTimeActionInfoList.add(qTimeActionInfo);
                    qTimeActionInfo.setQrestrictionTargetTimeStamp(qTimeRestrictionAction.getTargetTimeStamp());
                    qTimeActionInfo.setQrestrictionAction(qTimeRestrictionAction.getAction());
                    qTimeActionInfo.setReasonCodeID(qTimeRestrictionAction.getReasonCode());
                    qTimeActionInfo.setActionRouteID(qTimeRestrictionAction.getActionRouteID());
                    qTimeActionInfo.setActionOperationNumber(qTimeRestrictionAction.getOperationNumber());
                    qTimeActionInfo.setFutureHoldTiming(qTimeRestrictionAction.getTiming());
                    qTimeActionInfo.setReworkRouteID(qTimeRestrictionAction.getMainProcessDefinition());
                    qTimeActionInfo.setMessageID(qTimeRestrictionAction.getMessageDefinition());
                    qTimeActionInfo.setCustomField(qTimeRestrictionAction.getCustomField());
                    if (CimBooleanUtils.isTrue(qTimeRestrictionAction.getWatchdogRequired())) {
                        log.info("TRUE == aChildQTimeInfo->actions.watchdogRequired");
                        qTimeActionInfo.setWatchDogRequired("Y");
                    } else {
                        log.info("FALSE == aChildQTimeInfo->actions.watchdogRequired");
                        qTimeActionInfo.setWatchDogRequired("N");
                    }
                    if (CimBooleanUtils.isTrue(qTimeRestrictionAction.getActionDone())) {
                        log.info("TRUE == aChildQTimeInfo->actions.actionDone");
                        qTimeActionInfo.setActionDoneFlag("Y");
                    } else {
                        log.info("FALSE == aChildQTimeInfo->actions.actionDone");
                        qTimeActionInfo.setActionDoneFlag("N");
                    }
                }
            }else {
                log.info("actionLength == 0");
            }
            Inputs.QTimeChangeEventMakeParams params = new Inputs.QTimeChangeEventMakeParams();
            params.setUpdateMode(BizConstant.SP_QRESTTIME_OPECATEGORY_CREATE);
            params.setLotID(tmpChildLotID);
            params.setQtimeInfo(qtimeInfo);
            params.setClaimMemo("");
            eventMethod.qTimeChangeEventMake(objCommon, params);
        }

        for (int i = 0; i < CimArrayUtils.getSize(splitLotNotOnPfReqParams.getChildWaferIDs()); i++) {
            ObjectIdentifier childWafer = splitLotNotOnPfReqParams.getChildWaferIDs().get(i);
            CimWafer aChildWafer = baseCoreFactory.getBO(CimWafer.class, childWafer);
            Validations.check(CimObjectUtils.isEmpty(aChildWafer),retCodeConfig.getNotFoundWafer());
            List<com.fa.cim.newcore.bo.pd.CimQTimeRestriction> aChildWaferQTimeSeq = aChildWafer.allQTimeRestrictions();
            if(!CimObjectUtils.isEmpty(aChildWaferQTimeSeq)){
                for (com.fa.cim.newcore.bo.pd.CimQTimeRestriction aChildWaferQTime : aChildWaferQTimeSeq){
                    /*----------------------------*/
                    /*   Get Q-Time information   */
                    /*----------------------------*/
                    ProcessDTO.QTimeRestrictionInfo aChildWaferQTimeInfo = aChildWaferQTime.getQTimeRestrictionInfo();
                    aChildWaferQTime.setLot(aChildLot);
                    //----------------------------------------------------------------
                    // Make event
                    //----------------------------------------------------------------
                    Infos.QtimeInfo qtimeInfo = new Infos.QtimeInfo();
                    qtimeInfo.setQTimeType(aChildWaferQTimeInfo.getQTimeType());
                    qtimeInfo.setWaferID(aChildWaferQTimeInfo.getWaferID());
                    qtimeInfo.setPreTrigger(aChildWaferQTimeInfo.getPreTrigger());
                    qtimeInfo.setOriginalQTime(aChildWaferQTimeInfo.getOriginalQTime());
                    qtimeInfo.setProcessDefinitionLevel(aChildWaferQTimeInfo.getProcessDefinitionLevel());
                    qtimeInfo.setRestrictionTriggerRouteID(aChildWaferQTimeInfo.getTriggerMainProcessDefinition());
                    qtimeInfo.setRestrictionTriggerOperationNumber(aChildWaferQTimeInfo.getTriggerOperationNumber());
                    qtimeInfo.setRestrictionTriggerBranchInfo(aChildWaferQTimeInfo.getTriggerBranchInfo());
                    qtimeInfo.setRestrictionTriggerReturnInfo(aChildWaferQTimeInfo.getTriggerReturnInfo());
                    qtimeInfo.setRestrictionTriggerTimeStamp(aChildWaferQTimeInfo.getTriggerTimeStamp());
                    qtimeInfo.setRestrictionTargetRouteID(aChildWaferQTimeInfo.getTargetMainProcessDefinition());
                    qtimeInfo.setRestrictionTargetOperationNumber(aChildWaferQTimeInfo.getTargetOperationNumber());
                    qtimeInfo.setRestrictionTargetBranchInfo(aChildWaferQTimeInfo.getTargetBranchInfo());
                    qtimeInfo.setRestrictionTargetReturnInfo(aChildWaferQTimeInfo.getTargetReturnInfo());
                    qtimeInfo.setRestrictionTargetTimeStamp(aChildWaferQTimeInfo.getTargetTimeStamp());
                    qtimeInfo.setPreviousTargetInfo(aChildWaferQTimeInfo.getPreviousTargetInfo());
                    qtimeInfo.setSpecificControl(aChildWaferQTimeInfo.getControl());
                    if (CimBooleanUtils.isTrue(aChildWaferQTimeInfo.getWatchdogRequired())){
                        log.info("TRUE == aChildWaferQTimeInfo->watchdogRequired");
                        qtimeInfo.setWatchDogRequired("Y");
                    } else {
                        log.info("FALSE == aChildWaferQTimeInfo->watchdogRequired");
                        qtimeInfo.setWatchDogRequired("N");
                    }
                    if (CimBooleanUtils.isTrue(aChildWaferQTimeInfo.getActionDone())){
                        log.info("TRUE == aChildWaferQTimeInfo->actionDone");
                        qtimeInfo.setActionDoneFlag("Y");
                    } else {
                        log.info("FALSE == aChildWaferQTimeInfo->actionDone");
                        qtimeInfo.setActionDoneFlag("N");
                    }
                    qtimeInfo.setManualCreated(aChildWaferQTimeInfo.getManualCreated());
                    List<ProcessDTO.QTimeRestrictionAction> qTimeActions = aChildWaferQTimeInfo.getActions();
                    int actionLength = CimArrayUtils.getSize(qTimeActions);
                    List<Infos.QTimeActionInfo> qTimeActionInfoList = new ArrayList<>();
                    qtimeInfo.setStrQtimeActionInfoList(qTimeActionInfoList);
                    if (actionLength != 0){
                        log.info("actionLength != 0");
                        for (ProcessDTO.QTimeRestrictionAction qTimeRestrictionAction : qTimeActions){
                            Infos.QTimeActionInfo qTimeActionInfo = new Infos.QTimeActionInfo();
                            qTimeActionInfoList.add(qTimeActionInfo);
                            qTimeActionInfo.setQrestrictionTargetTimeStamp(qTimeRestrictionAction.getTargetTimeStamp());
                            qTimeActionInfo.setQrestrictionAction(qTimeRestrictionAction.getAction());
                            qTimeActionInfo.setReasonCodeID(qTimeRestrictionAction.getReasonCode());
                            qTimeActionInfo.setActionRouteID(qTimeRestrictionAction.getActionRouteID());
                            qTimeActionInfo.setActionOperationNumber(qTimeRestrictionAction.getOperationNumber());
                            qTimeActionInfo.setFutureHoldTiming(qTimeRestrictionAction.getTiming());
                            qTimeActionInfo.setReworkRouteID(qTimeRestrictionAction.getMainProcessDefinition());
                            qTimeActionInfo.setMessageID(qTimeRestrictionAction.getMessageDefinition());
                            qTimeActionInfo.setCustomField(qTimeRestrictionAction.getCustomField());
                            if (CimBooleanUtils.isTrue(qTimeRestrictionAction.getWatchdogRequired())) {
                                log.info("TRUE == aChildWaferQTimeInfo->actions.watchdogRequired");
                                qTimeActionInfo.setWatchDogRequired("Y");
                            } else {
                                log.info("FALSE == aChildWaferQTimeInfo->actions.watchdogRequired");
                                qTimeActionInfo.setWatchDogRequired("N");
                            }
                            if (CimBooleanUtils.isTrue(qTimeRestrictionAction.getActionDone())) {
                                log.info("TRUE == aChildWaferQTimeInfo->actions.actionDone");
                                qTimeActionInfo.setActionDoneFlag("Y");
                            } else {
                                log.info("FALSE == aChildWaferQTimeInfo->actions.actionDone");
                                qTimeActionInfo.setActionDoneFlag("N");
                            }
                        }
                    }else {
                        log.info("actionLength = 0");
                    }
                    Inputs.QTimeChangeEventMakeParams params = new Inputs.QTimeChangeEventMakeParams();
                    params.setUpdateMode(BizConstant.SP_QRESTTIME_OPECATEGORY_UPDATE);
                    params.setLotID(tmpChildLotID);
                    params.setQtimeInfo(qtimeInfo);
                    params.setClaimMemo("");
                    eventMethod.qTimeChangeEventMake(objCommon, params);
                }
            }
        }

        return tmpChildLotID;
    }

    @Override
    public Outputs.ObjLotAllStateCheckSame lotAllStateCheckSame(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID, ObjectIdentifier childLotID) {
        Outputs.ObjLotAllStateCheckSame lotAllStateCheckSame = new Outputs.ObjLotAllStateCheckSame();
        CimLot parentLot = baseCoreFactory.getBO(CimLot.class, parentLotID);
        CimLot childLot = baseCoreFactory.getBO(CimLot.class, childLotID);
        //-------------------------------
        // Check lotState
        //-------------------------------
        String aDifferentState = null;
        Long  diffStateCnt = 0L;

        if (CimStringUtils.equals(parentLot.getLotState(), childLot.getLotState())) {
            lotAllStateCheckSame.setLotState(parentLot.getLotState());
        } else {
            diffStateCnt++;
            aDifferentState = "LOTSTATE";
            lotAllStateCheckSame.setLotState("*");
        }
        //-------------------------------
        // Check LotProductionState
        //-------------------------------
        if (CimStringUtils.equals(parentLot.getLotProductionState(), childLot.getLotProductionState())) {
            lotAllStateCheckSame.setLotProductionState(parentLot.getLotProductionState());
        } else {
            diffStateCnt++;
            aDifferentState = "PRODUCTIONSTATE";
            lotAllStateCheckSame.setLotProductionState("*");
        }
        //-------------------------------
        // Check LotHoldState
        //-------------------------------
        if (CimStringUtils.equals(parentLot.getLotHoldState(), childLot.getLotHoldState())) {
            lotAllStateCheckSame.setLotHoldState(parentLot.getLotHoldState());
        } else {
            diffStateCnt++;
            aDifferentState = "HOLDSTATE";
            lotAllStateCheckSame.setLotHoldState("*");
        }
        //-------------------------------
        // Check lotFinishedState
        //-------------------------------
        if (!CimObjectUtils.isEmpty(parentLot.getLotFinishedState()) && !CimObjectUtils.isEmpty(childLot.getLotFinishedState())) {
            if (CimStringUtils.equals(parentLot.getLotFinishedState(), childLot.getLotFinishedState())) {
                lotAllStateCheckSame.setLotFinishedState(parentLot.getLotFinishedState());
            } else {
                diffStateCnt++;
                aDifferentState = "FINISHEDSTATE";
                lotAllStateCheckSame.setLotFinishedState("*");
            }
        }
        //-------------------------------
        // Check LotProcessState
        //-------------------------------
        if (CimStringUtils.equals(parentLot.getLotProcessState(), childLot.getLotProcessState())) {
            lotAllStateCheckSame.setLotProcessState(parentLot.getLotProcessState());
        } else {
            diffStateCnt++;
            aDifferentState = "PROCESSSTATE";
            lotAllStateCheckSame.setLotProcessState("*");
        }
        //-------------------------------
        // Check LotInventoryState
        //-------------------------------
        if (CimStringUtils.equals(parentLot.getLotInventoryState(), childLot.getLotInventoryState())) {
            lotAllStateCheckSame.setLotInventoryState(parentLot.getLotInventoryState());
        } else {
            diffStateCnt++;
            aDifferentState = "INVENTORYSTATE";
            lotAllStateCheckSame.setLotInventoryState("*");
        }

        if (diffStateCnt > 0) {
            if (diffStateCnt == 1
                    && "HOLDSTATE".equals(aDifferentState)) {
                lotAllStateCheckSame.setLotHoldState("HOLDSTATE");
            }
            Validations.check(true, lotAllStateCheckSame, retCodeConfig.getNotInAllSameState(), aDifferentState);
        }

        return lotAllStateCheckSame;
    }

    @Override
    public String lotBankCheckSame(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID, ObjectIdentifier childLotID) {

        CimLot childLot = baseCoreFactory.getBO(CimLot.class, childLotID);
        CimLot parentLot = baseCoreFactory.getBO(CimLot.class, parentLotID);
        com.fa.cim.newcore.bo.factory.CimBank aChildBank = childLot.getBank();
        com.fa.cim.newcore.bo.factory.CimBank aParentBank = parentLot.getBank();
        Validations.check(null == aChildBank || null == aParentBank, retCodeConfig.getNotFoundBank());

        if (!CimStringUtils.equals(aChildBank.getIdentifier(), aParentBank.getIdentifier())) {
            throw new ServiceException(retCodeConfig.getNotInSameBank());
        }
        return aParentBank.getIdentifier();
    }

    @Override
    public Results.LotAnnotationInqResult lotCommentFillInTxPLQ002DR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        log.info("PPTManager_i::lotComment_FillInTxPLQ002DR");
        Results.LotAnnotationInqResult strLotCommentFillInTxPLQ002DROut=new Results.LotAnnotationInqResult();
        strLotCommentFillInTxPLQ002DROut.setLotID (lotID);

        CimLot aLot;
        aLot=baseCoreFactory.getBO(CimLot.class, lotID);

        CimLotComment aLotComment;
        aLotComment = aLot.getLotComment();

        int count;
        count = 0;
        List<Infos.LotCommentInfo> strLotCommentInfo;
        strLotCommentInfo=new ArrayList<>(1);

        if (aLotComment!=null) {
            log.info("PPTManager_i::lotComment_FillInTxPLQ002DR", "!CORBA::is_nil(aLotComment)");
            strLotCommentInfo.add(new Infos.LotCommentInfo());
            strLotCommentInfo.get(count).setReportUserID( ObjectIdentifier.buildWithValue(aLotComment.getPersonID()));

            strLotCommentInfo.get(count).setReportTimeStamp (CimDateUtils.getTimestampAsString(aLotComment.getLastUpdateTimeStamp()));

            strLotCommentInfo.get(count).setLotCommentTitle (aLotComment.getTitle());

            strLotCommentInfo.get(count).setLotCommentDescription ( aLotComment.getContents());
            count++;
        } else {
            Validations.check(true,retCodeConfig.getSomeLotComtDataError());
        }

        strLotCommentFillInTxPLQ002DROut.setLotCommentInfos (strLotCommentInfo);

        log.info("PPTManager_i::lotComment_FillInTxPLQ002DR");
        return strLotCommentFillInTxPLQ002DROut;
    }

    @Override
    public void lotMergeWaferLotNotOnRoute(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID, ObjectIdentifier childLotID) {

        Boolean bParentLotVender = false;
        Boolean bChildLotVender  = false;

        Boolean bInParentCast = true;
        Boolean bInChildCast  = true;
        Boolean bInCast       = true;
        CimLot parentLot = baseCoreFactory.getBO(CimLot.class, parentLotID);
        Validations.check(CimObjectUtils.isEmpty(parentLot),retCodeConfig.getNotFoundLot());

        CimLot childLot = baseCoreFactory.getBO(CimLot.class, childLotID);
        Validations.check(CimObjectUtils.isEmpty(childLot),retCodeConfig.getNotFoundLot());
        //--------------------------------------------------------------------
        // Check wafer attributes
        //--------------------------------------------------------------------
        //------------------------------------------------------
        // Get all wafer information of Parent lot
        //------------------------------------------------------
        log.info("Get all wafer information of Parent Lot");
        List<ProductDTO.WaferInfo> parentLotWaferInfo = parentLot.getAllWaferInfo();
        if (CimArrayUtils.isEmpty(parentLotWaferInfo)) {
            bParentLotVender = true;
        }
        //------------------------------------------------------
        // Get all wafer information of Child lot
        //------------------------------------------------------
        log.info("Get all wafer information of Child Lot");
        List<ProductDTO.WaferInfo> childLotWaferInfo = childLot.getAllWaferInfo();
        if (CimArrayUtils.isEmpty(childLotWaferInfo)) {
            bChildLotVender = true;
        }
        Boolean flag1 = CimBooleanUtils.isTrue(bParentLotVender) && CimBooleanUtils.isTrue(bChildLotVender);
        Boolean flag2 = CimBooleanUtils.isFalse(bParentLotVender) && CimBooleanUtils.isFalse(bChildLotVender);
        if (flag1 || flag2) {
            log.info("Lot Wafer Status is OK!!");
        }else {
            throw new ServiceException(retCodeConfig.getProductCountZero());
        }
        com.fa.cim.newcore.bo.durable.CimCassette aParentCassette = null;
        if (CimBooleanUtils.isFalse(bParentLotVender) && CimBooleanUtils.isFalse(bChildLotVender)) {
            //-------------------------------------------------------------------
            // Check Stacked wafer Information
            // If it is different from Parent lot and Child lot, not allow merge
            //-------------------------------------------------------------------
            Boolean bInvalidStkWfr = false;
            Integer parentStkwaferCount = 0;
            Integer childStkwaferCount = 0;
            if (!CimArrayUtils.isEmpty(parentLotWaferInfo.get(0).getStackedWafers()) && !CimArrayUtils.isEmpty(childLotWaferInfo.get(0).getStackedWafers())) {
                parentStkwaferCount = CimArrayUtils.getSize(parentLotWaferInfo.get(0).getStackedWafers());
                childStkwaferCount = CimArrayUtils.getSize(childLotWaferInfo.get(0).getStackedWafers());
            }
            if (parentStkwaferCount.intValue() != childStkwaferCount.intValue()) {
                log.info("parent_stkwafer_count != child_stkwafer_count");
                throw new ServiceException(retCodeConfig.getError());
            }
            //------------------------------------------------------
            // Get cassette object reference of Parent lot
            //------------------------------------------------------
            List<MaterialContainer> aMaterialContainerSequence = null;
            aMaterialContainerSequence = parentLot.materialContainers();
            if (1 == CimArrayUtils.getSize(aMaterialContainerSequence)) {
                log.info("aMaterialContainerSequence->length() == 1");
                aParentCassette = (com.fa.cim.newcore.bo.durable.CimCassette) aMaterialContainerSequence.get(0);
            } else if (CimArrayUtils.isEmpty(aMaterialContainerSequence)){
                log.info("aMaterialContainerSequence->length() == 0");
                bInParentCast = false;
            } else {
                throw new ServiceException(retCodeConfig.getCassetteDifferentForMerge());
            }
            if (CimObjectUtils.isEmpty(aParentCassette)) {
                log.info("aParentCassette is nil");
                if (CimBooleanUtils.isTrue(bInParentCast)) {
                    log.info("bInParentCast is true");
                    throw new ServiceException(new OmCode(retCodeConfig.getNotFoundCassette(),""));
                }else {
                    log.info("bInParentCast is false");
                }
            }
            //------------------------------------------------------
            // Get cassette object reference of Child lot
            //------------------------------------------------------
            List<MaterialContainer> aChildMaterialContainerSequence = null;
            aChildMaterialContainerSequence = childLot.materialContainers();
            com.fa.cim.newcore.bo.durable.CimCassette aChildCassette = null;
            if (1 == CimArrayUtils.getSize(aChildMaterialContainerSequence)) {
                log.info("aChildMaterialContainerSequence->length() == 1");
                aChildCassette = (com.fa.cim.newcore.bo.durable.CimCassette) aChildMaterialContainerSequence.get(0);
            } else if (CimArrayUtils.isEmpty(aChildMaterialContainerSequence)){
                log.info("aMaterialContainerSequence->length() == 0");
                bInChildCast = false;
            } else {
                throw new ServiceException(retCodeConfig.getCassetteDifferentForMerge());
            }
            if (CimObjectUtils.isEmpty(aChildCassette)) {
                log.info("aChildCassette is nil");
                if (CimBooleanUtils.isTrue(bInChildCast)) {
                    log.info("bInChildCast is true");
                    throw new ServiceException(new OmCode(retCodeConfig.getNotFoundCassette(),""));
                }else {
                    log.info("bInChildCast is false");
                }
            }
            if (CimBooleanUtils.isFalse(bInParentCast) && CimBooleanUtils.isFalse(bInChildCast)) {
                log.info("Both ChildLot and ParentLot are not in the cassette.");
                bInCast = false;
            } else if (CimBooleanUtils.isTrue(bInParentCast) && CimBooleanUtils.isTrue(bInChildCast)){
                log.info("Both ChildLot and ParentLot are in the cassette.");
            } else {
                log.info("Either ChildLot or ParentLot is in the cassette. Another lot is not in the cassette.");
                throw new ServiceException(retCodeConfigEx.getMergeLotInAndNotInCast());
            }
            if (CimBooleanUtils.isTrue(bInCast)) {
                log.info("if( bInCast == TRUE)");
                if (!CimStringUtils.equals(aParentCassette.getIdentifier(), aChildCassette.getIdentifier())) {
                    log.info("strParentCassetteID != strChildCassetteID");
                    throw new ServiceException(retCodeConfig.getCassetteDifferentForMerge());
                }
                //------------------------------------------------------
                // Remove Lots from cassette
                //------------------------------------------------------
                for (int i = 0; i < CimArrayUtils.getSize(childLotWaferInfo); i++) {
                    Wafer wafer = aParentCassette.removeWaferFromPosition(childLotWaferInfo.get(i).getPosition());
                }
                //------------------------------------------------------
                // Remove from queue
                //------------------------------------------------------
                if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_FINISHED, childLot.getLotState())) {
                    dispatchingManager.removeFromQueue(childLot);
                }
            }else {
                log.info("bInCast is false. And skip the functions related with Cassette.");
            }
        }
        //---------------------------------------
        // Get theQuantity and theProductQuantity
        //---------------------------------------
        log.info("Get theQuantity and theProductQuantity");

        Integer totalQuantity = parentLot.getQuantity() + childLot.getQuantity();
        Integer totalProductQuantity =  parentLot.getProductQuantity() + childLot.getProductQuantity();
        Integer totalControlQuantity =  parentLot.getControlQuantity() + childLot.getControlQuantity();

        //---------------------------------------
        // Call lot merge method of F/W.
        //---------------------------------------
        log.info("Call lot merge method of F/W");
        Lot joinAllInto = productManager.joinAllInto(childLot, parentLot);

        //------------------------------------------------------
        // Add Lots to cassette
        //------------------------------------------------------
        // Add Start
        //----------------------------------------------
        // Case of ParentLot and ChildLot is not Vendor,
        // Check cassette Object is Nil or not.
        //----------------------------------------------
        if (CimBooleanUtils.isTrue(bInCast)) {
            log.info("if( bInCast == TRUE)");
            if (0 < CimArrayUtils.getSize(parentLotWaferInfo) || 0 < CimArrayUtils.getSize(childLotWaferInfo)) {
                if (CimObjectUtils.isEmpty(aParentCassette)) {
                    log.info("aParentCassette is nil");
                    throw new ServiceException(new OmCode(retCodeConfig.getNotFoundCassette(),""));
                }
            }
            for (int i = 0; i < CimArrayUtils.getSize(childLotWaferInfo); i++) {
                CimWafer aTmpWafer = baseCoreFactory.getBO(CimWafer.class, childLotWaferInfo.get(i).getWaferID());
                Validations.check(CimObjectUtils.isEmpty(aTmpWafer),retCodeConfig.getNotFoundWafer());
                aParentCassette.addWaferAtPosition(aTmpWafer, childLotWaferInfo.get(i).getPosition());
                //cimLot.deleteLotToLotMaterial(childLot, aTmpWafer);
            }
        }else {
            log.info("bInCast is false. And skip addWafer_atPosition");
        }
        //---------------------------------------------------------------------
        // change total wafer quantity of both parent lot and child lot.
        //  ParentLot.theQuantity   <= aParentLotQuantity + aChildLotQuantity
        //  ChildLot.theQuantity    <= 0
        //---------------------------------------------------------------------
        // for updating theQuantity
        log.info("change total wafer quantity of both parent lot and child lot");
        parentLot.setVendorLotQuantity(totalQuantity);
        childLot.setVendorLotQuantity(0);
        //-------------------------------------------------------------------------------------------
        // change the number of wafer which has waferID in itself.
        //  ParentLot.theProductQuantity   <= aParentLotProductQuantity + aChildProductLotQuantity
        //  ChildLot.theProductQuantity    <= 0
        //  ParentLot.theControlQuantity   <= aParentLotControlQuantity + aChildControlLotQuantity //P3000266
        //  ChildLot.theControlQuantity    <= 0                                                    //P3000266
        //-------------------------------------------------------------------------------------------
        // for updating theProductQuantity
        log.info("change the number of wafer which has waferID in itself");
        parentLot.setProductQuantity(totalProductQuantity);
        childLot.setProductQuantity(0);
        parentLot.setControlQuantity(totalControlQuantity);
        childLot.setControlQuantity(0);
        //---------------------------------------
        // Set update claim information into
        // child lot
        //---------------------------------------
        log.info("Set update claim information into child lot");
        childLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(CimObjectUtils.isEmpty(aPerson),retCodeConfig.getNotFoundPerson());
        childLot.setLastClaimedPerson(aPerson);
        childLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        childLot.setStateChangedPerson(aPerson);
        //---------------------------------------
        // Set update claim information into
        // parent lot
        //---------------------------------------
        log.info("Set update claim information into parent lot");
        parentLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        parentLot.setLastClaimedPerson(aPerson);
        parentLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        parentLot.setStateChangedPerson(aPerson);
        parentLot.setLastClaimAllWafers(objCommon.getTimeStamp().getReportTimeStamp(),aPerson);
        //-------------------------------------------------------------------------------------
        // If lot exists in CurrentLot of lotfamily then lot move to ArciveLot of lotfamily.
        //-------------------------------------------------------------------------------------
        log.info("aLot->getLotFamily()");
        CimLotFamily aLotFamily = childLot.getLotFamily();
        if (CimObjectUtils.isEmpty(aLotFamily)) {
            throw new ServiceException(retCodeConfig.getNotFoundLotFamily());
        }
        List<Lot> aCurrentLotSeq = aLotFamily.currentLots();
        Boolean bLotFoundInCurrentLots = false;
        for (int i = 0; i < CimArrayUtils.getSize(aCurrentLotSeq); i++) {
            if (ObjectIdentifier.equalsWithValue(childLot.getLotID(), aCurrentLotSeq.get(i).getIdentifier())) {
                log.info("Found childLotID in CurrentLots!");
                bLotFoundInCurrentLots = true;
                break;
            }
        }
        if (CimBooleanUtils.isTrue(bLotFoundInCurrentLots)) {
            log.info("aLotFamily->archiveLot(aChildLot)");
            aLotFamily.archiveLot(childLot);
            log.info("aLotFamily->removeCurrentLot(aChildLot)");
            aLotFamily.removeCurrentLot(childLot);
        }
    }

    @Override
    public Results.LotMemoInfoInqResult lotNoteFillInTxPLQ003DR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Results.LotMemoInfoInqResult lotMemoInfoInqResult = new Results.LotMemoInfoInqResult();
        lotMemoInfoInqResult.setLotID(lotID);
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        List<Infos.LotNoteInfo> lotNoteInfos = new ArrayList<>();
        List<CimLotNote> lotToNotes = lot.allLotNotes();
        int nLen = CimArrayUtils.getSize(lotToNotes);
        for (int i = 0; i < nLen; i++) {
            CimLotNote lotNote = lotToNotes.get(i);
            Infos.LotNoteInfo lotNoteInfo = new Infos.LotNoteInfo();

            lotNoteInfo.setReportUserID(new ObjectIdentifier(lotNote.getPerson().getIdentifier(), lotNote.getPerson().getPrimaryKey()));
            Timestamp updateTime = lotNote.getLastUpdateTimeStamp();
            if (null == updateTime) {
                Validations.check(retCodeConfig.getSomeLotNoteDataError());
            }
            lotNoteInfo.setReportTimeStamp(String.valueOf(updateTime));
            lotNoteInfo.setLotNoteTitle(lotNote.getTitle());
            String noteContents = lotNote.getContents();
            if (null == noteContents) {
                Validations.check(retCodeConfig.getSomeLotNoteDataError());
            }
            lotNoteInfo.setLotNoteDescription(noteContents);
            lotNoteInfos.add(lotNoteInfo);
        }

        lotNoteInfos.sort((o1, o2) -> {
            long o1Time = Timestamp.valueOf(o1.getReportTimeStamp()).getTime();
            long o2Time = Timestamp.valueOf(o2.getReportTimeStamp()).getTime();
            return o1Time < o2Time ? 1 : (o1Time == o2Time ? 0 : -1);
        });
        lotMemoInfoInqResult.setLotNoteInfos(lotNoteInfos);

        return lotMemoInfoInqResult;
    }

    @Override
    public Results.LotOpeMemoInfoInqResult lotOperationNoteFillInTxPLQ005DR(Infos.ObjCommon objCommon, Params.LotOpeMemoInfoInqParams lotOpeMemoInfoInqParams) {
        log.info("【Method Entry】lotOperationNoteFillInTxPLQ005DR()");
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotOpeMemoInfoInqParams.getLotID());
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        Results.LotOpeMemoInfoInqResult lotOpeMemoInfoInqResult = new Results.LotOpeMemoInfoInqResult();
        lotOpeMemoInfoInqResult.setLotID(lotOpeMemoInfoInqParams.getLotID());
        lotOpeMemoInfoInqResult.setRouteID(lotOpeMemoInfoInqParams.getRouteID());
        lotOpeMemoInfoInqResult.setOperationID(lotOpeMemoInfoInqParams.getOperationID());
        lotOpeMemoInfoInqResult.setOperationNumber(lotOpeMemoInfoInqParams.getOperationNumber());

        List<CimLotOperationNote> lotOpeNoteList = lot.allLotOperationNotes();

        int nLen = CimArrayUtils.getSize(lotOpeNoteList);
        log.info("lotOperationNoteFillInTxPLQ005DR(): the length of lotOpeNoteList is {}.", nLen);
        List<Infos.LotNoteInfo> lotNoteInfoList = new ArrayList<>();
        for (int i = 0; i < nLen; i++) {
            CimLotOperationNote lotOpeNote = lotOpeNoteList.get(i);
            if(lotOpeNote == null){
                continue;
            }
            com.fa.cim.newcore.bo.pd.CimProcessDefinition mainProcessDefinition = lotOpeNote.getMainProcessDefinition();

            ObjectIdentifier noteRouteID = null;
            if (mainProcessDefinition != null) {
                noteRouteID = ObjectIdentifier.build(mainProcessDefinition.getIdentifier(), mainProcessDefinition.getPrimaryKey());
            }

            if (!ObjectIdentifier.equalsWithValue(noteRouteID, lotOpeMemoInfoInqParams.getRouteID())) {
                continue;
            }

            String noteOperationNumber = lotOpeNote.getOperationNumber();
            if (!CimStringUtils.equals(noteOperationNumber, lotOpeMemoInfoInqParams.getOperationNumber())) {
                continue;
            }

            Infos.LotNoteInfo lotNoteInfo = new Infos.LotNoteInfo();
            ObjectIdentifier ownerID = new ObjectIdentifier(lotOpeNote.getPerson().getIdentifier(),lotOpeNote.getPerson().getPrimaryKey());
            lotNoteInfo.setReportUserID(ownerID);

            lotNoteInfo.setReportTimeStamp(lotOpeNote.getLastUpdateTimeStamp().toString());

            lotNoteInfo.setLotNoteTitle(lotOpeNote.getTitle());
            lotNoteInfo.setLotNoteDescription(lotOpeNote.getContents());

            if (CimStringUtils.isEmpty(lotNoteInfo.getLotNoteTitle())) {
                log.info("lotOperationNoteFillInTxPLQ005DR(): lotNoteTitle is empty.");
                Validations.check(retCodeConfig.getSomeLotNoteDataError());
            }

            if (CimStringUtils.isEmpty(lotNoteInfo.getLotNoteDescription())) {
                log.info("lotOperationNoteFillInTxPLQ005DR(): lotNoteDescription is empty.");
                Validations.check(retCodeConfig.getSomeLotNoteDataError());
            }

            lotNoteInfoList.add(lotNoteInfo);
        }

        log.info("【Method Exit】lotOperationNoteFillInTxPLQ005DR()");
        lotOpeMemoInfoInqResult.setLotOperationNoteInfoList(lotNoteInfoList);
        return lotOpeMemoInfoInqResult;
    }

    @Override
    public Results.LotOpeMemoListInqResult lotOperationNoteFillInTxPLQ004DR(Infos.ObjCommon objCommon, Params.LotOpeMemoListInqParams params) {


        log.info("【Method Entry】lotOperationNoteFillInTxPLQ004DR()");
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, params.getLotID());

        if (aLot == null) {
            log.info("Not found lot.");
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundLot(),  params.getLotID().getValue()));

        }

        Results.LotOpeMemoListInqResult result = new Results.LotOpeMemoListInqResult();
        result.setLotID(params.getLotID());

        List<CimLotOperationNote> lotOpeNoteList = aLot.allLotOperationNotes();

        int nLen = CimArrayUtils.getSize(lotOpeNoteList);
        log.info("lotOperationNoteFillInTxPLQ004DR() : lotOperationNoteSequence->length() = {}", nLen);

        List<Infos.LotOperationNoteList> LotOperationNotesList = new ArrayList<>();
        for (int i = 0; i < nLen; i++) {
            CimLotOperationNote lotOpeNote = lotOpeNoteList.get(i);

            Infos.LotOperationNoteList lotOperationNoteList = new Infos.LotOperationNoteList();
            lotOperationNoteList.setReportUserID(new ObjectIdentifier(lotOpeNote.getPersonID()));
            lotOperationNoteList.setReportTimeStamp(lotOpeNote.getLastUpdateTimeStamp().toString());
            lotOperationNoteList.setNoteTitle(lotOpeNote.getTitle());
            lotOperationNoteList.setOperationNumber(lotOpeNote.getOperationNumber());

            ObjectIdentifier routeID = new ObjectIdentifier("", "");
            com.fa.cim.newcore.bo.pd.CimProcessDefinition mainProcessDefinition = lotOpeNote.getMainProcessDefinition();
            if (mainProcessDefinition != null) {
                routeID.setReferenceKey(mainProcessDefinition.getPrimaryKey());
                routeID.setValue(mainProcessDefinition.getIdentifier());
            }
            lotOperationNoteList.setRouteID(routeID);

            ObjectIdentifier operationID = new ObjectIdentifier("", "");
            com.fa.cim.newcore.bo.pd.CimProcessDefinition processDefinition = lotOpeNote.getProcessDefinition();
            if (processDefinition != null) {
                operationID.setReferenceKey(processDefinition.getPrimaryKey());
                operationID.setValue(processDefinition.getIdentifier());
            }
            lotOperationNoteList.setOperationID(operationID);
            LotOperationNotesList.add(lotOperationNoteList);
        }

        log.info("【Method Exit】lotOperationNoteFillInTxPLQ004DR()");
        result.setLotOperationNotesList(LotOperationNotesList);

        return result;
    }

    @Override
    public ObjectIdentifier lotNoteMake(Infos.ObjCommon objCommon, ObjectIdentifier lotID, String lotNoteTitle, String lotNoteDescription) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lot), retCodeConfig.getNotFoundLot());

        com.fa.cim.newcore.bo.person.CimPerson person = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(CimObjectUtils.isEmpty(person), retCodeConfig.getNotFoundPerson());

        CimLotNote lotNote = lot.createLotNote(objCommon.getTimeStamp().getReportTimeStamp(), person);
        Validations.check(CimObjectUtils.isEmpty(lotNote), retCodeConfig.getNotFoundLotNote());
        lotNote.setTitle(lotNoteTitle);
        lotNote.setContents(lotNoteDescription);
        return lotID;
    }

    @Override
    public ObjectIdentifier lotOperationNoteMake(Infos.ObjCommon objCommon, Params.LotOperationNoteInfoRegisterReqParams params) {
        log.info("【Method Entry】lotOperationNoteMake()");


        if (CimStringUtils.isEmpty(params.getLotOperationNoteTitle()) ||
                CimStringUtils.isEmpty(params.getLotOperationNoteDescription())) {
            throw new ServiceException(retCodeConfig.getInvalidDataContents());

        }

        CimLot aLot = baseCoreFactory.getBO(CimLot.class, params.getLotID());
        if (aLot == null) {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundLot(), params.getLotID().getValue()));
        }

        ObjectIdentifier lotID = aLot.getLotID();

        com.fa.cim.newcore.bo.person.CimPerson aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, objCommon.getUser().getUserID());

        if (aPerson == null) {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));
        }

        com.fa.cim.newcore.bo.pd.CimProcessDefinition aMainProcessDefinition = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessDefinition.class, params.getRouteID());
        if (aMainProcessDefinition == null) {
            throw new ServiceException(retCodeConfig.getNotFoundProcessDefinition());
        }

        CimLotOperationNote aNewLotOpNote = aLot.createLotOperationNote(objCommon.getTimeStamp().getReportTimeStamp(), aPerson, aMainProcessDefinition, params.getOperationNumber());
        if (aNewLotOpNote == null) {
            throw new ServiceException(retCodeConfig.getNotFoundLotOpeNote());
        }

        aNewLotOpNote.setTitle(params.getLotOperationNoteTitle());
        aNewLotOpNote.setContents(params.getLotOperationNoteDescription());
        if (!CimStringUtils.isEmpty(params.getOperationID().getValue())) {
            com.fa.cim.newcore.bo.pd.CimProcessDefinition aProcessDefinition = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessDefinition.class, params.getOperationID());
            aNewLotOpNote.setProcessDefinition(aProcessDefinition);
        }

        log.info("【Method Exit】lotOperationNoteMake()");

        return lotID;
    }

    @Override
    public List<Infos.FutureHoldListAttributes> lotFutureHoldListbyKeyDR(Infos.ObjCommon objCommon,
                                                                         Infos.FutureHoldSearchKey futureHoldSearchKey,
                                                                         Integer count) {

        String HV_TMPBUFFER = "";

        Boolean firstCondition = true;
        CimLot aLot = null;
        String HV_BUFFER = "SELECT  A.LOT_ID, " +
                "                   B.HOLD_TYPE," +
                "                   B.REASON_CODE_ID, " +
                "                   B.REASON_CODE_RKEY, " +
                "                   B.USER_ID, " +
                "                   B.USER_RKEY, " +
                "                   B.MAIN_PROCESS_ID, " +
                "                   B.MAIN_PROCESS_RKEY, " +
                "                   B.OPE_NO, " +
                "                   B.TRX_TIME, " +
                "                   B.ASSOC_LOT_ID, " +
                "                   B.ASSOC_LOT_RKEY, " +
                "                   B.TRX_MEMO, " +
                "                   B.SINGLE_TRIGGER_MODE, " +
                "                   B.POST_MODE,  " +
                "                   B.DPT_NAME_PLATE " +
                "           FROM    OMLOT A, " +
                "                   OMLOT_FUTUREHOLD B \n" +
                "           WHERE   A.ID= B.REFKEY";
        String HV_FOR_SELECTCOUNT_BUFFER ="SELECT COUNT(B.REFKEY) \n" +
                "FROM OMLOT A, OMLOT_FUTUREHOLD B \n" +
                "WHERE A.ID= B.REFKEY ";
        //lotID
        if (!CimObjectUtils.isEmpty(futureHoldSearchKey.getLotID().getValue())){
            HV_TMPBUFFER = " AND B.REFKEY IN ( SELECT ID FROM OMLOT WHERE LOT_ID LIKE '%s' ) ";
            HV_TMPBUFFER = String.format(HV_TMPBUFFER,futureHoldSearchKey.getLotID().getValue());
            HV_BUFFER += HV_TMPBUFFER;
            HV_FOR_SELECTCOUNT_BUFFER += HV_TMPBUFFER;
        }
        //holdType
        if (!CimObjectUtils.isEmpty(futureHoldSearchKey.getHoldType())){
            HV_TMPBUFFER = " AND B.HOLD_TYPE = '%s' ";
            HV_TMPBUFFER = String.format(HV_TMPBUFFER,futureHoldSearchKey.getHoldType());
            HV_BUFFER += HV_TMPBUFFER;
            HV_FOR_SELECTCOUNT_BUFFER += HV_TMPBUFFER;
        }

        //reasonCodeID
        if (!ObjectIdentifier.isEmptyWithValue(futureHoldSearchKey.getReasonCodeID())){
            HV_TMPBUFFER = " AND B.REASON_CODE_ID = '%s' ";
            HV_TMPBUFFER = String.format(HV_TMPBUFFER,futureHoldSearchKey.getReasonCodeID().getValue());
            HV_BUFFER += HV_TMPBUFFER;
            HV_FOR_SELECTCOUNT_BUFFER += HV_TMPBUFFER;
        }

        //userID
        if (!ObjectIdentifier.isEmptyWithValue(futureHoldSearchKey.getUserID())){
            HV_TMPBUFFER = " AND B.USER_ID = '%s' ";
            HV_TMPBUFFER = String.format(HV_TMPBUFFER,futureHoldSearchKey.getUserID().getValue());
            HV_BUFFER += HV_TMPBUFFER;
            HV_FOR_SELECTCOUNT_BUFFER += HV_TMPBUFFER;
        }
        //routeID
        if (!ObjectIdentifier.isEmptyWithValue(futureHoldSearchKey.getRouteID())){
            HV_TMPBUFFER = " AND B.MAIN_PROCESS_ID LIKE '%s' ";
            HV_TMPBUFFER = String.format(HV_TMPBUFFER,futureHoldSearchKey.getRouteID().getValue());
            HV_BUFFER += HV_TMPBUFFER;
            HV_FOR_SELECTCOUNT_BUFFER += HV_TMPBUFFER;
        }
        //operationNumber
        if (!CimObjectUtils.isEmpty(futureHoldSearchKey.getOperationNumber())){
            HV_TMPBUFFER = " AND B.OPE_NO = '%s' ";
            HV_TMPBUFFER = String.format(HV_TMPBUFFER,futureHoldSearchKey.getOperationNumber());
            HV_BUFFER += HV_TMPBUFFER;
            HV_FOR_SELECTCOUNT_BUFFER += HV_TMPBUFFER;
        }
        //relatedLotID
        if (!ObjectIdentifier.isEmptyWithValue(futureHoldSearchKey.getRelatedLotID())){
            HV_TMPBUFFER = " AND B.ASSOC_LOT_ID = '%s' ";
            HV_TMPBUFFER = String.format(HV_TMPBUFFER,futureHoldSearchKey.getRelatedLotID().getValue());
            HV_BUFFER += HV_TMPBUFFER;
            HV_FOR_SELECTCOUNT_BUFFER += HV_TMPBUFFER;
        }
        //triggerLevel
        if (CimStringUtils.equals(BizConstant.SP_FUTUREHOLD_SINGLE,futureHoldSearchKey.getTriggerLevel())){
            HV_BUFFER += " AND B.SINGLE_TRIGGER_MODE = 1 ";
            HV_FOR_SELECTCOUNT_BUFFER += "AND B.SINGLE_TRIGGER_MODE = 1 ";
        }else if (CimStringUtils.equals(BizConstant.SP_FUTUREHOLD_MULTIPLE,futureHoldSearchKey.getTriggerLevel())){
            HV_BUFFER += " AND B.SINGLE_TRIGGER_MODE = 0 ";
            HV_FOR_SELECTCOUNT_BUFFER += "AND B.SINGLE_TRIGGER_MODE = 0 ";
        }
        //phase
        if (CimStringUtils.equals(BizConstant.SP_FUTUREHOLD_PRE,futureHoldSearchKey.getPhase())){
            HV_BUFFER += " AND B.POST_MODE = 0";
            HV_FOR_SELECTCOUNT_BUFFER += "AND B.POST_MODE = 0";
        }else if (CimStringUtils.equals(BizConstant.SP_FUTUREHOLD_POST,futureHoldSearchKey.getPhase())){
            HV_BUFFER += " AND B.POST_FLAG = 1";
            HV_FOR_SELECTCOUNT_BUFFER += "AND B.POST_MODE = 1";
        }

        com.fa.cim.newcore.bo.person.CimPerson aPerson = null;
        com.fa.cim.newcore.bo.code.CimCategory aCategory = null;
        com.fa.cim.newcore.bo.code.CimCode aCode = null;

        aCategory = codeManager.findCategoryNamed(BizConstant.SP_REASONCAT_FUTUREHOLD);
        Validations.check(CimObjectUtils.isEmpty(aCategory),retCodeConfig.getNotFoundCategory());

        //FOR READ ONLY IGNORE
        //-------------------------------------------
        // Judge and Convert SQL with Escape Sequence
        //-------------------------------------------
        String selectCountSql = HV_FOR_SELECTCOUNT_BUFFER;
        long countResult = cimJpaRepository.count(selectCountSql);
        if (countResult <= 0) {
            throw new ServiceException(retCodeConfig.getNotFoundFtholdEntW(), new ArrayList<Infos.FutureHoldListAttributes>());
        }

        Boolean bConvertFlag = false;
        String originalSql = HV_BUFFER;
        List<Object[]> originalResult = cimJpaRepository.query(originalSql);

        //-------------------------//
        //     Set output data     //
        //-------------------------//
        List<Infos.FutureHoldListAttributes> futureHoldListAttributesList = new ArrayList<>();
        if (CimArrayUtils.getSize(originalResult) > 0){
            for (Object[] objects : originalResult) {
                Infos.FutureHoldListAttributes futureHoldListAttributes = new Infos.FutureHoldListAttributes();

                futureHoldListAttributes.setLotID(new ObjectIdentifier(CimObjectUtils.toString(objects[0])));//A.LOT_ID
                futureHoldListAttributes.setHoldType(CimObjectUtils.toString(objects[1])); //B.HOLD_TYPE
                /*-----   Set CancelableFlag   -----*/

                futureHoldListAttributes.setCancelableFlag(CimStringUtils.equals(BizConstant.SP_HOLDTYPE_FUTUREHOLD, CimObjectUtils.toString(objects[1])) ? true : false);

                ObjectIdentifier mainProcessDefinitionID = new ObjectIdentifier(CimObjectUtils.toString(objects[6]), CimObjectUtils.toString(objects[7]));
                futureHoldListAttributes.setRouteID(mainProcessDefinitionID);//B.MAINPD_ID ,B.MAINPD_OBJ
                futureHoldListAttributes.setOperationNumber(CimObjectUtils.toString(objects[8]));//B.OPE_NO

                Boolean bGetOpName = true;
                Boolean routeFound = false;
                com.fa.cim.newcore.bo.pd.CimProcessDefinition processDefinition = null;
                if (!ObjectIdentifier.isEmpty(mainProcessDefinitionID)) {
                    processDefinition = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessDefinition.class,mainProcessDefinitionID);
                    Validations.check(CimObjectUtils.isEmpty(processDefinition),retCodeConfig.getNotFoundProcessDefinition());
                    if (null != processDefinition) {
                        routeFound = true;
                    }
                }
                if (CimBooleanUtils.isFalse(routeFound)) {
                    bGetOpName = false;
                }
                com.fa.cim.newcore.bo.pd.CimProcessFlow processFlow = null;
                if (CimBooleanUtils.isTrue(bGetOpName)) {
                    processFlow = processDefinition.getActiveMainProcessFlow();
                    if (null == processFlow) {
                        bGetOpName = false;
                    }
                }

                //-----------------------------------------------------------------
                // Check of "." existence for OperationNumber.
                // If "." does not exist, skip FW method to avoid System Exception.
                //-----------------------------------------------------------------
                String periodPos = BaseStaticMethod.convertOpeNoToModuleOpeNo(futureHoldListAttributes.getOperationNumber());
                if (CimStringUtils.isEmpty(periodPos)) {
                    bGetOpName = false;
                }

                String aPDoperationName = null;
                if (CimBooleanUtils.isTrue(bGetOpName)) {
                    com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aModulePOS = null;
                    AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainPF = new AtomicReference<>(null);
                    AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outModulePF = new AtomicReference<>(null);;
                    aModulePOS = processFlow.getProcessOperationSpecificationFor(futureHoldListAttributes.getOperationNumber(), outMainPF, outModulePF);

                    if (null != aModulePOS) {
                        List<ProcessDefinition> processDefinitions = aModulePOS.getProcessDefinitions();
                        if (CimArrayUtils.getSize(processDefinitions) > 0){
                            com.fa.cim.newcore.bo.pd.CimProcessDefinition aPosPD = (com.fa.cim.newcore.bo.pd.CimProcessDefinition) (processDefinitions.get(0));
                            aPDoperationName = aPosPD.getProcessDefinitionName();
                        }
                    }
                }
                futureHoldListAttributes.setOperationName(aPDoperationName);

                futureHoldListAttributes.setUserID(new ObjectIdentifier(CimObjectUtils.toString(objects[4]), CimObjectUtils.toString(objects[5])));//B.USER_ID, B.USER_OBJ
                /*-----   Set UserName   -----*/
                aPerson = baseCoreFactory.getBO(com.fa.cim.newcore.bo.person.CimPerson.class, futureHoldListAttributes.getUserID());
                if (!CimObjectUtils.isEmpty(aPerson)){
                    futureHoldListAttributes.setUserName(aPerson.getFullName());
                }

                futureHoldListAttributes.setReasonCodeID(new ObjectIdentifier(CimObjectUtils.toString(objects[2]), CimObjectUtils.toString(objects[3])));//B.REASON_CODE,B.REASON_CODE_OBJ
                /*-----   Set ReasonCodeDescription   -----*/
                String aCategoryIdentifier = aCategory.getIdentifier();
                if (ObjectIdentifier.isEmptyWithRefKey(futureHoldListAttributes.getReasonCodeID())){
                    Validations.check(ObjectIdentifier.isEmptyWithValue(futureHoldListAttributes.getReasonCodeID()),retCodeConfig.getNotFoundCode(),aCategoryIdentifier,"*****");
                    aCode = aCategory.findCodeNamed(futureHoldListAttributes.getReasonCodeID().getValue());
                }else {
                    aCode = baseCoreFactory.getBO(com.fa.cim.newcore.bo.code.CimCode.class,futureHoldListAttributes.getReasonCodeID().getReferenceKey());
                }
                Validations.check(null == aCode, retCodeConfig.getNotFoundCode(),aCategoryIdentifier, ObjectIdentifier.fetchValue(futureHoldListAttributes.getReasonCodeID()));
                if (!CimObjectUtils.isEmpty(aCode)){
                    futureHoldListAttributes.setReasonCodeDescription(aCode.getDescription());
                }


                futureHoldListAttributes.setReportTimeStamp(CimObjectUtils.toString(objects[9]));//B.CLAIM_TIME
                futureHoldListAttributes.setRelatedLotID(new ObjectIdentifier(CimObjectUtils.toString(objects[10]), CimObjectUtils.toString(objects[11])));//B.RELATED_LOT_ID,B.RELATED_LOT_OBJ
                futureHoldListAttributes.setPostFlag(CimBooleanUtils.getBoolean(CimObjectUtils.toString(objects[14])));//B.POST_FLAG
                futureHoldListAttributes.setSingleTriggerFlag(CimBooleanUtils.getBoolean(CimObjectUtils.toString(objects[13])));//B.SINGLE_TRIG_FLAG
                futureHoldListAttributes.setClaimMemo(CimObjectUtils.toString(objects[12]));//B.TRX_MEMO
                String departmentNamePlate = CimObjectUtils.toString(objects[15]);
                if (CimStringUtils.isNotEmpty(departmentNamePlate)) {
                    List<String> departmentAndSection = Arrays.stream(departmentNamePlate.split("\\.", 2)).collect(Collectors.toList());
                    if (CimNumberUtils.eq(departmentAndSection.size(), 2)) {
                        futureHoldListAttributes.setDepartment(departmentAndSection.get(0));
                        futureHoldListAttributes.setSection(departmentAndSection.get(1));
                    }
                }

                //【jerry】 bug - 445 ->  Future Hold Release: future hold one child lot which is just spilted out , then do future hold release but didn't work,
                //futureHoldListAttributes.setRelatedLotID(new ObjectIdentifier(futureHold.getRelatedLotID(), futureHold.getRelatedLotObj()));
                futureHoldListAttributesList.add(futureHoldListAttributes);
            }
        }

        return futureHoldListAttributesList;

        // -----------------------------old-------------------------------------
//        SearchCondition searchCondition = new SearchCondition();
//        searchCondition.setSize(Integer.MAX_VALUE);
//        CimLotFutureHoldDO lotFutureHold = new CimLotFutureHoldDO();
//        ObjectIdentifier lotID = futureHoldSearchKey.getLotID();
//        if (!ObjectUtils.isEmpty(lotID)) {
//            List<CimLotDO> lots = cimLot.findLotsByLotIDLike(lotID.getValue());
//            StringBuilder lotIds = new StringBuilder();
//            lots.forEach(lot -> {
//                lotIds.append(lot.getId());
//                lotIds.append(SpecificationTools.CONDITION_IN_SPLIT);
//            });
//            String condition = BaseStaticMethod.makeSearchCondition("referenceKey", SpecificationTools.CONDITION_IN, lotIds, searchCondition.getSeparator());
//            searchCondition.getConditions().add(condition);
//        }
//        String holdType = futureHoldSearchKey.getHoldType();
//        if (!ObjectUtils.isEmpty(holdType)) {
//            lotFutureHold.setHoldType(holdType);
//        }
//        ObjectIdentifier reasonCodeID = futureHoldSearchKey.getReasonCodeID();
//        if (!ObjectUtils.isEmpty(reasonCodeID)) {
//            lotFutureHold.setReasonCodeID(reasonCodeID.getValue());
//        }
//        ObjectIdentifier userID = futureHoldSearchKey.getUserID();
//        if (!ObjectUtils.isEmpty(userID)) {
//            lotFutureHold.setUserID(userID.getValue());
//        }
//        ObjectIdentifier routeID = futureHoldSearchKey.getRouteID();
//        if (!ObjectUtils.isEmpty(routeID)) {
//            String condition = BaseStaticMethod.makeSearchCondition("mainProcessDefinitionID", SpecificationTools.CONDITION_LIKE, routeID.getValue(), searchCondition.getSeparator());
//            searchCondition.getConditions().add(condition);
//        }
//        String operationNumber = futureHoldSearchKey.getOperationNumber();
//        if (!ObjectUtils.isEmpty(operationNumber)) {
//            lotFutureHold.setOperationNumber(operationNumber);
//        }
//        ObjectIdentifier relatedLotID = futureHoldSearchKey.getRelatedLotID();
//        if (!ObjectUtils.isEmpty(relatedLotID)) {
//            lotFutureHold.setRelatedLotID(relatedLotID.getValue());
//        }
//        String triggerLevel = futureHoldSearchKey.getTriggerLevel();
//        if (BizConstant.equals(BizConstant.FUTUREHOLD_SINGLE, triggerLevel)) {
//            lotFutureHold.setSingleTriggerFlag(true);
//        } else if (BizConstant.equals(BizConstant.FUTUREHOLD_MULTIPLE, triggerLevel)) {
//            lotFutureHold.setSingleTriggerFlag(false);
//        }
//        String phase = futureHoldSearchKey.getPhase();
//        if (BizConstant.equals(BizConstant.FUTUREHOLD_PRE, phase)) {
//            lotFutureHold.setPostFlag(false);
//        } else if (BizConstant.equals(BizConstant.FUTUREHOLD_POST, phase)) {
//            lotFutureHold.setPostFlag(true);
//        }
//
//        CimCategoryDO category = categoryCore.findByCategoryID(BizConstant.REASONCAT_FUTURE_HOLD.getValue());
//        if (null == category) {
//            throw new ServiceException(retCodeConfig.getNotFoundCategory());
//
//        }
//        List<Infos.FutureHoldListAttributes> futureHoldListAttributesList = new ArrayList<>();
//        List<CimLotFutureHoldDO> lotFutureHolds = cimLot.findLotFutureHolds(lotFutureHold, searchCondition);
//        for (CimLotFutureHoldDO futureHold : lotFutureHolds) {
//            Infos.FutureHoldListAttributes futureHoldListAttributes = new Infos.FutureHoldListAttributes();
//            CimLotDO lot = cimLot.findLotByLotID(new ObjectIdentifier(null, futureHold.getReferenceKey()));
//            futureHoldListAttributes.setLotID(new ObjectIdentifier(lot.getLotID(), lot.getId()));
//            futureHoldListAttributes.setHoldType(futureHold.getHoldType());
//            futureHoldListAttributes.setCancelableFlag(BizConstant.equals(BizConstant.HOLD_TYPE_FUTURE_HOLD, futureHold.getHoldType()) ? true : false);
//            String mainProcessDefinitionID = futureHold.getMainProcessDefinitionID();
//            futureHoldListAttributes.setRouteID(new ObjectIdentifier(mainProcessDefinitionID, futureHold.getMainProcessDefinitionObj()));
//            futureHoldListAttributes.setOperationNumber(futureHold.getOperationNumber());
//
//            boolean bGetOpName = true;
//            boolean routeFound = false;
//            CimProcessDefinitionDO processDefinition = null;
//            if (!StringUtils.isEmpty(mainProcessDefinitionID)) {
//                processDefinition = processDefinitionCore.findProcessDefinitionByProcessDefinitionID(mainProcessDefinitionID);
//                if (null != processDefinition) {
//                    routeFound = true;
//                }
//            }
//            if (!routeFound) {
//                bGetOpName = false;
//            }
//            CimProcessFlowDO processFlow = null;
//            if (bGetOpName) {
//                processFlow = processFlowCore.findProcessFlowById(processDefinition.getActiveMainProcessFlowObj());
//                if (null == processFlow) {
//                    bGetOpName = false;
//                }
//            }
//
//            //-----------------------------------------------------------------
//            // Check of "." existence for OperationNumber.
//            // If "." does not exist, skip FW method to avoid System Exception.
//            //-----------------------------------------------------------------
//            String periodPos = BaseStaticMethod.convertOpeNoToModuleOpeNo(futureHold.getOperationNumber());
//            if (StringUtils.isEmpty(periodPos)) {
//                bGetOpName = false;
//            }
//
//            String aPDoperationName = null;
//            if (bGetOpName) {
//                CimProcessOperationSpecificationDO aModulePOS = null;
//                AtomicReference<CimProcessFlowDO> outMainPF = new AtomicReference<>(null);
//                AtomicReference<CimProcessFlowDO> outModulePF = new AtomicReference<>(null);;
//                aModulePOS = processFlowCore.getProcessOperationSpecificationFor(processFlow, futureHold.getOperationNumber(), outMainPF, outModulePF);
//
//                if (null != aModulePOS) {
//                    CimProcessDefinitionDO apd = processDefinitionCore.findProcessDefinitionByProcessDefinitionID(aModulePOS.getProcessDefinitionID());
//                    if (null != apd) {
//                        aPDoperationName = apd.getProcessDefinitionID();
//                    }
//                }
//            }
//            futureHoldListAttributes.setOperationName(aPDoperationName);
//            CimPersonDO person = cimPerson.findPersonByUserID(futureHold.getUserID());
//            if (null != person) {
//                futureHoldListAttributes.setUserID(new ObjectIdentifier(person.getUserID(), person.getId()));
//                futureHoldListAttributes.setUserName(person.getUserFullID());
//            }
//            CimCodeDO code = cimCode.findCodeByCategoryIDAndCodeID(category.getCategoryID(), futureHold.getReasonCodeID());
//            if (null != code) {
//                futureHoldListAttributes.setReasonCodeID(new ObjectIdentifier(code.getCodeID(), code.getId()));
//                futureHoldListAttributes.setReasonCodeDescription(code.getDescription());
//            }
//            futureHoldListAttributes.setReportTimeStamp(futureHold.getClaimTime());
//            futureHoldListAttributes.setRelatedLotID(new ObjectIdentifier(futureHold.getRelatedLotID(), futureHold.getRelatedLotObj()));
//            futureHoldListAttributes.setPostFlag(futureHold.getPostFlag());
//            futureHoldListAttributes.setSingleTriggerFlag(futureHold.getSingleTriggerFlag());
//            futureHoldListAttributes.setClaimMemo(futureHold.getClaimMemo());
//            //【jerry】 bug - 445 ->  Future Hold Release: future hold one child lot which is just spilted out , then do future hold release but didn't work,
//            futureHoldListAttributes.setRelatedLotID(new ObjectIdentifier(futureHold.getRelatedLotID(), futureHold.getRelatedLotObj()));
//            futureHoldListAttributesList.add(futureHoldListAttributes);
//        }
//
//        return futureHoldListAttributesList;
    }

    @Override
    public void lotExternalPriorityUpdate(Infos.ObjCommon objCommon, ObjectIdentifier lotID, int externalPriority) {

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        if (lot == null) {
            throw new ServiceException(retCodeConfig.getNotFoundLot());

        }
        CimPerson person = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        if (person == null) {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID().getValue()));

        }
        lot.setPriority(externalPriority);
        lot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        lot.setLastClaimedPerson(person);
    }

    public ObjectIdentifier lotRouteIdGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        if (null == lot) {
            throw new ServiceException(retCodeConfig.getNotFoundLot());

        }
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aPosPD = lot.getMainProcessDefinition();

        ObjectIdentifier objectIdentifier = null == aPosPD ? null : new ObjectIdentifier(aPosPD.getIdentifier(),aPosPD.getPrimaryKey());
        return objectIdentifier;
    }


    @Override
    public void lotFutureHoldRequestsCheckBranchCancel(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        if (null == lot) {
            log.error("not found lot, the lotID:%s", lotID);
            throw new ServiceException(retCodeConfig.getNotFoundLot());
        }
        com.fa.cim.newcore.bo.pd.CimProcessDefinition aMainPD = lot.getMainProcessDefinition();
        if (null == aMainPD) {
            throw new ServiceException(retCodeConfig.getNotFoundProcessDefinition());
        }
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aProcessFlowContext = lot.getProcessFlowContext();
        if (null == aProcessFlowContext) {
            throw new ServiceException(retCodeConfig.getNotFoundPfx());
        }
        AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainProcessFlow = new AtomicReference<>();
        AtomicReference<String> outModuleNumber = new AtomicReference<>();
        AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outModuleProcessFlow = new AtomicReference<>();
        com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aModulePOS = aProcessFlowContext.getNextProcessOperationSpecificationOnCurrentRoute(outMainProcessFlow, outModuleNumber, outModuleProcessFlow);
        String aModuleNo = outModuleNumber.get();
        com.fa.cim.newcore.bo.pd.CimProcessOperation aProcessOperation = lot.getProcessOperation();
        if (null == aProcessOperation) {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundProcessOperation(),"*****",lot.getIdentifier()));
        }
        String currentMainPDID = aMainPD.getIdentifier();
        String currentOperationNumber = aProcessOperation.getOperationNumber();

        List<ProductDTO.FutureHoldRecord> aFutureHoldRecordSequence = lot.findFutureHoldRecordsFor(aMainPD, currentOperationNumber);
        for (int i = 0; i < CimArrayUtils.getSize(aFutureHoldRecordSequence); i++) {
            if (CimBooleanUtils.isTrue(aFutureHoldRecordSequence.get(i).isPostFlag())) {
                throw new ServiceException(new OmCode(retCodeConfig.getFutureHoldInBranch(),lotID.getValue(), currentMainPDID, currentOperationNumber));
            }
        }
        String mainPDID = aMainPD.getIdentifier();
        Infos.FutureHoldSearchKey futureHoldSearchKey1 = new Infos.FutureHoldSearchKey();
        futureHoldSearchKey1.setLotID(lotID);
        futureHoldSearchKey1.setRouteID(new ObjectIdentifier(mainPDID,aMainPD.getPrimaryKey()));
        List<Infos.FutureHoldListAttributes> out2 = null;
        try {
            out2 = lotFutureHoldListbyKeyDR(objCommon, futureHoldSearchKey1,0);
        } catch (ServiceException e) {
            out2 = e.getData(List.class);
            if (!Validations.isEquals(retCodeConfig.getNotFoundFtholdEntW() ,e.getCode())) {
                throw e;
            }
            if (Validations.isEquals(retCodeConfig.getNotFoundFtholdEntW() ,e.getCode())) {
                log.info("No futureHold exists.");
                return;
            }
        }
        com.fa.cim.newcore.bo.pd.CimProcessFlow aMainPF = outMainProcessFlow.get();
        com.fa.cim.newcore.bo.pd.CimProcessFlow aModulePF = outModuleProcessFlow.get();

        while (true) {
            AtomicReference<String> outModuleNo = new AtomicReference<>();
            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainPF = new AtomicReference<>();
            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outModulePF = new AtomicReference<>();
            if (null == aModulePOS) {
                break;
            }
            String aModuleOpeNo = aModulePOS.getOperationNumber();

            String aOperationNumber  = BaseStaticMethod.convertModuleOpeNoToOpeNo(aModuleNo,aModuleOpeNo);
            for (int i = 0; i < CimArrayUtils.getSize(out2); i++) {
                if (CimStringUtils.equals(aOperationNumber, out2.get(i).getOperationNumber())) {
                    throw new ServiceException(new OmCode(retCodeConfig.getFutureholdOnBranch(), lotID.getValue(), out2.get(i).getRouteID().getValue(), aOperationNumber));
                }
            }
            aModulePOS = aProcessFlowContext.getNextProcessOperationSpecificationOnCurrentRouteFor(aMainPF, aModuleNo, aModulePF, aModulePOS, outMainPF, outModuleNo, outModulePF);
            aModuleNo = outModuleNo.get();
            aMainPF = outMainPF.get();
            aModulePF = outModulePF.get();
        }
    }

    @Override
    public void lotFlowBatchCheckLocate(Infos.ObjCommon objCommon, Boolean locateDirection, ObjectIdentifier lotID, Infos.ProcessRef processRef) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);

        com.fa.cim.newcore.bo.dispatch.CimFlowBatch flowBatch = lot.getFlowBatch();
        String aTmpString = processRef.getModulePOS();
        com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification destProcessOperationSpecification = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification.class, aTmpString);
        Validations.check(destProcessOperationSpecification == null, retCodeConfig.getNotFoundPos());

        ProcessDTO.PosFlowBatchControl flowBatchControl = destProcessOperationSpecification.getFlowBatchControl();
        Boolean bDestEntryOperation = destProcessOperationSpecification.isFlowBatchEntryOperation();
        if (flowBatch == null) {
            if (!CimObjectUtils.isEmpty(flowBatchControl.getName())) {
                log.debug("flow batch control name is not null !");
                if (CimBooleanUtils.isFalse(bDestEntryOperation)) {
                    throw new ServiceException(retCodeConfig.getNotLocateToBatchOpe());
                }
            }
        } else {
            if(!CimObjectUtils.isEmpty(flowBatchControl.getName())) {
                com.fa.cim.newcore.bo.pd.CimProcessOperation aPO = lot.getProcessOperation();
                Validations.check(null == aPO, retCodeConfig.getNotFoundOperation());

                com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aPOS = aPO.getModuleProcessOperationSpecification();
                Validations.check(null == aPOS , retCodeConfig.getNotFoundPos());

                ProcessDTO.PosFlowBatchControl currentFlowBatch = aPO.getFlowBatchControl();
                String currentModuleNo = aPO.getModuleNumber();

                com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = lot.getProcessFlowContext();
                Validations.check(null == aPFX , retCodeConfig.getNotFoundPfx());

                com.fa.cim.newcore.bo.pd.CimProcessFlow processFlow = aPFX.getMainProcessFlow();
                Validations.check(null == processFlow , retCodeConfig.getNotFoundProcessFlow());

                ProcessDefinition aRootProcessDefinition = processFlow.getRootProcessDefinition();
                Validations.check(null == aRootProcessDefinition , retCodeConfig.getNotFoundProcessDefinition());

                String strRootName = aRootProcessDefinition.getIdentifier();

                String generatedFlowBatchName = strRootName;
                generatedFlowBatchName += BizConstant.SP_POSPROCESSOPERATIONSPECIFICATION_SEPARATOR_CHAR;
                generatedFlowBatchName += currentModuleNo;
                generatedFlowBatchName += BizConstant.SP_POSPROCESSOPERATIONSPECIFICATION_SEPARATOR_CHAR;
                generatedFlowBatchName += flowBatchControl.getName();
                flowBatchControl.setName(generatedFlowBatchName);

                if(CimStringUtils.equals(flowBatchControl.getName(), currentFlowBatch.getName())
                        && CimStringUtils.equals(currentModuleNo, processRef.getModuleNumber())){

                    com.fa.cim.newcore.bo.pd.CimProcessFlow aPF = aPFX.getModuleProcessFlow();
                    Validations.check(null == aPF , retCodeConfig.getNotFoundProcessFlow());

                    String destModuleOpeNo = destProcessOperationSpecification.getOperationNumber();

                    /*--------------------*/
                    /*   Locate Forward   */
                    /*--------------------*/
                    if(CimBooleanUtils.isTrue(locateDirection)){
                        Boolean bTargetOperation = aPOS .isFlowBatchTargetOperation();
                        Validations.check(CimBooleanUtils.isTrue(bTargetOperation) , retCodeConfig.getNotLocateToOverTarget());

                        com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification  nextPOS = null;
                        while (true){
                            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outPF = new AtomicReference<>();
                            nextPOS = aPF.nextProcessOperationSpecification(aPOS , outPF);

                            if (nextPOS == null) {
                                break;
                            }
                            String nextModuleOpeNo = nextPOS.getOperationNumber();

                            if(CimStringUtils.equals(nextModuleOpeNo, destModuleOpeNo)){
                                break;
                            }

                            bTargetOperation = nextPOS.isFlowBatchTargetOperation();
                            Validations.check(CimBooleanUtils.isTrue(bTargetOperation) , retCodeConfig.getNotLocateToOverTarget());

                            aPF = outPF.get();
                            aPOS  = nextPOS;
                        }
                    } else {
                        com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification prevPOS = null;
                        if (CimBooleanUtils.isTrue(bDestEntryOperation)) {
                            Boolean bContainTarget = false;
                            while (true){
                                AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outPF = new AtomicReference<>();
                                prevPOS = aPF.previousProcessOperationSpecification(aPOS, outPF);
                                if(prevPOS == null){
                                    break;
                                }
                                String prevModuleOpeNo = prevPOS.getOperationNumber();
                                Boolean bTargetOperation = prevPOS.isFlowBatchTargetOperation();
                                if(CimBooleanUtils.isTrue(bTargetOperation)){
                                    bContainTarget = true;
                                    break;
                                }
                                if(CimStringUtils.equals(prevModuleOpeNo, destModuleOpeNo)){
                                    break;
                                }

                                aPF = outPF.get();
                                aPOS  = prevPOS;
                            }
                            Validations.check(CimBooleanUtils.isTrue(bContainTarget), retCodeConfig.getLotRemoveFromBatch());

                        } else {
                            while (true){
                                AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outPF = new AtomicReference<>();
                                prevPOS = aPF.previousProcessOperationSpecification(aPOS, outPF);
                                if(prevPOS == null){
                                    break;
                                }
                                String prevModuleOpeNo = prevPOS.getOperationNumber();
                                Boolean bTargetOperation = prevPOS.isFlowBatchTargetOperation();
                                Validations.check(CimBooleanUtils.isTrue(bTargetOperation) , retCodeConfig.getNotLocateToOverTarget());

                                if(CimStringUtils.equals(prevModuleOpeNo, destModuleOpeNo)){
                                    break;
                                }

                                aPF = outPF.get();
                                aPOS  = prevPOS;
                            }
                        }
                    }
                } else {
                    if(CimBooleanUtils.isFalse(bDestEntryOperation)){
                        Validations.check(retCodeConfig.getNotLocateToBatchOpe());
                    } else {
                        Validations.check(retCodeConfig.getLotRemoveFromBatch());
                    }
                }
            } else {
                Validations.check(retCodeConfig.getLotRemoveFromBatch());
            }
        }
    }

    @Override
    public String lotContentsGet(ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        if (lot == null) {
            log.info("Not found lot in Database by {}", lotID.getValue());
            throw new ServiceException(retCodeConfig.getNotFoundLot());
        }

        return lot.getLotContents();
    }

    @Override
    public String lotProductionStateGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        log.info("【Method Entry】lotProductionStateGet()");
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        if (aLot == null) {
            log.info("Not found lot by {}", lotID.getValue());
            throw new ServiceException(retCodeConfig.getNotFoundLot());
        }
        log.info("【Method Exit】lotProductionStateGet()");
        return aLot.getLotProductionState();
    }

    @Override
    public String lotFinishedStateGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        log.debug("【Method Entry】lotFinishedStateGet()");

        CimLot lotBO = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lotBO), retCodeConfig.getNotFoundLot());
        log.debug("【Method Exit】lotFinishedStateGet()");

        return lotBO.getLotFinishedState();
    }

    @Override
    public String lotProcessStateGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        log.info("【Method Entry】lotProcessStateGet()");
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(lot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        return lot.getLotProcessState();
    }

    @Override
    public List<Infos.LotWaferMap> lotWaferMapGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        log.info("【Method Entry】lotWaferMapGet()");

        // Retrieve object reference of  PosLot from input parameter;
        log.info("lotWaferMapGet():Retrieve object reference of PosLot from input parameter");
        CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(aPosLot),retCodeConfig.getNotFoundLot());

        // Get all wafer object reference;
        log.info("Get all wafer object reference");

        List<Material> allMaterials = aPosLot.allMaterial();

        // Set length of output structure;
        int lenMaterialSeq = CimArrayUtils.getSize(allMaterials);
        log.info("lotWaferMapGet(): Set length of output structure = {}", lenMaterialSeq);
        List<Infos.LotWaferMap> lotWaferMapList = new ArrayList<>();
        for (int i = 0; i < lenMaterialSeq; i++) {
            CimWafer aPosWafer = (CimWafer) allMaterials.get(i);
            Validations.check(CimObjectUtils.isEmpty(aPosWafer),retCodeConfig.getNotFoundWafer());

            MaterialContainer materialContainer = aPosWafer.getMaterialContainer();
            com.fa.cim.newcore.bo.durable.CimCassette aPosCassette = (com.fa.cim.newcore.bo.durable.CimCassette) materialContainer;
            Infos.LotWaferMap lotWaferMapOut = new Infos.LotWaferMap();
            if (aPosCassette != null) {
                lotWaferMapOut.setCassetteID(new ObjectIdentifier(aPosCassette.getIdentifier(), aPosCassette.getPrimaryKey()));
            }
            lotWaferMapOut.setLotID(lotID);
            if (aPosWafer != null){
                lotWaferMapOut.setWaferID(new ObjectIdentifier(aPosWafer.getIdentifier(), aPosWafer.getPrimaryKey()));
            }
            lotWaferMapOut.setSlotNumber(aPosWafer.getPosition());
            lotWaferMapOut.setControlWaferFlag(aPosWafer.isControlWafer());
            lotWaferMapList.add(lotWaferMapOut);
        }

        log.info("【Method Exit】lotWaferMapGet()");
        return lotWaferMapList;
    }

    @Override
    public ObjectIdentifier lotCassetteGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        if (log.isDebugEnabled())
            log.debug("getLotBO : {}", lotID);
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot(), lotID);
        return lotCassetteGet(objCommon, lot);
    }

    @Override
    public ObjectIdentifier lotCassetteGet(Infos.ObjCommon objCommon, CimLot lot) {
        if (CimObjectUtils.isEmpty(lot)) {
            throw new ServiceException(retCodeConfig.getNotFoundLot());
        }
        if (log.isDebugEnabled())
            log.debug("get materialContainers from lot");
        List<MaterialContainer> materialContainers = lot.materialContainers();
        if (log.isTraceEnabled())
            log.trace("ArrayUtils.isEmpty(materialContainers) : {}", CimArrayUtils.isEmpty(materialContainers));
        if (CimArrayUtils.isEmpty(materialContainers)) {
            if (log.isErrorEnabled())
                log.error("findAllMaterialContainers() != ok");
            throw new ServiceException(retCodeConfig.getNotFoundCst());

        }
        if (log.isDebugEnabled())
            log.debug("get cimCassette");
        CimCassette cimCassette = (CimCassette) materialContainers.get(0);
        ObjectIdentifier out;
        if (log.isTraceEnabled())
            log.trace("!ObjectUtils.isEmpty(cimCassette) : {}",!CimObjectUtils.isEmpty(cimCassette));
        if (!CimObjectUtils.isEmpty(cimCassette)){
            out = new ObjectIdentifier(cimCassette.getIdentifier(), cimCassette.getPrimaryKey());
        }else {
            out = new ObjectIdentifier("","");
        }
        return out;
    }

    @Override
    public String lotStateGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lot),retCodeConfig.getNotFoundLot(),ObjectIdentifier.fetchValue(lotID));
        return lot.getLotState();
    }

    @Override
    public void lotCheckLockHoldConditionForOperation(Infos.ObjCommon objCommon, List<ObjectIdentifier> lotIDs) {
        log.info("【Method Entry】lotCheckLockHoldConditionForOperation()");
        int lotIDLen = CimArrayUtils.getSize(lotIDs);
        if (0 == lotIDLen) {
            log.info("The in-parameter is invalid.");
            throw new ServiceException(retCodeConfig.getInvalidInputParam());
        }
        log.info("lotIDLen = {}", lotIDLen);
        for (int i = 0; i < lotIDLen; i++) {
            // Get the lot's hold list.
            log.info("Get the lot's hold list. The lot is {} ", lotIDs.get(i));
            List<Infos.LotHoldListAttributes> lotHoldListAttributesRetCode = null;
            try {
                lotHoldListAttributesRetCode = this.lotFillInTxTRQ005DR(objCommon, lotIDs.get(i));
            } catch (ServiceException e) {
                if (!Validations.isEquals(retCodeConfig.getNotFoundEntry(), e.getCode())) {
                    log.info("lotFillInTxTRQ005DR() return {}", e.getCode());
                    throw e;
                }
            }
            // Check LOCK Hold.Check WDCH Hold.
            int lotRsnCnt = CimArrayUtils.getSize(lotHoldListAttributesRetCode);
            log.info("lotFillInTxTRQ005DR() return {} LotHoldListAttributes", lotRsnCnt);
            for (int j = 0; j < lotRsnCnt; j++) {
                Infos.LotHoldListAttributes lotHoldListAttributes = lotHoldListAttributesRetCode.get(j);
                if (ObjectIdentifier.equalsWithValue(lotHoldListAttributes.getReasonCodeID(), BizConstant.SP_REASON_LOTLOCK)) {
                    log.info("Find LOCK Hold lot. Cannot perform the operation... ");
                    throw new ServiceException(new OmCode(retCodeConfig.getPostprocLockHold(), lotIDs.get(i).getValue()));
                }
                if (ObjectIdentifier.equalsWithValue(lotHoldListAttributes.getReasonCodeID(), BizConstant.SP_REASON_WAITINGFORDATACOLLECTIONHOLD)) {
                    log.info("Find WDCH Hold lot. Cannot perform the operation... ");
                    throw new ServiceException(new OmCode(retCodeConfig.getWaitingForDataCollection(), lotIDs.get(i).getValue()));
                }
            }

        }
        log.info("【Method Exit】lotCheckLockHoldConditionForOperation()");
    }

    @Override
    public void lotHoldListCheckReworkCancel(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID, ObjectIdentifier childLotID) {
        log.info("【Method Entry】lotHoldListCheckReworkCancel()");
        CimLot aParentLot = baseCoreFactory.getBO(CimLot.class, parentLotID);
        Validations.check(aParentLot == null, retCodeConfig.getNotFoundLot());

        CimLot aChildLot = baseCoreFactory.getBO(CimLot.class, childLotID);
        Validations.check(aChildLot == null, retCodeConfig.getNotFoundLot());

        String parentLotHoldState = aParentLot.getLotHoldState();
        String childLotHoldState = aChildLot.getLotHoldState();
        if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, parentLotHoldState) &&
                CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, childLotHoldState)) {
            //ok
            return;
        } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, parentLotHoldState) &&
                CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, childLotHoldState)) {
            log.info("invalid lot hold state...");
            Validations.check(true, retCodeConfig.getInvalidLotHoldStat(),childLotID,childLotHoldState);

        } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, parentLotHoldState) &&
                CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, childLotHoldState)) {
            log.info("Only Parent lot is held, so cancellation is allowed.");
        } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, parentLotHoldState) &&
                CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD, childLotHoldState)) {
            List<ProductDTO.HoldRecord> childLotHoldRecords = aChildLot.allHoldRecords();
            int holdRecLen = CimArrayUtils.getSize(childLotHoldRecords);
            for (int holdRecCnt = 0; holdRecCnt < holdRecLen; holdRecCnt++) {
                ProductDTO.HoldRecord targetHoldRecord = new ProductDTO.HoldRecord();
                targetHoldRecord.setHoldType(childLotHoldRecords.get(holdRecCnt).getHoldType());
                targetHoldRecord.setReasonCode(childLotHoldRecords.get(holdRecCnt).getReasonCode());
                targetHoldRecord.setHoldPerson(childLotHoldRecords.get(holdRecCnt).getHoldPerson());
                if (!ObjectIdentifier.isEmpty(childLotHoldRecords.get(holdRecCnt).getRelatedLot())) {
                    if (ObjectIdentifier.equalsWithValue(childLotHoldRecords.get(holdRecCnt).getRelatedLot().getValue(), parentLotID)) {
                        targetHoldRecord.setRelatedLot(childLotID);
                    } else {
                        targetHoldRecord.setRelatedLot(childLotHoldRecords.get(holdRecCnt).getRelatedLot());
                    }
                } else {
                    targetHoldRecord.setRelatedLot(new ObjectIdentifier("",""));
                }

                ProductDTO.HoldRecord holdRecord = aParentLot.findHoldRecord(targetHoldRecord);
                if (holdRecord == null || CimObjectUtils.isEmpty(holdRecord.getHoldType())) {
                    log.info("Child lot has original Hold Record, so cancellation is not allowed.");
                    Validations.check(true, retCodeConfig.getHoldRecordOfChildOwn());
                }
            }
        } else {
            log.info("Hold State of Parent/Child lot is invalid: parentLotHoldState = {},childLotHoldState = {}", parentLotHoldState, childLotHoldState);
            Validations.check(true, retCodeConfig.getInvalidInputParam());
        }

        log.info("【Method Exit】lotHoldListCheckReworkCancel()");
    }

    @Override
    public ObjectIdentifier lotFlowBatchIDGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot(), lotID);
        return lotFlowBatchIDGet(objCommon, lot);
    }

    @Override
    public ObjectIdentifier lotFlowBatchIDGet(Infos.ObjCommon objCommon, CimLot lot) {
        if (log.isInfoEnabled())
            log.info("【Method Entry】lotFlowBatchIDGet()");
        CimFlowBatch aFlowbatch = lot.getFlowBatch();
        Validations.check(null == aFlowbatch, retCodeConfig.getLotFlowBatchIdBlank());
        if (log.isInfoEnabled())
            log.info("aFlowBatch is not nil");
        ObjectIdentifier flowBatchID = new ObjectIdentifier(aFlowbatch.getIdentifier(), aFlowbatch.getPrimaryKey());
        throw new ServiceException(new OmCode(retCodeConfig.getLotFlowBatchIdFilled()), flowBatchID);
    }

    @Override
    public Outputs.ObjLotHoldRecordEffectSpecCheckResultOut lotHoldRecordEffectSpecCheckResult(Outputs.ObjLotHoldRecordEffectSpecCheckResultOut outData,
                                                                                               Infos.ObjCommon objCommon,
                                                                                               List<Infos.StartCassette> startCassetteList,
                                                                                               List<Infos.InterFabMonitorGroupActionInfo> interFabMonitorGroupActionInfoList,
                                                                                               List<Results.DCActionLotResult> dcActionLotResultList) {
        Outputs.ObjLotHoldRecordEffectSpecCheckResultOut data = outData == null ? new Outputs.ObjLotHoldRecordEffectSpecCheckResultOut() : outData;
        if (interFabMonitorGroupActionInfoList == null) {
            interFabMonitorGroupActionInfoList = new ArrayList<>();
        }
        if (dcActionLotResultList == null) {
            dcActionLotResultList = new ArrayList<>();
        }
        data.setInterFabMonitorGroupActionInfoList(interFabMonitorGroupActionInfoList);
        data.setDcActionLotResultList(dcActionLotResultList);
        List<Infos.LotHoldEffectList> lotHoldEffectLists = new ArrayList<>();
        data.setLotHoldEffectList(lotHoldEffectLists);

        boolean findLotFlag = false;
        boolean findHoldFlag = false;
        boolean findMonitoringLotFlag = false;
        List<ProductDTO.MonitoredLot> effectedLots = new ArrayList<>();
        Validations.check(CimArrayUtils.isEmpty(startCassetteList), retCodeConfig.getInvalidParameter());

        for (Infos.StartCassette startCassette : startCassetteList) {
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            if (CimArrayUtils.isEmpty(lotInCassetteList)) {
                continue;
            }
            for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                //Omit Not-OpeStart lot & Omit Non-DataCollection
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())
                        || CimArrayUtils.isEmpty(lotInCassette.getStartRecipe().getDcDefList())) {
                    continue;
                }
                //Get lot ojbect
                CimLot lot = baseCoreFactory.getBO(CimLot.class,lotInCassette.getLotID());
                //Get lot's processOperation.
                CimProcessOperation po = null;
                //Current PO or Previous PO ? ,lot_CheckConditionForPO
                Boolean lotCheckConditionForPoOut = lotCheckConditionForPO(objCommon, lotInCassette.getLotID());

                if (CimBooleanUtils.isTrue(lotCheckConditionForPoOut)) {
                    //Get PO from Current Operation.
                    po = lot.getProcessOperation();
                } else {
                    //Get PO from Previous Operation.
                    po = lot.getPreviousProcessOperation();
                }
                Validations.check(null == po, retCodeConfig.getNotFoundProcessOperation());

                boolean requestOtherFabFlag = false;
                boolean findMeasurementLotFlag = false;
                int dcActionLotIndex = 0;
                String currentFabID = po.getFabID();
                String generatedFabID = null;
                /*
                 Set always the input lot to effectedLots[0]
                 even if lot is monitor lot or not.
                 */
                ProductDTO.MonitoredLot monitoredLot = new ProductDTO.MonitoredLot();
                effectedLots.add(monitoredLot);
                monitoredLot.setLotID(lotInCassette.getLotID());
                monitoredLot.setProcessOperation(po.getPrimaryKey());
                /*
                Check Monitor Grouping existnce
                If not existed, the input lot is not monitor lot.
                If existed, the input lot is monitor lot.
                 */
                //Check Monitor Grouping existnce
                CimMonitorGroup monitorGroup = lot.getControlMonitorGroup();
                //When Monitor Grouping is existed get get all related lots.
                if (monitorGroup != null) {
                    log.info("lotHoldRecordEffectSpecCheckResult(): When Monitor Grouping is existed get get all related lots.");
                    List<ProductDTO.MonitoredLot> monitoredLots = monitorGroup.allLots();
                    if (!CimArrayUtils.isEmpty(monitoredLots)) {
                        effectedLots.addAll(monitoredLots);
                    }
                    generatedFabID = monitorGroup.getGeneratedFabID();
                    if (!CimStringUtils.isEmpty(currentFabID) && !CimStringUtils.isEmpty(generatedFabID) && !CimStringUtils.equals(currentFabID, generatedFabID)) {
                        requestOtherFabFlag = true;
                    }
                }
                List<Infos.DataCollectionInfo> dcDefList = lotInCassette.getStartRecipe().getDcDefList();
                for (Infos.DataCollectionInfo dcDef : dcDefList) {
                    //Check actionCode
                    String reasonCode = "";
                    List<Infos.DataCollectionItemInfo> dcItemList = dcDef.getDcItems();
                    if (CimArrayUtils.isEmpty(dcItemList)) {
                        continue;
                    }
                    for (Infos.DataCollectionItemInfo dcItem : dcItemList) {
                        boolean lotHoldFlag = false;
                        if (CimStringUtils.isEmpty(dcItem.getActionCodes())) {
                            continue;
                        }
                        List<String> actionCodeList = Arrays.asList(dcItem.getActionCodes().split(","));
                        if (CimArrayUtils.isEmpty(actionCodeList)) {
                            continue;
                        }
                        for (String actionCode : actionCodeList) {
                            if (CimStringUtils.equals(actionCode, BizConstant.SP_ACTIONCODE_LOTHOLD)) {
                                lotHoldFlag = true;
                                break;
                            }
                        }
                        if (!lotHoldFlag) {
                            continue;
                        }
                        //Check specCheckResult and set reasonCode / messageReason
                        Map<String, String> reasonCodeMapping = new HashMap<>();
                        reasonCodeMapping.put(BizConstant.SP_SPECCHECKRESULT_UPPERCONTROLLIMIT, BizConstant.SP_REASON_SPECOVERHOLD_UPPERCONTROL);
                        reasonCodeMapping.put(BizConstant.SP_SPECCHECKRESULT_LOWERCONTROLLIMIT, BizConstant.SP_REASON_SPECOVERHOLD_LOWERCONTROL);
                        reasonCodeMapping.put(BizConstant.SP_SPECCHECKRESULT_UPPERSPECLIMIT, BizConstant.SP_REASON_SPECOVERHOLD_UPPERSPEC);
                        reasonCodeMapping.put(BizConstant.SP_SPECCHECKRESULT_LOWERSPECLIMIT, BizConstant.SP_REASON_SPECOVERHOLD_LOWERSPEC);
                        reasonCodeMapping.put(BizConstant.SP_SPECCHECKRESULT_UPPERSCREENLIMIT, BizConstant.SP_REASON_SPECOVERHOLD_UPPERSCREEN);
                        reasonCodeMapping.put(BizConstant.SP_SPECCHECKRESULT_LOWERSCREENLIMIT, BizConstant.SP_REASON_SPECOVERHOLD_LOWERSCREEN);
                        reasonCodeMapping.put(BizConstant.SP_SPECCHECKRESULT_APCERROR, BizConstant.SP_REASON_APCERRORHOLD);
                        if (reasonCodeMapping.containsKey(dcItem.getSpecCheckResult())) {
                            reasonCode = reasonCodeMapping.get(dcItem.getSpecCheckResult());
                        } else {
                            reasonCode = BizConstant.SP_REASON_SPECOVERHOLD;
                        }
                        boolean findFlag = false;
                        String lotState = null;
                        int interFabMonIndex = 0;
                        if (requestOtherFabFlag) {
                            findMonitoringLotFlag = false;
                            if (CimArrayUtils.getSize(effectedLots) > 1) {
                                if (CimArrayUtils.getSize(interFabMonitorGroupActionInfoList) > 0) {
                                    // if monitoringLot already checked, no add
                                    for (Infos.InterFabMonitorGroupActionInfo interFabMonitorGroupActionInfo : interFabMonitorGroupActionInfoList) {
                                        if (CimStringUtils.equals(effectedLots.get(0).getLotID().getValue(), interFabMonitorGroupActionInfo.getMonitoringLotID().getValue())) {
                                            interFabMonIndex = interFabMonitorGroupActionInfoList.indexOf(interFabMonitorGroupActionInfo);
                                            findMonitoringLotFlag = true;
                                            break;
                                        }
                                    }
                                }
                                if (!findMonitoringLotFlag) {
                                    //create data for lotHold of monitoredLots
                                    interFabMonIndex = interFabMonitorGroupActionInfoList.size();
                                    Infos.InterFabMonitorGroupActionInfo interFabMonitorGroupActionInfo = new Infos.InterFabMonitorGroupActionInfo();
                                    interFabMonitorGroupActionInfoList.add(interFabMonitorGroupActionInfo);
                                    interFabMonitorGroupActionInfo.setFabID(generatedFabID);
                                    interFabMonitorGroupActionInfo.setMonitoringLotID(effectedLots.get(0).getLotID());
                                }
                            }
                        }
                        //Get index of dcActionLot
                        if (!findMeasurementLotFlag) {
                            for (Results.DCActionLotResult dcActionLotResult : dcActionLotResultList) {
                                if (CimStringUtils.equals(dcActionLotResult.getMeasurementLotID().getValue(), effectedLots.get(0).getLotID().getValue())) {
                                    dcActionLotIndex = dcActionLotResultList.indexOf(dcActionLotResult);
                                    findMeasurementLotFlag = true;
                                    break;
                                }
                            }
                            if (!findMeasurementLotFlag) {
                                //create data for DCActionLotResults
                                dcActionLotIndex = dcActionLotResultList.size();
                                Results.DCActionLotResult dcActionLotResult = new Results.DCActionLotResult();
                                dcActionLotResultList.add(dcActionLotResult);
                                dcActionLotResult.setMeasurementLotID(effectedLots.get(0).getLotID());
                                findMeasurementLotFlag = true;
                            }
                        }
                        //Add LotHoldRecord to out trx
                        /*List<Infos.LotHoldEffectList> lotHoldEffectLists = new ArrayList<>();
                        data.setLotHoldEffectList(lotHoldEffectLists);*/
                        for (ProductDTO.MonitoredLot effectedLot : effectedLots) {
                            /*
                            Make strLotHoldEffectList for the input Lots included in strStartCassette.
                                (The input lot is stored in effectedLots[0].lotID)
                            Set SP_ResponsibleOperation_Previous to strLotHoldEffectList.responsibleOperationMark.
                             */
                            int effectedLotIndex = effectedLots.indexOf(effectedLot);
                            if (effectedLotIndex == 0) {
                                findFlag = false;
                                /*
                                Check if strLotHoldEffectList is already registed with the same lotID & reasonCode or not.
                                If only not existed, entry new inhibition.
                                 */
                                List<Infos.LotHoldEffectList> lotHoldEffectList = data.getLotHoldEffectList();
                                if (!CimArrayUtils.isEmpty(lotHoldEffectList)) {
                                    for (Infos.LotHoldEffectList holdEffectList : lotHoldEffectList) {
                                        if (CimStringUtils.equals(holdEffectList.getReasonCodeID().getValue(), reasonCode)
                                                && CimStringUtils.equals(holdEffectList.getLotID().getValue(), effectedLots.get(0).getLotID().getValue())) {
                                            findFlag = true;
                                        }
                                    }
                                }
                                if (!findFlag) {
                                    Infos.LotHoldEffectList lotHoldEffectListItem = new Infos.LotHoldEffectList();
                                    data.getLotHoldEffectList().add(lotHoldEffectListItem);
                                    lotHoldEffectListItem.setLotID(effectedLots.get(0).getLotID());
                                    lotHoldEffectListItem.setHoldType(BizConstant.SP_HOLDTYPE_SPECOVERHOLD);
                                    lotHoldEffectListItem.setReasonCodeID(ObjectIdentifier.build(reasonCode, null));
                                    lotHoldEffectListItem.setUserID(objCommon.getUser().getUserID());
                                    lotHoldEffectListItem.setResponsibleOperationMark(lotCheckConditionForPoOut ? BizConstant.SP_RESPONSIBLEOPERATION_CURRENT : BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                                    lotHoldEffectListItem.setRouteID(ObjectIdentifier.build("", null));
                                    lotHoldEffectListItem.setOperationNumber("");
                                    lotHoldEffectListItem.setRelatedLotID(ObjectIdentifier.build("", null));
                                    lotHoldEffectListItem.setClaimMemo("");

                                    //Add ActionResultInfo
                                    Results.DCActionLotResult dcActionLotResult = dcActionLotResultList.get(dcActionLotIndex);
                                    List<Infos.DCActionResultInfo> dcActionResultInfos = dcActionLotResult.getDcActionResultInfo();
                                    if (dcActionResultInfos == null) {
                                        dcActionResultInfos = new ArrayList<>();
                                        dcActionLotResult.setDcActionResultInfo(dcActionResultInfos);
                                    }
                                    Infos.DCActionResultInfo dcActionResultInfo = new Infos.DCActionResultInfo();
                                    dcActionResultInfos.add(dcActionResultInfo);

                                    dcActionResultInfo.setLotID(effectedLots.get(0).getLotID());
                                    dcActionResultInfo.setMonitorLotFlag(false);
                                    dcActionResultInfo.setDcDefID(dcDef.getDataCollectionDefinitionID());
                                    dcActionResultInfo.setDcSpecID(dcDef.getDataCollectionSpecificationID());
                                    dcActionResultInfo.setCheckType(BizConstant.SP_ACTIONRESULT_CHECKTYPE_SPEC);
                                    dcActionResultInfo.setReasonCode(reasonCode);
                                    dcActionResultInfo.setActionCode(BizConstant.SP_ACTIONCODE_LOTHOLD);
                                    dcActionResultInfo.setCorrespondingObjRefPO("");
                                    dcActionResultInfo.setBankID("");
                                    dcActionResultInfo.setReworkRouteID("");
                                    dcActionResultInfo.setEntities(new ArrayList<>());
                                }
                            } else {
                                /*
                                Make strLotHoldEffectList and strFutureHoldEffectList of out parameter.
                                If PROCESSING, set to strFutureHoldEffectList.
                                Else set to strLotHoldEffectList
                                 */
                                if (!requestOtherFabFlag) {
                                    //Get lot status.If IN-PROCESSING
                                    CimLot aEffectedLot = baseCoreFactory.getBO(CimLot.class,effectedLot.getLotID());
                                    lotState = aEffectedLot.getLotProcessState();
                                    if (CimStringUtils.equals(lotState, BizConstant.SP_LOT_PROCSTATE_PROCESSING)) {
                                        findFlag = false;
                                        /*
                                        Check if strFutureHoldEffectList is already registed with the same lotID & reasonCode or not.
                                        If only not existed, entry new inhibition.
                                         */
                                        List<Infos.LotHoldEffectList> futureHoldEffectList = data.getFutureHoldEffectList();
                                        if (!CimArrayUtils.isEmpty(futureHoldEffectList)) {
                                            for (Infos.LotHoldEffectList lotHoldEffectList : futureHoldEffectList) {
                                                if (CimStringUtils.equals(lotHoldEffectList.getReasonCodeID().getValue(), reasonCode)
                                                        && CimStringUtils.equals(lotHoldEffectList.getLotID().getValue(), effectedLot.getLotID().getValue())) {
                                                    findFlag = true;
                                                }
                                            }
                                        }
                                        if (!findFlag) {
                                            com.fa.cim.newcore.bo.pd.CimProcessFlowContext pfx = aEffectedLot.getProcessFlowContext();
                                            Validations.check(null == pfx, retCodeConfig.getNotFoundPfx());

                                            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outMainProcessFlow=new AtomicReference<>();
                                            AtomicReference<String> outModuleNumber=new AtomicReference<>();
                                            AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> outModuleProcessFlow=new AtomicReference<>();
                                            com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification nextPOSOut = pfx.getNextProcessOperationSpecification(outMainProcessFlow,outModuleNumber,outModuleProcessFlow);

                                            com.fa.cim.newcore.bo.pd.CimProcessFlow nextPF = outMainProcessFlow.get();
                                            String moduleNo = outModuleNumber.get();
                                            com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification nextPOS = nextPOSOut;
                                            com.fa.cim.newcore.bo.pd.CimProcessFlow modulePF = outModuleProcessFlow.get();
                                            Validations.check(null == nextPOS, retCodeConfig.getNotFoundPos());

                                            com.fa.cim.newcore.bo.pd.CimProcessFlow pf = pfx.getProcessFlow();
                                            Validations.check(null == pf, retCodeConfig.getNotFoundProcessFlow());

                                            ProcessDefinition targetRouteID = pf.getRootProcessDefinition();
                                            com.fa.cim.newcore.bo.pd.CimProcessOperation effectedPO = aEffectedLot.getProcessOperation();
                                            Validations.check(null == effectedPO, retCodeConfig.getNotFoundOperation());

                                            String targetOperationNumber = effectedPO.getOperationNumber();

                                            //Add futureholdRecord to out trx
                                            if (futureHoldEffectList == null) {
                                                futureHoldEffectList = new ArrayList<>();
                                                data.setFutureHoldEffectList(futureHoldEffectList);
                                            }
                                            Infos.LotHoldEffectList lotHoldEffectListItem = new Infos.LotHoldEffectList();
                                            futureHoldEffectList.add(lotHoldEffectListItem);
                                            lotHoldEffectListItem.setLotID(effectedLot.getLotID());
                                            lotHoldEffectListItem.setHoldType(BizConstant.SP_HOLDTYPE_SPECOVERHOLD);
                                            lotHoldEffectListItem.setReasonCodeID(ObjectIdentifier.build(reasonCode, null));
                                            lotHoldEffectListItem.setUserID(objCommon.getUser().getUserID());
                                            lotHoldEffectListItem.setResponsibleOperationMark(lotCheckConditionForPoOut ? BizConstant.SP_RESPONSIBLEOPERATION_CURRENT : BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                                            lotHoldEffectListItem.setRouteID(ObjectIdentifier.build(targetRouteID.getIdentifier(), targetRouteID.getPrimaryKey()));
                                            lotHoldEffectListItem.setOperationNumber(targetOperationNumber);
                                            lotHoldEffectListItem.setRelatedLotID(ObjectIdentifier.build("", null));
                                            lotHoldEffectListItem.setClaimMemo("");

                                            //Add ActionResultInfo
                                            Results.DCActionLotResult dcActionLotResult = dcActionLotResultList.get(dcActionLotIndex);
                                            List<Infos.DCActionResultInfo> dcActionResultInfos = dcActionLotResult.getDcActionResultInfo();
                                            if (dcActionResultInfos == null) {
                                                dcActionResultInfos = new ArrayList<>();
                                                dcActionLotResult.setDcActionResultInfo(dcActionResultInfos);
                                            }
                                            Infos.DCActionResultInfo dcActionResultInfo = new Infos.DCActionResultInfo();
                                            dcActionResultInfos.add(dcActionResultInfo);

                                            dcActionResultInfo.setLotID(effectedLot.getLotID());
                                            dcActionResultInfo.setMonitorLotFlag(true);
                                            dcActionResultInfo.setDcDefID(dcDef.getDataCollectionDefinitionID());
                                            dcActionResultInfo.setDcSpecID(dcDef.getDataCollectionSpecificationID());
                                            dcActionResultInfo.setCheckType(BizConstant.SP_ACTIONRESULT_CHECKTYPE_SPEC);
                                            dcActionResultInfo.setReasonCode(reasonCode);
                                            dcActionResultInfo.setActionCode(BizConstant.SP_ACTIONCODE_LOTHOLD);
                                            dcActionResultInfo.setCorrespondingObjRefPO("");
                                            dcActionResultInfo.setBankID("");
                                            dcActionResultInfo.setReworkRouteID("");
                                            dcActionResultInfo.setEntities(new ArrayList<>());
                                        }
                                    } else {
                                        //If Except IN-PROCESSING
                                        findFlag = false;
                                        /*
                                        Check if strLotHoldEffectList is already registed with the same lotID & reasonCode or not.
                                        If only not existed, entry new inhibition.
                                         */
                                        List<Infos.LotHoldEffectList> lotHoldEffectList = data.getLotHoldEffectList();
                                        if (!CimArrayUtils.isEmpty(lotHoldEffectList)) {
                                            for (Infos.LotHoldEffectList holdEffectList : lotHoldEffectList) {
                                                if (CimStringUtils.equals(holdEffectList.getReasonCodeID().getValue(), reasonCode)
                                                        && CimStringUtils.equals(holdEffectList.getLotID().getValue(), effectedLot.getLotID().getValue())) {
                                                    findFlag = true;
                                                }
                                            }
                                        }
                                        if (!findFlag) {
                                            //Add LotHoldRecord to out trx
                                            Infos.LotHoldEffectList lotHoldEffectListItem = new Infos.LotHoldEffectList();
                                            data.getLotHoldEffectList().add(lotHoldEffectListItem);
                                            lotHoldEffectListItem.setLotID(effectedLot.getLotID());
                                            lotHoldEffectListItem.setHoldType(BizConstant.SP_HOLDTYPE_SPECOVERHOLD);
                                            lotHoldEffectListItem.setReasonCodeID(ObjectIdentifier.build(reasonCode, null));
                                            lotHoldEffectListItem.setUserID(objCommon.getUser().getUserID());
                                            lotHoldEffectListItem.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                                            lotHoldEffectListItem.setRouteID(ObjectIdentifier.build("", null));
                                            lotHoldEffectListItem.setOperationNumber("");
                                            lotHoldEffectListItem.setRelatedLotID(ObjectIdentifier.build("", null));
                                            lotHoldEffectListItem.setClaimMemo("");

                                            //Add ActionResultInfo
                                            Results.DCActionLotResult dcActionLotResult = dcActionLotResultList.get(dcActionLotIndex);
                                            List<Infos.DCActionResultInfo> dcActionResultInfos = dcActionLotResult.getDcActionResultInfo();
                                            if (dcActionResultInfos == null) {
                                                dcActionResultInfos = new ArrayList<>();
                                                dcActionLotResult.setDcActionResultInfo(dcActionResultInfos);
                                            }
                                            Infos.DCActionResultInfo dcActionResultInfo = new Infos.DCActionResultInfo();
                                            dcActionResultInfos.add(dcActionResultInfo);

                                            dcActionResultInfo.setLotID(effectedLot.getLotID());
                                            dcActionResultInfo.setMonitorLotFlag(true);
                                            dcActionResultInfo.setDcDefID(dcDef.getDataCollectionDefinitionID());
                                            dcActionResultInfo.setDcSpecID(dcDef.getDataCollectionSpecificationID());
                                            dcActionResultInfo.setCheckType(BizConstant.SP_ACTIONRESULT_CHECKTYPE_SPEC);
                                            dcActionResultInfo.setReasonCode(reasonCode);
                                            dcActionResultInfo.setActionCode(BizConstant.SP_ACTIONCODE_LOTHOLD);
                                            dcActionResultInfo.setCorrespondingObjRefPO("");
                                            dcActionResultInfo.setBankID("");
                                            dcActionResultInfo.setReworkRouteID("");
                                            dcActionResultInfo.setEntities(new ArrayList<>());
                                        }
                                    }
                                } else {
                                    findLotFlag = false;
                                    findHoldFlag = false;
                                    int lotHoldIdx = 0;
                                    //Create HoldRecord for other Fab
                                    Infos.InterFabMonitorGroupActionInfo interFabMonitorGroupActionInfo = interFabMonitorGroupActionInfoList.get(interFabMonIndex);
                                    List<Infos.MonitoredLotHoldInfo> monitoredLotHoldInfoList = interFabMonitorGroupActionInfo.getMonitoredLotHoldInfoList();
                                    if (!CimArrayUtils.isEmpty(monitoredLotHoldInfoList)) {
                                        for (Infos.MonitoredLotHoldInfo monitoredLotHoldInfo : monitoredLotHoldInfoList) {
                                            if (CimStringUtils.equals(monitoredLotHoldInfo.getLotID().getValue(), effectedLot.getLotID().getValue())) {
                                                lotHoldIdx = monitoredLotHoldInfoList.indexOf(monitoredLotHoldInfo);
                                                findLotFlag = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (!findLotFlag) {
                                        //Add LotHoldRecord to out trx(request to other Fab)
                                        if (monitoredLotHoldInfoList == null) {
                                            monitoredLotHoldInfoList = new ArrayList<>();
                                            interFabMonitorGroupActionInfo.setMonitoredLotHoldInfoList(monitoredLotHoldInfoList);
                                        }
                                        lotHoldIdx = monitoredLotHoldInfoList.size();
                                        Infos.MonitoredLotHoldInfo monitoredLotHoldInfo = new Infos.MonitoredLotHoldInfo();
                                        monitoredLotHoldInfoList.add(monitoredLotHoldInfo);
                                        monitoredLotHoldInfo.setLotID(effectedLot.getLotID());
                                    }
                                    //check same message exist?
                                    Infos.MonitoredLotHoldInfo monitoredLotHoldInfo = monitoredLotHoldInfoList.get(lotHoldIdx);
                                    List<Infos.HoldInfo> holdInfoList = monitoredLotHoldInfo.getHoldInfoList();
                                    if (!CimArrayUtils.isEmpty(holdInfoList)) {
                                        for (Infos.HoldInfo holdInfo : holdInfoList) {
                                            if (CimStringUtils.equals(holdInfo.getReasonCode(), reasonCode)) {
                                                findHoldFlag = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (!findHoldFlag) {
                                        if (holdInfoList == null) {
                                            holdInfoList = new ArrayList<>();
                                            monitoredLotHoldInfo.setHoldInfoList(holdInfoList);
                                        }
                                        Infos.HoldInfo holdInfo = new Infos.HoldInfo();
                                        holdInfoList.add(holdInfo);
                                        holdInfo.setReasonCode(reasonCode);
                                        holdInfo.setHoldType(BizConstant.SP_HOLDTYPE_SPECOVERHOLD);

                                        //Add ActionResultInfo
                                        Results.DCActionLotResult dcActionLotResult = dcActionLotResultList.get(dcActionLotIndex);
                                        List<Infos.DCActionResultInfo> dcActionResultInfos = dcActionLotResult.getDcActionResultInfo();
                                        if (dcActionResultInfos == null) {
                                            dcActionResultInfos = new ArrayList<>();
                                            dcActionLotResult.setDcActionResultInfo(dcActionResultInfos);
                                        }
                                        Infos.DCActionResultInfo dcActionResultInfo = new Infos.DCActionResultInfo();
                                        dcActionResultInfos.add(dcActionResultInfo);

                                        dcActionResultInfo.setLotID(effectedLot.getLotID());
                                        dcActionResultInfo.setMonitorLotFlag(true);
                                        dcActionResultInfo.setDcDefID(dcDef.getDataCollectionDefinitionID());
                                        dcActionResultInfo.setDcSpecID(dcDef.getDataCollectionSpecificationID());
                                        dcActionResultInfo.setCheckType(BizConstant.SP_ACTIONRESULT_CHECKTYPE_SPEC);
                                        dcActionResultInfo.setReasonCode(reasonCode);
                                        dcActionResultInfo.setActionCode(BizConstant.SP_ACTIONCODE_LOTHOLD);
                                        dcActionResultInfo.setCorrespondingObjRefPO("");
                                        dcActionResultInfo.setBankID("");
                                        dcActionResultInfo.setReworkRouteID("");
                                        dcActionResultInfo.setEntities(new ArrayList<>());
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return data;
    }



    @Override
    public String lotInventoryStateGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());
        return lot.getLotInventoryState();
    }

    @Override
    public Outputs.ObjLotInPostProcessFlagOut lotInPostProcessFlagGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Outputs.ObjLotInPostProcessFlagOut out = new Outputs.ObjLotInPostProcessFlagOut();
        Validations.check(ObjectIdentifier.isEmpty(lotID), retCodeConfig.getInvalidInputParam());
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), "*****"));
        //-------------------------------------
        //  Get cassette which includes lot
        //-------------------------------------
        List<MaterialContainer> aMaterialContainerList = aLot.materialContainers();
        //-------------------------------------------
        //  Get InPostProcessFlag of Lot/Cassette
        //-------------------------------------------
        out.setInPostProcessFlagOfCassette(false);
        if (!CimObjectUtils.isEmpty(aMaterialContainerList)) {
            com.fa.cim.newcore.bo.durable.CimCassette aCassette = (com.fa.cim.newcore.bo.durable.CimCassette) aMaterialContainerList.get(0);
            if (null != aCassette) {
                out.setInPostProcessFlagOfCassette(aCassette.isPostProcessFlagOn());
            }
        }
        out.setInPostProcessFlagOfLot(!aLot.isDispatchReady());
        return out;
    }

    @Override
    public void lotInPostProcessFlagSet(Infos.ObjCommon objCommon, ObjectIdentifier lotID, boolean inPostProcessFlag) {
        /*---------------------------------------------------------------------------------*/
        /*   Not update cassette's post process flag in parallel post process execution.   */
        /*---------------------------------------------------------------------------------*/
        boolean bParallelPostProcFlag = false;
        String strParallelPostProcFlag = ThreadContextHolder.getThreadSpecificDataString(BizConstant.SP_THREADSPECIFICDATA_KEY_POSTPROCPARALLELFLAG);
        if (CimStringUtils.equals(strParallelPostProcFlag, BizConstant.SP_POSTPROCESS_PARALLELEXECUTION_ON)){
            bParallelPostProcFlag = true;
        }
        //---------------------------
        //  Check input parameter
        //---------------------------
        if (ObjectIdentifier.isEmptyWithValue(lotID)){
            throw new ServiceException(retCodeConfig.getInvalidInputParam());
        }
        //---------------------------------
        //  Convert lotID to lot object
        //---------------------------------
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        //-------------------------------------
        //  Get cassette which includes lot
        //-------------------------------------
        List<MaterialContainer> aMaterialContainerSequence = aLot.materialContainers();
        com.fa.cim.newcore.bo.durable.CimCassette aCassette = null;
        if (!CimArrayUtils.isEmpty(aMaterialContainerSequence)){
            aCassette = (com.fa.cim.newcore.bo.durable.CimCassette)aMaterialContainerSequence.get(0);
        }
        if (inPostProcessFlag){
            if (!bParallelPostProcFlag){
                if(aCassette != null){
                    boolean bPostProcessFlag = aCassette.isPostProcessFlagOn();
                    if (!bPostProcessFlag){
                        //---------------------------------------------
                        //  Set InPostProcessFlag of Cassette to ON
                        //---------------------------------------------
                        aCassette.makePostProcessFlagOn();
                    }
                }
            }
            //----------------------------------------
            //  Set InPostProcessFlag of Lot to ON
            //----------------------------------------
            aLot.makePostProcessFlagOn();
        } else {
            if (!bParallelPostProcFlag){
                if (aCassette != null){
                    //-------------------------------------------------------------
                    //  Check the other lots' InPostProcessFlag in the cassette
                    //-------------------------------------------------------------
                    List<Lot> aLotSequence = aCassette.allLots();
                    int nLotLen = CimArrayUtils.getSize(aLotSequence);
                    if (nLotLen > 1){
                        boolean foundFlag = false;
                        for (int i = 0; i < nLotLen; i++){
                            CimLot tmpLot = (CimLot) aLotSequence.get(i);
                            Validations.check(tmpLot == null, new OmCode(retCodeConfig.getNotFoundLot(), ""));
                            String aLotIdentifier = tmpLot.getIdentifier();
                            if (ObjectIdentifier.equalsWithValue(aLotIdentifier, lotID)){
                                continue;
                            }
                            boolean bPostProcessFlag = tmpLot.isPostProcessFlagOn();
                            if (bPostProcessFlag){
                                foundFlag = true;
                                break;
                            }
                        }
                        if (!foundFlag){
                            //----------------------------------------------
                            //  Set InPostProcessFlag of Cassette to OFF
                            //----------------------------------------------
                            aCassette.makePostProcessFlagOff();
                        }
                    } else {
                        //----------------------------------------------
                        //  Set InPostProcessFlag of Cassette to OFF
                        //----------------------------------------------
                        aCassette.makePostProcessFlagOff();
                    }
                }
            }
            //-----------------------------------------
            //  Set InPostProcessFlag of Lot to OFF
            //-----------------------------------------
            aLot.makePostProcessFlagOff();
        }
    }

    @Override
    public Outputs.ObjLotHoldRecordEffectSPCCheckResultOut lotHoldRecordEffectSPCCheckResult(Infos.ObjCommon objCommon,
                                                                                             List<Infos.SpcCheckLot> spcCheckLotList,
                                                                                             List<Infos.InterFabMonitorGroupActionInfo> interFabMonitorGroupActionInfoList,
                                                                                             List<Results.DCActionLotResult> dcActionLotResultList) {
        Outputs.ObjLotHoldRecordEffectSPCCheckResultOut lotHoldRecordEffectSPCCheckResultOut = new Outputs.ObjLotHoldRecordEffectSPCCheckResultOut();
        List<Infos.LotHoldEffectList> lotHoldEffectList = new ArrayList<>();
        int relMongCount = CimArrayUtils.getSize(interFabMonitorGroupActionInfoList);
        log.debug("relMongCount : {}", relMongCount);
        int dcActionLot_count = CimArrayUtils.getSize(dcActionLotResultList);
        log.debug("dcActionLot_count : {}", dcActionLot_count);

        int slLen = CimArrayUtils.getSize(spcCheckLotList);
        log.debug("strSpcCheckLot.length() : {}", slLen);

        int lotHold_count = 0;
        int FHold_count = 0;
        List<Infos.MonitoredLot> effectedLots = new ArrayList<>();

        boolean findLotFlag           = false;
        boolean findMonitoringLotFlag = false;

        for ( int i = 0; i < slLen; i++ ) {

            /*---------------------------*/
            /*   Omit Non-DataCollection */
            /*---------------------------*/
            if ( CimArrayUtils.getSize(spcCheckLotList.get(i).getSpcActionCode()) == 0 ) {
                continue;
            }

            //-----------------------------------------
            //  Get Lot ojbect
            //-----------------------------------------
            CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, spcCheckLotList.get(i).getLotID());

            //-----------------------------------------
            //  Get Lot's processOperation.
            //-----------------------------------------
            CimProcessOperation aPO;
            CimProcessOperation aPosPO;

            //-----------------------------------------
            // Current PO or Previous PO ?
            //-----------------------------------------
            Boolean strLotCheckConditionForPOOut = this.lotCheckConditionForPO(objCommon, spcCheckLotList.get(i).getLotID());

            if ( CimBooleanUtils.isTrue(strLotCheckConditionForPOOut)) {
                //--------------------------------------------------------------------------
                // Get PO from Current Operation.
                //--------------------------------------------------------------------------
                log.debug("Get PO from the current Operation.");
                aPO    = aPosLot.getProcessOperation();
                aPosPO = (CimProcessOperation)aPO;
            } else {
                //--------------------------------------------------------------------------
                // Get PO from Previous Operation.
                //--------------------------------------------------------------------------
                log.debug("Get PO from the previous Operation.");
                aPO = aPosLot.getPreviousProcessOperation();
                aPosPO = (CimProcessOperation)aPO;
            }
            Validations.check(aPosPO == null, new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****"));
            boolean requestOtherFabFlag = false;
            String generatedFabID = null;
            boolean findMeasurementLotFlag = false;
            int dcActionLot_idx = 0;
            int dcActionInfo_count = 0;
            String currentFabID = aPosPO.getFabID();

            //-------------------------------------------------------
            //  Set always the input Lot to effectedLots[0]
            //  even if lot is monitor lot or not.
            //-------------------------------------------------------
            Infos.MonitoredLot monitoredLot = new Infos.MonitoredLot();
            monitoredLot.setLotID(spcCheckLotList.get(i).getLotID());
            monitoredLot.setProcessOperation(spcCheckLotList.get(i).getProcessObjrefPO());
            effectedLots.add(monitoredLot);

            //-----------------------------------------------------------
            //  Check Monitor Grouping existnce
            //  If not existed, the input lot is not monitor lot.
            //  If existed, the input lot is monitor lot.
            //-----------------------------------------------------------

            //-----------------------------------------
            //  Check Monitor Grouping existnce
            //-----------------------------------------
            CimMonitorGroup aMonitorGroup = aPosLot.getControlMonitorGroup();

            if ( null ==  aMonitorGroup) {
                log.debug("null == (aMonitorGroup) : {}", i);
            }
            //----------------------------------------------------------------
            //  When Monitor Grouping is existed get get all related lots.
            //----------------------------------------------------------------
            else
            {
                log.debug("null != (aMonitorGroup) : {}", i);

                List<ProductDTO.MonitoredLot> monitoredLotsVar = aMonitorGroup.allLots();
                int nLenMonitoredLots = CimArrayUtils.getSize(monitoredLotsVar);
                for ( int j = 0; j < nLenMonitoredLots; j++ ) {
                    Infos.MonitoredLot monitoredLot1 = new Infos.MonitoredLot();
                    monitoredLot1.setLotID(monitoredLotsVar.get(j).getLotID());
                    monitoredLot1.setProcessOperation(monitoredLotsVar.get(j).getProcessOperation());
                    effectedLots.add(monitoredLot1);
                }
                generatedFabID = aMonitorGroup.getGeneratedFabID();

                log.debug("generatedFabID : {}", generatedFabID);
                if (CimStringUtils.isEmpty(generatedFabID)) {
                    log.debug("generatedFabID is null");
                }

                if( !CimStringUtils.isEmpty(generatedFabID) && !CimStringUtils.isEmpty(currentFabID)
                        && !CimStringUtils.equals(generatedFabID, currentFabID)) {
                    log.debug("currentFabID and generatedFabID is not same");
                    requestOtherFabFlag = true;
                }
            }

            //=========================================================================================
            // Check actionCode
            //=========================================================================================
            boolean lot_hold_flag = false;

            int mLen = CimArrayUtils.getSize(spcCheckLotList.get(i).getSpcActionCode());
            for ( int m = 0; m < mLen; m++ ) {

                if ( CimStringUtils.equals( spcCheckLotList.get(i).getSpcActionCode().get(m), BizConstant.SP_ACTIONCODE_LOTHOLD)) {
                    lot_hold_flag = true;
                    break;
                }
            }

            if (CimBooleanUtils.isFalse(lot_hold_flag)) {
                continue;
            }

            boolean findFlag = false;
            int n;
            int interFabMonIdx = 0;
            int lotHold_countForOtherFab = 0;

            int efLen = CimArrayUtils.getSize(effectedLots);
            if ( CimBooleanUtils.isTrue(requestOtherFabFlag)) {
                findMonitoringLotFlag = false;
                if ( efLen > 1 ) {
                    log.debug( "this lot has monitoredLots. : {}", effectedLots.get(0).getLotID());
                    if ( relMongCount > 0 ) {
                        // if monitoringLot already checked, no add
                        for (int m = 0; m < relMongCount; m++ ) {
                            if (ObjectIdentifier.equalsWithValue(effectedLots.get(0).getLotID(),
                                    interFabMonitorGroupActionInfoList.get(m).getMonitoringLotID())) {
                                log.debug("this monitoringLot already checked.");
                                interFabMonIdx = m;
                                lotHold_countForOtherFab = CimArrayUtils.getSize(interFabMonitorGroupActionInfoList.get(m).getMonitoredLotHoldInfoList());
                                findMonitoringLotFlag = true;
                                break;
                            }
                        }
                    }

                    if ( CimBooleanUtils.isFalse(findMonitoringLotFlag) ) {
                        log.debug("this lot(monitoring) has not been checked");
                        //------------------------------------------//
                        // create data for lotHold of monitoredLots //
                        //------------------------------------------//
                        Infos.InterFabMonitorGroupActionInfo interFabMonitorGroupActionInfo = new Infos.InterFabMonitorGroupActionInfo();
                        interFabMonitorGroupActionInfo.setFabID(generatedFabID);
                        interFabMonitorGroupActionInfo.setMonitoringLotID(effectedLots.get(0).getLotID());
                        interFabMonitorGroupActionInfoList.add(interFabMonitorGroupActionInfo);
                        interFabMonIdx = relMongCount;        //PSIV00001648
                        lotHold_countForOtherFab = 0;           //PSIV00001648
                        relMongCount++;
                    }
                }
            }

            //------------------------------------------//
            // Get index of dcActionLot                 //
            //------------------------------------------//
            if (CimBooleanUtils.isFalse(findMeasurementLotFlag)) {
                for ( int q = 0; q < dcActionLot_count; q++ ) {
                    if (ObjectIdentifier.equalsWithValue(effectedLots.get(0).getLotID(), dcActionLotResultList.get(q).getMeasurementLotID())){
                        log.debug("this measurementLot already checked for Action Result.");
                        dcActionLot_idx = q;
                        dcActionInfo_count = CimArrayUtils.getSize(dcActionLotResultList.get(q).getDcActionResultInfo());
                        findMeasurementLotFlag = true;
                        break;
                    }
                }

                if (CimBooleanUtils.isFalse(findMeasurementLotFlag)) {
                    log.debug("this lot(measurement) has not been checked for Action Result.");
                    //------------------------------------------//
                    // create data for DCActionLotResults       //
                    //------------------------------------------//
                    Results.DCActionLotResult dcActionLotResult = new Results.DCActionLotResult();
                    dcActionLotResult.setMeasurementLotID(effectedLots.get(0).getLotID());
                    dcActionLotResultList.add(dcActionLotResult);
                    dcActionLot_idx = dcActionLot_count;
                    dcActionLot_count++;
                    findMeasurementLotFlag = true;
                }
            }

            for (int m = 0; m < efLen; m++ ) {
                //------------------------------------------------------------------------------------------------
                //  Make strLotHoldEffectList and strFutureHoldEffectList of out parameter.
                //      (The input lot is stored in effectedLots[0].lotID)
                //  Set SP_ResponsibleOperation_Previous to strLotHoldEffectList.responsibleOperationMark.
                //
                //------------------------------------------------------------------------------------------------
                if ( m == 0 ) {
                    findFlag = false;
                    //-----------------------------------------------------------------------------------------
                    //  Check if strLotHoldEffectList is already registed with the same lotID & reasonCode or not.
                    //  If only not existed, entry new inhibition.
                    //-----------------------------------------------------------------------------------------
                    for ( n = 0; n < lotHold_count; n++ ) {
                        if(CimArrayUtils.isNotEmpty(lotHoldRecordEffectSPCCheckResultOut.getLotHoldEffectList())
                                && ObjectIdentifier.equalsWithValue(lotHoldRecordEffectSPCCheckResultOut.getLotHoldEffectList().get(n).getLotID(), effectedLots.get(0).getLotID())) {
                            findFlag = true;
                        }
                    }

                    if (CimBooleanUtils.isFalse(findFlag)) {
                        //-----------------------------------------------------------------------------
                        // Add LotHoldRecord to out trx
                        //-----------------------------------------------------------------------------
                        Infos.LotHoldEffectList lotHoldEffect = new Infos.LotHoldEffectList();
                        lotHoldEffect.setLotID(effectedLots.get(0).getLotID());
                        lotHoldEffect.setHoldType(BizConstant.SP_HOLDTYPE_SPCOUTOFRANGEHOLD);
                        lotHoldEffect.setReasonCodeID(ObjectIdentifier.build(BizConstant.SP_REASON_SPCOUTOFRANGEHOLD, null));
                        lotHoldEffect.setUserID(objCommon.getUser().getUserID());
                        lotHoldEffect.setResponsibleOperationMark(strLotCheckConditionForPOOut ? BizConstant.SP_RESPONSIBLEOPERATION_CURRENT : BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                        lotHoldEffectList.add(lotHoldEffect);
                        lotHold_count++;

                        //-----------------------------------------------------------------------------
                        // Add ActionResultInfo
                        //-----------------------------------------------------------------------------
                        List<Infos.DCActionResultInfo> dcActionLotResult = dcActionLotResultList.get(dcActionLot_idx).getDcActionResultInfo();
                        Infos.DCActionResultInfo  dcActionResultInfo = new Infos.DCActionResultInfo();
                        dcActionResultInfo.setLotID(effectedLots.get(0).getLotID());
                        dcActionResultInfo.setMonitorLotFlag(false);
                        dcActionResultInfo.setDcDefID(spcCheckLotList.get(i).getDcDefID());
                        dcActionResultInfo.setDcSpecID(spcCheckLotList.get(i).getDcSpecID());
                        dcActionResultInfo.setCheckType(BizConstant.SP_ACTIONRESULT_CHECKTYPE_SPC);
                        dcActionResultInfo.setReasonCode(BizConstant.SP_REASON_SPCOUTOFRANGEHOLD);
                        dcActionResultInfo.setActionCode(BizConstant.SP_ACTIONCODE_LOTHOLD);
                        dcActionLotResult.add(dcActionResultInfo);
                        dcActionInfo_count++;
                    }
                }
                else
                {
                    //------------------------------------------------------------------------------------------------
                    //  Make strLotHoldEffectList and strFutureHoldEffectList of out parameter.
                    //    If PROCESSING, set to strFutureHoldEffectList.
                    //    Else set to strLotHoldEffectList
                    //
                    //------------------------------------------------------------------------------------------------

                    if ( CimBooleanUtils.isFalse(requestOtherFabFlag)) {
                        log.debug("correspondingPO is current Fab");
                        //-----------------------------------------
                        //  Get lot status.
                        //  If IN-PROCESSING
                        //-----------------------------------------
                        CimLot aEffectedLot =  baseCoreFactory.getBO(CimLot.class, effectedLots.get(m).getLotID());

                        String lotState = aEffectedLot.getLotProcessState();

                        if( CimStringUtils.equals(lotState, BizConstant.SP_LOT_PROCSTATE_PROCESSING)) {

                            findFlag = false;
                            //-----------------------------------------------------------------------------------------
                            //  Check if strFutureHoldEffectList is already registed with the same lotID & reasonCode or not.
                            //  If only not existed, entry new inhibition.
                            //
                            //-----------------------------------------------------------------------------------------
                            for ( n = 0; n < FHold_count; n++ ) {

                                if (CimArrayUtils.isNotEmpty(lotHoldRecordEffectSPCCheckResultOut.getFutureHoldEffectList())
                                        && ObjectIdentifier.equalsWithValue(lotHoldRecordEffectSPCCheckResultOut.getFutureHoldEffectList().get(n).getLotID(), effectedLots.get(m).getLotID())) {
                                    findFlag = true;
                                }
                            }

                            if ( CimBooleanUtils.isFalse(findFlag)) {
                                CimProcessFlowContext aPFX = aEffectedLot.getProcessFlowContext();
                                Validations.check(null == aPFX, retCodeConfig.getNotFoundPfx());
                                AtomicReference<CimProcessFlow> aNextPF = null;
                                AtomicReference<CimProcessFlow> aModulePF = null;
                                AtomicReference<String>  moduleNo = new AtomicReference<>();
                                String var_moduleNo = null;
                                CimProcessOperationSpecification aNextPOS = aPFX.getNextProcessOperationSpecification(aNextPF, moduleNo, aModulePF) ;
                                var_moduleNo = moduleNo.get();

                                Validations.check(null == aNextPOS, retCodeConfig.getNotFoundPos());

                                Validations.check(null == aNextPF, retCodeConfig.getNotFoundProcessFlow());
                                CimProcessFlow aTmpNextPF = aNextPF.get();

                                CimProcessFlow aPF  = aPFX.getProcessFlow();
                                Validations.check(null == aPF, retCodeConfig.getNotFoundProcessFlow());

                                CimProcessDefinition targetRouteID = aPF.getRootProcessDefinition(); //D4100083

                                String targetOperationNumber;

                                CimProcessOperation aTmpPO = aEffectedLot.getProcessOperation();
                                CimProcessOperation aEffectedPO = (CimProcessOperation) aTmpPO;
                                Validations.check(null == aEffectedPO, retCodeConfig.getNotFoundOperation());

                                targetOperationNumber = aEffectedPO.getOperationNumber();

                                //-----------------------------------------------------------------------------
                                // Add futureholdRecord to out trx
                                //-----------------------------------------------------------------------------
                                Infos.LotHoldEffectList lotHoldEffect = new Infos.LotHoldEffectList();
                                lotHoldEffect.setLotID(effectedLots.get(m).getLotID());
                                lotHoldEffect.setHoldType(BizConstant.SP_HOLDTYPE_SPCOUTOFRANGEHOLD);
                                lotHoldEffect.setReasonCodeID(ObjectIdentifier.build(BizConstant.SP_REASON_SPCOUTOFRANGEHOLD, null));
                                lotHoldEffect.setUserID(objCommon.getUser().getUserID());
                                lotHoldEffect.setResponsibleOperationMark(strLotCheckConditionForPOOut ? BizConstant.SP_RESPONSIBLEOPERATION_CURRENT : BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                                lotHoldEffect.setRouteID(ObjectIdentifier.build(targetRouteID.getIdentifier(), targetRouteID.getPrimaryKey()));
                                lotHoldEffect.setOperationNumber(targetOperationNumber);
                                lotHoldEffectList.add(lotHoldEffect);
                                FHold_count++;


                                //-----------------------------------------------------------------------------
                                // Add ActionResultInfo
                                //-----------------------------------------------------------------------------
                                List<Infos.DCActionResultInfo> dcActionLotResult = dcActionLotResultList.get(dcActionLot_idx).getDcActionResultInfo();
                                Infos.DCActionResultInfo  dcActionResultInfo = new Infos.DCActionResultInfo();
                                dcActionResultInfo.setLotID(effectedLots.get(m).getLotID());
                                dcActionResultInfo.setMonitorLotFlag(true);
                                dcActionResultInfo.setDcDefID(spcCheckLotList.get(i).getDcDefID());
                                dcActionResultInfo.setDcSpecID(spcCheckLotList.get(i).getDcSpecID());
                                dcActionResultInfo.setCheckType(BizConstant.SP_ACTIONRESULT_CHECKTYPE_SPC);
                                dcActionResultInfo.setReasonCode(BizConstant.SP_REASON_SPCOUTOFRANGEHOLD);
                                dcActionResultInfo.setActionCode(BizConstant.SP_ACTIONCODE_LOTHOLD);
                                dcActionLotResult.add(dcActionResultInfo);

                                dcActionInfo_count++;
                            }
                        }
                        //-----------------------------------------
                        //  If Except IN-PROCESSING
                        //-----------------------------------------
                        else {

                            findFlag = false;
                            //-----------------------------------------------------------------------------------------
                            //  Check if strLotHoldEffectList is already registed with the same lotID or not.
                            //  If only not existed, entry new inhibition.
                            //
                            //-----------------------------------------------------------------------------------------

                            for ( n = 0; n < lotHold_count; n++ ) {

                                if( CimArrayUtils.isNotEmpty(lotHoldRecordEffectSPCCheckResultOut.getFutureHoldEffectList())
                                        && ObjectIdentifier.equalsWithValue(lotHoldRecordEffectSPCCheckResultOut.getLotHoldEffectList().get(n).getLotID(), effectedLots.get(m).getLotID())) {
                                    findFlag = true;
                                }
                            }

                            if ( CimBooleanUtils.isFalse(findFlag) ) {

                                //-----------------------------------------------------------------------------
                                // Add LotHoldRecord to out trx
                                //-----------------------------------------------------------------------------
                                Infos.LotHoldEffectList lotHoldEffect = new Infos.LotHoldEffectList();
                                lotHoldEffect.setLotID(effectedLots.get(m).getLotID());
                                lotHoldEffect.setHoldType(BizConstant.SP_HOLDTYPE_SPCOUTOFRANGEHOLD);
                                lotHoldEffect.setReasonCodeID(ObjectIdentifier.build(BizConstant.SP_REASON_SPCOUTOFRANGEHOLD, null));
                                lotHoldEffect.setUserID(objCommon.getUser().getUserID());
                                lotHoldEffect.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                                lotHoldEffectList.add(lotHoldEffect);
                                lotHold_count++;

                                //-----------------------------------------------------------------------------
                                // Add ActionResultInfo
                                //-----------------------------------------------------------------------------
                                List<Infos.DCActionResultInfo> dcActionLotResult = dcActionLotResultList.get(dcActionLot_idx).getDcActionResultInfo();
                                Infos.DCActionResultInfo  dcActionResultInfo = new Infos.DCActionResultInfo();
                                dcActionResultInfo.setLotID(effectedLots.get(m).getLotID());
                                dcActionResultInfo.setMonitorLotFlag(true);
                                dcActionResultInfo.setDcDefID(spcCheckLotList.get(i).getDcDefID());
                                dcActionResultInfo.setDcSpecID(spcCheckLotList.get(i).getDcSpecID());
                                dcActionResultInfo.setCheckType(BizConstant.SP_ACTIONRESULT_CHECKTYPE_SPC);
                                dcActionResultInfo.setReasonCode(BizConstant.SP_REASON_SPCOUTOFRANGEHOLD);
                                dcActionResultInfo.setActionCode(BizConstant.SP_ACTIONCODE_LOTHOLD);
                                dcActionLotResult.add(dcActionResultInfo);
                                dcActionInfo_count++;
                            }
                        }

                    }
                    else {
                        findLotFlag  = false;
                        int lotHoldIdx = 0;
                        int lotHoldCnt = 0;

                        //---------------------------------------------------------
                        //  Create HoldRecord for other Fab
                        //---------------------------------------------------------
                        for ( n = 0; n < lotHold_countForOtherFab; n++ ) {
                            if (ObjectIdentifier.equalsWithValue(interFabMonitorGroupActionInfoList.get(interFabMonIdx).getMonitoredLotHoldInfoList().get(n).getLotID(), effectedLots.get(m).getLotID())) {
                                log.debug("set findLotFlag = TRUE");
                                lotHoldIdx = n;
                                lotHoldCnt = CimArrayUtils.getSize(interFabMonitorGroupActionInfoList.get(interFabMonIdx).getMonitoredLotHoldInfoList().get(n).getHoldInfoList());
                                findLotFlag = true;
                                break;
                            }
                        }
                        Infos.MonitoredLotHoldInfo monitoredLotHoldInfo = interFabMonitorGroupActionInfoList.get(interFabMonIdx).getMonitoredLotHoldInfoList().get(lotHoldIdx);
                        if ( CimBooleanUtils.isFalse(findFlag) ) {

                            //-----------------------------------------------------------------------------
                            // Add LotHoldRecord to out trx(request to other Fab)
                            //-----------------------------------------------------------------------------
                            lotHoldIdx = lotHold_countForOtherFab++;
                            lotHoldCnt = 0;
                            monitoredLotHoldInfo.setLotID(effectedLots.get(m).getLotID());
                        }
                        List<Infos.HoldInfo> holdInfoList = monitoredLotHoldInfo.getHoldInfoList();
                        Infos.HoldInfo holdInfo = new Infos.HoldInfo();
                        holdInfo.setReasonCode(BizConstant.SP_REASON_SPCOUTOFRANGEHOLD);
                        holdInfo.setHoldType(BizConstant.SP_HOLDTYPE_SPCOUTOFRANGEHOLD);
                        holdInfoList.add(holdInfo);
                        //-----------------------------------------------------------------------------
                        // Add ActionResultInfo
                        //-----------------------------------------------------------------------------
                        List<Infos.DCActionResultInfo> dcActionLotResult = dcActionLotResultList.get(dcActionLot_idx).getDcActionResultInfo();
                        Infos.DCActionResultInfo  dcActionResultInfo = new Infos.DCActionResultInfo();
                        dcActionResultInfo.setLotID(effectedLots.get(m).getLotID());
                        dcActionResultInfo.setMonitorLotFlag(true);
                        dcActionResultInfo.setDcDefID(spcCheckLotList.get(i).getDcDefID());
                        dcActionResultInfo.setDcSpecID(spcCheckLotList.get(i).getDcSpecID());
                        dcActionResultInfo.setCheckType(BizConstant.SP_ACTIONRESULT_CHECKTYPE_SPC);
                        dcActionResultInfo.setReasonCode(BizConstant.SP_REASON_SPCOUTOFRANGEHOLD);
                        dcActionResultInfo.setActionCode(BizConstant.SP_ACTIONCODE_LOTHOLD);
                        dcActionLotResult.add(dcActionResultInfo);

                        dcActionInfo_count++;
                    }
                }
            }
        }


        lotHoldRecordEffectSPCCheckResultOut.setInterFabMonitorGroupActionInfoList(interFabMonitorGroupActionInfoList);
        lotHoldRecordEffectSPCCheckResultOut.setDcActionLotResultList(dcActionLotResultList);
        lotHoldRecordEffectSPCCheckResultOut.setLotHoldEffectList(lotHoldEffectList);
        return lotHoldRecordEffectSPCCheckResultOut;
    }

    @Override
    public String lotTypeGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        return aLot.getLotType();
    }

    @Override
    public void lotBankMove(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier toBankID) {
        log.info("ObjCommon = {}, lotID = {}, toBankID = {}", objCommon, lotID, toBankID);
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());
        CimBank aBank = baseCoreFactory.getBO(CimBank.class, toBankID);
        Validations.check(null == aBank, retCodeConfig.getNotFoundLot());

        CimBank aPreviousBank = lot.getBank();
        Validations.check(null == aPreviousBank, retCodeConfig.getNotFoundBank());

        lot.setBank(aBank);
        lot.setPreviousBank(aPreviousBank);
        lot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());

        CimPerson personBO = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == personBO, retCodeConfig.getNotFoundLot());
        lot.setLastClaimedPerson(personBO);

        boolean isRecycleBank = CimBooleanUtils.isTrue(aBank.isRecycleBank());
        boolean isControlWaferBank = CimBooleanUtils.isTrue(aBank.isControlWaferBank());
        boolean inUse = lot.isInUse();
        if (isRecycleBank) {
            lot.makeWaitRecycle();
        } else if (isControlWaferBank && CimBooleanUtils.isFalse(inUse)) {
            lot.makeWaitUse();
        }
    }

    @Override
    public void lotStateCancelShipped(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));

        CimPerson person = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, new OmCode(retCodeConfig.getNotFoundPerson(), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));

        lot.makeCancelShipped();
        Timestamp reportTime = objCommon.getTimeStamp().getReportTimeStamp();
        lot.setLastClaimedTimeStamp(reportTime);
        lot.setLastClaimedPerson(person);
        lot.setStateChangedTimeStamp(reportTime);
        lot.setStateChangedPerson(person);
    }

    @Override
    public void lotProcessLagTimeSet(Infos.ObjCommon objCommon, ObjectIdentifier lotID, String processLagTime) {
        //---------------------------------
        //   Get Lot Object
        //---------------------------------
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        //---------------------------------
        //   Set Lot's ProcessLagTime
        //---------------------------------
        aLot.setProcessLagTime(CimDateUtils.convertToOrInitialTime(processLagTime));
    }

    @Override
    public List<Infos.LotCtrlStatus> lotFillInTxPCQ017DR(Infos.ObjCommon objCommon) {
        List<Infos.LotCtrlStatus> controlUseStatusList = new ArrayList<>();
        String sql = "SELECT CODE_ID, DESCRIPTION\n" +
                "             FROM OMCODE\n" +
                "             WHERE\n" +
                "             CODETYPE_ID = ?";
        cimJpaRepository.query(sql, CimCodeDO.class, new Object[]{BizConstant.SP_CATEGORY_LOTCONTROLUSESTATE})
        .forEach(code -> controlUseStatusList.add(new Infos.LotCtrlStatus(code.getCodeID(), code.getDescription())));
        return controlUseStatusList;
    }

    @Override
    public Page<Infos.LotListAttributes> lotListGetDR(Infos.ObjCommon objCommon, Params.LotListInqParams lotListInqParams, SearchCondition searchCondition) {
        Validations.check(null == objCommon || null == lotListInqParams, retCodeConfig.getInvalidInputParam());

        log.info("【Step-1】Make up search condition and do search.");
        String querySql = this.getLotListInqSearchCondition(lotListInqParams,searchCondition);
        log.debug(">>>>>> ");
        log.debug(">>>>>> SQL: {}", querySql);
        log.debug(">>>>>> ");

        String maxLotsCountStr = StandardProperties.OM_MAX_SIZE_LOT_LIST_INQ.getValue();
        int maxLotsCount = CimStringUtils.isEmpty(maxLotsCountStr) ? 100 : Integer.parseInt(maxLotsCountStr);
        if (null != searchCondition && searchCondition.getSize() > maxLotsCount) {
            searchCondition.setSize(maxLotsCount);
        }

        Page<CimLotDO> queriedLots = cimJpaRepository.query(querySql, CimLotDO.class, searchCondition);
        if (null == queriedLots) return null;
        log.info("【Step-2】Make results info.");
        List<Infos.LotListAttributes> result = queriedLots.getContent().parallelStream().map(lot -> {
            log.debug("【Step-2.1】 Get Process Info");
            //-----------------------------//
            // Get Process Info            //
            //-----------------------------//
            String processInfoSql = this.getProcessInfoQuerySql(lot.getLotID(), BizConstant.SP_PD_FLOWLEVEL_OPERATION);
            Object[] sqlResult = cimJpaRepository.queryOne(processInfoSql);
            Infos.PDModuleInfo queryProcessInfo = new Infos.PDModuleInfo();
            if (!CimObjectUtils.isEmpty(sqlResult)) {
                queryProcessInfo.setOperationID(CimObjectUtils.toString(sqlResult[0]));
                queryProcessInfo.setOperationType(CimObjectUtils.toString(sqlResult[1]));
                queryProcessInfo.setPlanStartTime(CimObjectUtils.toString(sqlResult[2]));
            }

            log.debug("【Step-2.2】Get Lot hold record");
            //-----------------------------//
            // Get lot hold record         //
            //-----------------------------//
            String lotHoldReasonCode = "";
            List<Infos.LotHoldRecordInfo> lotHoldRecordInfos = this.lotHoldRecordGetDR(lot.getLotID());
            int lotHoldRecordSize = CimArrayUtils.getSize(lotHoldRecordInfos);
            if (!ObjectIdentifier.isEmpty(lotListInqParams.getHoldReasonCodeID())) {
                for (Infos.LotHoldRecordInfo lotHoldRecordInfo : lotHoldRecordInfos) {
                    if (ObjectIdentifier.equalsWithValue(lotListInqParams.getHoldReasonCodeID(), lotHoldRecordInfo.getHoldReasonID())) {
                        lotHoldReasonCode += lotHoldRecordInfo.getHoldReasonID().getValue();
                        if (1 < lotHoldRecordSize) {
                            lotHoldReasonCode += BizConstant.SP_ADCSETTING_ASTERISK;
                        }
                        break;
                    }
                }
            } else {
                if (1 == lotHoldRecordSize)
                    lotHoldReasonCode = lotHoldRecordInfos.get(0).getHoldReasonID().getValue();
                else if (1 < lotHoldRecordSize)
                    lotHoldReasonCode = ObjectIdentifier.fetchValue(lotHoldRecordInfos.get(0).getHoldReasonID()) + BizConstant.SP_ADCSETTING_ASTERISK;
            }

            log.debug("【Step-2.3】Gets Carrier information");
            Outputs.objCarrierEquipmentInfoGetOut carrierEquipmentInfo = this.getCarrierInformation(lot);

            log.debug("【Step-2.4】Get lot sorter job");
            com.fa.cim.sorter.Params.ObjSorterJobListGetDRIn sorterJobListGetDRIn = new com.fa.cim.sorter.Params.ObjSorterJobListGetDRIn();
            sorterJobListGetDRIn.setLotID(new ObjectIdentifier(lot.getLotID(), lot.getId()));
            if (CimBooleanUtils.isTrue(lotListInqParams.getSorterJobCreationCheckFlag())) {
                sorterJobListGetDRIn.setCarrierID(carrierEquipmentInfo.getCarrierID());
            }
            //sorter_jobList_GetDR;
            List<Info.SortJobListAttributes> sorterListInqResult = sorterMethod.sorterJobListGetDR(objCommon, sorterJobListGetDRIn);


            log.debug("【Step-2.5】Get InPostProcessFlag of lot");
            Outputs.ObjLotInPostProcessFlagOut objLotInPostProcessFlagGetOut = lotMethod.lotInPostProcessFlagGet(objCommon, new ObjectIdentifier(lot.getLotID(), lot.getId()));

            log.debug("【Step-2.6】Get Bonding Group ID");
            String bondingGroupID = this.lotBondingGroupIDGetDR(objCommon, new ObjectIdentifier(lot.getLotID(), lot.getId()));

            log.debug("【Step-2.7】Get Auto dispatch Control Information");
            Inputs.ObjAutoDispatchControlInfoGetDRIn objAutoDispatchControlInfoGetDRIn = new Inputs.ObjAutoDispatchControlInfoGetDRIn();
            objAutoDispatchControlInfoGetDRIn.setLotID(new ObjectIdentifier(lot.getLotID(), lot.getId()));
            List<Infos.LotAutoDispatchControlInfo> autoDispatchControlInfoGet = autoDispatchControlMethod.autoDispatchControlInfoGetDR(objCommon, objAutoDispatchControlInfoGetDRIn);


            log.debug("【Step-8】Acquire EqpMonitor job ID of lot");
            sqlResult = cimJpaRepository.queryOne("SELECT  OMAMJOB.AM_JOB_ID\n" +
                    "            FROM\n" +
                    "                OMAMJOB,\n" +
                    "                OMAMJOB_LOT\n" +
                    "            WHERE\n" +
                    "                OMAMJOB.ID = OMAMJOB_LOT.REFKEY AND\n" +
                    "                OMAMJOB_LOT.LOT_ID = ?", lot.getLotID());
            String hFREQPMONJOBEQPMONJOB_ID = "";
            if (!CimObjectUtils.isEmpty(sqlResult)) {
                hFREQPMONJOBEQPMONJOB_ID = CimObjectUtils.toString(sqlResult[0]);
            }

            //-------------------------------------------//
            // Set return value                          //
            //-------------------------------------------//
            Infos.LotStatusInformation lotStatusInfo = this.getLotStatusInfo(lot);
            Infos.LotListAttributes lotListAttributes = new Infos.LotListAttributes(lot);

            lotListAttributes.setLotStatus(lotStatusInfo.getLotStatus());
            lotListAttributes.setPlanStartTimeStamp(lotStatusInfo.getPlanStartTimeStamp());
            lotListAttributes.setLotInfoChangeFlag(CimBooleanUtils.isTrue(lotStatusInfo.getLotInfoChangeFlag()));

            List<Infos.LotStatusList> lotStatusLists = new ArrayList<>();
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_STATE, lot.getLotState()));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_PRODUCTIONSTATE, lot.getLotProductionState()));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_HOLDSTATE, lot.getLotHoldState()));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_FINISHEDSTATE, lot.getLotFinishedState()));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_PROCSTATE, lot.getLotProcessState()));
            lotStatusLists.add(new Infos.LotStatusList(BizConstant.SP_LOTSTATECAT_INVENTORYSTATE, lot.getLotInventoryState()));
            lotListAttributes.setLotStatusList(lotStatusLists);

            //----------------------------------------------------------
            //   Set Sorter Job existence flag if lot has Sorter Job.
            //----------------------------------------------------------
            if (CimArrayUtils.isNotEmpty(sorterListInqResult)) {
                lotListAttributes.setSorterJobExistFlag(true);
            } else {
                lotListAttributes.setSorterJobExistFlag(false);
            }

            //---------------------------
            //   Set hold reason code.
            //---------------------------
            lotListAttributes.setHoldReasonCodeID(ObjectIdentifier.buildWithValue(lotHoldReasonCode));

            //-------------------------------------------
            //  Set InPostProcessFlag of Lot/Cassette
            //-------------------------------------------
            if (null != objLotInPostProcessFlagGetOut) {
                lotListAttributes.setInPostProcessFlagOfCassette(objLotInPostProcessFlagGetOut.getInPostProcessFlagOfCassette());
                lotListAttributes.setInPostProcessFlagOfLot(objLotInPostProcessFlagGetOut.getInPostProcessFlagOfLot());
            }

            //----------------------------------
            //  Set Bonding Group ID
            //----------------------------------
            lotListAttributes.setBondingGroupID(bondingGroupID);

            //----------------------------------
            //  Set Auto Dispatch Control Flag
            //----------------------------------
            if (CimArrayUtils.isNotEmpty(autoDispatchControlInfoGet)) {
                lotListAttributes.setAutoDispatchControlFlag(true);
            } else {
                lotListAttributes.setAutoDispatchControlFlag(false);
            }

            //----------------------------------
            //  Set eqpMonitorJob ID
            //----------------------------------
            lotListAttributes.setEqpMonitorJobID(ObjectIdentifier.buildWithValue(hFREQPMONJOBEQPMONJOB_ID));

            lotListAttributes.setOperationID(ObjectIdentifier.buildWithValue(queryProcessInfo.getOperationID()));
            lotListAttributes.setPdType(queryProcessInfo.getOperationType());

            //----------------------------------
            //  Set Carrier and Equipment
            //----------------------------------
            lotListAttributes.setCarrierID(carrierEquipmentInfo.getCarrierID());
            lotListAttributes.setEquipmentID(carrierEquipmentInfo.getEquipmentID());

            ObjectIdentifier carrierID = carrierEquipmentInfo.getCarrierID();
            if (ObjectIdentifier.isNotEmptyWithValue(carrierID)){
                CimCassette aCast = baseCoreFactory.getBO(CimCassette.class, carrierID);
                lotListAttributes.setCarrierCategory(aCast.getCassetteCategory());
                lotListAttributes.setCarrierType(aCast.getCarrierType());
            }


            Infos.LotBackupInfo lotBackupInfo = new Infos.LotBackupInfo();
            lotBackupInfo.setBackupProcessingFlag(CimBooleanUtils.isTrue(lot.getBackupProcessingFlag()));
            lotBackupInfo.setCurrentLocationFlag(CimBooleanUtils.isTrue(lot.getCurrentLocationFlag()));
            lotBackupInfo.setTransferFlag(CimBooleanUtils.isTrue(lot.getTransferFlag()));
            Infos.BackupAddress backupAddress = new Infos.BackupAddress();

            backupAddress.setHostName(lot.getHostName());
            lotBackupInfo.setBornSiteAddress(backupAddress);

            lotListAttributes.setLotBackupInfo(lotBackupInfo);

            //set qtime state
            String lotQtimeState = "";
            String lotID = lot.getLotID();
            CimLot aLot = baseCoreFactory.getBOByIdentifier(CimLot.class, lotID);
            //Fix nullPointerException if lot not exist
            List<CimQTimeRestriction> cimQTimeRestrictions = Optional.ofNullable(aLot)
                    .map(CimLot::allQTimeRestrictions)
                    .orElse(Collections.emptyList());
            int qtimeWarnTime = StandardProperties.OM_QTIMEWARN_PERCENT.getIntValue();
            if (qtimeWarnTime > 99 || qtimeWarnTime < 1) {
                qtimeWarnTime = 25;
            }
            Timestamp currentTimeStamp = CimDateUtils.getCurrentTimeStamp();

            Optional<CimQTimeRestriction> max = cimQTimeRestrictions.parallelStream().filter(qTimeRestriction -> qTimeRestriction.isWatchDogRequired())
                    .max(Comparator.comparing(cimQTimeRestriction -> Long.valueOf(cimQTimeRestriction.getTargetTimeStamp().getTime()).intValue()));

            if (max.isPresent()) {
                CimQTimeRestriction qTime = max.get();

                Timestamp targetTimeStamp = qTime.getTargetTimeStamp();
                Timestamp triggerTimeStamp = qTime.getTriggerTimeStamp();
                BigDecimal duration = new BigDecimal(targetTimeStamp.getTime() - triggerTimeStamp.getTime());
                if (currentTimeStamp.after(targetTimeStamp)) {
                    lotQtimeState = BizConstant.LOT_QTIME_WARN_OVERTIME;
                } else {
                    BigDecimal remainTime = new BigDecimal(targetTimeStamp.getTime() - currentTimeStamp.getTime());
                    int multiply = remainTime.divide(duration, 10, BigDecimal.ROUND_UP).multiply(BigDecimal.valueOf(100)).intValue();
                    if (multiply < qtimeWarnTime) {
                        lotQtimeState = BizConstant.LOT_QTIME_WARN_HURRY;
                    } else {
                        lotQtimeState = BizConstant.LOT_QTIME_WARN_NORMAL;
                    }
                }

                Timestamp aTimeStamp = qTime.getTargetTimeStamp();
                Timestamp aTmp = objCommon.getTimeStamp().getReportTimeStamp();
                Timestamp currentTime = new Timestamp(System.currentTimeMillis());
                long aDuration;
                aDuration = aTimeStamp.getTime() - aTmp.getTime();
                double remainMinSeconds = Math.abs((currentTime.getTime() - qTime.getTriggerTimeStamp().getTime()) / 1000);

                String timeSign;
                String hhmmss;
                int hours;
                int minutes;
                int seconds;

                if (CimDateUtils.compare(currentTime, qTime.getTriggerTimeStamp()) == 0) {
                    timeSign = " ";
                } else if (CimDateUtils.compare(currentTime, qTime.getTriggerTimeStamp()) < 0) {
                    timeSign = "+";
                } else {
                    timeSign = "-";
                }
                hours = (int) (remainMinSeconds / 3600);
                minutes = (int) ((remainMinSeconds - (hours * 3600)) / 60);
                seconds = (int) (remainMinSeconds - (hours * 3600) - (minutes * 60));

                if (hours < 100) {
                    hhmmss = String.format("%s%02d:%02d:%02d", timeSign, hours, minutes, seconds);
                } else if (hours < 10000) {
                    hhmmss = String.format("%s%04d:%02d:%02d", timeSign, hours, minutes, seconds);
                } else {
                    hhmmss = String.format("%s%06d:%02d:%02d", timeSign, hours, minutes, seconds);
                }
                lotListAttributes.setQtimeRemainTime(hhmmss);
                lotListAttributes.setLotQtimeState(lotQtimeState);
                lotListAttributes.setFlip(lot.getFlip() == null ? false : lot.getFlip());
            }

            return lotListAttributes;
        }).collect(Collectors.toList());

        log.info("【Step-3】Return results.");
        return new PageImpl<>(result, queriedLots.getPageable(), queriedLots.getTotalElements());
    }

    /**
     * description: GET LOT STATE
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param lot lot
     * @return lotState
     * @author Sun
     * @date 2018/08/27 15:05
     */
    private Infos.LotStatusInformation getLotStatusInfo(CimLotDO lot) {
        Infos.LotStatusInformation lotStatusInformation = new Infos.LotStatusInformation();

        if (CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_NONPROBANK,lot.getLotInventoryState())) {
            if (CimStringUtils.equals(CIMStateConst.CIM_LOT_FINISHED_STATE_SCRAPPED,lot.getLotFinishedState()) ||
                    CimStringUtils.equals(CIMStateConst.CIM_LOT_FINISHED_STATE_EMPTIED,lot.getLotFinishedState())) {
                lotStatusInformation.setLotStatus(lot.getLotFinishedState());
            } else {
                lotStatusInformation.setLotStatus(lot.getLotInventoryState());
            }
        } else {
            if (CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD,lot.getLotHoldState())) {
                if (CimStringUtils.equals(CIMStateConst.CIM_LOT_FINISHED_STATE_SCRAPPED,lot.getLotFinishedState()) ||
                        CimStringUtils.equals(CIMStateConst.CIM_LOT_FINISHED_STATE_EMPTIED,lot.getLotHoldState())) {
                    lotStatusInformation.setLotStatus(lot.getLotFinishedState());
                } else {
                    lotStatusInformation.setLotStatus(lot.getLotHoldState());
                }
            } else {
                if (CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_LOTCREATED,lot.getLotState()) ||
                        CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_RELEASED, lot.getLotState()) ||
                        CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_SHIPPED, lot.getLotState())) {
                    lotStatusInformation.setLotStatus(lot.getLotState());
                } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_FINISHED, lot.getLotState())) {
                    lotStatusInformation.setLotStatus(lot.getLotFinishedState());
                    lotStatusInformation.setPlanStartTimeStamp((lot.getReleasedTimeStamp() != null) ? lot.getReleasedTimeStamp().toString() : "");
                } else if (CimStringUtils.equals(CIMStateConst.CIM_LOT_STATE_ACTIVE, lot.getLotState())) {
                    lotStatusInformation.setLotStatus(lot.getLotProcessState());
                    lotStatusInformation.setPlanStartTimeStamp((lot.getPlanStartTimeStamp() != null) ? lot.getPlanStartTimeStamp().toString() : "");
                    CimScheduleChangeReservationDO cimScheduleChangeReservationExam = new CimScheduleChangeReservationDO();
                    cimScheduleChangeReservationExam.setObjectID(lot.getLotID());
                    cimScheduleChangeReservationExam.setLotInfoChangeFlag(true);
                    lotStatusInformation.setLotInfoChangeFlag(cimJpaRepository.count(Example.of(cimScheduleChangeReservationExam)) > 0);
                }
            }
        }
        return lotStatusInformation;
    }

    /**
     * description: GET lot Hold Reason CimCode
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param lotID -
     * @return List<Infos.LotHoldRecordInfo>
     * @author Sun
     * @since 2018/08/278 13:14
     */
    public List<Infos.LotHoldRecordInfo> lotHoldRecordGetDR(String lotID) {
        List<Infos.LotHoldRecordInfo> result = new ArrayList<>();
        String querySql = String.format("SELECT T2.*\n" +
                "  FROM OMLOT T1, OMLOT_HOLD T2\n" +
                " WHERE T1.LOT_ID = '%s'\n" +
                "   AND T1.ID = T2.REFKEY\n" +
                " ORDER BY T2.HOLD_TIME", lotID);
        List<CimLotHoldRecordDO> holdRecords = cimJpaRepository.query(querySql, CimLotHoldRecordDO.class);

        for (CimLotHoldRecordDO holdRecord : holdRecords) {
            Infos.LotHoldRecordInfo lotHoldRecordInfo = new Infos.LotHoldRecordInfo();
            lotHoldRecordInfo.setDKey(holdRecord.getLinkKey());
            lotHoldRecordInfo.setHoldType(holdRecord.getHoldType());
            lotHoldRecordInfo.setHoldUserID(new ObjectIdentifier(holdRecord.getHoldPersonID(), holdRecord.getHoldPersonObj()));
            lotHoldRecordInfo.setHoldTime(holdRecord.getHoldTime());
            lotHoldRecordInfo.setRelatedLotID(new ObjectIdentifier(holdRecord.getRelatedLotID(), holdRecord.getRelatedLotObj()));
            lotHoldRecordInfo.setHoldClaimMemo(holdRecord.getHoldClaimMemo());
            lotHoldRecordInfo.setHoldReasonID(new ObjectIdentifier(holdRecord.getHoldReasonID(), holdRecord.getHoldReasonObj()));
            if (holdRecord.getResponsibleOperationFlag()) {
                lotHoldRecordInfo.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
            } else {
                lotHoldRecordInfo.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
            }
            result.add(lotHoldRecordInfo);
        }
        return result;
    }

    /**
     * description:
     * change history:
     * date             defect             person             comments
     * 2018/12/25       Bug-148            Sun                filter lot for Move Bank Screen, only display 'InBank' Lot;
     * -----------------------------------------------------------------------------------------------------------------
     * @author Sun
     * @since 12/25/2018 2:04 PM
     * @param lotListInqParams -
     * @return java.lang.String
     */
    private String getLotListInqSearchCondition(Params.LotListInqParams lotListInqParams,SearchCondition searchCondition) {
        Validations.check(null == lotListInqParams, retCodeConfig.getInvalidInputParam());
        String sql = "SELECT LOT.* FROM OMLOT LOT ";
        boolean bFirstCondition = true;

        if (ObjectIdentifier.isNotEmptyWithValue(lotListInqParams.getOperationID())) {
            sql += ", OMPROPE PO, OMPRP OPEPD ";
            sql += String.format(
                    " WHERE LOT.PROPE_RKEY = PO.ID\n" +
                    "   AND OPEPD.PRP_LEVEL = '%s'\n" +
                    "   AND PO.STEP_RKEY = OPEPD.ID\n" +
                    "   AND OPEPD.PRP_ID LIKE '%%%s%%'\n", BizConstant.SP_PD_FLOWLEVEL_OPERATION, lotListInqParams.getOperationID().getValue());
            bFirstCondition = false;
        }

        // Filter Virtual Operation
        if(CimBooleanUtils.isTrue(lotListInqParams.getVirtualOperationFlag())) {
            if (bFirstCondition ) {
                sql += ", OMPROPE PO, OMPRP OPEPD ";
                sql += String.format(
                        " WHERE LOT.PROPE_RKEY = PO.ID\n" +
                                "   AND OPEPD.PRP_LEVEL = '%s'\n" +
                                "   AND PO.STEP_RKEY = OPEPD.ID AND \n", BizConstant.SP_PD_FLOWLEVEL_OPERATION);
            } else sql += " AND";
            sql += String.format(" OPEPD.PRP_TYPE = '%s'", BizConstant.SP_OPEPDTYPE_VIRTUAL);
            bFirstCondition = false;
        }

        // carrier attribute
        String requiredCassetteCategory = lotListInqParams.getRequiredCassetteCategory();
        String requiredCassetteType = lotListInqParams.getRequiredCassetteType();
        if (CimStringUtils.isNotEmpty(requiredCassetteCategory) || CimStringUtils.isNotEmpty(requiredCassetteType)) {
            if (bFirstCondition) {
                sql += ", OMCARRIER_LOT CASTLOT, OMCARRIER CAST ";
                sql += "  WHERE LOT.ID = CASTLOT.LOT_RKEY " +
                        "  AND CASTLOT.REFKEY = CAST.ID ";
            } else {
                String rex = "(?<=from|FROM).*?(?=where|WHERE)";
                Pattern pattern = Pattern.compile(rex);
                Matcher matcher = pattern.matcher(sql);
                if (matcher.find()) {
                    String fromTable = matcher.group();
                    String newFromTable = fromTable + ", OMCARRIER_LOT CASTLOT, OMCARRIER CAST ";
                    sql = sql.replace(fromTable, newFromTable);
                    sql += "  AND LOT.ID = CASTLOT.LOT_RKEY " +
                            "  AND CASTLOT.REFKEY = CAST.ID ";
                }
            }
            bFirstCondition = false;
        }


        // Filter Hold Record
        if(ObjectIdentifier.isNotEmptyWithValue(lotListInqParams.getHoldReasonCodeID())) {
            if (bFirstCondition ) {
                sql += " WHERE";
            } else sql += " AND";
            sql += String.format(" (\n" +
                    "        CASE \n" +
                    "                WHEN (SELECT COUNT(HOLDRECORD.ID) FROM OMLOT_HOLD HOLDRECORD WHERE HOLDRECORD.REFKEY = LOT.ID AND HOLDRECORD.REASON_CODE_ID = '%s') > 0\n" +
                    "                THEN 1\n" +
                    "                ELSE 0\n" +
                    "        END) = 1 ", lotListInqParams.getHoldReasonCodeID().getValue());
            bFirstCondition = false;
        }

        // Filter Sorter Job
        if(CimBooleanUtils.isTrue(lotListInqParams.getSorterJobCreationCheckFlag())) {
            if (bFirstCondition ) {
                sql += " WHERE";
            } else sql += " AND";
            sql += " (\n" +
                    "        CASE\n" +
                    "                WHEN (SELECT COUNT(SORTMAP.LOT_ID) " +
                    "                       FROM OMSORTJOB_COMP_SLOTMAP SORTMAP " +
                    "                       WHERE SORTMAP.LOT_ID = LOT.LOT_ID) > 0\n" +
                    "                THEN 1\n" +
                    "                ELSE 0\n" +
                    "        END) = 0 ";
            sql += " AND LOT.CJ_ID IS NULL ";
            bFirstCondition = false;
        }

        // Filter Auto Dispatch Control
        if(CimBooleanUtils.isTrue(lotListInqParams.getAutoDispatchControlLotFlag())) {
            if (bFirstCondition ) {
                sql += " WHERE";
            } else sql += " AND";

            sql += " (\n" +
                    "        CASE\n" +
                    "                WHEN (SELECT COUNT(DISPCTRL.ID) FROM OMLOT_DISPCTRL DISPCTRL WHERE DISPCTRL.REFKEY = LOT.ID) > 0\n" +
                    "                THEN 1\n" +
                    "                ELSE 0\n" +
                    "        END) = 1 ";

            bFirstCondition = false;
        }

        // task-3899 LotID --> LOT_ID add new Fuzzy query of LotID
        if (ObjectIdentifier.isNotEmptyWithValue(lotListInqParams.getLotID()) && !ObjectIdentifier.equalsWithValue(lotListInqParams.getLotID(), BizConstant.PERCENT)) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.LOT_ID LIKE '%%%s%%'", lotListInqParams.getLotID().getValue());
            bFirstCondition = false;
        }

        //stb lot don't have bank_id;
        if (ObjectIdentifier.isNotEmptyWithValue(lotListInqParams.getBankID())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            // task-3899 BankId --> BANK_ID add new Fuzzy query of BankId
            sql += String.format(" LOT.BANK_ID LIKE '%%%s%%'", lotListInqParams.getBankID().getValue());
            bFirstCondition = false;
        }

        if (CimStringUtils.isNotEmpty(lotListInqParams.getLotType())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.LOT_TYPE = '%s'", lotListInqParams.getLotType());
            bFirstCondition = false;
        }

        // task-3899 subLotType --> subLotType add new Fuzzy query of subLotType
        if (CimStringUtils.isNotEmpty(lotListInqParams.getSubLotType())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.SUB_LOT_TYPE LIKE '%%%s%%'", lotListInqParams.getSubLotType());
            bFirstCondition = false;
        }

        // task-3899 ProductID --> PRODSPEC_ID add new Fuzzy query of ProductID
        if (ObjectIdentifier.isNotEmptyWithValue(lotListInqParams.getProductID()) && !ObjectIdentifier.equalsWithValue(lotListInqParams.getProductID(), BizConstant.PERCENT)) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.PROD_ID LIKE '%%%s%%'", lotListInqParams.getProductID().getValue());
            bFirstCondition = false;
        }

        if (CimStringUtils.isNotEmpty(lotListInqParams.getCustomerCode())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.CUSTOMER_ID = '%s'", lotListInqParams.getCustomerCode());
            bFirstCondition = false;
        }

        // task-3899 orderNumber -->orderNumber add new Fuzzy query of orderNumber
        if (CimStringUtils.isNotEmpty(lotListInqParams.getOrderNumber())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.MFG_ORDER_NO LIKE '%%%s%%'", lotListInqParams.getOrderNumber());
            bFirstCondition = false;
        }

        if (ObjectIdentifier.isNotEmptyWithValue(lotListInqParams.getManufacturingLayer())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.MFG_LAYER = '%s'", lotListInqParams.getManufacturingLayer().getValue());
            bFirstCondition = false;
        }

        if (CimBooleanUtils.isTrue(lotListInqParams.getBankInRequiredFlag())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += " LOT.BANK_IN_REQD = 1";
            sql += String.format(" AND LOT.LOT_INV_STATE = '%s' ", BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR);
            sql += String.format(" AND (LOT.LOT_FINISHED_STATE != '%s' ",BizConstant.SP_LOT_FINISHED_STATE_EMPTIED);
            sql += String.format(" AND LOT.LOT_FINISHED_STATE != '%s' ", BizConstant.SP_LOT_FINISHED_STATE_SCRAPPED);
            sql += String.format(" AND LOT.LOT_FINISHED_STATE != '%s' OR LOT.LOT_FINISHED_STATE IS NULL )", BizConstant.SP_LOT_FINISHED_STATE_STACKED);
            bFirstCondition = false;
        }

        // task-3899 ProcessFlowId --> RouteId add new Fuzzy query of ProcessFlowId
        if (ObjectIdentifier.isNotEmptyWithValue(lotListInqParams.getRouteID())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.MAIN_PROCESS_ID LIKE '%%%s%%'", lotListInqParams.getRouteID().getValue());
            bFirstCondition = false;
        }

        if (CimStringUtils.isNotEmpty(lotListInqParams.getOperationNumber())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.OPE_NO = '%s'", lotListInqParams.getOperationNumber());
            bFirstCondition = false;
        }

        // convert FOSB or FOUP
        /*if (StringUtils.isNotEmpty(lotListInqParams.getRequiredCassetteCategory())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.REQD_CAST_CTGRY = '%s'", lotListInqParams.getRequiredCassetteCategory());
            bFirstCondition = false;
        }*/

        // carrier category
        if (CimStringUtils.isNotEmpty(lotListInqParams.getRequiredCassetteCategory())) {
            sql += String.format("AND CAST.CARRIER_CATEGORY = '%s'", lotListInqParams.getRequiredCassetteCategory());
        }

        // carrier type
        if (CimStringUtils.isNotEmpty(lotListInqParams.getRequiredCassetteType())) {
            sql += String.format("AND CAST.CARRIER_TYPE = '%s'", lotListInqParams.getRequiredCassetteType());
        }

        if (CimBooleanUtils.isTrue(lotListInqParams.getBackupProcessingFlag())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += " LOT.BCKUP_FLAG = 1 ";
            bFirstCondition = false;
        }

        /*if (BooleanUtils.isTrue(lotListInqParams.getAutoDispatchControlLotFlag())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += " LOT.ID IN (SELECT REFKEY FROM FRLOT_DISPCTRL) ";
            bFirstCondition = false;
        }*/

        if (ObjectIdentifier.isNotEmptyWithValue(lotListInqParams.getHoldReasonCodeID())) {
            if (bFirstCondition) {
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.LOT_HOLD_STATE= '%s'", BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD);
            bFirstCondition = false;
        }
//            if (StringUtils.equals(BizConstant.CIMFW_LOT_STATE_LOTCREATED,lotListInqParams.getLotStatus())||
//                    StringUtils.equals(BizConstant.CIMFW_LOT_STATE_SHIPPED,lotListInqParams.getLotStatus()) ||
//                    StringUtils.equals(BizConstant.CIMFW_LOT_STATE_RELEASED,lotListInqParams.getLotStatus())) {
//                tempSql = String.format(" LOT.LOT_STATE = '%s' ", lotListInqParams.getLotStatus());
//            } else if (StringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_COMPLETED,lotListInqParams.getLotStatus()) ||
//                    StringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_EMPTIED,lotListInqParams.getLotStatus()) ||
//                    StringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_SCRAPPED,lotListInqParams.getLotStatus()) ||
//                    StringUtils.equals(BizConstant.SP_LOT_FINISHED_STATE_STACKED,lotListInqParams.getLotStatus())) {
//                tempSql = String.format(" LOT.LOT_STATE = '%s' AND LOT.LOT_FINISHED_STATE = '%s' ", BizConstant.CIMFW_LOT_STATE_FINISHED, lotListInqParams.getLotStatus());
//            } else if (StringUtils.equals(BizConstant.SP_LOT_PROCSTATE_WAITING,lotListInqParams.getLotStatus()) ||
//                    StringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING,lotListInqParams.getLotStatus()) ||
//                    StringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSED,lotListInqParams.getLotStatus())) {
//                tempSql = String.format(" LOT.LOT_STATE = '%s' AND LOT.LOT_HOLD_STATE = '%s' AND LOT.LOT_PROCESS_STATE = '%s' ", BizConstant.CIMFW_LOT_STATE_ACTIVE, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD, lotListInqParams.getLotStatus());
//            } else if (StringUtils.equals(BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD,lotListInqParams.getLotStatus())) {
//                tempSql = String.format(" LOT.LOT_HOLD_STATE = '%s' ", lotListInqParams.getLotStatus());
//            } else if (StringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_NONPROBANK,lotListInqParams.getLotStatus())) {
//                tempSql = String.format(" LOT.LOT_INV_STATE = '%s' ", lotListInqParams.getLotStatus());
//            } else {
//                bLotStatusFlg = false;
//            }
//
//            if (bLotStatusFlg) {
//                if (bFirstCondition) {
//                    bFirstCondition = false;
//                    sql += " WHERE";
//                } else sql += " AND";
//                sql += tempSql;
//            }
//        }
        else if (!CimArrayUtils.isEmpty(lotListInqParams.getLotStatusList())) {
            StringBuilder tempSql = new StringBuilder();

            List<String> lotStatusList = lotListInqParams.getLotStatusList();
            // BUG-1935 sql concatenation error if the lotstatus parameter length is greater than 1
            if (lotStatusList.size()>1) {
                tempSql = new StringBuilder("(");
            }
            boolean firstLoop = true;

            for (String lotStatus : lotStatusList){
                if (CimStringUtils.equals(BizConstant.CIMFW_LOT_STATE_LOTCREATED,lotStatus)||
                        CimStringUtils.equals(BizConstant.CIMFW_LOT_STATE_SHIPPED,lotStatus) ||
                        CimStringUtils.equals(BizConstant.CIMFW_LOT_STATE_RELEASED,lotStatus)) {
                    if (!firstLoop){
                        tempSql.append(" OR ");
                    }
                    tempSql.append(String.format(" LOT.LOT_STATE = '%s' ", lotStatus));
                } else if (CimStringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_COMPLETED,lotStatus) ||
                        CimStringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_EMPTIED,lotStatus) ||
                        CimStringUtils.equals(BizConstant.CIMFW_LOT_FINISHEDSTATE_SCRAPPED,lotStatus) ||
                        CimStringUtils.equals(BizConstant.SP_LOT_FINISHED_STATE_STACKED,lotStatus)) {
                    if (!firstLoop){
                        tempSql.append(" OR ");
                    }
                    tempSql.append(String.format(" ( LOT.LOT_STATE = '%s' AND LOT.LOT_FINISHED_STATE = '%s' ) ", BizConstant.CIMFW_LOT_STATE_FINISHED, lotStatus));
                } else if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_WAITING,lotStatus) ||
                        CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING,lotStatus) ||
                        CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSED,lotStatus)) {
                    if (!firstLoop){
                        tempSql.append(" OR ");
                    }
                    tempSql.append(String.format(" ( LOT.LOT_STATE = '%s' AND LOT.LOT_HOLD_STATE = '%s' AND LOT.LOT_PROCESS_STATE = '%s' ) ", BizConstant.CIMFW_LOT_STATE_ACTIVE, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD, lotStatus));
                } else if (CimStringUtils.equals(BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD,lotStatus)) {
                    if (!firstLoop){
                        tempSql.append(" OR ");
                    }
                    tempSql.append(String.format(" LOT.LOT_HOLD_STATE = '%s' ", lotStatus));
                } else if (CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_NONPROBANK,lotStatus)) {
                    if (!firstLoop){
                        tempSql.append(" OR ");
                    }
                    tempSql.append(String.format(" LOT.LOT_INV_STATE = '%s' ", lotStatus));
                }else {
                    continue;
                }
                firstLoop = false;
            }
            if (lotStatusList.size() >1) {
                tempSql.append(")");
            }
            if (CimStringUtils.isNotEmpty(tempSql.toString())) {
                if (bFirstCondition) {
                    bFirstCondition = false;
                    sql += " WHERE";
                } else sql += " AND";
                sql += tempSql;
            }
        }

        if (CimStringUtils.isNotEmpty(lotListInqParams.getInterFabXferState())) {
            if (bFirstCondition) {
                bFirstCondition = false;
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.INTERFAB_XFER_STATE = '%s'", lotListInqParams.getInterFabXferState());
        }

        if (CimBooleanUtils.isTrue(lotListInqParams.getPoObjFilterFlag())) {
            //using in STB Cancel web;
            if (bFirstCondition) {
                bFirstCondition = false;
                sql += " WHERE";
            } else sql += " AND";

            sql += String.format(" LOT.PROPE_RKEY is not null" + " AND" + " (LOT.LOT_FINISHED_STATE is null or LOT.LOT_FINISHED_STATE != '%s') ", BizConstant.CIMFW_LOT_FINISHEDSTATE_EMPTIED);
        }

        CimBank bank = baseCoreFactory.getBO(CimBank.class, lotListInqParams.getBankID());
        if (null != bank && bank.isProductionBank()) {                                                                        //BUG-437 [add by Nyx]
            //Bug-148 start;
            if (CimBooleanUtils.isTrue(lotListInqParams.getInBankLotFilterFlag())) {
                //using in move bank screen;
                if (bFirstCondition) {
                    sql += " WHERE";
                } else {
                    sql += " AND";
                }
                sql += String.format(" LOT.LOT_INV_STATE = '%s'", BizConstant.SP_LOT_INVENTORYSTATE_INBANK);
            }                                                                                                               //BUG-437 [add by Nyx]
            //Bug-148 end;
        }

        // Use the default sort field "Last CLaimed Time"
        // Use the default sort order DESC
        String defaultSortName = "LOT.LAST_TRX_TIME";
        String defaultSortOrder = "ASC";
        if (!CimObjectUtils.isEmpty(searchCondition.getSortName())){

            defaultSortName = searchCondition.getSortName();
        }

        if (CimBooleanUtils.isTrue(searchCondition.getSortDirection())){

            defaultSortOrder = "DESC";
        }

        sql += String.format(" ORDER BY %s,LOT.LOT_ID %s",defaultSortName,defaultSortOrder);

        return sql;
    }

    private String getProcessInfoQuerySql(String LotID, String processDefinitionLevel) {
        return String.format("   SELECT OMPRP.PRP_ID, OMPRP.PRP_TYPE, OMPROPE.PLAN_START_TIME\n" +
                "     FROM OMLOT, OMPROPE, OMPRP \n" +
                "    WHERE OMLOT.LOT_ID = '%s' \n" +
                "      and OMLOT.PROPE_RKEY = OMPROPE.ID \n" +
                "      and OMPROPE.STEP_ID = OMPRP.PRP_ID \n" +
                "      and OMPRP.PRP_LEVEL = '%s' \n", LotID, processDefinitionLevel);


    }

    private Outputs.objCarrierEquipmentInfoGetOut getCarrierInformation(CimLotDO lot) {
        ObjectIdentifier outEquipmentId = new ObjectIdentifier();
        ObjectIdentifier cassetteId = new ObjectIdentifier();
        if (lot == null) {
            log.info("Failed to get system key from object reference.");
        } else {
            CimLotMaterialContainerDO cimLotMaterialContainerExample = new CimLotMaterialContainerDO();
            cimLotMaterialContainerExample.setReferenceKey(lot.getId());
            CimLotMaterialContainerDO cassetteInfo = cimJpaRepository.findOne(Example.of(cimLotMaterialContainerExample)).orElse(null);

            if (CimObjectUtils.isEmpty(cassetteInfo)) {
                log.debug("lot is not in carrier.");

                List<ObjectIdentifier> equipmentIdList = new ArrayList<>();
                if (CimStringUtils.equals(BizConstant.CIMFW_LOT_STATE_SHIPPED, lot.getLotState()) ||
                        CimStringUtils.equals(BizConstant.CIMFW_LOT_STATE_FINISHED, lot.getLotState()) ||
                        !CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR, lot.getLotInventoryState())) {

                    //omit NonProBankIn Lot;
                    log.info("When lot state is in FINISHED/SHIPPED or lot inventory state is not ON-FLOOR, set EQP info as below: equipmentIDSeq is null");
                } else {
                    // If lot state is "Processing", set the current assigned machine in PO.
                    if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING, lot.getLotProcessState())) {
                        log.debug("Set EQP info on SP_Lot_ProcState_Processing.");

                        CimProcessOperationDO processOperations = cimJpaRepository.queryOne("SELECT ALLOC_EQP_ID, ALLOC_EQP_RKEY\n" +
                                "                                     FROM   OMPROPE\n" +
                                "                                     WHERE  ID = ?", CimProcessOperationDO.class, lot.getProcessOperationObj());
                        if (null != processOperations) {
                            ObjectIdentifier equipmentId = new ObjectIdentifier(processOperations.getAssignEquipmentID(), processOperations.getAssignEquipmentObj());
                            equipmentIdList.add(equipmentId);
                        } else {
                            log.debug("eqp not be found.");
                        }
                    } else if (CimStringUtils.equals(BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD, lot.getLotHoldState())) {
                        // If lot state is hold , set the hold queued machines as the next equipments.
                        log.debug("Set EQP info on CIMFW_Lot_HoldState_OnHold.");
                        CimLotHoldEquipmentDO cimLotHoldEquipmentExample = new CimLotHoldEquipmentDO();
                        cimLotHoldEquipmentExample.setReferenceKey(lot.getLotID());
                        List<CimLotHoldEquipmentDO> lotHoldEquipments = cimJpaRepository.findAll(Example.of(cimLotHoldEquipmentExample));

                        for (CimLotHoldEquipmentDO holdEqp : lotHoldEquipments) {
                            equipmentIdList.add(new ObjectIdentifier(holdEqp.getEquipmentID(), holdEqp.getEquipmentObj()));
                        }

                    } else {
                        // If lot state is wating , set the queued machines as the next equipments.
                        // In other case("Processed"), set blank.
                        log.debug("Set EQP info on other cases.");
                        equipmentIdList.add(new ObjectIdentifier());
                    }
                }

                if (1 == CimArrayUtils.getSize(equipmentIdList) && ObjectIdentifier.isEmpty(equipmentIdList.get(0))) {
                    log.debug("equipmentIdList is null");
                } else if (0 < CimArrayUtils.getSize(equipmentIdList)) {
                    List<ObjectIdentifier> waferIdList = new ArrayList<>();
                    CimLotMaterialDO cimLotMaterialExample = new CimLotMaterialDO();
                    cimLotMaterialExample.setReferenceKey(lot.getId());
                    List<CimLotMaterialDO> lotWafers = cimJpaRepository.findAll(Example.of(cimLotMaterialExample));

                    for (CimLotMaterialDO lotWafer : lotWafers) {
                        waferIdList.add(new ObjectIdentifier(lotWafer.getMaterialID(), lotWafer.getMaterialObj()));
                    }

                    int eqpIDListLen = CimArrayUtils.getSize(equipmentIdList);
                    int eqpCnt;
                    boolean loopOutFlag = false;
                    for (eqpCnt = 0; eqpCnt < eqpIDListLen; eqpCnt++) {
                        ObjectIdentifier equipmentId = equipmentIdList.get(eqpCnt);

                        Infos.EqpContainerInfo ObjEquipmentBrInfoGetDROuts = equipmentMethod.equipmentContainerInfoGetDR(null, equipmentId);
                        int eqpCtnLen = CimArrayUtils.getSize(ObjEquipmentBrInfoGetDROuts.getEqpContainerList());
                        int eqpCtnCnt;
                        for (eqpCtnCnt = 0; eqpCtnCnt < eqpCtnLen; eqpCtnCnt++) {
                            int ctnPstLen = ObjEquipmentBrInfoGetDROuts.getEqpContainerList().get(eqpCtnCnt).getEqpContainerPosition().size();
                            int ctnPstCnt;
                            for (ctnPstCnt = 0; ctnPstCnt < ctnPstLen; ctnPstCnt++) {
                                int waferSeqLen = CimArrayUtils.getSize(waferIdList);
                                int waferSeqCnt;
                                for (waferSeqCnt = 0; waferSeqCnt < waferSeqLen; waferSeqCnt++) {
                                    Infos.EqpContainerPosition eqpContainerPosition = ObjEquipmentBrInfoGetDROuts.getEqpContainerList().get(eqpCtnCnt).getEqpContainerPosition().get(ctnPstCnt);
                                    ObjectIdentifier waferId = eqpContainerPosition.getWaferID();
                                    String slmState = eqpContainerPosition.getFmcState();
                                    if (ObjectIdentifier.equalsWithValue(waferId, waferIdList.get(waferSeqCnt)) && BizConstant.SP_SLMSTATE_STORED.equals(slmState)) {
                                        outEquipmentId = equipmentId;
                                        loopOutFlag = true;
                                        break;
                                    }
                                }
                            }
                            if (loopOutFlag) {
                                break;
                            }
                        }
                        if (loopOutFlag) {
                            break;
                        }
                    }
                }

            } else {
                cassetteId = new ObjectIdentifier(cassetteInfo.getMaterialContainerID(), cassetteInfo.getMaterialContainerObj());
                CimCassetteDO cimCassetteExample = new CimCassetteDO();
                cimCassetteExample.setCassetteID(cassetteInfo.getMaterialContainerID());
                cimCassetteExample.setTransferState(BizConstant.SP_TRANSSTATE_EQUIPMENTIN);
                CimCassetteDO cassette = cimJpaRepository.findOne(Example.of(cimCassetteExample)).orElse(null);

                log.debug("lot is in carrier {}.", cassetteId);
                if (CimObjectUtils.isEmpty(cassette)) {
                    log.debug("cassette is not loaded on eqp. CassetteID = {}", cassetteId);
                } else {
                    ObjectIdentifier equipmentId = new ObjectIdentifier(cassette.getEquipmentID(), cassette.getEquipmentObj());
                    log.debug("cassette is not loaded on eqp. equipmentID = {}", equipmentId);
                    outEquipmentId = equipmentId;
                }
            }
        }

        Outputs.objCarrierEquipmentInfoGetOut carrierEquipmentInfo = new Outputs.objCarrierEquipmentInfoGetOut();
        carrierEquipmentInfo.setCarrierID(cassetteId);
        carrierEquipmentInfo.setEquipmentID(outEquipmentId);


        return carrierEquipmentInfo;
    }

    /**
     * description:
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param objCommon   -
     * @param sourceLotID -
     * @return com.fa.cim.pojo.obj.RetCode<Outputs.ObjSourceLotProductRequestGetDROut>
     * @author Bear
     * @since 2018/5/24
     */
    @Override
    public ObjectIdentifier sourceLotProductRequestGetDR(Infos.ObjCommon objCommon, ObjectIdentifier sourceLotID) {

        log.info("[in-param]sourceLotID={}", sourceLotID);

        // Get the Product Request RefKey/PrimaryKey
        Object[] sqlResult = cimJpaRepository.queryOne("SELECT REFKEY FROM OMPRORDER_SRCLOT WHERE SRC_LOT_ID = ?1", sourceLotID.getValue());

        Validations.check(CimObjectUtils.isEmpty(sqlResult), new OmCode(retCodeConfig.getNotFoundProductRequestForSourceLot(), sourceLotID.getValue()));

        // Get the Product Request ID
        String productRequestObj = CimObjectUtils.toString(sqlResult[0]);
        sqlResult = cimJpaRepository.queryOne("SELECT PROD_ORDER_ID,\n" +
                "                 FROM   OMPRORDER\n" +
                        "                 WHERE ID = ?1", productRequestObj);

        Validations.check(CimObjectUtils.isEmpty(sqlResult), retCodeConfig.getNotFoundProductRequest());

        //【bear】yes, it just use the REFKEY to match the PRODREQ
        String productRequestID = CimObjectUtils.toString(sqlResult[0]);
        return new ObjectIdentifier(productRequestID, productRequestObj);
    }

    @Override
    public List<Infos.WaferListInLotFamilyInfo> lotWafersStatusListGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotFamilyID) {
        List<Infos.WaferListInLotFamilyInfo> data = new ArrayList<>();

        String sql = "SELECT " +
                "OMWAFER.LOT_ID," +
                "OMWAFER.LOT_RKEY, " +
                "OMWAFER.WAFER_ID," +
                "OMWAFER.ID," +
                "SCRAP_STATE, " +
                "OMWAFER.POSITION  " +
                "FROM OMWAFER, OMLOT WHERE OMWAFER.LOT_ID = OMLOT.LOT_ID AND OMLOT.LOT_FAMILY_ID = ?1 order by OMWAFER.POSITION";
        List<Object[]> wafers = cimJpaRepository.query(sql, lotFamilyID.getValue());
        if (!CimObjectUtils.isEmpty(wafers)) {
            //wafers.sort(comparingInt(CimWaferDO::getPosition));
            for (Object[] wafer : wafers) {
                Infos.WaferListInLotFamilyInfo waferListInLotFamilyInfo = new Infos.WaferListInLotFamilyInfo();
                waferListInLotFamilyInfo.setLotID(new ObjectIdentifier(CimObjectUtils.toString(wafer[0]), CimObjectUtils.toString(wafer[1])));
                waferListInLotFamilyInfo.setWaferID(new ObjectIdentifier(CimObjectUtils.toString(wafer[2]), CimObjectUtils.toString(wafer[3])));
                waferListInLotFamilyInfo.setScrapFlag(CimStringUtils.equals(CimObjectUtils.toString(wafer[4]), "Scrap"));
                waferListInLotFamilyInfo.setSlotNumber(Integer.valueOf(CimObjectUtils.toString(wafer[5])));
                data.add(waferListInLotFamilyInfo);
            }
        }

        return data;
    }

    @Override
    public Outputs.ObjLotChangeScheduleOut lotChangeSchedule(Infos.ObjCommon objCommon, Infos.ReScheduledLotAttributes attributes) {

        ObjectIdentifier productID = attributes.getProductID();
        ObjectIdentifier paraRouteID = attributes.getRouteID();
        String currentOperationNumber = attributes.getCurrentOperationNumber();
        Outputs.ObjLotChangeScheduleOut objLotChangeScheduleOut = new Outputs.ObjLotChangeScheduleOut();
        objLotChangeScheduleOut.setOpehsAddFlag(false);
        objLotChangeScheduleOut.setOpehsMoveFlag(false);
        ObjectIdentifier lotID = attributes.getLotID();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));

        com.fa.cim.newcore.bo.pd.CimProcessOperation processOperation = lot.getProcessOperation();
        Validations.check(null == processOperation, new OmCode(retCodeConfig.getNotFoundProcessOperation(), ""));

        ProcessDTO.PosProcessOperationEventData oldPOEventData = processOperation.getEventData();
        Inputs.OldCurrentPOData oldCurrentPOData = new Inputs.OldCurrentPOData();
        if (oldPOEventData != null){
            BeanUtils.copyProperties(oldPOEventData, oldCurrentPOData);
        }
        objLotChangeScheduleOut.setOldCurrentPOData(oldCurrentPOData);
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aProcessFlowContext = lot.getProcessFlowContext();

        CimProcessDefinition processDefinition = null;
        if (!ObjectIdentifier.isEmpty(productID) && !ObjectIdentifier.isEmpty(paraRouteID) && !CimObjectUtils.isEmpty(currentOperationNumber)) {
            //----------------------------------------------------//
            //   Check for Route and Operation                    //
            //   - Specified Route is Main ? (not subroute ?)     //
            //   - Specified operation is existing ?              //
            //----------------------------------------------------//
            processDefinition = baseCoreFactory.getBO(CimProcessDefinition.class, paraRouteID);
            Validations.check(null == processDefinition, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), ObjectIdentifier.fetchValue(paraRouteID)));

            String processFlowType = processDefinition.getProcessFlowType();
            String processDefinitionType = processDefinition.getProcessDefinitionType();

            //---------------------------------//
            //   Get lot's Route Information   //
            //---------------------------------//
            //===== get lot's currectPD (MainPD) object =====//
            com.fa.cim.newcore.bo.pd.CimProcessDefinition currentProcessDefinition = processOperation.getMainProcessDefinition();
            Validations.check(null == currentProcessDefinition, retCodeConfig.getNotFoundMainRoute());

            //===== get currentPD's ID =====//
            ObjectIdentifier currentRouteID = new ObjectIdentifier(currentProcessDefinition.getIdentifier(), currentProcessDefinition.getPrimaryKey());

            //-----------------------//
            //   Check combination   //
            //-----------------------//
            if (!CimStringUtils.equals(BizConstant.SP_FLOWTYPE_MAIN, processFlowType)
             && !CimStringUtils.equals(BizConstant.SP_MAINPDTYPE_BACKUP, processDefinitionType)) {
                Validations.check(!ObjectIdentifier.equalsWithValue(paraRouteID, currentRouteID), new OmCode(retCodeConfig.getInvalidFlowType(), processFlowType));
            }
            Inputs.ProcessOperationListForRoute processOperationListForRoute = new Inputs.ProcessOperationListForRoute();
            processOperationListForRoute.setRouteID(paraRouteID);
            processOperationListForRoute.setOperationNumber(currentOperationNumber);
            processOperationListForRoute.setSearchCount(1);
            List<Infos.OperationNameAttributes> forRouteOut = processMethod.processOperationListForRoute(objCommon, processOperationListForRoute);

            //------------------------------------------------------------------//
            //   Check for Route and Operation                                  //
            //   - Route which Schedul Client known is Main ? (not subroute ?)  //
            //   - Operation which Schedul Client known is existing ?           //
            //------------------------------------------------------------------//
            //===== get PD object =====//
            String originalRouteID = attributes.getOriginalRouteID();
            CimProcessDefinition originalProcessDefinition = baseCoreFactory.getBO(CimProcessDefinition.class, ObjectIdentifier.buildWithValue(originalRouteID));

            Validations.check(null == originalProcessDefinition, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), originalRouteID));

            //===== get and check specified route's flow type =====//
            String orgProcessFlowType = originalProcessDefinition.getProcessFlowType();
            //===== get and check specified route's pd type =====//
            String orgProcessDefinitionType = originalProcessDefinition.getProcessDefinitionType();

            //-------------------------------------------//
            //   Check combination about Original Route  //
            //-------------------------------------------//
            if (!CimStringUtils.equals(BizConstant.SP_FLOWTYPE_MAIN, orgProcessFlowType)
             && !CimStringUtils.equals(BizConstant.SP_MAINPDTYPE_BACKUP, orgProcessDefinitionType)) {
                Validations.check(!ObjectIdentifier.equalsWithValue(paraRouteID, currentRouteID), new OmCode(retCodeConfig.getInvalidFlowType(), orgProcessFlowType));
            }
            String originalOperationNumber = attributes.getOriginalOperationNumber();
            //------------------------------------------------------------------------//
            // Get current RouteID by lotID                                           //
            //------------------------------------------------------------------------//
            currentRouteID = this.lotCurrentRouteIDGet(objCommon, lotID);
            //------------------------------------------------------------------------//
            // Get current oparation No. by lotID                                     //
            //------------------------------------------------------------------------//
            currentOperationNumber = this.lotCurrentOpeNoGet(objCommon, lotID);
            Validations.check(!ObjectIdentifier.equalsWithValue(currentRouteID, originalRouteID) || !currentOperationNumber.equals(originalOperationNumber)
                    , new OmCode(retCodeConfig.getInvalidRouteOperationSpecified(), ObjectIdentifier.fetchValue(lotID), originalRouteID, originalOperationNumber));

            com.fa.cim.newcore.bo.prodspec.CimProductSpecification aPrevproductSpecification = lot.getProductSpecification();
            Validations.check(null == aPrevproductSpecification, retCodeConfig.getNotFoundProductSpec());
            objLotChangeScheduleOut.setPreviousProductID(ObjectIdentifier.build(aPrevproductSpecification.getIdentifier(),aPrevproductSpecification.getPrimaryKey()));

            CimProductSpecification productSpecification = baseCoreFactory.getBO(CimProductSpecification.class, attributes.getProductID());
            objLotChangeScheduleOut.setOpehsMoveFlag(true);
            objLotChangeScheduleOut.setOpehsAddFlag(true);
            // Remove aLot from current dispatching queue
            dispatchingManager.removeFromQueue(lot);
            // Set new product specification
            lot.setProductSpecification(productSpecification);

            com.fa.cim.newcore.bo.durable.CimReticleSet reticleSet = productSpecification.getReticleSet();
            if (null != reticleSet) {
                lot.setReticleSet(reticleSet);
            }

            // --------------------------------//
            //       Update MFG Layer          //
            // --------------------------------//
            String aMfgLayer = productSpecification.getMFGLayer();
            if (CimStringUtils.isNotEmpty(aMfgLayer)) {
                lot.setMFGLayer(aMfgLayer);
            }

            List<Material> wafers = lot.allMaterial();
            for (int i = 0; i < CimArrayUtils.getSize(wafers); i++) {
                CimWafer wafer = (CimWafer)wafers.get(i);
                Validations.check(null == wafer, retCodeConfig.getNotFoundWafer());
                wafer.setProductSpecification(productSpecification);
            }

            processDefinition = baseCoreFactory.getBO(CimProcessDefinition.class, paraRouteID);
            Validations.check(null == processDefinition, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), "*****"));
            lot.changeFlowTo(processDefinition, attributes.getCurrentOperationNumber());
            String procState = lot.getLotProcessState();
            String holdState = lot.getLotHoldState();
            String invtState = lot.getLotInventoryState();
            if (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_WAITING, procState)
             && CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, holdState)
             && CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR, invtState)) {
                dispatchingManager.addToQueue(lot);
            }
        }

        //--------------------------------------------------------//
        //             Set Production State                       //
        //--------------------------------------------------------//
        CimPerson person = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, new OmCode(retCodeConfig.getNotFoundPerson(), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));

        if (!ObjectIdentifier.isEmptyWithValue(paraRouteID)) {
            lot.changeProductionStateBy(objCommon.getTimeStamp().getReportTimeStamp().toString(), person);
        }

        String subLotType = attributes.getSubLotType();
        if (!CimStringUtils.isEmpty(subLotType)) {
            Outputs.LotSubLotTypeGetDetailInfoDR lotSubLotTypeGetDetailInfoDR = lotSubLotTypeGetDetailInfoDR(objCommon, subLotType);
            //-------------------
            // Get lottype
            //-------------------
            String lotType = lotSubLotTypeGetDetailInfoDR.getLotType();
            String tmpLotType = lot.getLotType();
            Validations.check(CimStringUtils.isNotEmpty(lotType) && !CimStringUtils.equals(lotType, tmpLotType), retCodeConfig.getInvalidParameter());
            lot.setSubLotType(subLotType);
        }

        if (CimStringUtils.isNotEmpty(attributes.getShedulingMode())) {
            lot.setScheduleMode(attributes.getShedulingMode());
        }

        String priorityClass = attributes.getPriorityClass();
        if (!CimStringUtils.isEmpty(priorityClass)) {
            lot.setPriorityClass(Integer.valueOf(priorityClass));
        }

        if (!CimStringUtils.isEmpty(attributes.getPlannedStartTime())) {
            lot.setPlannedStartDateTime(Timestamp.valueOf(attributes.getPlannedStartTime()));
        }

        if (!CimStringUtils.isEmpty(attributes.getPlannedFinishTime())) {
            lot.setPlannedCompletionDateTime(Timestamp.valueOf(attributes.getPlannedFinishTime()));
        }

        List<Infos.ChangedLotSchedule> changedLotSchedules = attributes.getChangedLotScheduleList();
        if (!CimObjectUtils.isEmpty(changedLotSchedules)) {
            CimLotOperationSchedule lotOperationSchedule = null;
            com.fa.cim.newcore.bo.planning.CimLotSchedule lotSchedule = lot.getLotSchedule();
            Boolean parentLotFlag = lot.isOriginalLot();
            String noschedule = StandardProperties.OM_LOT_SPLIT_NO_SCHEDULE_FOR_CHILD.getValue();
            if ((CimStringUtils.isEmpty(noschedule) || !CimStringUtils.equals(noschedule, "1") )&& null == lotSchedule) {
                Validations.check(true, new OmCode(retCodeConfig.getNotFoundLotSchedule(), ""));
            } else if (!CimStringUtils.isEmpty(noschedule) && CimStringUtils.equals(noschedule, "1") && CimBooleanUtils.isFalse(parentLotFlag)) {

            } else {
                if (!CimObjectUtils.isEmpty(lotSchedule)) {
                    lotSchedule.removeAllLotOperationSchedules();
                    //-------------------------------------
                    // Judgement of RouteID is in InPara or
                    //-------------------------------------
                    String routeID = null;
                    if (!ObjectIdentifier.isEmptyWithValue(paraRouteID)) {
                        routeID = paraRouteID.getValue();
                    } else {
                        //------------
                        // Get MainPD
                        //------------
                        CimProcessDefinition aMainPD = lot.getMainProcessDefinition();
                        Validations.check(null == aMainPD, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), ""));

                        //-------------
                        // Get RouteID
                        //-------------
                        routeID = aMainPD.getIdentifier();
                        processDefinition = (CimProcessDefinition)processDefinitionManager.findMainProcessDefinitionNamed(routeID);
                        Validations.check(null == processDefinition, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), routeID));
                    }

                    for (Infos.ChangedLotSchedule changedLotSchedule : changedLotSchedules) {
                        //-------------------------------
                        // Operation Number Length Check
                        //-------------------------------
                        String operationNumber = changedLotSchedule.getOperationNumber();
                        if (!CimStringUtils.isEmpty(operationNumber)) {
                            String makeUpKey = String.format("%s.%s", routeID, operationNumber);
                            try {
                                lotOperationSchedule = lotSchedule.createLotOperationScheduleNamed(makeUpKey);
                            } catch(DuplicateRecordException e) {
                                throw new ServiceException(retCodeConfig.getSystemError());
                            }

                            Validations.check(null == lotOperationSchedule, retCodeConfig.getNotFoundLotOperationSchedule());

                            lotOperationSchedule.setMainProcessDefinition(processDefinition);
                            lotOperationSchedule.setOperationNumber(changedLotSchedule.getOperationNumber());
                            String plannedStartTime = changedLotSchedule.getPlannedStartTime();
                            lotOperationSchedule.setPlannedStartDateTime(CimStringUtils.isEmpty(plannedStartTime) ? null : Timestamp.valueOf(plannedStartTime));
                            String plannedFinishTime = changedLotSchedule.getPlannedFinishTime();
                            lotOperationSchedule.setPlannedEndDateTime(CimStringUtils.isEmpty(plannedFinishTime) ? null : Timestamp.valueOf(plannedFinishTime));
                            ObjectIdentifier equipmentID = changedLotSchedule.getEquipmentID();
                            if (!ObjectIdentifier.isEmptyWithValue(equipmentID)) {
                                CimMachine aMachine = baseCoreFactory.getBO(CimMachine.class, equipmentID);
                                lotOperationSchedule.setPlannedMachine(aMachine);
                            }
                        } else {
                            Validations.check(true, new OmCode(retCodeConfig.getNotFoundLotOperationSchedule(), ""));
                        }
                    }

                    String strTmpOpeNo = CimStringUtils.isEmpty(currentOperationNumber) ? lot.getOperationNumber() : currentOperationNumber;
                    String makeUpKey = String.format("%s.%s", routeID, strTmpOpeNo);
                    lotOperationSchedule = lotSchedule.findLotOperationScheduleNamed(makeUpKey);
                    if (null != lotOperationSchedule) {
                        com.fa.cim.newcore.bo.pd.CimProcessOperation aTmpNewProcessOperation = lot.getProcessOperation();
                        if (null != aTmpNewProcessOperation) {
                            aTmpNewProcessOperation.setPlannedStartTimeStamp(lotOperationSchedule.getPlannedStartDateTime());
                            aTmpNewProcessOperation.setPlannedCompTimeStamp(lotOperationSchedule.getPlannedEndDateTime());
                            aTmpNewProcessOperation.setPlannedMachine(lotOperationSchedule.getPlannedMachine());
                        } else {
                            Validations.check(true, retCodeConfig.getNotFoundProcessOperation());
                        }
                    }
                }
            }
        }
        lot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        lot.setLastClaimedPerson(person);
        return objLotChangeScheduleOut;
    }

    @Override
    public List<Infos.DataCollectionInfo> lotCurrentOperationDataCollectionInformationGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        List<Infos.DataCollectionInfo> dataCollectionInfos = null;
        //--------------------------------------------------
        // Set target Items.
        //--------------------------------------------------

        /*--------------------------*/
        /*   Get Lot Related Info   */
        /*--------------------------*/
        log.info("Input Param lotID :{}", lotID);
        CimLot lot = baseCoreFactory.getBO(CimLot.class,lotID);
        //--------------------------------------------------------------------------
        // Get PO from Previous Operation.
        //--------------------------------------------------------------------------
        com.fa.cim.newcore.bo.pd.CimProcessOperation apo = lot.getProcessOperation();
        Validations.check(null == apo, retCodeConfig.getNotFoundProcessOperation());

        ProcessDTO.ActualStartInformationForPO actualStartInfo = apo.getActualStartInfo(true);
        if (actualStartInfo.getAssignedDataCollectionFlag()) {
            log.info("actualStartInfo->assignedDataCollectionFlag == TRUE");
            final List<ProcessDTO.DataCollectionInfo> assignedDataCollections = actualStartInfo.getAssignedDataCollections();
            int dcLen = CimArrayUtils.getSize(assignedDataCollections);
            log.info("loop to actualStartInfo->assignedDataCollections.length()", dcLen);


            if(CimArrayUtils.isNotEmpty(assignedDataCollections)) {
                dataCollectionInfos = new ArrayList<>();
                for (ProcessDTO.DataCollectionInfo assignedDataCollection : assignedDataCollections) {
                    Infos.DataCollectionInfo collectionInfo = new Infos.DataCollectionInfo();
                    dataCollectionInfos.add(collectionInfo);
                    collectionInfo.setDataCollectionDefinitionID(assignedDataCollection.getDataCollectionDefinitionID());
                    collectionInfo.setDescription(assignedDataCollection.getDescription());
                    collectionInfo.setDataCollectionType(assignedDataCollection.getDataCollectionType());
                    collectionInfo.setCalculationRequiredFlag(assignedDataCollection.getCalculationRequiredFlag());
                    collectionInfo.setSpecCheckRequiredFlag(assignedDataCollection.getSpecCheckRequiredFlag());
                    collectionInfo.setDataCollectionSpecificationID(assignedDataCollection.getDataCollectionSpecificationID());
                    collectionInfo.setDcSpecDescription(assignedDataCollection.getDcSpecDescription());
                    collectionInfo.setPreviousDataCollectionDefinitionID(assignedDataCollection.getPreviousDataCollectionDefinitionID());
                    collectionInfo.setPreviousOperationID(assignedDataCollection.getPreviousOperationID());
                    collectionInfo.setPreviousOperationNumber(assignedDataCollection.getPreviousOperationNumber());

                    final List<ProcessDTO.DataCollectionSpecInfo> dcSpecsTmp = assignedDataCollection.getDcSpecs();
                    List<Infos.DataCollectionSpecInfo> dcSpecs = new ArrayList<>();
                    collectionInfo.setDcSpecs(dcSpecs);
                    if(CimArrayUtils.isNotEmpty(dcSpecsTmp)) {
                        for (ProcessDTO.DataCollectionSpecInfo dataCollectionSpecInfo : dcSpecsTmp) {
                            Infos.DataCollectionSpecInfo specInfo = new Infos.DataCollectionSpecInfo();
                            dcSpecs.add(specInfo);
                            specInfo.setDataItemName(dataCollectionSpecInfo.getDataItemName());
                            specInfo.setScreenLimitUpperRequired(dataCollectionSpecInfo.getScreenLimitUpperRequired());
                            specInfo.setScreenLimitUpper(dataCollectionSpecInfo.getScreenLimitUpper());
                            specInfo.setActionCodesUscrn(dataCollectionSpecInfo.getActionCodesUscrn());
                            specInfo.setScreenLimitLowerRequired(dataCollectionSpecInfo.getScreenLimitLowerRequired());
                            specInfo.setScreenLimitLower(dataCollectionSpecInfo.getScreenLimitLower());
                            specInfo.setActionCodesLscrn(dataCollectionSpecInfo.getActionCodesLscrn());
                            specInfo.setSpecLimitUpperRequired(dataCollectionSpecInfo.getSpecLimitUpperRequired());
                            specInfo.setSpecLimitUpper(dataCollectionSpecInfo.getSpecLimitUpper());
                            specInfo.setActionCodesUsl(dataCollectionSpecInfo.getActionCodesUsl());
                            specInfo.setSpecLimitLowerRequired(dataCollectionSpecInfo.getSpecLimitLowerRequired());
                            specInfo.setSpecLimitLower(dataCollectionSpecInfo.getSpecLimitLower());
                            specInfo.setActionCodesLsl(dataCollectionSpecInfo.getActionCodesLsl());
                            specInfo.setControlLimitUpperRequired(dataCollectionSpecInfo.getControlLimitUpperRequired());
                            specInfo.setControlLimitUpper(dataCollectionSpecInfo.getControlLimitUpper());
                            specInfo.setActionCodesUcl(dataCollectionSpecInfo.getActionCodesUcl());
                            specInfo.setControlLimitLowerRequired(dataCollectionSpecInfo.getControlLimitLowerRequired());
                            specInfo.setControlLimitLower(dataCollectionSpecInfo.getControlLimitLower());
                            specInfo.setActionCodesLcl(dataCollectionSpecInfo.getActionCodesLcl());
                            specInfo.setTarget(dataCollectionSpecInfo.getTarget());
                            specInfo.setTag(dataCollectionSpecInfo.getTag());
                            specInfo.setDcSpecGroup(dataCollectionSpecInfo.getDcSpecGroup());
                        }
                    }

                    final List<ProcessDTO.DataCollectionItemInfo> dcItemsTmp = assignedDataCollection.getDcItems();
                    List<Infos.DataCollectionItemInfo> dcItems = new ArrayList<>();
                    collectionInfo.setDcItems(dcItems);
                    if(CimArrayUtils.isNotEmpty(dcItemsTmp)) {
                        for (ProcessDTO.DataCollectionItemInfo dataCollectionItemInfo : dcItemsTmp) {
                            Infos.DataCollectionItemInfo itemInfo = new Infos.DataCollectionItemInfo();
                            dcItems.add(itemInfo);
                            itemInfo.setDataCollectionItemName(dataCollectionItemInfo.getDataCollectionItemName());
                            itemInfo.setDataCollectionMode(dataCollectionItemInfo.getDataCollectionMode());
                            itemInfo.setDataCollectionUnit(dataCollectionItemInfo.getDataCollectionUnit());
                            itemInfo.setDataType(dataCollectionItemInfo.getDataType());
                            itemInfo.setItemType(dataCollectionItemInfo.getItemType());
                            itemInfo.setMeasurementType(dataCollectionItemInfo.getMeasurementType());
                            itemInfo.setWaferID(dataCollectionItemInfo.getWaferID());
                            itemInfo.setWaferPosition(dataCollectionItemInfo.getWaferPosition());
                            itemInfo.setSitePosition(dataCollectionItemInfo.getSitePosition());
                            itemInfo.setHistoryRequiredFlag(dataCollectionItemInfo.getHistoryRequiredFlag());
                            itemInfo.setCalculationType(dataCollectionItemInfo.getCalculationType());
                            itemInfo.setCalculationExpression(dataCollectionItemInfo.getCalculationExpression());
                            itemInfo.setDataValue(dataCollectionItemInfo.getDataValue());
                            itemInfo.setTargetValue(dataCollectionItemInfo.getTargetValue());
                            itemInfo.setSpecCheckResult(dataCollectionItemInfo.getSpecCheckResult());
                            itemInfo.setActionCodes(dataCollectionItemInfo.getActionCodes());
                        }
                    }
                }
            }

        }
        return dataCollectionInfos;
    }

    @Override
    public Infos.StartRecipe lotActualOperationStartRecipeGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Infos.StartRecipe retVal = new Infos.StartRecipe();

        Validations.check(null == lotID, retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID));
        final CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID));

        final CimProcessOperation processOperation = aLot.getProcessOperation();
        Validations.check(null == processOperation, retCodeConfig.getNotFoundPoForLot());

        final ProcessDTO.ActualStartInformationForPO actualStartInfo = processOperation.getActualStartInfo(false);
        if (null != actualStartInfo) {
            retVal.setLogicalRecipeID(actualStartInfo.getAssignedLogicalRecipe());
            retVal.setMachineRecipeID(actualStartInfo.getAssignedMachineRecipe());
            retVal.setPhysicalRecipeID(actualStartInfo.getAssignedPhysicalRecipe());
            retVal.setDataCollectionFlag(actualStartInfo.getAssignedDataCollectionFlag());
        }
        return retVal;
    }

    @Override
    public Infos.EqpMonitorJobLotInfo lotEqpMonitorJobGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Infos.EqpMonitorJobLotInfo eqpMonitorJobLOut = new Infos.EqpMonitorJobLotInfo();
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        ProductDTO.EqpMonitorJobLotInfo equipmentMonitorJobInfo = lot.getEqpMonitorJobLotInfo();

        if(equipmentMonitorJobInfo == null || ObjectIdentifier.isEmpty(equipmentMonitorJobInfo.getEqpMonitorJobID())){
            return eqpMonitorJobLOut;
        }
        eqpMonitorJobLOut.setEquipmentID(equipmentMonitorJobInfo.getEquipmentID());
        eqpMonitorJobLOut.setChamberID(equipmentMonitorJobInfo.getChamberID());
        eqpMonitorJobLOut.setEqpMonitorID(equipmentMonitorJobInfo.getEqpMonitorID());
        eqpMonitorJobLOut.setEqpMonitorJobID(equipmentMonitorJobInfo.getEqpMonitorJobID());
        eqpMonitorJobLOut.setLotID(equipmentMonitorJobInfo.getLotID());
        eqpMonitorJobLOut.setMonitorLotStatus(equipmentMonitorJobInfo.getMonitorLotStatus());
        eqpMonitorJobLOut.setStartSeqNo(equipmentMonitorJobInfo.getStartSeqNo());
        eqpMonitorJobLOut.setMonitorOpeKey(equipmentMonitorJobInfo.getMonitorOpeKey());
        eqpMonitorJobLOut.setExitFlag(equipmentMonitorJobInfo.getExitFlag());
        eqpMonitorJobLOut.setResult(equipmentMonitorJobInfo.getResult());

        String monitorOpeKey = equipmentMonitorJobInfo.getMonitorOpeKey();
        Map<String, String> eqpMonitorMap = BaseStaticMethod.convertMonopekeyToRouteOpeForHostvariable(monitorOpeKey);
        eqpMonitorJobLOut.setMonitorRouteID(ObjectIdentifier.buildWithValue(eqpMonitorMap.get("routeID")));
        eqpMonitorJobLOut.setMonitorOpeNo(eqpMonitorMap.get("monitorOpeNo"));

        return eqpMonitorJobLOut;
    }

    @Override
    public void lotCheckConditionForFlowBatch(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, String portGroupID, List<Infos.StartCassette> strStartCassette, String operation) {

        int totalWaferCount = 0;
        if(!CimArrayUtils.isEmpty(strStartCassette)){
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                if(!CimArrayUtils.isEmpty(lotInCassetteList)){
                    for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                        //Omit Not Process lot
                        boolean operationStartFlag = lotInCassette.getMoveInFlag();
                        if(CimBooleanUtils.isFalse(operationStartFlag)){
                            continue;
                        }
                        // Get lot Object
                        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotInCassette.getLotID().getValue()));
                        //Get lot's Countol Job ID
                        CimControlJob aControlJob = aLot.getControlJob();
                        if (aControlJob != null){
                            ObjectIdentifier jobID = new ObjectIdentifier(aControlJob.getIdentifier(), aControlJob.getPrimaryKey());
                            throw new ServiceException(new OmCode(retCodeConfig.getLotControlJobidFilled(), lotInCassette.getLotID().getValue(), jobID.getValue()));
                        }
                        //Get and Check lot's State
                        if(!CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL)
                            && !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE)){
                            String holdState = aLot.getLotHoldState();
                            String processState = aLot.getLotProcessState();
                            String inventoryState = aLot.getLotInventoryState();

                            Validations.check(!CimStringUtils.equals(holdState, CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD),
                                    new OmCode(retCodeConfig.getInvalidLotStat(), lotInCassette.getLotID().getValue(), holdState));

                            Validations.check(!CimStringUtils.equals(processState, BizConstant.SP_LOT_PROCSTATE_WAITING),
                                    new OmCode(retCodeConfig.getInvalidLotProcstat(), lotInCassette.getLotID().getValue(), processState));

                            Validations.check(!CimStringUtils.equals(inventoryState, BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR),
                                    retCodeConfig.getInvalidLotInventoryStat(), ObjectIdentifier.fetchValue(lotInCassette.getLotID()),
                                            inventoryState);

                            // Check InPostProcessFlag of lot
                            boolean inPostProcessFlag = aLot.isPostProcessFlagOn();
                            Validations.check(CimBooleanUtils.isTrue(inPostProcessFlag),
                                    new OmCode(retCodeConfig.getLotInPostProcess(), lotInCassette.getLotID().getValue()));

                            //Check SorterJob existence
                            List<ObjectIdentifier> lotIDs = new ArrayList<>();
                            lotIDs.add(lotInCassette.getLotID());
                            Inputs.ObjWaferSorterJobCheckForOperation objWaferSorterJobCheckForOperation = new Inputs.ObjWaferSorterJobCheckForOperation();
                            objWaferSorterJobCheckForOperation.setLotIDList(lotIDs);
                            objWaferSorterJobCheckForOperation.setOperation(BizConstant.SP_OPERATION_FOR_LOT);

                            //step1 - waferSorter_sorterJob_CheckForOperation
                            log.info("step1 - waferSorter_sorterJob_CheckForOperation");
                            waferMethod.waferSorterSorterJobCheckForOperation(objCommon, objWaferSorterJobCheckForOperation);
                        }
                        //Check eqp Availability
                        if(!CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL) &&
                                !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE)){
                            //Get and Check eqp Availability for lot
                            List<ObjectIdentifier> checkLotIDs = new ArrayList<>();
                            checkLotIDs.add(lotInCassette.getLotID());
                            //step2 - equipment_CheckAvailForLot
                            log.info("step2 - equipment_CheckAvailForLot");
                            equipmentMethod.equipmentCheckAvailForLot(objCommon, equipmentID, checkLotIDs);
                        }
                        /*--------------------------------------------*/
                        /*   Save Total Wafer Count to be Processed   */
                        /*--------------------------------------------*/
                        totalWaferCount += lotInCassette.getLotWaferList().size();
                    }
                }
            }
        }
        //Get eqp's Process Batch Condition
        if(!ObjectIdentifier.isEmptyWithValue(equipmentID)){
            //step3 - equipment_processBatchCondition_Get
            log.info("step3 - equipment_processBatchCondition_Get");
            Outputs.ObjEquipmentProcessBatchConditionGetOut equipmentProcessBatchCondition = equipmentMethod.equipmentProcessBatchConditionGet(objCommon, equipmentID);
            if(!CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_EQPRESERVECANCEL) &&
                    !CimStringUtils.equals(operation, BizConstant.SP_OPERATION_FLOWBATCH_LOTREMOVE)){
                //Check Minimun wafer Count
                Validations.check(equipmentProcessBatchCondition.getMinWaferSize() > totalWaferCount, retCodeConfig.getInvalidInputWaferCount());
            }
        }
    }

    @Override
    public ObjectIdentifier lotCassetteCheckSame(Infos.ObjCommon objCommon, List<ObjectIdentifier> lotIDs) {
        List<MaterialContainer> tmpCassetteIDs = new ArrayList<>();
        int lLen = CimArrayUtils.getSize(lotIDs);
        for (int i = 0; i < lLen; i++) {
            CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotIDs.get(i));
            Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotIDs.get(i).getValue()));
            List<MaterialContainer> aCassetteList = aLot.materialContainers();
            if (i == 0) {
                tmpCassetteIDs = aCassetteList;
            } else {
                boolean foundFlag =false;
                ObjectIdentifier tmpCassetteObjId = null;
                ObjectIdentifier aCassetteSeqObjId = null;
                if(!CimArrayUtils.isEmpty(tmpCassetteIDs)){
                    for (MaterialContainer tmpCassetteID : tmpCassetteIDs) {
                        if(!CimArrayUtils.isEmpty(aCassetteList)){
                            for (MaterialContainer materialContainer : aCassetteList) {
                                tmpCassetteObjId = new ObjectIdentifier(tmpCassetteID.getIdentifier(), tmpCassetteID.getPrimaryKey());
                                aCassetteSeqObjId = new ObjectIdentifier(materialContainer.getIdentifier(), materialContainer.getPrimaryKey());
                                if(ObjectIdentifier.equalsWithValue(tmpCassetteObjId, aCassetteSeqObjId)){
                                    tmpCassetteIDs.set(0, materialContainer);
                                    foundFlag = true;
                                    break;
                                }
                            }
                        }
                        if(CimBooleanUtils.isTrue(foundFlag)){
                            break;
                        }
                    }
                }
                Validations.check(CimBooleanUtils.isFalse(foundFlag),
                        new OmCode(retCodeConfig.getLotCastUnmatch(), lotIDs.get(i).getValue(), ObjectIdentifier.fetchValue(tmpCassetteObjId)));
            }
        }
        return new ObjectIdentifier(tmpCassetteIDs.get(0).getIdentifier(), tmpCassetteIDs.get(0).getPrimaryKey());
    }

    @Override
    public void lotNextOperationCheckEntryPointOfFlowBatch(Infos.ObjCommon objCommon, Infos.BatchingReqLot batchingReqLot) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, batchingReqLot.getLotID());
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), batchingReqLot.getLotID().getValue()));
        com.fa.cim.newcore.bo.pd.CimProcessOperation curPO = aLot.getProcessOperation();
        Validations.check(curPO == null, new OmCode(retCodeConfig.getNotFoundOperation(), ""));
        boolean flag = curPO.isFlowBatchEntryOperation();
        if (flag){
            return;
        }
        throw new ServiceException(new OmCode(retCodeConfig.getNotEntryPointOfBatch(), batchingReqLot.getLotID().getValue()));
    }


    @Override
    public List<Object[]> getWaitingLotList() {
        String querySql = "SELECT A.ID,\n" +
                " A.LOT_ID,\n" +
                " A.ID,\n" +
                " A.PROPE_RKEY,\n" +
                " A.FLOWB_ID,\n" +
                " B.ROUTE_PRSS_RKEY\n" +
                " FROM OMLOT A, OMPROPE B\n" +
                " WHERE A.LOT_FINISHED_STATE = ''\n" +
                " AND A.LOT_HOLD_STATE     = 'NOTONHOLD'\n" +
                " AND A.LOT_INV_STATE      = 'OnFloor'\n" +
                " AND A.LOT_PROCESS_STATE  = 'Waiting'\n" +
                " AND A.PROPE_RKEY             = B.ID\n" +
                " ORDER BY A.LOT_ID ASC";
        return cimJpaRepository.query(querySql);
    }


    @Override
    public List<Infos.FutureReworkInfo> lotFutureReworkListGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier routeID, String operationNumber) {
        Params.FutureActionDetailInfoInqParams params = new Params.FutureActionDetailInfoInqParams();
        params.setLotID(lotID);
        Infos.OperationFutureActionAttributes attributes = new Infos.OperationFutureActionAttributes();
        attributes.setRouteID(routeID);
        attributes.setOperationNumber(operationNumber);
        params.setOperationFutureActionAttributes(attributes);
        Outputs.lotFutureReworkListGetDROut reworkOut = lotMethod.lotFutureReworkListGetDR(objCommon, params);

        return CimObjectUtils.isEmpty(reworkOut) ? null : reworkOut.getFutureReworkDetailInfoList();
    }

    @Override
    public void lotProcessStateMakeWaiting(Infos.ObjCommon objCommon, List<Infos.StartCassette> startCassetteList) {

        //Get person Object;
        CimPerson aPerson = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(CimObjectUtils.isEmpty(aPerson), retCodeConfig.getNotFoundPerson());

        //Loop for strStartCassette;
        int scLen = CimArrayUtils.getSize(startCassetteList);
        for (int i = 0; i < scLen; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            //Loop for strLotInCassette;
            int lcLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
            for (int j = 0; j < lcLen; j++) {
                Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                // Omit Not-Start lot ;
                Boolean operationStartFlag = lotInCassette.getMoveInFlag();
                if (!operationStartFlag) {
                    continue;
                }

                // Get lot Object;
                CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                Validations.check(CimObjectUtils.isEmpty(aLot), retCodeConfig.getNotFoundLot());
                //Change ProcessingState to Waiting  ;
                aLot.makeWaiting();

                //Change LastClaimedXxxx / LastStateChangedXxxx;
                aLot.setLastClaimedPerson(aPerson);

                aLot.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());

                aLot.setStateChangedPerson(aPerson);

                aLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());

            }
        }


    }

    @Override
    public List<Infos.LotHoldEffectList> lotHoldRecordEffectMonitorIssue(Infos.ObjCommon objCommon, List<Infos.StartCassette> startCassetteList) {
        List<Infos.LotHoldEffectList> outObject = new ArrayList<>();

        //Initialize;
        int lotHold_count = 0;
        CimPerson aHoldPerson = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == aHoldPerson, new OmCode(retCodeConfig.getNotFoundPerson(), ObjectIdentifier.fetchValue(objCommon.getUser().getUserID())));

        // Hold Request ;
        int startCassetteLen = CimArrayUtils.getSize(startCassetteList);
        //get start lots;
        int startLotCnt = 0;
        List<ObjectIdentifier> startLotList = new ArrayList<>();
        for (int i = 0; i < startCassetteLen; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            int lotLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
            for (int j = 0; j < lotLen; j++) {
                Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                if (CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag())) {
                    startLotList.add(lotInCassette.getLotID());
                }
            }
        }

        for (int i = 0; i < startCassetteLen; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            int lotLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
            for (int j = 0; j < lotLen; j++) {
                Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                // Omit Not-Started lot;
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                    continue;
                }

                // Check Monitor Flag;
                CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotInCassette.getLotID())));

                com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = aLot.getProcessFlowContext();
                Validations.check (aPFX == null, new OmCode(retCodeConfig.getNotFoundPfx(), "*****"));

                com.fa.cim.newcore.bo.pd.CimProcessOperation aPrevPO = aPFX.getPreviousProcessOperation();
                Validations.check(aPrevPO == null, new OmCode(retCodeConfig.getNotFoundOperation(), "******"));


                com.fa.cim.newcore.bo.recipe.CimLogicalRecipe aLogicalRecipe = aPrevPO.getAssignedLogicalRecipe();
                Validations.check(aLogicalRecipe == null, retCodeConfig.getNotFoundLogicalRecipe());

                Boolean Flag = aLogicalRecipe.isMonitorHoldRequired();
                if (CimBooleanUtils.isTrue(Flag)) {
                    List<CimMonitorGroup> monitorGroupList = aLot.allMonitorGroups();
                    int monitorGroupLen = CimArrayUtils.getSize(monitorGroupList);
                    if (monitorGroupLen > 0) {
                        Boolean bLotHeld = false;
                        for (int m = 0; m < monitorGroupLen; m++) {
                            CimMonitorGroup monitorGroup = monitorGroupList.get(m);
                            //get Monitoring lot;
                            CimLot aMonitorLot = monitorGroup.getMonitorLot();
                            Validations.check (aMonitorLot == null, retCodeConfig.getNotFoundMonitorLot());

                            ObjectIdentifier monitorLotID = new ObjectIdentifier(aMonitorLot.getIdentifier());
                            //search Monitoring lot from start lots;
                            for (int k = 0; k < CimArrayUtils.getSize(startLotList); k++) {
                                ObjectIdentifier startLot = startLotList.get(k);
                                if (ObjectIdentifier.equalsWithValue(startLot, monitorLotID)) {
                                    log.info("Monitoring lot is one of start lots.");
                                    Infos.LotHoldEffectList lotHoldEffectList = new Infos.LotHoldEffectList();
                                    outObject.add(lotHoldEffectList);
                                    lotHoldEffectList.setLotID(lotInCassette.getLotID());
                                    lotHoldEffectList.setHoldType(BizConstant.SP_HOLDTYPE_WAITINGMONITORRESULTHOLD);
                                    ObjectIdentifier reasonCode = new ObjectIdentifier(BizConstant.SP_REASON_WAITINGMONITORRESULTHOLD);
                                    lotHoldEffectList.setReasonCodeID(reasonCode);
                                    lotHoldEffectList.setUserID(objCommon.getUser().getUserID());
                                    lotHoldEffectList.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                                    lotHoldEffectList.setRelatedLotID(monitorLotID);
                                    bLotHeld = true;
                                    break;
                                }
                            }
                        }

                        String envMoniWaitHoldFlag = StandardProperties.OM_PROC_MON_WAIT_HOLD_LOGIC.getValue();
                        if (CimStringUtils.equals("1", envMoniWaitHoldFlag) && CimBooleanUtils.isFalse(bLotHeld)) {
                            Boolean bFoundMonLot = false;
                            for (int monCnt = 0; monCnt < monitorGroupLen; monCnt++) {
                                CimMonitorGroup mGroup = monitorGroupList.get(monCnt);
                                //get Monitoring lot;
                                CimLot aMonitorLot = mGroup.getMonitorLot();
                                Validations.check (aMonitorLot == null, retCodeConfig.getNotFoundMonitorLot());


                                // Get ProductID of representative lot.
                                log.info("Get ProductID of representative lot");
                                com.fa.cim.newcore.bo.prodspec.CimProductSpecification aPosProductSpec = aMonitorLot.getProductSpecification();
                                Validations.check(aPosProductSpec == null, retCodeConfig.getNotFoundProductSpec());

                                ObjectIdentifier representativeProdID = new ObjectIdentifier(aPosProductSpec.getIdentifier());
                                log.info("representativeProdID = {}", representativeProdID.getValue());

                                // Get ProductID of logicalrecipe.
                                log.info("Get ProductID of logicalrecipe");
                                com.fa.cim.newcore.bo.prodspec.CimProductSpecification aMonitorProduct = aLogicalRecipe.getMonitorProduct();
                                Validations.check(aMonitorProduct == null, retCodeConfig.getNotFoundProductSpec());


                                ObjectIdentifier monitorProdID = new ObjectIdentifier(aMonitorProduct.getIdentifier());
                                log.info("monitorProdID = {}", monitorProdID.getValue());
                                if (ObjectIdentifier.equalsWithValue(representativeProdID, monitorProdID)) {
                                    // Hold lot with "Monitor Waiting Hold" reason code and set monitor group representative LotID in the hold record as a related lot.
                                    // When lot has multiple monitor groups with different lot of the same product ID, lot will be held with 1st found MonitorLotID.
                                    log.info("Hold lot = {}", lotInCassette.getLotID().getValue());
                                    Infos.LotHoldEffectList lotHoldEffectList = new Infos.LotHoldEffectList();
                                    outObject.add(lotHoldEffectList);
                                    lotHoldEffectList.setLotID(lotInCassette.getLotID());
                                    lotHoldEffectList.setHoldType(BizConstant.SP_HOLDTYPE_WAITINGMONITORRESULTHOLD);
                                    ObjectIdentifier reasonCode = new ObjectIdentifier(BizConstant.SP_REASON_WAITINGMONITORRESULTHOLD);
                                    lotHoldEffectList.setReasonCodeID(reasonCode);
                                    lotHoldEffectList.setUserID(objCommon.getUser().getUserID());
                                    lotHoldEffectList.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                                    lotHoldEffectList.setRelatedLotID(aMonitorLot.getLotID());
                                    bFoundMonLot = true;
                                    break;
                                }
                            }

                            // Hold lot with "Monitor Waiting Hold" reason code and set 1st monitor group representative lot ID in the hold record as a related lot.
                            if (!bFoundMonLot) {
                                //get Monitoring lot;
                                CimMonitorGroup mGroup = monitorGroupList.get(0);
                                CimLot aMonitorLot = mGroup.getMonitorLot();
                                Validations.check (aMonitorLot == null, retCodeConfig.getNotFoundMonitorLot());


                                Infos.LotHoldEffectList lotHoldEffectList = new Infos.LotHoldEffectList();
                                outObject.add(lotHoldEffectList);
                                lotHoldEffectList.setLotID(lotInCassette.getLotID());
                                lotHoldEffectList.setHoldType(BizConstant.SP_HOLDTYPE_WAITINGMONITORRESULTHOLD);
                                ObjectIdentifier reasonCode = new ObjectIdentifier(BizConstant.SP_REASON_WAITINGMONITORRESULTHOLD);
                                lotHoldEffectList.setReasonCodeID(reasonCode);
                                lotHoldEffectList.setUserID(objCommon.getUser().getUserID());
                                lotHoldEffectList.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                                lotHoldEffectList.setRelatedLotID(aMonitorLot.getLotID());
                            }

                            // Even though there is the setting of Monitor Waiting Hold in lot's oper comp operation (in Logical Recipe setting),
                            // when lot does not have monitor group information, lot won't be held.
                            // (Same as current system behavior.)
                        }
                    } else {
                        continue;
                    }
                } else {
                    continue;
                }
            }
        }

        return outObject;
    }

    @Override
    public Infos.LotInCassette lotProcessJobExecFlagGetRecycleSampling(Infos.ObjCommon objCommon, Infos.LotInCassette lotInCassette, ObjectIdentifier lotID) {
        Validations.check(ObjectIdentifier.isEmptyWithValue(lotID), retCodeConfig.getInvalidInputParam());
        // Get a recycle sampling setting
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));
        CimProcessOperation aPosProcessOperation = aLot.getProcessOperation();
        Validations.check(null == aPosProcessOperation, new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****", lotID.getValue()));

        String targetOperationNo = aPosProcessOperation.getSamplingRecycleOpeNo();
        Validations.check(CimStringUtils.isEmpty(targetOperationNo), retCodeConfig.getNoSmplSetting());
        //Setting format check
        //Check targetOperationNo contain ".";
        Validations.check(!targetOperationNo.contains("."), retCodeConfig.getInvalidSmplSetting());
        List<String> samplingWafers = null;
        try {
            samplingWafers = this.lotProcessedWaferIDsGet(objCommon, lotID, targetOperationNo);
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getNotFoundSmplRecord(), e.getCode()) && !Validations.isEquals(retCodeConfig.getNotFoundProcessOperation(), e.getCode())){
                throw e;
            } else if (Validations.isEquals(retCodeConfig.getNotFoundSmplRecord(), e.getCode()) || Validations.isEquals(retCodeConfig.getNotFoundProcessOperation(), e.getCode())) {
                throw new ServiceException(retCodeConfig.getIgnoreRecycleSmpl(), targetOperationNo);
            }
        }
        log.info("lot_processedWaferIDs_Get() rc == RC_OK");
        List<Infos.LotWafer> lotWafers = lotInCassette.getLotWaferList();
        lotWafers.forEach(lotWafer -> lotWafer.setProcessJobExecFlag(false));
        boolean lackWaferFlag = false;
        boolean matchFlag = false;
        int smplWaferLen = CimArrayUtils.getSize(samplingWafers);
        if (smplWaferLen > 0){
            for (String samplingWafer : samplingWafers) {
                matchFlag = false;
                for (Infos.LotWafer lotWafer : lotWafers) {
                    if (ObjectIdentifier.equalsWithValue(lotWafer.getWaferID(), samplingWafer)) {
                        lotWafer.setProcessJobExecFlag(true);
                        matchFlag = true;
                        break;
                    }
                }
                if (!matchFlag) {
                    lackWaferFlag = true;
                    break;
                }
            }
        }
        Validations.check(lackWaferFlag, new OmCode(retCodeConfig.getIgnoreRecycleSmpl(), targetOperationNo));
        return lotInCassette;
    }

    @Override
    public List<String> lotProcessedWaferIDsGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID, String targetOperationNo) {
        log.info("lotMethod::lotProcessedWaferIDsGet()");
        Validations.check(ObjectIdentifier.isEmptyWithValue(lotID) || CimStringUtils.isEmpty(targetOperationNo), retCodeConfig.getInvalidInputParam());
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        //-------------------------------
        //  Get ProcessFlowContext
        //-------------------------------
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPosProcessFlowContext = aLot.getProcessFlowContext();
        Validations.check (null == aPosProcessFlowContext, new OmCode(retCodeConfig.getNotFoundPfx(), ""));
        //--------------------------
        //  Get ProcessOperation
        //--------------------------
        CimProcessOperation aPosPO = aPosProcessFlowContext.findProcessOperationForOperationNumberBefore(targetOperationNo);
        Validations.check (null == aPosPO, new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****", lotID.getValue()));
        //--------------------------------
        //  Get AssignedSamplingWafers
        //--------------------------------
        List<String> assignedSamplingWafers = aPosPO.getAssignedSamplingWafers();
        Validations.check (CimArrayUtils.isEmpty(assignedSamplingWafers), new OmCode(retCodeConfig.getNotFoundSmplRecord(), lotID.getValue()));
        return assignedSamplingWafers;
    }

    @Override
    public String lotSamplingMessageCreate(Infos.ObjCommon objCommon, ObjectIdentifier lotID, Integer messageType, String messageText) {
        if (ObjectIdentifier.isEmptyWithValue(lotID)) {
            return null;
        }
        //-----------------------------
        //  Get base info for lotID
        //-----------------------------
        ObjectIdentifier lotOwnerID = null;
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        com.fa.cim.newcore.bo.person.CimPerson aLotOwner = aLot.getLotOwner();
        if (null != aLotOwner) {
            lotOwnerID = new ObjectIdentifier(aLotOwner.getIdentifier(), aLotOwner.getPrimaryKey());
        }
        //-------------------------------
        //  Get Desription of OwnerID
        //-------------------------------
        Results.BasicUserInfoInqResult basicUserInfoInqResult = personMethod.personFillInTxPLQ013DR(objCommon, lotOwnerID);
        String userDescripiton = basicUserInfoInqResult.getUserName();

        //--------------------------------
        //  Get current operation info
        //--------------------------------
        log.info("Get current operation info");
        Outputs.ObjLotCurrentOperationInfoGetOut objLotCurrentOperationInfoGetOut = lotMethod.lotCurrentOperationInfoGet(objCommon, lotID);

        //--------------------
        //  Create message
        //--------------------
        StringBuilder mailMsgStream = new StringBuilder();
        if (messageType == BizConstant.SP_SAMPLING_ERROR_MAIL || messageType == BizConstant.SP_SAMPLING_WARN_MAIL) {
            mailMsgStream.append("lot has been held for invalid wafer sampling setting. Refer the detail information on the lot hold list of OPI.\n");
        } else if (messageType == BizConstant.SP_SAMPLING_IGNORED_MAIL) {
            mailMsgStream.append("Recycle sampling setting for the lot was ignored.\n");
        }
        mailMsgStream.append("  Lot ID     : ").append(lotID.getValue()).append("\n");
        mailMsgStream.append("  Lot Owner ID / Description  : ").append(ObjectIdentifier.fetchValue(lotOwnerID)).append(" / ").append(userDescripiton).append("\n");
        mailMsgStream.append("  Route ID   : ").append(objLotCurrentOperationInfoGetOut.getRouteID().getValue()).append("\n");
        mailMsgStream.append("  Process ID : ").append(objLotCurrentOperationInfoGetOut.getOperationID().getValue()).append("\n");
        mailMsgStream.append("  Ope No.    : ").append(objLotCurrentOperationInfoGetOut.getOperationNumber()).append("\n");
        mailMsgStream.append("  Error Description   : ").append(messageText).append("\n");
        return mailMsgStream.toString();
    }

    @Override
    public Infos.LotInCassette lotProcessJobExecFlagGetPolicySampling(Infos.ObjCommon objCommon, Infos.LotInCassette lotInCassette, ObjectIdentifier lotID, ObjectIdentifier equipmentID) {
        Infos.LotInCassette lotInCassetteOut = new Infos.LotInCassette();
        // Check input Parameter
        Validations.check(ObjectIdentifier.isEmptyWithValue(lotID), retCodeConfig.getInvalidInputParam());
        //------------------------------------
        //  Get a policy sampling setting
        //------------------------------------
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        com.fa.cim.newcore.bo.pd.CimProcessOperation aPosProcessOperation = aLot.getProcessOperation();
        Validations.check(null == aPosProcessOperation, new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****", lotID.getValue()));
        //Get ProductSpec
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification aPosProductSpecification = aLot.getProductSpecification();
        Validations.check (null == aPosProductSpecification, retCodeConfig.getNotFoundProductSpec());
        //Get LogicalRecipe setting
        com.fa.cim.newcore.bo.recipe.CimLogicalRecipe aLogicalRecipe = aPosProcessOperation.findLogicalRecipeFor(aPosProductSpecification);
        Validations.check(null == aLogicalRecipe, retCodeConfig.getNotFoundLogicalRecipe());

        String policyName = aLogicalRecipe.getSamplingPolicyName();
        String attribute = aLogicalRecipe.getSamplingWaferAttribute();
        if (CimStringUtils.isEmpty(policyName) && CimStringUtils.isEmpty(attribute)) {
            // Get Equipment setting
            CimMachine aMachine = baseCoreFactory.getBO(CimMachine.class, equipmentID);
            Validations.check(null == aMachine, new OmCode(retCodeConfig.getNotFoundEqp(), equipmentID.getValue()));
            policyName = aMachine.getSamplingPolicyName();
            attribute = aMachine.getSamplingWaferAttribute();
        }
        //------------------------------------
        //  Setting check
        //------------------------------------
        // Setting existence check
        Validations.check(CimStringUtils.isEmpty(policyName) && CimStringUtils.isEmpty(attribute), retCodeConfig.getNoSmplSetting());
        //Setting format check
        //Check attribute is valid for policyName
        try {
            samplingSettingMethod.samplingSettingFormatCheck(objCommon, policyName, attribute);
        } catch(ServiceException ex){
            throw new ServiceException(retCodeConfig.getInvalidSmplSetting());
        }
        List<Infos.LotWafer> lotWaferList = lotInCassette.getLotWaferList();
        int waferLen = CimArrayUtils.getSize(lotWaferList);
        Infos.LotWafer tempLotWafer = null;
        for (int i = 0; i < waferLen; i++) {
            Infos.LotWafer iLotWafer = lotWaferList.get(i);
            for (int j = i + 1; j < waferLen; j++) {
                Infos.LotWafer jLotWafer = lotWaferList.get(j);
                if (iLotWafer.getSlotNumber() > jLotWafer.getSlotNumber()) {
                    tempLotWafer = jLotWafer;
                    jLotWafer = iLotWafer;
                    iLotWafer = tempLotWafer;
                }
            }
            iLotWafer.setProcessJobExecFlag(false);
        }
        lotInCassetteOut = lotInCassette;
        //------------------------------------
        //  Set processJobExecFlag
        //------------------------------------
        int attributeNumber = 0;
        int minCnt = 0;
        // TOP / BOTTOM / RANDOM
        if (CimStringUtils.equals(BizConstant.SP_SAMPLING_POLICY_TOP, policyName)) {
            log.info("SamplingRule == Top");
            attributeNumber = CimNumberUtils.intValue(attribute);
            minCnt = attributeNumber < waferLen ? attributeNumber : waferLen;
            for (int waferCnt = 0; waferCnt < minCnt; waferCnt++) {
                lotWaferList.get(waferCnt).setProcessJobExecFlag(true);
            }
        }
        if (CimStringUtils.equals(BizConstant.SP_SAMPLING_POLICY_BOTTOM, policyName)) {
            log.info("SamplingRule == Bottom");
            attributeNumber = CimNumberUtils.intValue(attribute);
            minCnt = attributeNumber < waferLen ? attributeNumber : waferLen;
            for (int waferCnt = 0; waferCnt < minCnt; waferCnt++) {
                lotWaferList.get(waferLen - waferCnt - 1).setProcessJobExecFlag(true);
            }
        }
        if (CimStringUtils.equals(BizConstant.SP_SAMPLING_POLICY_RANDOM, policyName)) {
            log.info("SamplingRule == Random");
            attributeNumber = CimNumberUtils.intValue(attribute);
            minCnt = attributeNumber < waferLen ? attributeNumber : waferLen;
            int waferCnt = 0;
            while (waferCnt < minCnt) {
                int indexRand = rand.nextInt(waferLen);
                if (!lotWaferList.get(indexRand).getProcessJobExecFlag()) {
                    lotWaferList.get(indexRand).setProcessJobExecFlag(true);
                    waferCnt++;
                }
            }
        }

        // EVEN / ODD
        if (CimStringUtils.equals(BizConstant.SP_SAMPLING_POLICY_EVEN, policyName) || CimStringUtils.equals(BizConstant.SP_SAMPLING_POLICY_ODD, policyName)) {
            log.info("SamplingRule == Even/Odd");
            boolean bEven = false;
            if (CimStringUtils.equals(BizConstant.SP_SAMPLING_POLICY_EVEN, policyName)) {
                bEven = true;
            }
            int waferFindCnt = 0;
            for (Infos.LotWafer lotWafer : lotWaferList) {
                int slotNumber = lotWafer.getSlotNumber().intValue();
                if ((slotNumber % 2) > 0 && !bEven) {
                    log.info("Odd");
                    lotWafer.setProcessJobExecFlag(true);
                    waferFindCnt++;
                }
                if ((slotNumber % 2) == 0 && bEven) {
                    log.info("Even");
                    lotWafer.setProcessJobExecFlag(true);
                    waferFindCnt++;
                }
            }
            Validations.check(0 == waferFindCnt, new OmCode(retCodeConfig.getSmplInvalidSlotSelect(), lotInCassette.getLotID().getValue(), policyName, policyName));
        }
        // TOP AND BOTTOM
        if (CimStringUtils.equals(BizConstant.SP_SAMPLING_POLICY_TOPANDBOTTOM, policyName)) {
            log.info("SamplingRule == Top and Bottom");
            String[] tokens = attribute.split(",");
            int top = 0, bottom = 0;
            if (!CimObjectUtils.isEmpty(tokens) && tokens.length >= 2) {
                top = Integer.valueOf(tokens[0]);
                bottom = Integer.valueOf(tokens[1]);
            }
            minCnt = (top < waferLen) ? top : waferLen;
            for (int waferCnt = 0; waferCnt < minCnt; waferCnt++) {
                lotWaferList.get(waferCnt).setProcessJobExecFlag(true);
            }
            minCnt = (bottom < waferLen) ? bottom : waferLen;
            for (int waferCnt = 0; waferCnt < minCnt; waferCnt++) {
                lotWaferList.get(waferLen - waferCnt - 1).setProcessJobExecFlag(true);
            }
        }
        // SLOT
        if (CimStringUtils.equals(BizConstant.SP_SAMPLING_POLICY_SLOT, policyName)) {
            String[] tokens = attribute.split(",");
            int tokensSize = CimObjectUtils.isEmpty(tokens) ? 0 : tokens.length;
            int i = 0;
            int appendCount = 0;
            StringBuilder lackSlotNumbers = new StringBuilder();
            while (i++ < tokensSize) {
                attributeNumber = Integer.valueOf(tokens[i - 1]);
                boolean matchFlag = false;
                for (Infos.LotWafer lotWafer : lotWaferList) {
                    if (lotWafer.getSlotNumber().intValue() == attributeNumber) {
                        lotWafer.setProcessJobExecFlag(true);
                        matchFlag = true;
                        break;
                    }
                }
                if (!matchFlag) {
                    if (appendCount > 0) {
                        lackSlotNumbers.append(",");
                    }
                    lackSlotNumbers.append(tokens[i - 1]);
                    appendCount++;
                }
            }
            Validations.check (appendCount > 0, new OmCode(retCodeConfig.getSmplInvalidSlotSelect(), lotInCassette.getLotID().getValue(), attribute, lackSlotNumbers.toString()));
        }
        lotInCassetteOut = lotInCassette;
        return lotInCassetteOut;
    }

    @Override
    public void lotOperationCheckSameForFlowBatch(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, List<Infos.BatchingReqLot> strBatchingReqLot) {
        int i, j, k;
        int lenBatchingReqLot = CimArrayUtils.getSize(strBatchingReqLot);
        Validations.check(lenBatchingReqLot == 0, new OmCode(retCodeConfig.getNotFoundLot(), "*****"));

        List<String> sLogicalRecipeSeq = new ArrayList<>();
        List<Boolean> bTargetOpeSeq = new ArrayList<>();
        long nFirstLotFlowBatchOpeCount = 0;
        long nFirstLotFutureOpeCnt = 0;
        for (i = 0; i < lenBatchingReqLot; i++) {
            CimLot aLot = baseCoreFactory.getBO(CimLot.class, strBatchingReqLot.get(i).getLotID());
            Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), strBatchingReqLot.get(i).getLotID().getValue()));
            // ------------------------------
            // Get information of SM from lot
            // ------------------------------
            com.fa.cim.newcore.bo.prodspec.CimProductSpecification aProductSpecification = aLot.getProductSpecification();
            com.fa.cim.newcore.bo.pd.CimProcessFlowContext aProcessFlowContext = aLot.getProcessFlowContext();
            Validations.check(aProcessFlowContext == null, new OmCode(retCodeConfig.getNotFoundPfx(), ""));
            com.fa.cim.newcore.bo.pd.CimProcessOperation aProcessOperation = aLot.getProcessOperation();
            Validations.check(aProcessOperation == null, new OmCode(retCodeConfig.getNotFoundOperation(), ""));

            ProcessDTO.PosFlowBatchControl flowBatchCtrl = aProcessOperation.getFlowBatchControl();
            Validations.check(null == flowBatchCtrl || CimStringUtils.isEmpty(flowBatchCtrl.getName()),
                    new OmCode(retCodeConfig.getNotFoundFlowBatch(), "section"));

            com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aPOS = aProcessOperation.getActiveModuleProcessOperationSpecification();
            Validations.check (aPOS == null,
                    new OmCode(retCodeConfig.getNotFoundPos(), "*****", strBatchingReqLot.get(i).getLotID().getValue()));
            com.fa.cim.newcore.bo.pd.CimProcessFlow aProcessFlow = aProcessFlowContext.getMainProcessFlow();
            String moduleNumber = aProcessFlowContext.getModuleNumber();
            com.fa.cim.newcore.bo.pd.CimProcessFlow aModulePF = aProcessFlowContext.getModuleProcessFlow();
            Validations.check (aModulePF == null, new OmCode(retCodeConfig.getNotFoundProcessFlow(), ""));

            boolean bEntryPoint = aPOS.isFlowBatchEntryOperation();
            boolean bTargetPoint = false;
            flowBatchCtrl = aPOS.getFlowBatchControl();
            String curFlowBatchName = null;
            if (null != flowBatchCtrl && !CimStringUtils.isEmpty(flowBatchCtrl.getName())) {
                curFlowBatchName = flowBatchCtrl.getName();
            } else {
                throw new ServiceException(new OmCode(retCodeConfig.getNotFoundFlowBatch(), "section"));
            }
            long nFlowBatchOpeCnt = aPOS.getFlowBatchOperationCount();
            if (!bEntryPoint) {
                com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aModulePOS = aPOS;
                com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aOldModulePOS = aPOS;
                com.fa.cim.newcore.bo.pd.CimProcessFlow aOldPF = aModulePF;
                while (true) {
                    AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> aOutPF = new AtomicReference<>();
                    aModulePOS = aModulePF.previousProcessOperationSpecification(aModulePOS, aOutPF);
                    Validations.check(aOutPF.get() == null, new OmCode(retCodeConfig.getNotFoundProcessFlow(), ""));
                    if (aModulePOS == null){
                        aPOS = aOldModulePOS;
                        aModulePF = aOldPF;
                        break;
                    }
                    bEntryPoint = aModulePOS.isFlowBatchEntryOperation();
                    bTargetPoint = aModulePOS.isFlowBatchTargetOperation();
                    if (bEntryPoint || bTargetPoint) {
                        aPOS = aOldModulePOS;
                        aModulePF = aOldPF;
                        break;
                    }
                    ProcessDTO.PosFlowBatchControl posFBCtrl = aModulePOS.getFlowBatchControl();
                    if (posFBCtrl == null) {
                        aPOS = aOldModulePOS;
                        aModulePF = aOldPF;
                        break;
                    }
                    if (posFBCtrl != null && !CimStringUtils.equals(posFBCtrl.getName(), curFlowBatchName)) {
                        aPOS = aOldModulePOS;
                        aModulePF = aOldPF;
                        break;
                    }
                    aOldModulePOS = aModulePOS;
                    aOldPF = aModulePF;
                    aModulePF = aOutPF.get();
                }
            } else if (nFlowBatchOpeCnt == 1) {
                log.info("nFlowBatchOpeCnt is 1");
            } else {
                log.info("aPOS is EntryPoint");
                AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> aOutPF = new AtomicReference<>();
                boolean bCurrentTarget = aPOS.isFlowBatchTargetOperation();
                if (!bCurrentTarget) {
                    aPOS = aModulePF.nextProcessOperationSpecification(aPOS, aOutPF);
                    aModulePF = aOutPF.get();
                }
            }
            Validations.check (aPOS == null, new OmCode(retCodeConfig.getNotFoundPos(), "*****", strBatchingReqLot.get(i).getLotID().getValue()));
            Validations.check (aModulePF == null, new OmCode(retCodeConfig.getNotFoundProcessFlow(), ""));

            //********************************************************************************************//
            //                                                                                            //
            //   Operation from Operation got in the above logic to end of FlowBatchSection is checked.   //
            //                                                                                            //
            //   1. LogicalRecipe of operations. (Only target operation)                                  //
            //                                                                                            //
            //********************************************************************************************//
            long nLenOpeCnt = aPOS.getFlowBatchOperationCount();
            if (i == 0) {
                nFirstLotFlowBatchOpeCount = nLenOpeCnt;
                sLogicalRecipeSeq = new ArrayList<>((int)nFirstLotFlowBatchOpeCount);
                bTargetOpeSeq = new ArrayList<>((int)nFirstLotFlowBatchOpeCount);
            } else if (nFirstLotFlowBatchOpeCount != nLenOpeCnt) {
                throw new ServiceException(new OmCode(retCodeConfig.getNotSameFlowCntOfBatch(), strBatchingReqLot.get(i).getLotID().getValue()));
            }

            boolean bFirstTarget = false;
            com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification aModulePOS = aPOS;
            for (j = 0; j < nFirstLotFlowBatchOpeCount; j++) {
                bTargetOpeSeq.add(null);
                sLogicalRecipeSeq.add("");
                Validations.check (i > 0 && j > nFirstLotFutureOpeCnt, new OmCode(retCodeConfig.getNotSameFlowCntOfBatch(), strBatchingReqLot.get(i).getLotID().getValue()));
                AtomicReference<com.fa.cim.newcore.bo.pd.CimProcessFlow> aOutPF = new AtomicReference<>();
                boolean bTargetOperation = aModulePOS.isFlowBatchTargetOperation();
                if (i == 0) {
                    bTargetOpeSeq.set(j, bTargetOperation);
                } else {
                    Validations.check (bTargetOperation != bTargetOpeSeq.get(j),
                            new OmCode(retCodeConfig.getNotSameTargetOperOfBatch(), strBatchingReqLot.get(i).getLotID().getValue()));

                }
                if (bTargetOpeSeq.get(j)) {
                    List<ProcessDefinition> aProcessDefinitionSeq = aModulePOS.getProcessDefinitions();
                    com.fa.cim.newcore.bo.pd.CimProcessDefinition aProcesDefinition = (com.fa.cim.newcore.bo.pd.CimProcessDefinition) aProcessDefinitionSeq.get(0);
                    Validations.check (aProcesDefinition == null, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), ""));
                    if (!bFirstTarget) {
                        /*-----------------------------------*/
                        /*   Check EQP of first work exist   */
                        /*-----------------------------------*/
                        List<CimMachine> aMachineSequence = aProcesDefinition.findMachinesFor(aProductSpecification);
                        boolean bMachineFound = false;
                        int lenMachineSeq = CimArrayUtils.getSize(aMachineSequence);
                        for (k = 0; k < lenMachineSeq; k++) {
                            String aMachineID = aMachineSequence.get(k).getIdentifier();
                            if (ObjectIdentifier.equalsWithValue(aMachineID, equipmentID)) {
                                bMachineFound = true;
                                break;
                            }
                        }
                        Validations.check(!bMachineFound, new OmCode(retCodeConfig.getNotFoundEqp(), equipmentID.getValue()));
                        bFirstTarget = true;
                    }
                    //---------------------------------
                    //   Get and Stock logicalrecipe
                    //---------------------------------
                    com.fa.cim.newcore.bo.recipe.CimLogicalRecipe aLogicalRecipe = aProcesDefinition.findLogicalRecipeFor(aProductSpecification);
                    Validations.check (aLogicalRecipe == null, retCodeConfig.getNotFoundMachineRecipe());
                    String logicalRecipeID = aLogicalRecipe.getIdentifier();
                    if (i == 0) {
                        sLogicalRecipeSeq.set(j, logicalRecipeID);
                    } else {
                        Validations.check (!CimStringUtils.equals(sLogicalRecipeSeq.get(j), logicalRecipeID),
                                new OmCode(retCodeConfig.getNotSameRecipeInTargetOper(), strBatchingReqLot.get(i).getLotID().getValue()));

                    }
                } else {
                    log.info("<<Not>> Target Operation !!");
                }
                aModulePOS = aModulePF.nextProcessOperationSpecification(aModulePOS, aOutPF);
                if (aModulePOS == null) {
                    break;
                }
                ProcessDTO.PosFlowBatchControl posFBCtrl = aModulePOS.getFlowBatchControl();
                if (posFBCtrl == null) {
                    break;
                }
                if (!CimStringUtils.equals(posFBCtrl.getName(), curFlowBatchName)){
                    break;
                }
                aModulePF = aOutPF.get();
            }
            if (i == 0) {
                nFirstLotFutureOpeCnt = j;
            } else if (j != nFirstLotFutureOpeCnt) {
                throw new ServiceException(new OmCode(retCodeConfig.getNotSameFlowCntOfBatch(), strBatchingReqLot.get(i).getLotID().getValue()));

            }
        }

    }

    public Results.EDCHistoryInqResult lotDataCollectionInformationGetDR(Infos.ObjCommon objCommon, Params.EDCHistoryInqParams params) {
        log.info("PPTManager_i::lot_dataCollectionInformation_GetDR__120");

        ObjectIdentifier lotID = params.getLotID();
        ObjectIdentifier routeID = params.getRouteID();
        String operationNumber = params.getOperationNumber();
        String operationPass = params.getOperationPass();
        Boolean getSpecFlag = params.getGetSpecFlag();

        log.info("in para lotID          ={}", lotID.getValue());
        log.info("in para routeID        ={}", routeID.getValue());
        log.info("in para operationNumber={}", operationNumber);
        log.info("in para operationPass  ={}", operationPass);

        //---------------------------------------------------------------------------------
        //   Initialize
        //---------------------------------------------------------------------------------

        String hFRPOd_theTableMarker2;

        long speccount = 0L;
        Boolean getSpecFromDefFlag = false;

        String hFRLOTLOT_ID = null;

        hFRLOTLOT_ID = lotID.getValue();

        ObjectIdentifier tmpDataCollectionSpecificationID;

        //---------------------------------------------------------------------------------
        // Get PFX_OBJ of specified lot from OMLOT
        //---------------------------------------------------------------------------------
        String hFRLOTPFX_OBJ = CimObjectUtils.toString(cimJpaRepository.queryOne("select PRFCX_RKEY, LOT_ID from OMLOT where LOT_ID = ?", hFRLOTLOT_ID)[0]);

        //---------------------------------------------------------------------------------
        // Get D_THESYSTEMKEY of process flow context to read FRPFX_POLIST
        //---------------------------------------------------------------------------------
        String hFRPFXd_theSystemKey = CimObjectUtils.toString(cimJpaRepository.queryOne("select ID,MPROCESS_STRING from OMPRFCX where ID = ?", hFRLOTPFX_OBJ)[0]);

        //---------------------------------------------------------------------------------
        //   Get D_THESYSTEMKEY of Process Operation
        //---------------------------------------------------------------------------------
        String hFRPOMAINPD_ID = null;
        String hFRPOOPE_NO = null;

        hFRPOMAINPD_ID = routeID.getValue();

        hFRPOOPE_NO = operationNumber;
        Integer hFRPOPASS_COUNT = CimNumberUtils.intValue(operationPass);

        Object[] one = cimJpaRepository.queryOne("select ID,OPE_NO\n" +
                        "        from   OMPROPE\n" +
                        "        where  MAIN_PROCESS_ID  = ?\n" +
                        "        and    OPE_NO     = ?\n" +
                        "        and    PASS_COUNT = ?\n" +
                        "        and    ID in ( select PROPE_RKEY\n" +
                        "                from   OMPRFCX_PROPESEQ\n" +
                        "                where  REFKEY = ? )", hFRPOMAINPD_ID
                , hFRPOOPE_NO
                , hFRPOPASS_COUNT
                , hFRPFXd_theSystemKey);
        Validations.check(one == null, retCodeConfig.getNotFoundCdata());
        String hFRPOd_theSystemKey = CimObjectUtils.toString(one[0]);

        //---------------------------------------------------------------------------------
        //   Get DCDef Info from FRPO_DC
        //---------------------------------------------------------------------------------
        List<Object[]> CUR_PO_DC_120 = cimJpaRepository.query("select IDX_NO,\n" +
                "                EDC_PLAN_ID,\n" +
                "                EDC_PLAN_RKEY,\n" +
                "                DESCRIPTION,\n" +
                "                EDC_TYPE,\n" +
                "                CALC_FLG,\n" +
                "                SPCHK_FLG,\n" +
                "                EDC_SPEC_ID,\n" +
                "                EDC_SPEC_RKEY,\n" +
                "                PREV_EDC_PLAN_ID,\n" +
                "                PREV_EDC_PLAN_RKEY,\n" +
                "                PREV_STEP_ID,\n" +
                "                PREV_STEP_RKEY,\n" +
                "                PREV_OPE_NO,\n" +
                "                EDC_SPEC_DESC\n" +
                "        from   OMPROPE_EDC\n" +
                "        where  REFKEY = ?\n" +
                "        order by IDX_NO", hFRPOd_theSystemKey);

        int count = 0;
        int t_count = StandardProperties.OM_EDC_PLAN_EXTLEN_IN_EDC_HIST_INQ.getIntValue();

        Results.EDCHistoryInqResult strLotDataCollectionInformationGetDROut = new Results.EDCHistoryInqResult();
        strLotDataCollectionInformationGetDROut.setStrDCDefResult(new ArrayList<>(t_count));

        for (Object[] CUR_PO_DC : CUR_PO_DC_120) {
            //-----------------------------------------------------------------------------
            //   Get DC Definition of corresponding Process Operation from FRPO_DC
            //-----------------------------------------------------------------------------
            String hFRPO_DCd_SeqNo = CimObjectUtils.toString(CUR_PO_DC[0]);
            String hFRPO_DCDCDEF_ID = CimObjectUtils.toString(CUR_PO_DC[1]);
            String hFRPO_DCDCDEF_OBJ = CimObjectUtils.toString(CUR_PO_DC[2]);
            String hFRPO_DCDESCRIPTION = CimObjectUtils.toString(CUR_PO_DC[3]);
            String hFRPO_DCDC_TYPE = CimObjectUtils.toString(CUR_PO_DC[4]);
            Boolean hFRPO_DCCALC_FLG = CimBooleanUtils.convert(CUR_PO_DC[5]);
            Boolean hFRPO_DCSPCHK_FLG = CimBooleanUtils.convert(CUR_PO_DC[6]);
            String hFRPO_DCDCSPEC_ID = CimObjectUtils.toString(CUR_PO_DC[7]);
            String hFRPO_DCDCSPEC_OBJ = CimObjectUtils.toString(CUR_PO_DC[8]);
            String hFRPO_DCPRV_DCDEF_ID = CimObjectUtils.toString(CUR_PO_DC[9]);
            String hFRPO_DCPRV_DCDEF_OBJ = CimObjectUtils.toString(CUR_PO_DC[10]);
            String hFRPO_DCPRV_OPE_ID = CimObjectUtils.toString(CUR_PO_DC[11]);
            String hFRPO_DCPRV_OPE_OBJ = CimObjectUtils.toString(CUR_PO_DC[12]);
            String hFRPO_DCPRV_OPE_NO = CimObjectUtils.toString(CUR_PO_DC[13]);
            String hFRPO_DCDCSPEC_DESCRIPTION = CimObjectUtils.toString(CUR_PO_DC[14]);

            //-----------------------------------------------------------------------------
            //   Set DCDef Info into out paramter
            //-----------------------------------------------------------------------------
            if (count >= t_count) {
                t_count = t_count + StandardProperties.OM_EDC_PLAN_EXTLEN_IN_EDC_HIST_INQ.getIntValue();
            }

            strLotDataCollectionInformationGetDROut.getStrDCDefResult().add(new Infos.DCDefResult());
            Infos.DCDefResult strDCDefResult = strLotDataCollectionInformationGetDROut.getStrDCDefResult().get(count);

            strDCDefResult.setDataCollectionDefinitionID(ObjectIdentifier.build(hFRPO_DCDCDEF_ID
                    , hFRPO_DCDCDEF_OBJ));
            strDCDefResult.setDescription(hFRPO_DCDESCRIPTION);
            strDCDefResult.setDataCollectionType(hFRPO_DCDC_TYPE);
            strDCDefResult.setCalculationRequiredFlag(hFRPO_DCCALC_FLG);
            strDCDefResult.setSpecCheckRequiredFlag(hFRPO_DCSPCHK_FLG);
            strDCDefResult.setDataCollectionSpecificationID(ObjectIdentifier.build(hFRPO_DCDCSPEC_ID, hFRPO_DCDCSPEC_OBJ));
            strDCDefResult.setDcSpecDescription(hFRPO_DCDCSPEC_DESCRIPTION);
            strDCDefResult.setPreviousDataCollectionDefinitionID(ObjectIdentifier.build(hFRPO_DCPRV_DCDEF_ID, hFRPO_DCPRV_DCDEF_OBJ));
            strDCDefResult.setPreviousOperationNumber(hFRPO_DCPRV_OPE_NO);

            String hFRPOd_theTableMarker = "";
            hFRPOd_theTableMarker = String.format(
                    "%s%d", BizConstant.SP_PO_DC_ITEMS_TABLEMARKER, count);

            log.info("hOMPROPEd_theTableMarker={}", hFRPOd_theTableMarker);

            hFRPOd_theTableMarker2 = "";
            hFRPOd_theTableMarker2 = String.format("%d", count);

            if (getSpecFlag == true) {
                if (CimStringUtils.length(ObjectIdentifier.fetchValue(strDCDefResult.getDataCollectionSpecificationID())) != 0) {
                    //---------------------------------------------------------------------------------
                    // Get count of specified PO and FRPO_DC.D_SEQNO from FRPO_DC_SPECS
                    //---------------------------------------------------------------------------------
                    speccount = 0;

                    speccount = cimJpaRepository.count("select COUNT(REFKEY)\n" +
                                    "                    from   OMPROPE_EDC_SPECS\n" +
                                    "                    where  REFKEY = ?\n" +
                                    "                    and    LINK_MARKER in (?, ?)",
                            hFRPOd_theSystemKey,
                            hFRPOd_theTableMarker,
                            hFRPOd_theTableMarker2);

                    if (speccount > 0) {
                        log.info("This PO has DC Spec's detailed information.");
                        //Nothing to do.
                    } else {
                        log.info("This PO does not have DC Spec's detailed information.");
                        getSpecFromDefFlag = true;
                    }
                }
            }

            List<Object[]> CUR_PO_DC_120_ITEMS_120 = cimJpaRepository.query("select IDX_NO,\n" +
                            "                    EDC_ITEM_NAME,\n" +
                            "                    EDC_MODE,\n" +
                            "                    EDC_UOM,\n" +
                            "                    DATA_TYPE,\n" +
                            "                    ITEM_TYPE,\n" +
                            "                    MEAS_TYPE,\n" +
                            "                    WAFER_ID,\n" +
                            "                    WAFER_RKEY,\n" +
                            "                    WAFER_POSITION,\n" +
                            "                    SITE_POSITION,\n" +
                            "                    STORE_FLAG,\n" +
                            "                    FUNC_TYPE,\n" +
                            "                    FUNC_EXPR,\n" +
                            "                    DATA_VAL,\n" +
                            "                    TARGET_VAL,\n" +
                            "                    SPEC_CHECK_RESULT,\n" +
                            "                    ACTION_CODE\n" +
                            "            from   OMPROPE_EDC_ITEMS\n" +
                            "            where  REFKEY = ?\n" +
                            "            and    LINK_MARKER in (?, ?)\n" +
                            "            order by IDX_NO",
                    hFRPOd_theSystemKey,
                    hFRPOd_theTableMarker,
                    hFRPOd_theTableMarker2);

            int count2 = 0;
            int t_count2 = StandardProperties.OM_EDC_ITEM_EXTLEN_IN_EDC_HIST_INQ.getIntValue();

            strDCDefResult.setDcItemResultList(new ArrayList<>(t_count2));

            for (Object[] CUR_PO_DC_120_ITEMS : CUR_PO_DC_120_ITEMS_120) {
                //-----------------------------------------------------------------------------
                //   Get DC Items of corresponding DC Definition from FRPO_DC_ITEMS
                //-----------------------------------------------------------------------------
                String hFRPO_DC_ITEMSd_SeqNo = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[0]);
                String hFRPO_DC_ITEMSDCITEM_NAME = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[1]);
                String hFRPO_DC_ITEMSDCMODE = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[2]);
                String hFRPO_DC_ITEMSDCUNIT = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[3]);
                String hFRPO_DC_ITEMSDATA_TYPE = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[4]);
                String hFRPO_DC_ITEMSITEM_TYPE = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[5]);
                String hFRPO_DC_ITEMSMEAS_TYPE = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[6]);
                String hFRPO_DC_ITEMSWAFER_ID = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[7]);
                String hFRPO_DC_ITEMSWAFER_OBJ = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[8]);
                String hFRPO_DC_ITEMSWAFER_POSITION = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[9]);
                String hFRPO_DC_ITEMSSITE_POSITION = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[10]);
                Boolean hFRPO_DC_ITEMSHISTORY_FLG = CimBooleanUtils.convert(CUR_PO_DC_120_ITEMS[11]);
                String hFRPO_DC_ITEMSCALC_TYPE = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[12]);
                String hFRPO_DC_ITEMSCALC_EXPR = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[13]);
                String hFRPO_DC_ITEMSDATA_VAL = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[14]);
                String hFRPO_DC_ITEMSTGT_VAL = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[15]);
                String hFRPO_DC_ITEMSSPECCHK_RESULT = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[16]);
                String hFRPO_DC_ITEMSACT_CODE = CimObjectUtils.toString(CUR_PO_DC_120_ITEMS[17]);

                //-------------------------------------------------------------------------
                //   Set DCItem Info
                //-------------------------------------------------------------------------
                if (count2 >= t_count2) {
                    t_count2 = t_count2 + StandardProperties.OM_EDC_ITEM_EXTLEN_IN_EDC_HIST_INQ.getIntValue();
                }

                strDCDefResult.getDcItemResultList().add(count2, new Infos.DCItemResult());
                strDCDefResult.getDcItemResultList().get(count2).setDataCollectionItemName(hFRPO_DC_ITEMSDCITEM_NAME);
                strDCDefResult.getDcItemResultList().get(count2).setDataCollectionMode(hFRPO_DC_ITEMSDCMODE);
                strDCDefResult.getDcItemResultList().get(count2).setDataCollectionUnit(hFRPO_DC_ITEMSDCUNIT);
                strDCDefResult.getDcItemResultList().get(count2).setDataType(hFRPO_DC_ITEMSDATA_TYPE);
                strDCDefResult.getDcItemResultList().get(count2).setItemType(hFRPO_DC_ITEMSITEM_TYPE);
                strDCDefResult.getDcItemResultList().get(count2).setMeasurementType(hFRPO_DC_ITEMSMEAS_TYPE);
                strDCDefResult.getDcItemResultList().get(count2).setWaferID(ObjectIdentifier.build(hFRPO_DC_ITEMSWAFER_ID, hFRPO_DC_ITEMSWAFER_OBJ));
                strDCDefResult.getDcItemResultList().get(count2).setWaferPosition(hFRPO_DC_ITEMSWAFER_POSITION);
                strDCDefResult.getDcItemResultList().get(count2).setSitePosition(hFRPO_DC_ITEMSSITE_POSITION);
                strDCDefResult.getDcItemResultList().get(count2).setHistoryRequiredFlag(hFRPO_DC_ITEMSHISTORY_FLG);
                strDCDefResult.getDcItemResultList().get(count2).setCalculationType(hFRPO_DC_ITEMSCALC_TYPE);
                strDCDefResult.getDcItemResultList().get(count2).setCalculationExpression(hFRPO_DC_ITEMSCALC_EXPR);
                strDCDefResult.getDcItemResultList().get(count2).setDataValue(hFRPO_DC_ITEMSDATA_VAL);
                strDCDefResult.getDcItemResultList().get(count2).setTargetValue(hFRPO_DC_ITEMSTGT_VAL);
                strDCDefResult.getDcItemResultList().get(count2).setSpecCheckResult(hFRPO_DC_ITEMSSPECCHK_RESULT);

                if (CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJ, strDCDefResult.getDcItemResultList().get(count2).getMeasurementType())) {
                    // Get processJobID from FRPO_SMPL table

                    String hFRPO_SMPLPRCSJOB_POS = strDCDefResult.getDcItemResultList().get(count2).getWaferPosition();

                    one = cimJpaRepository.queryOne("select PJ_ID,REFKEY\n" +
                                    "                    from   OMPROPE_WAFERJOB\n" +
                                    "                    where  REFKEY = ?\n" +
                                    "                    and    PJ_POSITION   = ?" +
                                "                        fetch first rows only", hFRPOd_theSystemKey,
                            hFRPO_SMPLPRCSJOB_POS);
                    String hFRPO_SMPLPRCSJOB_ID = one==null?null: CimObjectUtils.toString(one[0]);
                    strDCDefResult.getDcItemResultList().get(count2).setProcessJobID(hFRPO_SMPLPRCSJOB_ID);
                } else {
                    strDCDefResult.getDcItemResultList().get(count2).setProcessJobID("");
                }

                /* act_code must be disassembled and set each of them into string sequence of action code. */
                //                           0         1         2
                //                           012345678901234567890123456
                // hFRPO_DC_ITEMSACT_CODE = "Inhibit-Recipe,HoldLot,Mail"
                if(hFRPO_DC_ITEMSACT_CODE!=null){
                    strDCDefResult.getDcItemResultList().get(count2).setActionCode(CimArrayUtils.generateList(
                            hFRPO_DC_ITEMSACT_CODE.split(",")));
                }
                if (getSpecFlag) {
                    if (CimStringUtils.length(ObjectIdentifier.fetchValue(strDCDefResult.getDataCollectionSpecificationID())) != 0) {
                        if (!getSpecFromDefFlag) {

                            //----------------------------------------------------------------------------------------------------
                            // Get DC Spec's information of specified PO and FRPO_DC.D_SEQNO and DCITEM_NAME from FRPO_DC_SPECS
                            //----------------------------------------------------------------------------------------------------
                            one = cimJpaRepository.queryOne("select EDC_ITEM_NAME,\n" +
                                            "                                    SCRN_UP_FLAG,    SCRN_UP_LIMIT,    SCRN_UP_ACT,\n" +
                                            "                                    SCRN_LO_FLAG,    SCRN_LO_LIMIT,    SCRN_LO_ACT,\n" +
                                            "                                    SPEC_UP_FLAG,    SPEC_UP_LIMIT,    SPEC_UP_ACT,\n" +
                                            "                                    SPEC_LO_FLAG,    SPEC_LO_LIMIT,    SPEC_LO_ACT,\n" +
                                            "                                    CTRL_UP_FLAG,    CTRL_UP_LIMIT,    CTRL_UP_ACT,\n" +
                                            "                                    CTRL_LO_FLAG,    CTRL_LO_LIMIT,    CTRL_LO_ACT,\n" +
                                            "                                    EDC_ITEM_TARGET,     EDC_ITEM_TAG,          EDC_SPEC_GROUP\n" +
                                            "                            from   OMPROPE_EDC_SPECS\n" +
                                            "                            where  REFKEY = ?\n" +
                                            "                            and    LINK_MARKER in (?, ?)\n" +
                                            "                            and    EDC_ITEM_NAME = ?",
                                    hFRPOd_theSystemKey,
                                    hFRPOd_theTableMarker,
                                    hFRPOd_theTableMarker2,
                                    hFRPO_DC_ITEMSDCITEM_NAME);

                            if (one == null || one.length == 0) {
                                count2++;
                                continue;
                            }

                            String hFRPO_DC_SPECSDCITEM_NAME = CimObjectUtils.toString(one[0]);
                            Boolean hFRPO_DC_SPECSSCRN_UPPER_REQ = CimBooleanUtils.convert(one[1]);
                            Double hFRPO_DC_SPECSSCRN_UPPER_LIMIT = CimDoubleUtils.doubleValue(one[2]);
                            String hFRPO_DC_SPECSSCRN_UPPER_ACTIONS = CimObjectUtils.toString(one[3]);
                            Boolean hFRPO_DC_SPECSSCRN_LOWER_REQ = CimBooleanUtils.convert(one[4]);
                            Double hFRPO_DC_SPECSSCRN_LOWER_LIMIT = CimDoubleUtils.doubleValue(one[5]);
                            String hFRPO_DC_SPECSSCRN_LOWER_ACTIONS = CimObjectUtils.toString(one[6]);
                            Boolean hFRPO_DC_SPECSSPEC_UPPER_REQ = CimBooleanUtils.convert(one[7]);
                            Double hFRPO_DC_SPECSSPEC_UPPER_LIMIT = CimDoubleUtils.doubleValue(one[8]);
                            String hFRPO_DC_SPECSSPEC_UPPER_ACTIONS = CimObjectUtils.toString(one[9]);
                            Boolean hFRPO_DC_SPECSSPEC_LOWER_REQ = CimBooleanUtils.convert(one[10]);
                            Double hFRPO_DC_SPECSSPEC_LOWER_LIMIT = CimDoubleUtils.doubleValue(one[11]);
                            String hFRPO_DC_SPECSSPEC_LOWER_ACTIONS = CimObjectUtils.toString(one[12]);
                            Boolean hFRPO_DC_SPECSCNTL_UPPER_REQ = CimBooleanUtils.convert(one[13]);
                            Double hFRPO_DC_SPECSCNTL_UPPER_LIMIT = CimDoubleUtils.doubleValue(one[14]);
                            String hFRPO_DC_SPECSCNTL_UPPER_ACTIONS = CimObjectUtils.toString(one[15]);
                            Boolean hFRPO_DC_SPECSCNTL_LOWER_REQ = CimBooleanUtils.convert(one[16]);
                            Double hFRPO_DC_SPECSCNTL_LOWER_LIMIT = CimDoubleUtils.doubleValue(one[17]);
                            String hFRPO_DC_SPECSCNTL_LOWER_ACTIONS = CimObjectUtils.toString(one[18]);
                            Double hFRPO_DC_SPECSDCITEM_TARGET = CimDoubleUtils.doubleValue(one[19]);
                            String hFRPO_DC_SPECSDCITEM_TAG = CimObjectUtils.toString(one[20]);
                            String hFRPO_DC_SPECSDC_SPEC_GROUP = CimObjectUtils.toString(one[21]);

                            strDCDefResult.getDcItemResultList().get(count2).setDataItemName(hFRPO_DC_SPECSDCITEM_NAME);
                            strDCDefResult.getDcItemResultList().get(count2).setScreenLimitUpperRequired(hFRPO_DC_SPECSSCRN_UPPER_REQ);
                            strDCDefResult.getDcItemResultList().get(count2).setScreenLimitUpper(hFRPO_DC_SPECSSCRN_UPPER_LIMIT);
                            strDCDefResult.getDcItemResultList().get(count2).setActionCodesUpperScreen(hFRPO_DC_SPECSSCRN_UPPER_ACTIONS);
                            strDCDefResult.getDcItemResultList().get(count2).setScreenLimitLowerRequired(hFRPO_DC_SPECSSCRN_LOWER_REQ);
                            strDCDefResult.getDcItemResultList().get(count2).setScreenLimitLower(hFRPO_DC_SPECSSCRN_LOWER_LIMIT);
                            strDCDefResult.getDcItemResultList().get(count2).setActionCodesLowerScreen(hFRPO_DC_SPECSSCRN_LOWER_ACTIONS);
                            strDCDefResult.getDcItemResultList().get(count2).setSpecLimitUpperRequired(hFRPO_DC_SPECSSPEC_UPPER_REQ);
                            strDCDefResult.getDcItemResultList().get(count2).setSpecLimitUpper(hFRPO_DC_SPECSSPEC_UPPER_LIMIT);
                            strDCDefResult.getDcItemResultList().get(count2).setActionCodesUpperSpecLimit(hFRPO_DC_SPECSSPEC_UPPER_ACTIONS);
                            strDCDefResult.getDcItemResultList().get(count2).setSpecLimitLowerRequired(hFRPO_DC_SPECSSPEC_LOWER_REQ);
                            strDCDefResult.getDcItemResultList().get(count2).setSpecLimitLower(hFRPO_DC_SPECSSPEC_LOWER_LIMIT);
                            strDCDefResult.getDcItemResultList().get(count2).setActionCodesLowerSpecLimit(hFRPO_DC_SPECSSPEC_LOWER_ACTIONS);
                            strDCDefResult.getDcItemResultList().get(count2).setControlLimitUpperRequired(hFRPO_DC_SPECSCNTL_UPPER_REQ);
                            strDCDefResult.getDcItemResultList().get(count2).setControlLimitUpper(hFRPO_DC_SPECSCNTL_UPPER_LIMIT);
                            strDCDefResult.getDcItemResultList().get(count2).setActionCodesUpperControlLimit(hFRPO_DC_SPECSCNTL_UPPER_ACTIONS);
                            strDCDefResult.getDcItemResultList().get(count2).setControlLimitLowerRequired(hFRPO_DC_SPECSCNTL_LOWER_REQ);
                            strDCDefResult.getDcItemResultList().get(count2).setControlLimitLower(hFRPO_DC_SPECSCNTL_LOWER_LIMIT);
                            strDCDefResult.getDcItemResultList().get(count2).setActionCodesLowerControlLimit(hFRPO_DC_SPECSCNTL_LOWER_ACTIONS);
                            strDCDefResult.getDcItemResultList().get(count2).setTarget(hFRPO_DC_SPECSDCITEM_TARGET);
                            strDCDefResult.getDcItemResultList().get(count2).setTag(hFRPO_DC_SPECSDCITEM_TAG);
                            strDCDefResult.getDcItemResultList().get(count2).setDcSpecGroup(hFRPO_DC_SPECSDC_SPEC_GROUP);
                        } else {

                            CimDataCollectionSpecification aPosDCSpec;
                            tmpDataCollectionSpecificationID = ObjectIdentifier.build("", "");
                            tmpDataCollectionSpecificationID = strDCDefResult.getDataCollectionSpecificationID();

                            aPosDCSpec = baseCoreFactory.getBO(CimDataCollectionSpecification.class,
                                    tmpDataCollectionSpecificationID);

                            EDCDTO.DCItemSpecification tempDCItemSpecification;
                            tempDCItemSpecification = aPosDCSpec.findDCSpec(strDCDefResult.getDcItemResultList().get(count2).getDataCollectionItemName());

                            String dataItemName;
                            dataItemName = tempDCItemSpecification.getDataItemName();
                            if (CimStringUtils.length(dataItemName) == 0) {
                                count2++;
                                continue;
                            } else {
                                strDCDefResult.getDcItemResultList().get(count2).setDataItemName(tempDCItemSpecification.getDataItemName());
                                strDCDefResult.getDcItemResultList().get(count2).setScreenLimitUpperRequired(tempDCItemSpecification.getScreenLimitUpperRequired());
                                strDCDefResult.getDcItemResultList().get(count2).setScreenLimitUpper(tempDCItemSpecification.getScreenLimitUpper());
                                strDCDefResult.getDcItemResultList().get(count2).setActionCodesUpperScreen(tempDCItemSpecification.getActionCodesUscrn());
                                strDCDefResult.getDcItemResultList().get(count2).setScreenLimitLowerRequired(tempDCItemSpecification.getScreenLimitLowerRequired());
                                strDCDefResult.getDcItemResultList().get(count2).setScreenLimitLower(tempDCItemSpecification.getScreenLimitLower());
                                strDCDefResult.getDcItemResultList().get(count2).setActionCodesLowerScreen(tempDCItemSpecification.getActionCodesLscrn());
                                strDCDefResult.getDcItemResultList().get(count2).setSpecLimitUpperRequired(tempDCItemSpecification.getSpecLimitUpperRequired());
                                strDCDefResult.getDcItemResultList().get(count2).setSpecLimitUpper(tempDCItemSpecification.getSpecLimitUpper());
                                strDCDefResult.getDcItemResultList().get(count2).setActionCodesUpperSpecLimit(tempDCItemSpecification.getActionCodesUsl());
                                strDCDefResult.getDcItemResultList().get(count2).setSpecLimitLowerRequired(tempDCItemSpecification.getSpecLimitLowerRequired());
                                strDCDefResult.getDcItemResultList().get(count2).setSpecLimitLower(tempDCItemSpecification.getSpecLimitLower());
                                strDCDefResult.getDcItemResultList().get(count2).setActionCodesLowerSpecLimit(tempDCItemSpecification.getActionCodesLsl());
                                strDCDefResult.getDcItemResultList().get(count2).setControlLimitUpperRequired(tempDCItemSpecification.getControlLimitUpperRequired());
                                strDCDefResult.getDcItemResultList().get(count2).setControlLimitUpper(tempDCItemSpecification.getControlLimitUpper());
                                strDCDefResult.getDcItemResultList().get(count2).setActionCodesUpperControlLimit(tempDCItemSpecification.getActionCodesUcl());
                                strDCDefResult.getDcItemResultList().get(count2).setControlLimitLowerRequired(tempDCItemSpecification.getControlLimitLowerRequired());
                                strDCDefResult.getDcItemResultList().get(count2).setControlLimitLower(tempDCItemSpecification.getControlLimitLower());
                                strDCDefResult.getDcItemResultList().get(count2).setActionCodesLowerControlLimit(tempDCItemSpecification.getActionCodesLcl());
                                strDCDefResult.getDcItemResultList().get(count2).setTarget(tempDCItemSpecification.getTarget());
                                strDCDefResult.getDcItemResultList().get(count2).setTag(tempDCItemSpecification.getTag());
                                strDCDefResult.getDcItemResultList().get(count2).setDcSpecGroup(tempDCItemSpecification.getDcSpecGroup());
                            }
                        }
                    }

                }

                count2++;
            }

            strLotDataCollectionInformationGetDROut.getStrDCDefResult().set(count, strDCDefResult);
            count++;
        }

        if (count == 0) {
            //---------------------------------------------------------------------------------
            // Get ASGN_DC_FLG of specified PO from FRPO
            //---------------------------------------------------------------------------------
            CimProcessOperationDO po = cimJpaRepository.queryOne("select ALLOC_EDC_FLAG,ID\n" +
                    "            from   OMPROPE\n" +
                    "            where  ID = ?", CimProcessOperationDO.class, hFRPOd_theSystemKey);
            if (CimBooleanUtils.isFalse(po.getAssignDataCollectionFlag())) {
                Validations.check(true, retCodeConfig.getNotFoundCdata());
            } else {
                Validations.check(true, retCodeConfig.getCdataDeleted());
            }
        }

        Validations.check(getSpecFromDefFlag == true, retCodeConfig.getDefinedDcSpecInfo());

        //---------------------------------------------------------------------------------
        //   Return to Caller
        //---------------------------------------------------------------------------------
        return strLotDataCollectionInformationGetDROut;
    }

    public List<Infos.WhatNextAttributes> lotCheckConditionForWhatNextEqpMonitorLot(
            Infos.ObjCommon objCommon,
            Inputs.ObjLotCheckConditionForWhatNextEqpMonitorLotIn objLotCheckConditionForWhatNextEqpMonitorLotIn) {
        //--------------------------------//
        //  Get Auto Monitor Object  //
        //--------------------------------//

        CimEqpMonitor anEqpMonitor = baseCoreFactory.getBO(CimEqpMonitor.class,
                objLotCheckConditionForWhatNextEqpMonitorLotIn.getEqpMonitorID());
        //BUG-2014 check eapMonitor ID if exist
        Validations.check(anEqpMonitor == null,retCodeConfig.getNotFoundEqpMonitor(),
                ObjectIdentifier.fetchValue(objLotCheckConditionForWhatNextEqpMonitorLotIn.getEqpMonitorID()));
        List<Infos.WhatNextAttributes> tmpWhatNextAttributes = new ArrayList();
        boolean bKitFlag = anEqpMonitor.isKitFlag();
        CimMachine aMachine = anEqpMonitor.getMachine();
        Validations.check(aMachine==null, retCodeConfig.getNotFoundMachine());

        ObjectIdentifier equipmentID = ObjectIdentifier.build(aMachine.getIdentifier(),aMachine.getPrimaryKey());
        List<Infos.WhatNextAttributes> strWhatNextAttributes = objLotCheckConditionForWhatNextEqpMonitorLotIn
                .getStrWhatNextAttributes();
        int size = CimArrayUtils.getSize(strWhatNextAttributes);
        for (int i = 0; i < size; i++) {
            Infos.WhatNextAttributes strWhatNextAttribute = strWhatNextAttributes.get(i);
            Inputs.strLotCheckConditionForEqpMonitorIn strLotCheckConditionForEqpMonitorIn = new Inputs
                    .strLotCheckConditionForEqpMonitorIn();
            strLotCheckConditionForEqpMonitorIn.setEqpMonitorID(objLotCheckConditionForWhatNextEqpMonitorLotIn
                    .getEqpMonitorID());
            strLotCheckConditionForEqpMonitorIn.setOperation(BizConstant.SP_EQPMONITOR_OPECATEGORY_WHATSNEXT);
            if(bKitFlag){
                strLotCheckConditionForEqpMonitorIn.setCheckLevel(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONKIT);
            }else {
                strLotCheckConditionForEqpMonitorIn.setCheckLevel(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT);
            }
            strLotCheckConditionForEqpMonitorIn.setLotID(strWhatNextAttribute.getLotID());

            try {
                this.lotCheckConditionForEqpMonitor(objCommon, strLotCheckConditionForEqpMonitorIn);
            }catch (ServiceException ex){
                log.debug("Not candidate for EqpMonitor lot.");
                continue;
            }
            // if lotCheckConditionForEqpMonitor method succeeds else add attribute
            tmpWhatNextAttributes.add(strWhatNextAttribute);
        }
        return tmpWhatNextAttributes;
    }

    @Override
    public void lotCheckConditionForEqpMonitor(Infos.ObjCommon objCommon, Inputs.strLotCheckConditionForEqpMonitorIn strLotCheckConditionForEqpMonitorIn) {
        ObjectIdentifier lotID = strLotCheckConditionForEqpMonitorIn.getLotID();
        //--------------------------------//
        //  Get Auto Monitor Object  //
        //--------------------------------//
        CimEqpMonitor anEqpMonitor = baseCoreFactory.getBO(CimEqpMonitor.class, strLotCheckConditionForEqpMonitorIn.getEqpMonitorID());
        // BUG-2014 check autoMonitor entity if exist
        Validations.check(anEqpMonitor == null,retCodeConfig.getNotFoundEqpMonitor(),
                ObjectIdentifier.fetchValue(strLotCheckConditionForEqpMonitorIn.getEqpMonitorID()));
        //Get Equipment object
        CimMachine anEquipment = anEqpMonitor.getMachine();
        Validations.check(anEquipment==null, retCodeConfig.getSystemError());

        ObjectIdentifier equipmentID = ObjectIdentifier.build(anEquipment.getIdentifier(),anEquipment.getPrimaryKey());
        String eqpCategory = anEquipment.getCategory();
        // step1 lot_cassette_Get
        // Get Cassette ID from Lot ID
        ObjectIdentifier cassetteID = this.lotCassetteGet(objCommon, strLotCheckConditionForEqpMonitorIn.getLotID());

        CimCassette aCassette = baseCoreFactory.getBO(CimCassette.class, cassetteID);
        Validations.check(null == aCassette, retCodeConfig.getNotFoundCassette());

        // Get Lot object
        CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, strLotCheckConditionForEqpMonitorIn.getLotID());
        Validations.check(null == aPosLot, retCodeConfig.getNotFoundLot());
        //-------------------------------------//
        //Check if scrap wafer is in the cassette
        //-------------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT, strLotCheckConditionForEqpMonitorIn.getCheckLevel())){
            // step2 cassette_scrapWafer_SelectDR
            List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
            cassetteIDs.add(cassetteID);
            List<Infos.LotWaferMap> lotWaferMaps = cassetteMethod.cassetteScrapWaferSelectDR(objCommon, cassetteIDs);
            Validations.check(CimArrayUtils.isNotEmpty(lotWaferMaps), retCodeConfig.getFoundScrap());
        }
        //--------------------------------//
        //Check if scrap wafer is in the lot
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONKIT, strLotCheckConditionForEqpMonitorIn.getCheckLevel())){
            // step3 lot_scrapWafer_SelectDR
            List<ObjectIdentifier> strLoScrapWaferSelectDrIn = new ArrayList<>();
            strLoScrapWaferSelectDrIn.add(strLotCheckConditionForEqpMonitorIn.getLotID());
            List<Infos.WaferListInLotFamilyInfo>  strLotScrapWaferSelectDrOut = this.lotScrapWaferSelectDR(objCommon, strLoScrapWaferSelectDrIn);
            Validations.check(CimArrayUtils.isNotEmpty(strLotScrapWaferSelectDrOut), retCodeConfig.getFoundScrap());
        }
        //--------------------------------//
        //Check SorterJob existence
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation()) &&
                CimStringUtils.equals(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT, strLotCheckConditionForEqpMonitorIn.getCheckLevel())){
            log.debug("SorterJob - operation is EqpMonReserve, checkLevel is EqpMonNoKit");
            List<ObjectIdentifier> dummyIDs = new ArrayList<>();
            List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
            cassetteIDs.add(cassetteID);
            Inputs.ObjWaferSorterJobCheckForOperation objWaferSorterJobCheckForOperation = new Inputs.ObjWaferSorterJobCheckForOperation();
            Infos.EquipmentLoadPortAttribute equipmentLoadPortAttribute = new Infos.EquipmentLoadPortAttribute();
            List<Infos.CassetteLoadPort> cassetteLoadPorts = new ArrayList<>();
            Infos.CassetteLoadPort cassetteLoadPort = new Infos.CassetteLoadPort();
            cassetteLoadPort.setCassetteID(cassetteID);
            cassetteLoadPorts.add(cassetteLoadPort);
            equipmentLoadPortAttribute.setCassetteLoadPortList(cassetteLoadPorts);
            equipmentLoadPortAttribute.setEquipmentID(equipmentID);
            objWaferSorterJobCheckForOperation.setEquipmentLoadPortAttribute(equipmentLoadPortAttribute);
            objWaferSorterJobCheckForOperation.setCassetteIDList(cassetteIDs);
            objWaferSorterJobCheckForOperation.setLotIDList(dummyIDs);
            objWaferSorterJobCheckForOperation.setOperation(BizConstant.SP_OPERATION_FOR_CAST);

            //step4 - waferSorter_sorterJob_CheckForOperation
            waferMethod.waferSorterSorterJobCheckForOperation(objCommon, objWaferSorterJobCheckForOperation);
        }
        //--------------------------------//
        //Get and Check ControlJobID
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            log.debug("ControlJobID - operation is EqpMonReserve");
            CimControlJob aControlJob = aCassette.getControlJob();
            Validations.check(aControlJob!=null, retCodeConfig.getCassetteControlJobFilled());

        }
        //--------------------------------//
        //Check MultipleCapability VS MultiLotType
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation()) &&
                CimStringUtils.equals(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT, strLotCheckConditionForEqpMonitorIn.getCheckLevel())){
            log.debug("SorterJob - operation is EqpMonReserve, checkLevel is EqpMonNoKit");
            String multiLotType = aCassette.getMultiLotType();
            String multiRecipeCapability = anEquipment.getMultipleRecipeCapability();
            if ( CimStringUtils.equals(multiRecipeCapability, BizConstant.SP_EQP_MULTIRECIPECAPABILITY_MULTIPLERECIPE) ) {
               // result.setReturnCode(retCodeConfig.getSucc());
            }else if(CimStringUtils.equals(multiRecipeCapability, BizConstant.SP_EQP_MULTIRECIPECAPABILITY_SINGLERECIPE) ) {
               // result.setReturnCode(retCodeConfig.getSucc());
            }else if(CimStringUtils.equals(multiRecipeCapability, BizConstant.SP_EQP_MULTIRECIPECAPABILITY_BATCH) ) {
                log.debug("multiRecipeCapability == SP_Eqp_MultiRecipeCapability_Batch");
                if(CimStringUtils.equals(multiLotType, BizConstant.SP_CAS_MULTILOTTYPE_SINGLELOTSINGLERECIPE) ||
                        CimStringUtils.equals(multiLotType, BizConstant.SP_CAS_MULTILOTTYPE_MULTILOTSINGLERECIPE)) {
                  //  result.setReturnCode(retCodeConfig.getSucc());
                }else {
                    throw new ServiceException(retCodeConfig.getCassetteEquipmentConditionError());
                }
            }
            else {
                log.debug("No Process <Check MultiRecipeCapability VS MultiLotType>");
            }
        }
        //--------------------------------//
        //Check Cassette Transfer Status
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            String transferState = aCassette.getTransportState();
            //Transferstate should be SI/BI/MI
            Validations.check(!CimStringUtils.equals(transferState, BizConstant.SP_TRANSSTATE_STATIONIN) && !CimStringUtils.equals(transferState, BizConstant.SP_TRANSSTATE_BAYIN) && !CimStringUtils.equals(
                    transferState, BizConstant.SP_TRANSSTATE_MANUALIN), new OmCode(retCodeConfig.getInvalidCassetteTransferState(), transferState,cassetteID.getValue()));
        }
        //--------------------------------//
        //Get and Check Cassette Dispatch Status
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            boolean dispatchReserveFlag = aCassette.isDispatchReserved();
            Validations.check(!CimBooleanUtils.isFalse(dispatchReserveFlag), retCodeConfig.getAlreadyDispatchReservedCassette());

        }
        //--------------------------------//
        //Get and Check Cassette Status
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation()) &&
                CimStringUtils.equals(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT, strLotCheckConditionForEqpMonitorIn.getCheckLevel())){
            String cassetteState = aCassette.getDurableState();
            if (CimStringUtils.equals(BizConstant.CIMFW_DURABLE_AVAILABLE, cassetteState)
                    || CimStringUtils.equals(BizConstant.CIMFW_DURABLE_INUSE, cassetteState)) {
                log.debug("cassetteState = CIMFW_Durable_Available or CIMFW_Durable_InUse");
            } else {
                Validations.check(retCodeConfig.getInvalidCassetteState(),BizConstant.CIMFW_DURABLE_AVAILABLE,
                        BizConstant.CIMFW_DURABLE_INUSE);
            }
        }
        //--------------------------------//
        //Check InPostProcessingFlag
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            // step5 cassette_inPostProcessFlag_Get
            Boolean strCassette_inPostProcessFlag_Get_out = cassetteMethod.cassetteInPostProcessFlagGet(objCommon, cassetteID);
            //---------------------------------------------------
            //  If Cassette is in post process, returns error
            //---------------------------------------------------
            Validations.check(strCassette_inPostProcessFlag_Get_out, retCodeConfig.getCassetteInPostProcess());
        }
        //--------------------------------//
        //Check cassette InterFabXfer State
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            // step6 cassette_interFabXferState_Get
            String strCassette_interFabXferState_Get_out = cassetteMethod.cassetteInterFabXferStateGet(objCommon, cassetteID);
            Validations.check(CimStringUtils.equals(BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING, strCassette_interFabXferState_Get_out),retCodeConfig.getInterfabInvalidCassetteTransferStateForRequest());
        }
        //--------------------------------//
        // Check EqpMonitor job existence
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            ProductDTO.EqpMonitorJobLotInfo anEqpMonitorJobLotInfo = aPosLot.getEqpMonitorJobLotInfo();
            if(null != anEqpMonitorJobLotInfo) {
                Validations.check(!CimStringUtils.isEmpty(anEqpMonitorJobLotInfo.getEqpMonitorJobID().getValue()), retCodeConfig.getEqpmonjobExist());

            }

        }
        //--------------------------------//
        //Check lot InterFabXfer State
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            // step7 lot_interFabXferState_Get
            String strLotInterFabXferStateGetOut = this.lotInterFabXferStateGet(objCommon, strLotCheckConditionForEqpMonitorIn.getLotID());

            if( CimStringUtils.equals(strLotInterFabXferStateGetOut, BizConstant.SP_INTERFAB_XFERSTATE_REQUIRED) ||
                    CimStringUtils.equals(strLotInterFabXferStateGetOut, BizConstant.SP_INTERFAB_XFERSTATE_TRANSFERRING)) {
                throw new ServiceException(retCodeConfig.getInterfabInvalidLotXferstateForReq());
            }
        }
        //--------------------------------//
        //Get Lot Control Job ID
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            CimControlJob aControlJob = aPosLot.getControlJob();
            if (null != aControlJob) {
                Validations.check( new OmCode(retCodeConfig.getLotControlJobidFilled(), aPosLot.getIdentifier(), aControlJob.getIdentifier()));
            }
        }
        //--------------------------------//
        //Get and Check Lot State
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            String holdState = aPosLot.getLotHoldState();
            String processState = aPosLot.getLotProcessState();
            String inventoryState = aPosLot.getLotInventoryState();
            //Check for hold state
            Validations.check(!CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, holdState), retCodeConfig.getNotCandidateLotForOperationStart());
            Validations.check(!CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_WAITING, processState), retCodeConfig.getInvalidLotProcstat());
            Validations.check(!CimStringUtils.equals(BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR, inventoryState), retCodeConfig.getInvalidLotInventoryStat(),
                    ObjectIdentifier.fetchValue(aPosLot.getLotID()),inventoryState);
        }
        //--------------------------------//
        //Check Equipment ID (Check Queued Machines of Lot)
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            log.debug("Check Equipment - operation is EqpMonReserve.");
            List<CimMachine> aMachineSeq = aPosLot.getQueuedMachines();
            boolean matchFlag = false;
            for (CimMachine equipment1 : aMachineSeq) {
                ObjectIdentifier qEquipmentID = ObjectIdentifier.build(equipment1.getIdentifier(), equipment1.getPrimaryKey());
                if(ObjectIdentifier.equalsWithValue(qEquipmentID, equipmentID)){
                    matchFlag = true;
                    break;
                }
            }
            Validations.check(CimBooleanUtils.isFalse(matchFlag), retCodeConfig.getNotCorrectEqpForOperationStart());

        }
        //--------------------------------//
        //Check current Operation is Bank-In Operation or Not
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation())){
            boolean bankInFlag = aPosLot.isBankInRequired();
            Validations.check(CimBooleanUtils.isTrue(bankInFlag), retCodeConfig.getBankinOperation());
        }
        //--------------------------------//
        //Check Equipment Availability
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation()) &&
                CimStringUtils.equals(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT, strLotCheckConditionForEqpMonitorIn.getCheckLevel())){
            log.debug("Equipment Availability - operation is EqpMonReserve and checkLevel is EqpMonNoKit");
            List<ObjectIdentifier> checkLotIDs = new ArrayList<>();
            checkLotIDs.add(strLotCheckConditionForEqpMonitorIn.getLotID());
            // step8 equipment_CheckAvailForLot
            equipmentMethod.equipmentCheckAvailForLot(objCommon, equipmentID, checkLotIDs);
        }
        //--------------------------------//
        //Check Lot Condition in Bonding Flow Section
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation()) &&
                CimStringUtils.equals(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT, strLotCheckConditionForEqpMonitorIn.getCheckLevel())){
            //----------------------------------//
            //   Get Bonding Flow Section Name  //
            //----------------------------------//
            String bondFlowName = aPosLot.getBondingFlowName();
            if(!CimStringUtils.isEmpty(bondFlowName)){
                //----------------------------------------------------------------------------//
                //   Check for all operations in Bonding Flow Section                         //
                //     If Lot is not reserved to Bonding Group, operation cannot be performed //
                //----------------------------------------------------------------------------//
                //-------------------------//
                //   Get Bonding Group ID  //
                //-------------------------//
                // step9 lot_bondingGroupID_GetDR
                String strLot_bondingGroupID_GetDR_out = this.lotBondingGroupIDGetDR(objCommon, strLotCheckConditionForEqpMonitorIn.getLotID());

                if ( CimStringUtils.isEmpty( strLot_bondingGroupID_GetDR_out ) ) {
                   throw new ServiceException(retCodeConfig.getNotFoundBondingGroupForLot());
                } else {
                    com.fa.cim.newcore.bo.pd.CimProcessOperation aPosPO = aPosLot.getProcessOperation();
                    Validations.check( aPosPO==null, retCodeConfig.getNotFoundProcessOperation());

                    String operationNo = aPosPO.getOperationNumber();
                    boolean bValidEqpForBndFlow = true;
                    if( CimBooleanUtils.isTrue(aPosPO.isBondingFlowSectionTargetOperation()) && !CimStringUtils.equals(eqpCategory, BizConstant.SP_MC_CATEGORY_WAFERBONDING)){
                        bValidEqpForBndFlow = false;
                    }else if(CimBooleanUtils.isFalse(aPosPO.isBondingFlowSectionTargetOperation()) && CimStringUtils.equals(eqpCategory, BizConstant.SP_MC_CATEGORY_WAFERBONDING)){
                        log.debug("isBondingFlowSectionTargetOperation() != TRUE && eqpCategory == SP_Mc_Category_WaferBonding");
                        bValidEqpForBndFlow = false;
                    }else {
                        log.debug("OK. bValidEqpForBndFlow = TRUE");
                    }

                    Validations.check( !bValidEqpForBndFlow, new OmCode(retCodeConfig.getBondGroupInvalidEqp(), ObjectIdentifier.fetchValue(aPosLot.getLotID()), equipmentID.getValue(), aPosPO.getOperationName()));
                }
            }
        }

        //--------------------------------//
        //SLM reserved condition
        //--------------------------------//
        if(CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE, strLotCheckConditionForEqpMonitorIn.getOperation()) &&
                CimStringUtils.equals(BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT, strLotCheckConditionForEqpMonitorIn.getCheckLevel())){
            log.debug("SLM reserved condition - operation is EqpMonReserve and checkLevel is EqpMonNoKit");
            CimMachine aSLMReservedMachine = aCassette.getSLMReservedMachine();
            Validations.check(aSLMReservedMachine!=null, new OmCode(retCodeConfig.getAlreadyReservedCassetteSlm(), aCassette.getIdentifier()));

        }

    }

    @Override
    public List<Infos.WaferListInLotFamilyInfo> lotScrapWaferSelectDR(Infos.ObjCommon objCommon, List<ObjectIdentifier> strLoScrapWaferSelectDrIn) {
        int len = strLoScrapWaferSelectDrIn.size();
        List<Infos.WaferListInLotFamilyInfo> strLotWaferList = new ArrayList<>();
        long lenScrap = 0;
        long maxInAlot = 0;
        String lMaxWfrStr = StandardProperties.OM_MAX_WAFER_COUNT_FOR_LOT.getValue();
        if(CimStringUtils.isEmpty(lMaxWfrStr)){
            log.debug("SP_MAX_WAFER_IN_LOT is empty");
            maxInAlot = 25;
        }else {
            int lMaxWfr = Integer.valueOf(lMaxWfrStr);
            maxInAlot = lMaxWfr;
        }
        lenScrap  = len*maxInAlot;
        for (ObjectIdentifier lotID : strLoScrapWaferSelectDrIn) {
            CimWaferDO cimWaferExample = new CimWaferDO();
            cimWaferExample.setLotID(ObjectIdentifier.fetchValue(lotID));
            cimWaferExample.setScrapState(BizConstant.SP_SCRAPSTATE_SCRAP);
            List<CimWaferDO> wafers = cimJpaRepository.findAll(Example.of(cimWaferExample));
            // ---------------------------------------------------
            // Fetch Data from DB
            // ---------------------------------------------------
            for(long j = 0L; j < maxInAlot ; j++ ){
                if(wafers==null || wafers.size()<=0){
                    break;
                }
                if (!CimObjectUtils.isEmpty(wafers)) {
                    wafers.sort(comparingInt(CimWaferDO::getPosition));
                    if (j <= wafers.size() - 1) {
                        Infos.WaferListInLotFamilyInfo waferListInLotFamilyInfo = new Infos.WaferListInLotFamilyInfo();
                        waferListInLotFamilyInfo.setLotID(new ObjectIdentifier(wafers.get((int) j).getLotID(), wafers.get((int) j).getLotObj()));
                        waferListInLotFamilyInfo.setWaferID(new ObjectIdentifier(wafers.get((int) j).getWaferID(), wafers.get((int) j).getId()));
                        waferListInLotFamilyInfo.setScrapFlag(true);
                        waferListInLotFamilyInfo.setSlotNumber(wafers.get((int) j).getPosition());
                        strLotWaferList.add(waferListInLotFamilyInfo);
                    }
                }
            }
        }
        return strLotWaferList;
    }


    @Override
    public Boolean lotFPCAvailFlagGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {


        //------------------------------------------------------------------------//
        // Get Object PosLot_var from lotID                                       //
        //------------------------------------------------------------------------//
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check (null == lot, retCodeConfig.getNotFoundLot());

        //------------------------------------------------------------------------//
        // Get Object ProductSpecification_var                                    //
        //------------------------------------------------------------------------//
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification productSpecification = lot.getProductSpecification();
        Validations.check (null == productSpecification, retCodeConfig.getNotFoundProductSpec());

        //------------------------------------------------------------------------//
        // Get DOC Available Flag                                                 //
        //------------------------------------------------------------------------//
        return productSpecification.isFPCAvailableFlagOn();
    }

    @Override
    public void lotCheckConditionForStartReserveCancel(Infos.ObjCommon objCommon, ObjectIdentifier controlJobID, List<Infos.StartCassette> strStartCassette) {
        /*-------------------------*/
        /*   Check Lot Condition   */
        /*-------------------------*/
        int SCLength = CimArrayUtils.getSize(strStartCassette);
        log.info("loop to strStartCassette.size()", SCLength);
        for (int i = 0; i < SCLength; i++) {
            Infos.StartCassette startCassette = strStartCassette.get(i);
            /*-------------------------*/
            /*   Omit Empty Cassette   */
            /*-------------------------*/
            String loadPurposeType = startCassette.getLoadPurposeType();
            log.info("loadPurposeType : {}", loadPurposeType);
            if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE, loadPurposeType)) {
                continue;
            }
            int LICLength = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
            log.info("loop to strStartCassette[i].strLotInCassette.size() : {}", LICLength);
            for (int j = 0; j < LICLength; j++) {
                Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                /*--------------------------*/
                /*   Omit Not-Started Lot   */
                /*--------------------------*/
                Boolean operationStartFlag = lotInCassette.getMoveInFlag();
                if (!operationStartFlag) {
                    continue;
                }
                /*--------------------*/
                /*   Get Lot Object   */
                /*--------------------*/
                CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                Validations.check (null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), lotInCassette.getLotID().getValue()));

                /*-------------------------------*/
                /*   Get and Check Lot's State   */
                /*-------------------------------*/
                String lotProcessState = aLot.getLotProcessState();
                Validations.check (CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING, lotProcessState),
                        new OmCode(retCodeConfig.getInvalidLotProcessState(), lotInCassette.getLotID().getValue(), lotProcessState));

                /*----------------------------------*/
                /*   Get controlJobID of Cassette   */
                /*----------------------------------*/
                CimControlJob aControlJob = aLot.getControlJob();
                Validations.check (null == aControlJob, new OmCode(retCodeConfig.getLotControlJobIdBlank(), lotInCassette.getLotID().getValue()));
                Validations.check(!ObjectIdentifier.equalsWithValue(aControlJob.getControlJobID(), controlJobID), retCodeConfig.getLotControlJobMix());
            }
        }
    }

    @Override
    public List<Infos.FPCInfo> lotCurrentFPCInfoGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier equipmentID,
                                                             Boolean waferIDInfoGetFlag, Boolean recipeParmInfoGetFlag, Boolean reticleInfoGetFlag, Boolean dcSpecItemInfoGetFlag) {
        List<Infos.FPCInfo> fpcInfoRet = null;

        log.debug(" lot_currentFPCInfo_Get");
        log.debug("input LotID = {}", lotID);
        log.debug("input EqpID {}", equipmentID);

        // Get Lot Object
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot,retCodeConfig.getNotFoundLot());

        // FPC_info_GetDR call parameters
        List<String> dummyFPCIDs = new ArrayList<>();
        ObjectIdentifier currentMainPDID, originalMainPDID = null, subOrigMainPDID = null;
        String currentOpeNo, originalOpeNo = null, subOrigOpeNo = null;

        // Get Lot's current mainPD ID
        com.fa.cim.newcore.bo.pd.CimProcessDefinition currentMainPD = lot.getMainProcessDefinition();
        Validations.check(null == currentMainPD,retCodeConfig.getNotFoundProcessDefinition());


        currentMainPDID = new ObjectIdentifier(currentMainPD.getIdentifier(), currentMainPD.getPrimaryKey());
        log.debug("current MainPD ID = {}", currentMainPDID);

        // Get Lot's current OpeNo
        currentOpeNo = lot.getOperationNumber();
        log.debug("current OpeNo = {}", currentOpeNo);


        // Get Lot's original routeID and OpeNo
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = lot.getProcessFlowContext();
        Validations.check (null == aPFX,retCodeConfig.getNotFoundPfx());

        List<ProcessDTO.BackupOperation> backupPOListPtr = aPFX.allBackupOperations();
        Integer branchNestLevel = CimArrayUtils.getSize(backupPOListPtr);
        log.debug("branchNestLevel is {}", branchNestLevel);

        if (branchNestLevel > 2) {
            log.debug("DOC Info is not defined in this nest level. {} {}", lotID, branchNestLevel);
        } else {
            log.debug("branchNestLevel OK.");
            Integer level = 0;
            String tmpPDIDStr, tmpOpeNoStr;
            for (int i=0; i<branchNestLevel; i++) {
                ProcessDTO.BackupOperation backPO = backupPOListPtr.get(i);
                log.debug("  Now collect info for level {}", level);
                String reworkOutKey = backPO.getReworkOutKey();
                if (!CimObjectUtils.isEmpty(reworkOutKey)) {
                    log.debug("This Lot is reworked on level {}", level);

                    //===== Divide reworkOutKey to RouteID and OpeNo =======//
                    //reworkOutKey = "MainPD ID" + '.' + "MainPD Version" + '.' + "Module No" + '.' + "Module OpeNo"
                    String point = ".";
                    int pointIndex = reworkOutKey.indexOf(point, reworkOutKey.indexOf(point) + 1);
                    Validations.check(pointIndex == -1,retCodeConfig.getNotFoundMainRoute());

                    tmpPDIDStr = reworkOutKey.substring(0, pointIndex);
                    tmpOpeNoStr = reworkOutKey.substring(pointIndex + 1);
                } else {
                    log.debug("This Lot is branched on level {}", level);
                    com.fa.cim.newcore.bo.pd.CimProcessOperation aPO = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessOperation.class, new ObjectIdentifier(null, backPO.getProcessOperation()));
                    Validations.check (null == aPO, retCodeConfig.getNotFoundProcessOperation());

                    // Get Lot's current mainPD ID
                    com.fa.cim.newcore.bo.pd.CimProcessDefinition anOrigMainPD = aPO.getMainProcessDefinition();
                    Validations.check(null == anOrigMainPD, retCodeConfig.getNotFoundProcessDefinition());

                    tmpPDIDStr = anOrigMainPD.getIdentifier();
                    tmpOpeNoStr = aPO.getOperationNumber();
                }

                if (branchNestLevel - level == 1) {
                    originalMainPDID = new ObjectIdentifier(tmpPDIDStr);
                    originalOpeNo = tmpOpeNoStr;
                } else if (branchNestLevel - level == 2) {
                    subOrigMainPDID = new ObjectIdentifier(tmpPDIDStr);
                    subOrigOpeNo = tmpOpeNoStr;
                }
                level ++;
            }

            // call FPC_info_GetDR
            Inputs.ObjFPCInfoGetDRIn in = new Inputs.ObjFPCInfoGetDRIn();
            in.setFPCIDs(dummyFPCIDs);
            in.setLotID(lotID);
            in.setLotFamilyID(null);
            in.setMainPDID(currentMainPDID);
            in.setMainOperNo(currentOpeNo);
            in.setOrgMainPDID(originalMainPDID);
            in.setOrgOperNo(originalOpeNo);
            in.setSubMainPDID(subOrigMainPDID);
            in.setSubOperNo(subOrigOpeNo);
            in.setEquipmentID(equipmentID);
            in.setWaferIDInfoGetFlag(waferIDInfoGetFlag);
            in.setRecipeParmInfoGetFlag(recipeParmInfoGetFlag);
            in.setReticleInfoGetFlag(reticleInfoGetFlag);
            in.setDcSpecItemInfoGetFlag(dcSpecItemInfoGetFlag);
            fpcInfoRet = fpcMethod.fpcInfoGetDR(objCommon, in);


        }
        return fpcInfoRet;
    }

    /**
     * description:
     * change history:
     * date             defect             person             comments
     * -----------------------------------------------------------------------------------------------------------------
     * @author Sun
     * @date 3/14/2019 1:17 PM
     * @param sql -
     * @param params -
     * @return java.util.List<com.fa.cim.bean.extension.Infos.lotFutureHoldDR>
     */
    private List<Infos.lotFutureHoldDR> queryFutureHoldLots(String sql , Object... params){
        List<Infos.lotFutureHoldDR> lotFutureHoldDRs = new ArrayList<>();
        List<Object[]> futureHoldLots  = cimJpaRepository.query(sql,params);

        int count = CimArrayUtils.getSize(futureHoldLots);
        if(count == 0){
            return lotFutureHoldDRs;
        }

        for (int i=0;i<count;i++){
            Infos.lotFutureHoldDR lotFutureHoldDR = new Infos.lotFutureHoldDR();
            if(futureHoldLots.get(i)==null){
                continue;
            }
            lotFutureHoldDR.setLotID((String)(futureHoldLots.get(i))[0]);
            lotFutureHoldDR.setFutureHoldType((String)(futureHoldLots.get(i))[1]);
            lotFutureHoldDR.setFutureHoldReasonCode((String)(futureHoldLots.get(i))[2]);
            lotFutureHoldDR.setFutureHoldReasonCodeObj((String)(futureHoldLots.get(i))[3]);
            lotFutureHoldDR.setFutureHoldUserID((String)(futureHoldLots.get(i))[4]);
            lotFutureHoldDR.setFutureHoldUserObj((String)(futureHoldLots.get(i))[5]);
            lotFutureHoldDR.setFutureHoldMainProcessDefinitionID((String)(futureHoldLots.get(i))[6]);
            lotFutureHoldDR.setFutureHoldMainProcessDefinitionObj((String)(futureHoldLots.get(i))[7]);
            lotFutureHoldDR.setFutureHoldOperationNumber((String)(futureHoldLots.get(i))[8]);
            lotFutureHoldDR.setFutureHoldClaimTime((String)(futureHoldLots.get(i))[9]);
            lotFutureHoldDR.setFutureHoldRelatedLotID((String)(futureHoldLots.get(i))[10]);
            lotFutureHoldDR.setFutureHoldRelatedLotObj((String)(futureHoldLots.get(i))[11]);
            lotFutureHoldDR.setFutureHoldClaimMemo((String)(futureHoldLots.get(i))[12]);
            lotFutureHoldDR.setFutureHoldSingleTrigFlag((String)(futureHoldLots.get(i))[13]);
            lotFutureHoldDR.setFutureHoldPostFlag((String)(futureHoldLots.get(i))[14]);
            lotFutureHoldDRs.add(lotFutureHoldDR);
        }

        return lotFutureHoldDRs;
    }

    @Override
    public void lotCheckFlowBatchConditionForBranch(Infos.ObjCommon objCommon, Infos.BranchReq branchReq) {

        ObjectIdentifier lotID = branchReq.getLotID();
        String returnOperationNumber = branchReq.getReturnOperationNumber();
        String currentOperationNumber = branchReq.getCurrentOperationNumber();
        ObjectIdentifier currentRouteID = branchReq.getCurrentRouteID();
        ObjectIdentifier subRouteID = branchReq.getSubRouteID();
        //-----------------------------------------------------------------------------------
        //  Check the return point of the branch-route steps over the target or not.
        //  Check the return point of the branch operation is in a FlowBatch Section or not.
        //  Check the flowBatched lots go out from the FlowBatch Section or not.
        //-----------------------------------------------------------------------------------
        CimLot lotDO = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lotDO, retCodeConfig.getNotFoundLot());


        CimProcessFlowContext pfxDO = lotDO.getProcessFlowContext();
        Validations.check(null == pfxDO, retCodeConfig.getNotFoundPfx());


        Boolean isAfter = pfxDO.isAfterOperationNumber(returnOperationNumber, currentOperationNumber);
        Inputs.ObjProcessOperationProcessRefListForLotIn in = new Inputs.ObjProcessOperationProcessRefListForLotIn();
        in.setSearchDirection(isAfter);
        in.setPosSearchFlag(true);
        in.setSearchCount(9999);
        in.setSearchRouteID(currentRouteID);
        in.setSearchOperationNumber(returnOperationNumber);
        in.setCurrentFlag(true);
        in.setLotID(lotID);
        List<Infos.OperationProcessRefListAttributes> refListForLotRetCode = processMethod.processOperationProcessRefListForLot(objCommon, in);
        int operationCoutForLot = CimArrayUtils.getSize(refListForLotRetCode);
        this.lotFlowBatchCheckLocate(objCommon, isAfter, lotID, refListForLotRetCode.get(operationCoutForLot - 1).getProcessRef());


        // Check the flowBatched lots move to the branch route with a FlowBatch section or not
        CimFlowBatch flowBatchDO = lotDO.getFlowBatch();
        if (null == flowBatchDO) {
          //  result.setReturnCode(retCodeConfig.getSucc());
           // return result;
        } else {
            Inputs.ProcessOperationListForRoute listForRouteParams = new Inputs.ProcessOperationListForRoute();
            listForRouteParams.setRouteID(subRouteID);
            listForRouteParams.setOperationID(null);
            listForRouteParams.setOperationNumber(null);
            listForRouteParams.setPdType(null);
            in.setSearchCount(-1);
            List<Infos.OperationNameAttributes> listForRouteRetCode = processMethod.processOperationListForRoute(objCommon, listForRouteParams);

            Boolean fbSectionFoundFlag = false;
            int opeationCountForRouteSize = CimArrayUtils.getSize(listForRouteRetCode);
            for (int i = 0; i < opeationCountForRouteSize; i++) {
                Infos.OperationNameAttributes operationNameAttributes = listForRouteRetCode.get(i);
                Outputs.ObjProcessFlowBatchDefinitionGetDROut getDROutRetCode = processMethod.processFlowBatchDefinitionGetDR(objCommon, operationNameAttributes.getProcessRef().getModulePOS());

                if (CimStringUtils.isNotEmpty(getDROutRetCode.getFlowBatchControl().getName())) {
                    if (CimBooleanUtils.isTrue(getDROutRetCode.getFlowBatchSection().getEntryOperationFlag())) {
                        log.debug("flowbatch section is found.");
                        fbSectionFoundFlag = true;
                        break;
                    }
                }
            }

            Validations.check(CimBooleanUtils.isTrue(fbSectionFoundFlag), retCodeConfig.getNotBranchBatchOpe());
            log.debug("the branch route does not have a flowbatch section.");

        }

    }

    @Override
    public void lotCheckBondingFlowSectionForBranch(Infos.ObjCommon objCommon, Infos.BranchReq branchReq) {
        ObjectIdentifier lotID = branchReq.getLotID();
        String returnOperationNumber = branchReq.getReturnOperationNumber();
        String currentOperationNumber = branchReq.getCurrentOperationNumber();
        ObjectIdentifier currentRouteID = branchReq.getCurrentRouteID();
        ObjectIdentifier subRouteID = branchReq.getSubRouteID();

        //-----------------------------------------------------------------------------------
        //  Check the return point of the branch-route steps over the target or not.
        //  Check the return point of the branch operation is in a FlowBatch Section or not.
        //  Check the flowBatched lots go out from the FlowBatch Section or not.
        //-----------------------------------------------------------------------------------
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == aLot, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = aLot.getProcessFlowContext();
        Validations.check(null == aPFX , new OmCode(retCodeConfig.getNotFoundPfx(), ""));

        Boolean isAfter = aPFX.isAfterOperationNumber(returnOperationNumber, currentOperationNumber);
        Inputs.ObjProcessOperationProcessRefListForLotIn in = new Inputs.ObjProcessOperationProcessRefListForLotIn();
        in.setSearchDirection(isAfter);
        in.setPosSearchFlag(true);
        in.setSearchCount(9999);
        in.setSearchRouteID(currentRouteID);
        in.setSearchOperationNumber(returnOperationNumber);
        in.setCurrentFlag(true);
        in.setLotID(lotID);
        List<Infos.OperationProcessRefListAttributes> operationProcessRefListAttributesList = processMethod.processOperationProcessRefListForLot(objCommon, in);
        int operationCoutForLot = CimArrayUtils.getSize(operationProcessRefListAttributesList);
        this.lotBondingFlowSectionCheckLocate(objCommon, lotID, operationProcessRefListAttributesList.get(operationCoutForLot -1).getProcessRef());

        // Check the lots move to the branch route with a bonding flow section or not .
        String bondingGroupID = this.lotBondingGroupIDGetDR(objCommon, lotID);
        if (!CimStringUtils.isEmpty(bondingGroupID)) {
            log.debug("The input lot has a bondingGroupID.");
            Inputs.ProcessOperationListForRoute listForRouteParams = new Inputs.ProcessOperationListForRoute();
            listForRouteParams.setRouteID(subRouteID);
            in.setSearchCount(-1);
            List<Infos.OperationNameAttributes> operationNameAttributesList = processMethod.processOperationListForRoute(objCommon, listForRouteParams);
            int opeationCountForRouteSize = CimArrayUtils.getSize(operationNameAttributesList);
            for (int i = 0; i < opeationCountForRouteSize; i++) {
                Infos.OperationNameAttributes operationNameAttributes = operationNameAttributesList.get(i);
                Outputs.ObjProcessBondingFlowDefinitionGetDROut objProcessBondingFlowDefinitionGetDROut = processMethod.processBondingFlowDefinitionGetDR(objCommon, operationNameAttributes.getProcessRef().getModulePOS());
                Validations.check(CimStringUtils.isNotEmpty(objProcessBondingFlowDefinitionGetDROut.getFlowSectionControl().getFlowSectionID()),
                        new OmCode(retCodeConfig.getNotBranchBondingFlow(), "The target lots cannot move to the branch route with a bonding flow section."));

            }
        }
    }

    @Override
    public void lotBondingFlowSectionCheckLocate(Infos.ObjCommon objCommon, ObjectIdentifier lotID, Infos.ProcessRef processRef) {
        //---------------------------------------
        // Get destination Flow Section Control
        //---------------------------------------
        com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification destProcessOperationSpecification = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification.class, processRef.getModulePOS());
        Validations.check(null == destProcessOperationSpecification, retCodeConfig.getNotFoundPos());

        ProcessDTO.FlowSectionControl destFlowSectionControl = destProcessOperationSpecification.getBondingFlowSectionControl();

        Boolean bDestEntryOperation = destProcessOperationSpecification.isFlowSectionEntryOperation();

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        com.fa.cim.newcore.bo.pd.CimProcessOperation apo = lot.getProcessOperation();
        Validations.check(null == apo, retCodeConfig.getNotFoundProcessOperation());

        com.fa.cim.newcore.bo.pd.CimProcessOperationSpecification apos = apo.getModuleProcessOperationSpecification();
        Validations.check(null == apos, retCodeConfig.getNotFoundPos());

        ProcessDTO.FlowSectionControl currentFlowSectionControl = apos.getBondingFlowSectionControl();

        //---------------------------------------
        // Get current Module Number
        //---------------------------------------
        String currentModuleNo = apo.getModuleNumber();
        if (CimStringUtils.isEmpty(currentFlowSectionControl.getFlowSectionID())) {
            if (CimObjectUtils.isEmpty(destFlowSectionControl.getFlowSectionID())) {

            } else {
                Validations.check(!bDestEntryOperation, retCodeConfig.getNotLocatetoBondingflowsection());
            }
        } else {
            String objLotBondingGroupIDGetDROut = this.lotBondingGroupIDGetDR(objCommon, lotID);
            if (CimStringUtils.isEmpty(objLotBondingGroupIDGetDROut) ) {
                if (CimStringUtils.isEmpty(destFlowSectionControl.getFlowSectionID())) {

                }else {
                    Validations.check(!bDestEntryOperation, retCodeConfig.getNotLocatetoBondingflowsection());
                }
            } else {
                if (CimStringUtils.isNotEmpty(destFlowSectionControl.getFlowSectionID())) {
                    if (CimStringUtils.equals(currentFlowSectionControl.getFlowSectionID(), destFlowSectionControl.getFlowSectionID())
                            && CimStringUtils.equals(currentModuleNo, processRef.getModuleNumber())) {

                    } else {
                        Validations.check(retCodeConfig.getNotLocatetoBondingflowsection());

                    }
                } else {
                    Validations.check(retCodeConfig.getNotLocatetoBondingflowsection());
                }
            }
        }
    }

    @Override
    public Outputs.ObjLotEquipmentOrderGetByLotStatusOut lotEquipmentOrderGetByLotStatus(Infos.ObjCommon objCommon, Infos.LotLocationInfo cassetteLocationInfo, Infos.LotStatusInfo lotStatus) {
        Outputs.ObjLotEquipmentOrderGetByLotStatusOut objLotEquipmentOrderGetByLotStatusOut = new Outputs.ObjLotEquipmentOrderGetByLotStatusOut();
        /*****************************/
        /*  Check input parameter.   */
        /*****************************/
        Validations.check(CimObjectUtils.isEmpty(lotStatus.getLotID().getValue()),retCodeConfig.getInvalidInputParam() );

        List<ObjectIdentifier> eqpIDs = new ArrayList<>();
        Integer setMachineType = -1;
        ObjectIdentifier operationID = null;
        Boolean previousEquipmentFlag = false;
        /*****************************/
        /* When Lot is on Floor.     */
        /*****************************/
        switch (lotStatus.isOnFloorFlag() ? 1 : 0) {
            case 1: {
                /**********************************/
                /*  Check lot InterFabXfer plan   */
                /**********************************/
                log.info("Step1 - Check lot InterFabXfer Plan");
                //------------------------------
                //  Get Lot current operation
                //------------------------------
                Outputs.ObjLotCurrentOperationInfoGetDROut objLotCurrentOperationInfoGetDROutRetCode = this.lotCurrentOperationInfoGetDR(objCommon, lotStatus.getLotID());

                //--------------------------------------
                //  Get original FabID
                //--------------------------------------
                String orgFabID = StandardProperties.OM_SITE_ID.getValue();
                //--------------------------------------
                //  Check lot InterFab transfer plan
                //--------------------------------------
                Inputs.ObjInterFabXferPlanListGetDRIn objInterFabXferPlanListGetDRIn = new Inputs.ObjInterFabXferPlanListGetDRIn();
                Infos.InterFabLotXferPlanInfo strInterFabLotXferPlanInfo = new Infos.InterFabLotXferPlanInfo();
                objInterFabXferPlanListGetDRIn.setStrInterFabLotXferPlanInfo(strInterFabLotXferPlanInfo);
                strInterFabLotXferPlanInfo.setLotID(lotStatus.getLotID());
                strInterFabLotXferPlanInfo.setOriginalFabID(orgFabID);
                strInterFabLotXferPlanInfo.setOriginalRouteID(objLotCurrentOperationInfoGetDROutRetCode.getMainPDID());
                strInterFabLotXferPlanInfo.setOriginalOpeNumber(objLotCurrentOperationInfoGetDROutRetCode.getOpeNo());
                Outputs.ObjInterFabXferPlanListGetDROut objInterFabXferPlanListGetDROutRetCode = null;
                try {
                    objInterFabXferPlanListGetDROutRetCode = interFabMethod.interFabXferPlanListGetDR(objCommon, objInterFabXferPlanListGetDRIn);
                } catch (ServiceException e) {
                    objInterFabXferPlanListGetDROutRetCode = e.getData(Outputs.ObjInterFabXferPlanListGetDROut.class);
                    if (!Validations.isEquals( retCodeConfig.getInterfabNotFoundXferPlan(),e.getCode())) {
                        throw e;
                    }
                }
                if (!CimObjectUtils.isEmpty(objInterFabXferPlanListGetDROutRetCode.getStrInterFabLotXferPlanInfoSeq())) {
                    List<Infos.InterFabLotXferPlanInfo> strInterFabLotXferPlanInfoList = objInterFabXferPlanListGetDROutRetCode.getStrInterFabLotXferPlanInfoSeq();
                    if (CimStringUtils.equals(strInterFabLotXferPlanInfoList.get(0).getState(), BizConstant.SP_INTERFAB_XFERPLANSTATE_CREATED)
                            || CimStringUtils.equals(strInterFabLotXferPlanInfoList.get(0).getState(), BizConstant.SP_INTERFAB_XFERPLANSTATE_CANCELED)) {
                        setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setCassetteMachine.getType();
                        break;
                    }
                }
                /********************************/
                /*                              */
                /*  Get queued machine List     */
                /*                              */
                /********************************/
                log.info("Step2 - lot_queuedMachines_GetByOperationOrder");
                Outputs.ObjLotQueuedMachinesGetByOperationOrderOut objLotQueuedMachinesGetByOperationOrderOutRetCode = this.lotQueuedMachinesGetByOperationOrder(objCommon, lotStatus.getLotID(), lotStatus.getProductID());

                int nQueuedEqpLen = CimArrayUtils.getSize(objLotQueuedMachinesGetByOperationOrderOutRetCode.getQueuedMachineList());
                if (nQueuedEqpLen > 0) {
                    eqpIDs = objLotQueuedMachinesGetByOperationOrderOutRetCode.getQueuedMachineList();
                    setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setQueuedMachine.getType();
                    break;
                }
                /************************************/
                /*   FlowBatch-WaitingLot Support   */
                /************************************/
                if (nQueuedEqpLen == 0 && CimStringUtils.equals(lotStatus.getCurrentStatus().getHoldState(), CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD)
                        && CimStringUtils.equals(lotStatus.getCurrentStatus().getProcessState(), CIMStateConst.CIM_LOT_PROCESS_STATE_WAITING)) {
                    log.info("Step3 - process_flowBatchDefinition_GetDR(FlowBatch-WaitingLot Support)");
                    Outputs.ObjProcessFlowBatchDefinitionGetDROut objProcessFlowBatchDefinitionGetDROutRetCode = processMethod.processFlowBatchDefinitionGetDR(objCommon, objLotCurrentOperationInfoGetDROutRetCode.getModulePOS());
                    if (CimBooleanUtils.isTrue(objProcessFlowBatchDefinitionGetDROutRetCode.getFlowBatchSection().getEntryOperationFlag())) {
                        operationID = objLotCurrentOperationInfoGetDROutRetCode.getOperationID();
                        setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setOperationDispatchedMachine.getType();
                        break;
                    }
                }
                /*************************************/
                /* When held Lot is detected         */
                /*************************************/
                Boolean previousHoldFlag = false;
                if (CimStringUtils.equals(lotStatus.getCurrentStatus().getHoldState(), CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD)) {
                    /********************************/
                    /*    Check hold detail info    */
                    /********************************/
                    log.info("Step4 - lot_FillInTxTRQ005DR");
                    List<Infos.LotHoldListAttributes> listRetCode = lotFillInTxTRQ005DR(objCommon, lotStatus.getLotID());

                    int holdRecLen = CimArrayUtils.getSize(listRetCode);
                    for (int i = 0; i < holdRecLen; i++) {
                        if (CimStringUtils.equals(listRetCode.get(i).getResponsibleOperationMark(), BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS)) {
                            previousHoldFlag = true;
                            break;
                        }
                    }
                }
                /*************************************/
                /* When Lot is on Floor and          */
                /*   is not WIP lot.                 */
                /*  - FlowBatch floating lot         */
                /*  - Previous Hold lot              */
                /*************************************/
                if (CimStringUtils.equals(lotStatus.getCurrentStatus().getHoldState(), CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD) || CimBooleanUtils.isTrue(previousHoldFlag)) {
                    String transferStatus = cassetteLocationInfo.getTransferStatus();
                    if (CimStringUtils.equals(transferStatus, BizConstant.SP_TRANSSTATE_STATIONIN)
                            || CimStringUtils.equals(transferStatus, BizConstant.SP_TRANSSTATE_BAYIN)
                            || CimStringUtils.equals(transferStatus, BizConstant.SP_TRANSSTATE_MANUALIN)
                            || CimStringUtils.equals(transferStatus, BizConstant.SP_TRANSSTATE_SHELFIN)
                            || CimStringUtils.equals(transferStatus, BizConstant.SP_TRANSSTATE_INTERMEDIATEIN)
                            || CimStringUtils.equals(transferStatus, BizConstant.SP_TRANSSTATE_ABNORMALIN)) {
                        setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setNoMachine.getType();
                        break;
                    } else {
                        previousEquipmentFlag = true;
                        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotStatus.getLotID());
                        Validations.check(aLot == null,retCodeConfig.getNotFoundLot());
                        CimControlJob aControlJob = aLot.getControlJob();
                        if (CimStringUtils.equals(transferStatus, BizConstant.SP_TRANSSTATE_EQUIPMENTIN) && aControlJob == null) {
                            setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setCassetteMachine.getType();
                            break;
                        } else {
                            /********************************/
                            /*                              */
                            /* Get the previous equipment   */
                            /*                              */
                            /********************************/
                            com.fa.cim.newcore.bo.pd.CimProcessFlowContext aFlowContext = aLot.getProcessFlowContext();
                            Validations.check(aFlowContext == null, retCodeConfig.getNotFoundPfx());

                            com.fa.cim.newcore.bo.pd.CimProcessOperation prevPO = aFlowContext.getPreviousProcessOperation();
                            Validations.check(prevPO == null, retCodeConfig.getNotFoundPoForLot());

                            com.fa.cim.newcore.bo.pd.CimProcessDefinition aPD = prevPO.getProcessDefinition();
                            Validations.check(aPD == null, retCodeConfig.getNotFoundProcessDefinition());

                            /********************************/
                            /*                              */
                            /*   Get queued machine List    */
                            /*                              */
                            /********************************/
                            operationID = new ObjectIdentifier(aPD.getIdentifier(), aPD.getPrimaryKey());
                            setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setOperationDispatchedMachine.getType();
                            break;
                        }
                    }
                }
                /*********************************/
                /* When Lot is on Floor and      */
                /*   Held on Current Operation.  */
                /*********************************/
                else {
                    operationID = objLotCurrentOperationInfoGetDROutRetCode.getOperationID();
                    setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setOperationDispatchedMachine.getType();
                    break;
                }
            }
            case 0: {
                /**********************************/
                /* When Lot is in Bank.           */
                /**********************************/
                CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotStatus.getLotID());
                Validations.check(aLot == null,retCodeConfig.getNotFoundLot());
                com.fa.cim.newcore.bo.factory.CimBank aBank = aLot.getBank();
                Validations.check(aBank == null, retCodeConfig.getNotFoundBank());

                com.fa.cim.newcore.bo.machine.CimStorageMachine aStocker = aBank.getStorageMachine();
                if (aStocker == null) {
                    if (!ObjectIdentifier.isEmptyWithValue(cassetteLocationInfo.getEquipmentID())) {
                        previousEquipmentFlag = true;
                        setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setCassetteMachine.getType();
                        break;
                    }
                }
                setMachineType = MethodEnums.LotEquipmentOrderGetByLotStatusEnums.setNoMachine.getType();
                break;
            }
            default:
                break;
        }
        switch (MethodEnums.LotEquipmentOrderGetByLotStatusEnums.getByType(setMachineType)){
            case setQueuedMachine:
                break;
            case setOperationDispatchedMachine:{
                /***********************************************/
                /*    Call process_dispatchEquipments_GetDR    */
                /***********************************************/
                log.info("Step5 - process_dispatchEquipments_GetDR");
                List<ObjectIdentifier> processDispatchEquipmentsResult = processMethod.processDispatchEquipmentsGetDR(objCommon, lotStatus.getProductID(), operationID);

                eqpIDs = processDispatchEquipmentsResult;
                break;
            }
            case setCassetteMachine:{
                /*************************************/
                /*  Set Cassette related Machine.    */
                /*************************************/
                eqpIDs.add(cassetteLocationInfo.getEquipmentID());
                break;
            }
            case setNoMachine:{
                break;
            }
            default:
                break;
        }
        if(!CimObjectUtils.isEmpty(eqpIDs)){
            Boolean checkInhibitFlag = true;
            Boolean checkMachineAvailabilityFlag = true;
            if(CimBooleanUtils.isTrue(previousEquipmentFlag)){
                /********************************************************************************/
                /*  Responsible operation of this Lot is previous operation.                    */
                /*  So it should not be checked its availability for the previous equipment.    */
                /********************************************************************************/
                checkInhibitFlag = false;
                checkMachineAvailabilityFlag = false;
            }
            /**********************************/
            /*  Sort the Equipment.           */
            /**********************************/
            log.info("Step6 - equipment_priorityOrder_GetByLotAvailability(Sort the Equipment)");
            Outputs.ObjEquipmentPriorityOrderGetByLotAvailabilityOut objEquipmentPriorityOrderGetByLotAvailabilityOutRetCode = equipmentMethod.equipmentPriorityOrderGetByLotAvailability(objCommon, eqpIDs, lotStatus.getLotID(), checkInhibitFlag, checkMachineAvailabilityFlag);
            /**********************************/
            /*  Set Equipment information.    */
            /**********************************/
            objLotEquipmentOrderGetByLotStatusOut.setWhereNextEqpStatusList(objEquipmentPriorityOrderGetByLotAvailabilityOutRetCode.getWhereNextEqpStatuseList());
            objLotEquipmentOrderGetByLotStatusOut.setAvailableEqpExistFlag(objEquipmentPriorityOrderGetByLotAvailabilityOutRetCode.getAvailableEqpExistFlag());
        }  else {
            objLotEquipmentOrderGetByLotStatusOut.setAvailableEqpExistFlag(true);
        }
        return objLotEquipmentOrderGetByLotStatusOut;
    }

    @Override
    public Outputs.ObjLotQueuedMachinesGetByOperationOrderOut lotQueuedMachinesGetByOperationOrder(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier productID) {
        Outputs.ObjLotQueuedMachinesGetByOperationOrderOut objLotQueuedMachinesGetByOperationOrderOut = new Outputs.ObjLotQueuedMachinesGetByOperationOrderOut();
        /****************************/
        /* Check input parameter    */
        /****************************/
        Validations.check(ObjectIdentifier.isEmptyWithValue(lotID), "lotQueuedMachinesGetByOperationOrder: Empty lotID");

        /********************************/
        /*  Get queued machine List     */
        /********************************/
        log.info("Step 1 - lot_queuedMachines_GetDR");
        Outputs.ObjLotQueuedMachinesGetDROut objLotQueuedMachinesGetDROutRetCode = this.lotQueuedMachinesGetDR(objCommon, lotID);

        List<ObjectIdentifier> lotEqpIDs = objLotQueuedMachinesGetDROutRetCode.getQueuedMachineList();
        if (!CimObjectUtils.isEmpty(lotEqpIDs)) {
            /******************************/
            /*    Get lot current info    */
            /******************************/
            log.info("Step 2 - lot_currentOperationInfo_GetDR");
            Outputs.ObjLotCurrentOperationInfoGetDROut objLotCurrentOperationInfoGetDROutRetCode = this.lotCurrentOperationInfoGetDR(objCommon, lotID);

            /***********************************************/
            /*    Call process_dispatchEquipments_GetDR    */
            /***********************************************/
            log.info("Step 3 - process_dispatchEquipments_GetDR");
            List<ObjectIdentifier> processDispatchEquipmentResult = processMethod.processDispatchEquipmentsGetDR(objCommon, productID, objLotCurrentOperationInfoGetDROutRetCode.getOperationID());

            List<ObjectIdentifier> processEqpIDs = processDispatchEquipmentResult;
            /***************************************************/
            /* Sort by eqp_id sequence which are defined in PD */
            /***************************************************/
            log.info("Step 4 - Sort by eqp_id sequence which are defined in PD");
            int lotEqpLen = CimArrayUtils.getSize(lotEqpIDs);
            int procEqpLen = CimArrayUtils.getSize(processEqpIDs);
            int count = 0;
            List<ObjectIdentifier> queuedMachineList = new ArrayList<>();
            objLotQueuedMachinesGetByOperationOrderOut.setQueuedMachineList(queuedMachineList);
            for (int i = 0; i < procEqpLen; i++) {
                for (int j = 0; j < lotEqpLen; j++) {
                    if (ObjectIdentifier.equalsWithValue(processEqpIDs.get(i), lotEqpIDs.get(j))) {
                        if (count < lotEqpLen) {
                            queuedMachineList.add(lotEqpIDs.get(j));
                            count++;
                        }
                        break;
                    }
                }
            }
            if (count < lotEqpLen) {
                for (int i = 0; i < lotEqpLen; i++) {
                    Boolean existFlag = false;
                    for (int j = 0; j < count; j++) {
                        if (ObjectIdentifier.equalsWithValue(lotEqpIDs.get(i), queuedMachineList.get(j))) {
                            existFlag = true;
                            break;
                        }
                    }
                    if (!existFlag) {
                        if (count < lotEqpLen) {
                            queuedMachineList.add(lotEqpIDs.get(i));
                            count++;
                        }
                    }
                }
            }
        }
        return objLotQueuedMachinesGetByOperationOrderOut;
    }

    @Override
    public Outputs.ObjLotQueuedMachinesGetDROut lotQueuedMachinesGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Outputs.ObjLotQueuedMachinesGetDROut objLotQueuedMachinesGetDROut = new Outputs.ObjLotQueuedMachinesGetDROut();
        /*--------------------------------------------*/
        /*  Select all UTSs from FREQP_UTS and FRSTK  */
        /*--------------------------------------------*/
        String sql = "SELECT OMLOT_EQP.EQP_ID,\n" +
                "                   OMLOT_EQP.EQP_RKEY\n" +
                "            FROM   OMLOT, OMLOT_EQP\n" +
                "            WHERE  OMLOT.LOT_ID=?\n" +
                "            AND    OMLOT.ID=OMLOT_EQP.REFKEY\n" +
                "            AND    OMLOT.LOT_HOLD_STATE=? ";
        List<CimLotEquipmentDO> cimLotEquipmentDList = cimJpaRepository.query(sql, CimLotEquipmentDO.class, new Object[]{lotID.getValue(), CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD});
        List<ObjectIdentifier> queuedMachineList = new ArrayList<>();
        objLotQueuedMachinesGetDROut.setQueuedMachineList(queuedMachineList);
        if (!CimObjectUtils.isEmpty(cimLotEquipmentDList)) {
            for (CimLotEquipmentDO cimLotEquipmentDO : cimLotEquipmentDList) {
                /*-------------------------*/
                /*  Set return structure   */
                /*-------------------------*/
                ObjectIdentifier queuedMachine = new ObjectIdentifier(cimLotEquipmentDO.getEquipmentID(), cimLotEquipmentDO.getEquipmentObj());
                queuedMachineList.add(queuedMachine);
            }
        }
        return objLotQueuedMachinesGetDROut;
    }

    @Override
    public void lotCheckConditionForEqpMonitorLotReserve(Infos.ObjCommon objCommon, Inputs.LotCheckConditionForEqpMonitorLotReserveIn lotCheckConditionForEqpMonitorLotReserveIn) {
         /*----------------*/
        /*   Initialize   */
        /*----------------*/
        List<Infos.EqpMonitorProductLotMap> strProdLotMap = lotCheckConditionForEqpMonitorLotReserveIn.getStrProductLotMap();
        int nSeqLen = 0;
        int nLotLen = 0;

        //Trace InParameters
        log.info("in para eqpMonitorID : {}",lotCheckConditionForEqpMonitorLotReserveIn.getEqpMonitorID() );

        //--------------------------------
        //  - Check Lot-Product relation
        //  - Check wafer count
        //--------------------------------
        int nMonProdLen = CimArrayUtils.getSize(strProdLotMap);
        log.info( "nMonProdLen : {}", nMonProdLen);
        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        for(int i = 0; i < nMonProdLen; i++ ) {
            int nTotalWaferCnt = 0;

            int nMonLotLen = CimArrayUtils.getSize(strProdLotMap.get(i).getEqpMonitorLotIDs());
            log.info( "nMonLotLen : {}", nMonLotLen);
            for(int j = 0; j < nMonLotLen; j++ ) {
                //Import all lot id to lotIDs
                ObjectIdentifier lotID = strProdLotMap.get(i).getEqpMonitorLotIDs().get(j);
                lotIDs.add(strProdLotMap.get(i).getEqpMonitorLotIDs().get(j));

                CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, lotID);
                Validations.check(null == aPosLot, retCodeConfig.getNotFoundLot(), objCommon.getTransactionID());

                com.fa.cim.newcore.bo.prodspec.CimProductSpecification aProdSpec = aPosLot.getProductSpecification();
                Validations.check(null == aProdSpec, retCodeConfig.getNotFoundProductSpec(), objCommon.getTransactionID());

                String prodSpecID = aProdSpec.getIdentifier();
                log.info("prodSpecID : {}", prodSpecID);
                Validations.check(!ObjectIdentifier.equalsWithValue(prodSpecID, strProdLotMap.get(i).getStrEqpMonitorProductInfo().getProductID()), retCodeConfig.getInvalidMonitorProduct());

                Outputs.ObjLotRecipeGetOut objLotRecipeGetOut = lotMethod.lotRecipeGet(objCommon, lotCheckConditionForEqpMonitorLotReserveIn.getEquipmentID(), lotID);
                ObjectIdentifier machineRecipeId = objLotRecipeGetOut.getMachineRecipeId();
                if (!ObjectIdentifier.isEmptyWithValue(machineRecipeId)){
                    Validations.check(!ObjectIdentifier.equalsWithValue(machineRecipeId, strProdLotMap.get(i).getStrEqpMonitorProductInfo().getRecipeID()), retCodeConfig.getInvalidParameter());
                }


                int nWaferCnt = 0;
                nWaferCnt = aPosLot.getQuantity();
                nTotalWaferCnt = nTotalWaferCnt + nWaferCnt;
            }

            Validations.check( strProdLotMap.get(i).getStrEqpMonitorProductInfo().getWaferCount() > nTotalWaferCnt, retCodeConfig.getEqpmonitorWaferNotEnough());

        }

        //--------------------------------//
        //  Get Auto Monitor Object  //
        //--------------------------------//
        CimEqpMonitor anEqpMonitor = baseCoreFactory.getBO(CimEqpMonitor.class, lotCheckConditionForEqpMonitorLotReserveIn.getEqpMonitorID());
        Validations.check(null == anEqpMonitor, retCodeConfig.getNotFoundEqpMonitor(), objCommon.getTransactionID());
        Boolean bKitFlag = anEqpMonitor.isKitFlag();

        String strCheckLevel;
        if(bKitFlag) {
            log.info("TRUE == bKitFlag");
            strCheckLevel = BizConstant.SP_EQPMONITOR_LEVEL_EQPMONKIT;
        } else {
            log.info("TRUE != bKitFlag");
            strCheckLevel = BizConstant.SP_EQPMONITOR_LEVEL_EQPMONNOKIT;
        }
        CimMachine aMachine = anEqpMonitor.getMachine();
        Validations.check(null == aMachine, retCodeConfig.getNotFoundMachine(), objCommon.getTransactionID());

        String multiRecipeCapability = aMachine.getMultipleRecipeCapability();

        ObjectIdentifier equipmentID = new ObjectIdentifier(aMachine.getIdentifier(), aMachine.getPrimaryKey());
        int prodLotMapSize = CimArrayUtils.getSize(strProdLotMap);
        for(int i =0; i<prodLotMapSize; i++) {
            int lotIDSize = CimArrayUtils.getSize(strProdLotMap.get(i).getEqpMonitorLotIDs());
            for(int j =0; j<lotIDSize; j++) {
                Inputs.strLotCheckConditionForEqpMonitorIn strLotCheckConditionForEqpMonitorIn = new Inputs.strLotCheckConditionForEqpMonitorIn();
                strLotCheckConditionForEqpMonitorIn.setEqpMonitorID(lotCheckConditionForEqpMonitorLotReserveIn.getEqpMonitorID());
                strLotCheckConditionForEqpMonitorIn.setOperation(BizConstant.SP_EQPMONITOR_OPECATEGORY_EQPMONRESERVE);
                strLotCheckConditionForEqpMonitorIn.setCheckLevel(strCheckLevel);
                strLotCheckConditionForEqpMonitorIn.setLotID(strProdLotMap.get(i).getEqpMonitorLotIDs().get(j));
                this.lotCheckConditionForEqpMonitor(objCommon, strLotCheckConditionForEqpMonitorIn);
            }
        }

        //This check is only for strCheckLevel=EqpMonKit
        //--------------------------------
        // Check StartSeqNo in a cassette
        // Lots which has different StartSeqNo should start with different control job.
        // If the equipment is batch, lots in cassette is started at the same time and shouldn't have different StartSeqNo.
        //--------------------------------
        if( CimStringUtils.equals(multiRecipeCapability, BizConstant.SP_EQP_MULTIRECIPECAPABILITY_BATCH) && !bKitFlag ) {
            log.info("multiRecipeCapability is Batch and bKitFlag is FALSE.");
            int nLenCast = 0;
            List<Infos.StartSeqNo> strStartSeqNoForCast = new ArrayList<>();

            Boolean bCastFoundFlag = false;
            for(int i =0; i< prodLotMapSize; i++) {
                int lotIDSize = CimArrayUtils.getSize(strProdLotMap.get(i).getEqpMonitorLotIDs());
                for(int j =0; j<lotIDSize; j++) {
                    bCastFoundFlag = false;

                    //Get Cassette object from Lot ID
                    ObjectIdentifier strLotCassetteGetOut = this.lotCassetteGet(objCommon, strProdLotMap.get(i).getEqpMonitorLotIDs().get(j));

                    for (int x = 0; x<nLenCast; x++) {
                        log.info("loop through strStartSeqNoForCast ; {}",x);
                        if (ObjectIdentifier.equalsWithValue(strLotCassetteGetOut, strStartSeqNoForCast.get(x).getKey())) {
                            log.info("Found cassetteID",strLotCassetteGetOut);
                            Validations.check(strStartSeqNoForCast.get(x).getStartSeqNo().intValue() != lotCheckConditionForEqpMonitorLotReserveIn.getStrProductLotMap().get(i).getStrEqpMonitorProductInfo().getStartSeqNo().intValue(), retCodeConfig.getMismatchEqpMonitorStartSeq());
                            bCastFoundFlag = true;
                            break;
                        }
                    }
                    if (CimBooleanUtils.isFalse(bCastFoundFlag)) {
                        log.info("new cassetteID");
                        //Add the combination of cassette ID and startSeqNo to strStartSeqNoForCast
                        Infos.StartSeqNo startSeqNo = new Infos.StartSeqNo();
                        startSeqNo.setKey(ObjectIdentifier.fetchValue(strLotCassetteGetOut));
                        startSeqNo.setStartSeqNo(strProdLotMap.get(i).getStrEqpMonitorProductInfo().getStartSeqNo());
                        // bug-2113
                        strStartSeqNoForCast.add(startSeqNo);
                        nLenCast++;
                    }
                }
            }
        }

        //--------------------------------
        // Check startSeqNo for Flow Batch
        // Lots which has different StartSeqNo should start with different control job.
        // If lots are included in Flow Batch, lots in Flow batch is started at the same time and shouldn't have different StartSeqNo.
        //--------------------------------
        List<Infos.StartSeqNo> strStartSeqNoForFlowBatch = new ArrayList<>();
        int nLenFB = 0;
        Boolean bFlowBatchFoundFlag = false;
        log.info("length of strProdLotMap : {}",nMonProdLen);
        for(int i =0; i<nMonProdLen; i++) {
            int nMonLotLen = CimArrayUtils.getSize(strProdLotMap.get(i).getEqpMonitorLotIDs());
            for(int j =0; j<nMonLotLen; j++) {
                bFlowBatchFoundFlag = false;
                CimLot aPosLot = baseCoreFactory.getBO(CimLot.class, strProdLotMap.get(i).getEqpMonitorLotIDs().get(j));
                Validations.check(null == aPosLot, retCodeConfig.getNotFoundLot(), objCommon.getTransactionID());

                com.fa.cim.newcore.bo.dispatch.CimFlowBatch aLotFlowBatch = aPosLot.getFlowBatch();
                if(null == aLotFlowBatch) {
                    continue;
                } else {
                    log.info("","Lot is involved in FlowBatch. Checking StartSeqNo condition.");
                    ObjectIdentifier flowBatchID = new ObjectIdentifier(aLotFlowBatch.getIdentifier(),aLotFlowBatch.getPrimaryKey());

                    CimMachine aReservedMachine = aLotFlowBatch.getMachine();
                    if ( null == aReservedMachine) {
                        log.info("Equipment isn't connected to FlowBatch");
                        continue;
                    }
                    ObjectIdentifier reservedEquipmentID = new ObjectIdentifier(aReservedMachine.getIdentifier(), aReservedMachine.getPrimaryKey());
                    if( !CimObjectUtils.equals(reservedEquipmentID, equipmentID) ) {
                        log.info("Flow batch for other equipment. No need to check FlowBatch VS StartSeqNo for this lot.");
                        continue;
                    }

                    for (int x = 0; x<nLenFB; x++ ) {
                        if (ObjectIdentifier.equalsWithValue(flowBatchID, strStartSeqNoForFlowBatch.get(x).getKey())) {
                            log.info("Found flowBatchID : {}",flowBatchID);
                            Validations.check(strStartSeqNoForFlowBatch.get(x).getStartSeqNo().intValue() != strProdLotMap.get(i).getStrEqpMonitorProductInfo().getStartSeqNo(), retCodeConfig.getMismatchEqpMonitorStartSeq());

                            bFlowBatchFoundFlag = true;
                            break;
                        }
                    }
                    if (CimBooleanUtils.isFalse(bFlowBatchFoundFlag)) {
                        log.info("new FlowBatch ID");
                        //Add the combination of FlowBatch ID and startSeqNo to strStartSeqNo
                        Infos.StartSeqNo startSeqNo = new Infos.StartSeqNo();
                        startSeqNo.setKey(ObjectIdentifier.fetchValue(flowBatchID));
                        startSeqNo.setStartSeqNo(strProdLotMap.get(i).getStrEqpMonitorProductInfo().getStartSeqNo());
                        nLenFB++;
                    }
                }
            }
        }

        //--------------------------------
        // Check StartSeqNo for Bonding Group
        // Lots which has different StartSeqNo should start with different control job.
        // If lots are included in Bonding Group, lots in Bonding Group is started at the same time and shouldn't have different StartSeqNo.
        //--------------------------------
        List<Infos.StartSeqNo> strStartSeqNoForBondinGroup = new ArrayList<>();
        int nLenBG = 0;
        for(int i =0; i<prodLotMapSize; i++) {
            int lotIDSize = CimArrayUtils.getSize(strProdLotMap.get(i).getEqpMonitorLotIDs());
            for(int j =0; j<lotIDSize; j++) {
                Boolean bBondingGroupFoundFlag = false;
                String bondingGroupIDGetDR = this.lotBondingGroupIDGetDR(objCommon, strProdLotMap.get(i).getEqpMonitorLotIDs().get(j));
                if (CimStringUtils.isEmpty(bondingGroupIDGetDR)) {
                    continue;
                } else {
                    Outputs.ObjBondingGroupInfoGetDROut objBondingGroupInfoGetDROut = bondingGroupMethod.bondingGroupInfoGetDR(objCommon, bondingGroupIDGetDR, false);
                    if(!CimObjectUtils.equals(objBondingGroupInfoGetDROut.getBondingGroupInfo().getTargetEquipmentID(), equipmentID)) {
                        log.info("Bonding Group for other equipment. No need to check Bonding Group VS StartSeqNo for this lot.");
                        continue;
                    }
                    for (int x = 0; x<nLenBG; x++ ) {
                        if (CimObjectUtils.equals(strStartSeqNoForBondinGroup.get(x).getKey(), objBondingGroupInfoGetDROut.getBondingGroupInfo().getBondingGroupID())) {
                            if ( strStartSeqNoForBondinGroup.get(x).getStartSeqNo() != strProdLotMap.get(i).getStrEqpMonitorProductInfo().getStartSeqNo()) {
                                Validations.check(retCodeConfig.getMismatchEqpMonitorStartSeq());
                            }
                            bBondingGroupFoundFlag = true;
                            break;
                        }
                    }
                    if (CimBooleanUtils.isFalse(bBondingGroupFoundFlag)) {
                        //Add the combination of BondingGroup ID and startSeqNo to strStartSeqNo
                        strStartSeqNoForBondinGroup.get(nLenBG).setKey(objBondingGroupInfoGetDROut.getBondingGroupInfo().getBondingGroupID());
                        strStartSeqNoForBondinGroup.get(nLenBG).setStartSeqNo(lotCheckConditionForEqpMonitorLotReserveIn.getStrProductLotMap().get(i).getStrEqpMonitorProductInfo().getStartSeqNo());
                        nLenBG++;
                    }
                }

            }
        }

        //Used for keeping cassette-lot relation
        List<Infos.StartCassette> tmpStartCassette = new ArrayList<>();
        if(CimBooleanUtils.isFalse(bKitFlag)) {
            log.info("bKitFlag == FALSE ");
            //--------------------------------
            // Check Condition for Logical Recipe / Machine Recipe
            // Reuse logic in lot_CheckConditionForOperation()
            //--------------------------------
            for(int i = 0; i< CimArrayUtils.getSize(lotCheckConditionForEqpMonitorLotReserveIn.getStrProductLotMap()); i++) {
                for(int j = 0; j< CimArrayUtils.getSize(lotCheckConditionForEqpMonitorLotReserveIn.getStrProductLotMap().get(i).getEqpMonitorLotIDs()); j++) {
                    log.info("loop strLot_CheckConditionForEqpMonitorLotReserve_in.strProductLotMap.eqpMonitorLotIDs : {}",j);
                    //Set cassette ID and lot ID to tmpStartCassette
                    ObjectIdentifier strLotCassetteGetOut = this.lotCassetteGet(objCommon, strProdLotMap.get(i).getEqpMonitorLotIDs().get(j));

                    int nLenST = CimArrayUtils.getSize(tmpStartCassette);
                    Boolean bFoundST = false;
                    for(int x = 0; x<nLenST; x++) {
                        if( CimObjectUtils.equals(strLotCassetteGetOut,tmpStartCassette.get(x).getCassetteID())) {
                            log.info( "Found same cassetteID");
                            int nLenLots = CimArrayUtils.getSize(tmpStartCassette.get(x).getLotInCassetteList());
                            Infos.StartCassette startCassette = new Infos.StartCassette();
                            List<Infos.LotInCassette> lotInCassettes = new ArrayList<>();
                            Infos.LotInCassette lotInCassette = new Infos.LotInCassette();
                            lotInCassette.setLotID(lotCheckConditionForEqpMonitorLotReserveIn.getStrProductLotMap().get(i).getEqpMonitorLotIDs().get(j));
                            lotInCassettes.add(lotInCassette);
                            startCassette.setLotInCassetteList(lotInCassettes);
                            tmpStartCassette.add(startCassette);
                            bFoundST = true;
                            break;
                        }
                    }
                    if(CimBooleanUtils.isFalse(bFoundST)) {
                        log.info("new cassetteID");
                        Infos.StartCassette startCassette = new Infos.StartCassette();
                        List<Infos.LotInCassette> lotInCassettes = new ArrayList<>();
                        Infos.LotInCassette lotInCassette = new Infos.LotInCassette();
                        lotInCassette.setLotID(lotCheckConditionForEqpMonitorLotReserveIn.getStrProductLotMap().get(i).getEqpMonitorLotIDs().get(j));
                        lotInCassettes.add(lotInCassette);
                        startCassette.setLotInCassetteList(lotInCassettes);
                        startCassette.setCassetteID(strLotCassetteGetOut);
                        tmpStartCassette.add(startCassette);
                    }
                }
            }
            int startCastSize = CimArrayUtils.getSize(tmpStartCassette);
            for(int i = 0; i<startCastSize;i++) {
                int lotIncastSize = CimArrayUtils.getSize(tmpStartCassette.get(i).getLotInCassetteList());
                for(int j = 0; j<lotIncastSize; j++) {
                    Boolean skipFlag = false;
                    Outputs.ObjLotEffectiveFPCInfoGetOut lotEffectiveFPCInfoGet = this.lotEffectiveFPCInfoGet(objCommon, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEINFO,
                            equipmentID, tmpStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                    CimLot aLot = baseCoreFactory.getBO(CimLot.class, tmpStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                    /*------------------------------------------*/
                    /*    Get / Set Lot Type and Sub Lot Type   */
                    /*------------------------------------------*/
                    Infos.LotInCassette lotInCassette = tmpStartCassette.get(i).getLotInCassetteList().get(j);
                    lotInCassette.setLotType(aLot.getLotType());
                    lotInCassette.setSubLotType(aLot.getSubLotType());

                    /*===== get PO object =====*/
                    com.fa.cim.newcore.bo.pd.CimProcessOperation aPosPO = aLot.getProcessOperation();
                    Validations.check(null == aPosPO, retCodeConfig.getNotFoundProcessOperation(), objCommon.getTransactionID());

                    /*===== get ProdSpec object =====*/
                    com.fa.cim.newcore.bo.prodspec.CimProductSpecification aPosProdSpec = aLot.getProductSpecification();
                    Validations.check(null == aPosProdSpec, retCodeConfig.getNotFoundProductSpec(), objCommon.getTransactionID());

                    /*===== get LogicalRecipe object and set objectIdentifier =====*/
                    com.fa.cim.newcore.bo.recipe.CimLogicalRecipe aLogicalRecipe = aPosPO.findLogicalRecipeFor(aPosProdSpec);
                    Validations.check(null == aLogicalRecipe, retCodeConfig.getNotFoundLogicalRecipe(), objCommon.getTransactionID());
                    Infos.StartRecipe startRecipe = new Infos.StartRecipe();
                    startRecipe.setLogicalRecipeID(new ObjectIdentifier(aLogicalRecipe.getIdentifier(), aLogicalRecipe.getPrimaryKey()));

                    /*===== get / set MachineRecipe object and set objectIdentifier =====*/
                    com.fa.cim.newcore.bo.recipe.CimMachineRecipe aMachineRecipe;
                    int searchCondition = 0;
                    String searchConditionVar = StandardProperties.OM_CONSTRAINT_CHK_WITH_SEARCH.getValue();
                    if( null  != searchConditionVar ) {
                        log.info("OM_CONSTRAINT_CHK_WITH_SEARCH is not empty.");
                        searchCondition = Integer.valueOf(searchConditionVar);
                    }
                    if( searchCondition == 1 ) {
                        log.info("OM_CONSTRAINT_CHK_WITH_SEARCH is 1");
                        aMachineRecipe = aLogicalRecipe.findMachineRecipeFor(aLot, aMachine);
                    } else {
                        log.info("OM_CONSTRAINT_CHK_WITH_SEARCH is not 1");
                        aMachineRecipe = aLogicalRecipe.findMachineRecipeForSubLotType(aMachine, lotInCassette.getSubLotType());
                    }

                    if ( null == aMachineRecipe) {
                        log.info("aMachineRecipe is nil.");
                        Validations.check(!lotEffectiveFPCInfoGet.isMachineRecipeActionRequiredFlag(), retCodeConfig.getNotFoundMachineRecipe());

                        log.info("", "MachineRecipe is overwritten by DOC");
                        skipFlag = true;
                    }

                    if(!skipFlag) {
                        log.info("skipFlag == FALSE");
                        startRecipe.setMachineRecipeID(new ObjectIdentifier(aMachineRecipe.getIdentifier(), aMachineRecipe.getPrimaryKey()));
                    }
                    lotInCassette.setStartRecipe(startRecipe);

                    /*--------------------------------------------------------------*/
                    /*   Check if the recipe is available on Eqp.                   */
                    /*   This check is skipped when recipe is overwritten by DOC.   */
                    /*--------------------------------------------------------------*/
                    String tmpFPCAdoptFlagVar = StandardProperties.OM_DOC_ENABLE_FLAG.getValue();
                    int tmpFPCAdoptFlag = Integer.valueOf(tmpFPCAdoptFlagVar);
                    Boolean bFPCFlag = false;
                    if( 1 == tmpFPCAdoptFlag ) {
                        log.info( "Use DOC Infomation.");
                        Outputs.ObjLotEffectiveFPCInfoGetOut strLotEffectiveFPCInfoGetOut = this.lotEffectiveFPCInfoGet(objCommon, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEINFO, equipmentID,
                                lotInCassette.getLotID());

                        if (CimBooleanUtils.isTrue(strLotEffectiveFPCInfoGetOut.isMachineRecipeActionRequiredFlag())) {
                            log.info("TRUE == strLot_CheckConditionForEqpMonitor_out.machineRecipeActionRequired");
                            bFPCFlag = true;
                        }
                    }
                    if (CimBooleanUtils.isFalse(bFPCFlag)) {
                        log.info("bFPCFlag == FALSE");
                        CimMachineRecipe aMachineRecipe1 = baseCoreFactory.getBO(CimMachineRecipe.class, startRecipe.getMachineRecipeID());
                        Validations.check(null == aMachineRecipe1, retCodeConfig.getNotFoundMachineRecipe(), objCommon.getTransactionID());

                        Boolean bUsedFlag = false;
                        bUsedFlag = aMachineRecipe1.isUsedBy(aMachine);
                        Validations.check(CimBooleanUtils.isFalse(bUsedFlag),  retCodeConfig.getInvalidRecipeForEqp());
                    }

                    /*------------------------------------------*/
                    /*   Check condition for recipe / chamber   */
                    /*------------------------------------------*/
                    String tmpChamberCheckPolicyVar = StandardProperties.OM_CHAMBER_CHK_RULE.getValue();
                    int tmpChamberCheckPolicy = null == tmpChamberCheckPolicyVar ? 0 : Integer.valueOf(tmpChamberCheckPolicyVar);
                    if ( 1 == tmpChamberCheckPolicy ) {
                        log.info("Check condition for recipe/chamber.");
                        // Check chamber condition for logical recipe and recipe
                        //  - Chamber status
                        //  - Conditional available

                        Inputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn = new Inputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn();
                        strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setLotID(lotInCassette.getLotID());
                        strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setEquipmentID(equipmentID);
                        strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setLogicalRecipeID(lotInCassette.getStartRecipe().getLogicalRecipeID());
                        strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setMachineRecipeID(lotInCassette.getStartRecipe().getMachineRecipeID());
                        strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn.setInhibitCheckFlag(false);
                        // step10 - logicalRecipe_candidateChamberInfo_GetByMachineRecipe
                        Outputs.ObjLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut strLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut = logicalRecipeMethod.logicalRecipeCandidateChamberInfoGetByMachineRecipe(objCommon, strLogicalRecipeCandidateChamberInfoGetByMachineRecipeIn);
                        if (strLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut.isMultiChamberFlag()) {
                            // Multi chamber case
                            log.info( "Multi chamber case.");

                                // machine recipe is defined in logical recipe, but there is no available chamber
                                Validations.check(strLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut.isRecipeDefinedFlag()
                                        &&    0 == CimArrayUtils.getSize(strLogicalRecipeCandidateChamberInfoGetByMachineRecipeOut.getCandidateChamberList()) ,
                                        retCodeConfig.getChamberNotAvailableForLot());

                                // Following 2 cases
                                // 1. Machine recipe isn't defined in logical recipe.
                                // 2. Machine recipe is defined in logical recipe and chambers are found which meets following condition
                                //     - Chamber Status
                                //     - Conditional available
                                log.info("recipe/chamber check OK");

                        } else {
                            // Not multi chamber
                            log.info("Not multi chamber.");
                        }
                    }
                }
            }

            if ( CimStringUtils.equals(multiRecipeCapability, BizConstant.SP_EQP_MULTIRECIPECAPABILITY_BATCH)) {
                log.info("Equipment multiRecipeCapability is Batch." );
                for (int i = 0; i< CimArrayUtils.getSize(tmpStartCassette); i++) {
                    /*------------------*/
                    /*   Check Recipe   */
                    /*------------------*/
                    log.info( "Check recipe conbination for Batch equipment..." );
                    String baseLogicalRecipeID = null;
                    String baseMachineRecipeID = null;

                    Boolean bFirstFlag = true;
                    Boolean baseRecipeSetFlag = true;
                    for (int j = 0; j< CimArrayUtils.getSize(tmpStartCassette.get(i).getLotInCassetteList()); j++) {
                        Infos.LotInCassette lotInCassette = tmpStartCassette.get(i).getLotInCassetteList().get(j);
                        if ( bFirstFlag ) {
                            log.info("baseRecipeSetFlag == FALSE" );
                            baseLogicalRecipeID = ObjectIdentifier.fetchValue(lotInCassette.getStartRecipe().getLogicalRecipeID());
                            baseMachineRecipeID = ObjectIdentifier.fetchValue(lotInCassette.getStartRecipe().getMachineRecipeID());
                            log.info("baseLogicalRecipeID ： {}", baseLogicalRecipeID);
                            log.info("baseMachineRecipeID ： {}", baseMachineRecipeID);
                            baseRecipeSetFlag = false;
                            bFirstFlag = false;
                        } else {
                            log.info("baseRecipeSetFlag != FALSE" );
                            log.info("Check Recipe");
                            log.info("baseLogicalRecipeID : {}", baseLogicalRecipeID);
                            log.info("baseMachineRecipeID : {}", baseMachineRecipeID);
                            log.info("logicalRecipeID : {}", lotInCassette.getStartRecipe().getLogicalRecipeID());
                            log.info("machineRecipeID : {}", lotInCassette.getStartRecipe().getMachineRecipeID());

                            Validations.check(!ObjectIdentifier.equalsWithValue(lotInCassette.getStartRecipe().getLogicalRecipeID(), baseLogicalRecipeID) &&
                                            ObjectIdentifier.equalsWithValue(lotInCassette.getStartRecipe().getMachineRecipeID(), baseMachineRecipeID),
                                    retCodeConfig.getInvalidRecipeForEqp());

                                log.info("logicalRecipe / MachineRecipe is same as baseRecipe" );

                        }
                    }
                }
            }

            //--------------------------------//
            //Get and Check Entity Inhibition //
            //--------------------------------//
            equipmentMethod.equipmentCheckInhibitForLotWithMachineRecipe(objCommon, equipmentID, lotIDs, tmpStartCassette );

            //--------------------------------//
            //Durable condition check
            //--------------------------------//
            log.info("Durable condition -  checkLevel is EqpMonNoKit");
            for(int i = 0; i< CimArrayUtils.getSize(tmpStartCassette); i++) {
                Outputs.ObjProcessDurableCheckConditionForOperationStartOut objProcessDurableCheckConditionForOpeStartOut
                        = processMethod.processDurableCheckConditionForOpeStart(objCommon, equipmentID,
                        tmpStartCassette.get(i).getLotInCassetteList().get(0).getStartRecipe().getLogicalRecipeID(),
                        tmpStartCassette.get(i).getLotInCassetteList().get(0).getStartRecipe().getMachineRecipeID(),
                        tmpStartCassette.get(i).getLotInCassetteList().get(0).getLotID());
            }

        }
    }

   /**
    * description:
    * change history:
    * date             defect#             person             comments
    * ---------------------------------------------------------------------------------------------------------------------
    * 2019/7/15                               Neyo                create file
    *
    * @author: Neyo
    * @date: 2019/7/15 21:33
    * @copyright: 2019, FA Software (Shanghai) Co., Ltd. All Rights Reserved.
    */
    @Override
    public List<Infos.LotHoldEffectList> lotHoldRecordEffectMonitorIssueForPostProc(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        //Initialize
        List<Infos.LotHoldEffectList> out = new ArrayList<>();
        int lotHoldCount = 0;

        // Check Monitor Flag
        //Get Lot object refernce
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);

        //Get Previous PO from Lot
        log.info("Get PO from the previous Operation.");

        // 当EDC check 失败后，会被Hold在当前站点，不会做 process move 操作，因此需要判断，这个添加这个 Flag 的逻辑判断
        final boolean checkConditionForPO = lotMethod.lotCheckConditionForPO(objCommon, lotID);
        CimProcessOperation aPosProcessOperation;
        if (checkConditionForPO) {
            aPosProcessOperation = aLot.getProcessOperation();
        } else {
            aPosProcessOperation = aLot.getPreviousProcessOperation();
        }

        Validations.check(CimObjectUtils.isEmpty(aPosProcessOperation),retCodeConfig.getNotFoundOperation() );


        //Get Logical Recipe from Revious PO
        CimLogicalRecipe aLogicalRecipe = null;
        aLogicalRecipe = aPosProcessOperation.getAssignedLogicalRecipe();
        Validations.check(CimObjectUtils.isEmpty(aLogicalRecipe), retCodeConfig.getNotFoundLogicalRecipe());


        //Get Monitor Hold Required Flag from logical Recipe
        Boolean flag = aLogicalRecipe.isMonitorHoldRequired();
        if (CimBooleanUtils.isTrue(flag)){
            log.info("aLogicalRecipe->isMonitorHoldRequired()");
            List<CimMonitorGroup>  aMonitorGroupSequence = null;
            aMonitorGroupSequence = aLot.allMonitorGroups();
            int pmgLen = CimArrayUtils.getSize(aMonitorGroupSequence);
            if (pmgLen > 0){
                int maxHoldCnt = pmgLen + CimArrayUtils.getSize(out);
                Boolean bLotHeld = false;
                for (int m = 0; m < pmgLen; m++) {
                    //get Monitoring Lotm
                    CimLot aMonitorLot = aMonitorGroupSequence.get(m).getMonitorLot();
                    Validations.check(CimObjectUtils.isEmpty(aMonitorLot),retCodeConfig.getNotFoundMonitorLot());

                    String monitorLotID = aMonitorLot.getIdentifier();

                    //Get Control Job ID from Previous PO
                    //PPT_DISPLAY_RESPONSE_TIME(); ??
                    //CimControlJob aPosControlJob = aPosProcessOperation.getAssignedControlJob();
                    // bug -2424 monitor lot can not be hold
                    String strControlJobID = aPosProcessOperation.getAssignedControlJobID();
                    //【step-1 】lot_previousOperationInfo_Get__101
                    ObjectIdentifier in = ObjectIdentifier.buildWithValue(monitorLotID);
                    Outputs.ObjLotPreviousOperationInfoGetOut lotPreviousOperationInfoGetRetCode = this.lotPreviousOperationInfoGet(objCommon,in);

                    /* Check ContorolJobId : Monitored Lot vs Related Lot */
                    if (CimStringUtils.equals(strControlJobID,lotPreviousOperationInfoGetRetCode.getControlJobID().getValue())){
                        log.info("(MonitoredLot control Job ID) == (Related Lot control Job ID)");
                        Infos.LotHoldEffectList lotHoldEffectList = new Infos.LotHoldEffectList();
                        out.add(lotHoldCount,lotHoldEffectList);
                        lotHoldEffectList.setLotID(lotID);
                        lotHoldEffectList.setHoldType(BizConstant.SP_HOLDTYPE_WAITINGMONITORRESULTHOLD);
                        lotHoldEffectList.setReasonCodeID(ObjectIdentifier.buildWithValue(BizConstant.SP_REASON_WAITINGMONITORRESULTHOLD));
                        lotHoldEffectList.setUserID(objCommon.getUser().getUserID());
                        lotHoldEffectList.setResponsibleOperationMark(aMonitorLot.isPendingMoveNext() ?
                                BizConstant.SP_RESPONSIBLEOPERATION_CURRENT : BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                        lotHoldEffectList.setRelatedLotID(ObjectIdentifier.buildWithValue(monitorLotID));
                        lotHoldCount ++;
                        bLotHeld = true;
                        break;
                    }
                }
                String envMoniWaitHoldFlag = StandardProperties.OM_PROC_MON_WAIT_HOLD_LOGIC.getValue();
                if (CimStringUtils.equals(envMoniWaitHoldFlag,"1") && CimBooleanUtils.isFalse(bLotHeld)){
                    Boolean bFoundMonLot = false;
                    for (int monCnt = 0; monCnt < pmgLen; monCnt++) {
                        CimLot aMonitorLot = aMonitorGroupSequence.get(monCnt).getMonitorLot();
                        //Get ProductID of representative Lot.
                        log.info("Get ProductID of representative Lot");
                        CimProductSpecification aPosProductSpec = aMonitorLot.getProductSpecification();
                        Validations.check(CimObjectUtils.isEmpty(aPosProductSpec), retCodeConfig.getNotFoundProductSpec());

                        ObjectIdentifier representativeProdID = new ObjectIdentifier();
                        if (!CimObjectUtils.isEmpty(aPosProductSpec)){
                            representativeProdID = ObjectIdentifier.build(aPosProductSpec.getIdentifier(), aPosProductSpec.getPrimaryKey());
                        }else {
                            representativeProdID = ObjectIdentifier.build("", "");
                        }
                        // Get ProductID of LogicalRecipe.
                        log.info("Get ProductID of LogicalRecipe");
                        CimProductSpecification aMonitorProduct = aLogicalRecipe.getMonitorProduct();
                        Validations.check(CimObjectUtils.isEmpty(aMonitorProduct), retCodeConfig.getNotFoundProductSpec());

                        ObjectIdentifier monitorProdID = new ObjectIdentifier();
                        if (!CimObjectUtils.isEmpty(aMonitorProduct)){
                            monitorProdID = ObjectIdentifier.build(aMonitorProduct.getIdentifier(), aMonitorProduct.getPrimaryKey());
                        }else {
                            monitorProdID = ObjectIdentifier.build("", "");
                        }
                        if (CimObjectUtils.equals(representativeProdID,monitorProdID)){
                            // Hold lot with "Monitor Waiting Hold" reason code and set monitor group representative LotID in the hold record as a related lot.
                            // When lot has multiple monitor groups with different lot of the same product ID, Lot will be held with 1st found MonitorLotID.
                            Infos.LotHoldEffectList lotHoldEffectList = new Infos.LotHoldEffectList();
                            out.add(lotHoldCount,lotHoldEffectList);
                            lotHoldEffectList.setLotID(lotID);
                            lotHoldEffectList.setHoldType(BizConstant.SP_HOLDTYPE_WAITINGMONITORRESULTHOLD);
                            lotHoldEffectList.setReasonCodeID(ObjectIdentifier.buildWithValue(BizConstant.SP_REASON_WAITINGMONITORRESULTHOLD));
                            lotHoldEffectList.setUserID(objCommon.getUser().getUserID());
                            lotHoldEffectList.setResponsibleOperationMark(aMonitorLot.isPendingMoveNext() ?
                                    BizConstant.SP_RESPONSIBLEOPERATION_CURRENT : BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                            if (!CimObjectUtils.isEmpty(aMonitorLot)){
                                lotHoldEffectList.setRelatedLotID(ObjectIdentifier.build(aMonitorLot.getIdentifier(), aMonitorLot.getPrimaryKey()));
                            }else {
                                lotHoldEffectList.setRelatedLotID(ObjectIdentifier.build("", ""));
                            }
                            lotHoldCount++;
                            bFoundMonLot = true;
                            break;
                        }
                    }
                    //Hold lot with "Monitor Waiting Hold" reason code and set 1st monitor group representative lot ID in the hold record as a related lot.
                    if (CimBooleanUtils.isFalse(bFoundMonLot)){
                        CimLot aMonitorLot = aMonitorGroupSequence.get(0).getMonitorLot();
                        Infos.LotHoldEffectList lotHoldEffectList = new Infos.LotHoldEffectList();
                        out.add(lotHoldCount,lotHoldEffectList);
                        lotHoldEffectList.setLotID(lotID);
                        lotHoldEffectList.setHoldType(BizConstant.SP_HOLDTYPE_WAITINGMONITORRESULTHOLD);
                        lotHoldEffectList.setReasonCodeID(ObjectIdentifier.buildWithValue(BizConstant.SP_REASON_WAITINGMONITORRESULTHOLD));
                        lotHoldEffectList.setUserID(objCommon.getUser().getUserID());
                        lotHoldEffectList.setResponsibleOperationMark(aMonitorLot.isPendingMoveNext() ?
                                BizConstant.SP_RESPONSIBLEOPERATION_CURRENT : BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                        if (!CimObjectUtils.isEmpty(aMonitorLot)){
                            lotHoldEffectList.setRelatedLotID(ObjectIdentifier.build(aMonitorLot.getIdentifier(), aMonitorLot.getPrimaryKey()));
                        }else {
                            lotHoldEffectList.setRelatedLotID(ObjectIdentifier.build("", ""));
                        }
                        lotHoldCount ++;
                    }
                    // Even though there is the setting of Monitor Waiting Hold in Lot's oper comp operation (in Logical Recipe setting),
                    // when lot does not have monitor group information, lot won't be held.
                    // (Same as current system behavior.)
                }
            }else {
                log.info("PMGLen <= 0");
            }
        }else {
            log.info("Flag != TRUE");
        }
        return out;
    }

    /**
     * description:
     * change history:
     * date             defect#             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * 2019/7/15                               Neyo                create file
     *
     * @author: Neyo
     * @date: 2019/7/15 22:26
     * @copyright: 2019, FA Software (Shanghai) Co., Ltd. All Rights Reserved.
     */
    @Override
    public Outputs.ObjLotPreviousOperationInfoGetOut lotPreviousOperationInfoGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {

        //init
        Outputs.ObjLotPreviousOperationInfoGetOut out  = new Outputs.ObjLotPreviousOperationInfoGetOut();

        //Get Lot Object Reference
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        // Get Previous PO from Lot.
        log.info("Get PO from the previous Operation.");
        //Bug-2638 【千岛QA】使用waiting monitor lbank 的时候做process monitor时product lot未被hold住,
        // 此时的lot为lotStarti新生成的lotId并且在初始站点,无法获取到上一个站点信息
        CimProcessOperation aPosProcessOperation = Optional.ofNullable(aLot.getResponsibleProcessOperation()).orElseGet(aLot::getProcessOperation);

        Validations.check(CimObjectUtils.isEmpty(aPosProcessOperation), new OmCode(retCodeConfig.getNotFoundOperation(), ""));
        // Get Main PD from Previous PO
        // PPT_DISPLAY_RESPONSE_TIME();??
        CimProcessDefinition aMainProcessDefinition = aPosProcessOperation.getMainProcessDefinition();
        // Get PD from Previous PO
        CimProcessDefinition aProcessDefinition = aPosProcessOperation.getProcessDefinition();
        // Get Operation Number from Previous PO
        String strOperationNumber = aPosProcessOperation.getOperationNumber();
        // Get Assigned Control Job from Previous PO
        String controlJobID = aPosProcessOperation.getAssignedControlJobID();
        out.setControlJobID(new ObjectIdentifier(controlJobID));
        // Set output structure
        if (!CimObjectUtils.isEmpty(aMainProcessDefinition)){
            out.setRouteID(ObjectIdentifier.build(aMainProcessDefinition.getIdentifier(), aMainProcessDefinition.getPrimaryKey()));
        }
        if (!CimObjectUtils.isEmpty(aProcessDefinition)){
            out.setOperationID(ObjectIdentifier.build(aProcessDefinition.getIdentifier(), aProcessDefinition.getPrimaryKey()));
        }
        out.setOperationNumber(strOperationNumber);
        //PassCount
        Long operationPassL = aPosProcessOperation.getPassCount();
        out.setOperationPass(CimObjectUtils.toString(operationPassL));
        return out;
    }

	/**
     * description:
     * change history:
     * date             defect#             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * 2019/7/9                               Neyo                create file
     *
     * @author: Neyo
     * @date: 2019/7/9 17:02
     * @copyright: 2019, FA Software (Shanghai) Co., Ltd. All Rights Reserved.
     */
    @Override
    public Outputs.ObjLotProductIDGetOut lotProductIDGet(Infos.ObjCommon objCommonIn, ObjectIdentifier lotID) {
        //Initialize
        Outputs.ObjLotProductIDGetOut out = new Outputs.ObjLotProductIDGetOut();

        //Get Object PosLot_var from lotID
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(aLot), retCodeConfig.getNotFoundLot());

        // Get Object ProductSpecification_var
        com.fa.cim.newcore.bo.prodspec.CimProductSpecification aLotProdSpec = aLot.getProductSpecification();
        Validations.check(CimObjectUtils.isEmpty(aLotProdSpec), retCodeConfig.getNotFoundProductSpec());

        //Get ProductID
        ObjectIdentifier productID = new ObjectIdentifier();
        productID = ObjectIdentifier.buildWithValue(aLotProdSpec.getIdentifier());

        //Set OutPut buffer
        out.setProductID(productID);
        return out;
    }

    @Override
    public void lotProcessOperationDataTransferInProcessing(Infos.ObjCommon objCommon, ObjectIdentifier sourceLotID, ObjectIdentifier destLotID){
        // Get lot objects and PO objects for both source lot and destination lot
        CimLot aSourceLot = baseCoreFactory.getBO(CimLot.class, sourceLotID);
        Validations.check(CimObjectUtils.isEmpty(aSourceLot), retCodeConfig.getNotFoundLot());
        // Get lot process operation
        com.fa.cim.newcore.bo.pd.CimProcessOperation aSourcePosPO = aSourceLot.getProcessOperation();
        Validations.check(CimObjectUtils.isEmpty(aSourcePosPO), retCodeConfig.getNotFoundProcessOperation());

        CimLot aDestLot = baseCoreFactory.getBO(CimLot.class, destLotID);
        Validations.check(CimObjectUtils.isEmpty(aDestLot), retCodeConfig.getNotFoundLot());
        com.fa.cim.newcore.bo.pd.CimProcessOperation aDestPosPO = aDestLot.getProcessOperation();
        Validations.check(CimObjectUtils.isEmpty(aDestPosPO), retCodeConfig.getNotFoundProcessOperation());

        // Copy follow data from source lot to destination lot
        //  - controlJobID
        aDestLot.setControlJob(aSourceLot.getControlJob());
        // Transit PO data from parent lot to child lot by waferID if child lot is going to perform opeComp
        // Get waferID of destLot
        log.info("Step1 - lot_materials_GetWafers");
        List<Infos.LotWaferAttributes> destWaferIDs = this.lotMaterialsGetWafers(objCommon, destLotID);
        boolean destWaferFoundFlag = false;
        // a.   Wafer chamber process
        for (Infos.LotWaferAttributes lotWaferAttributes : destWaferIDs){
            // Get Wafer-Chamber Information
            ProcessDTO.ProcessResourceInfo processResourceInfo = aSourcePosPO.findAssignedProcessResourceInfo(lotWaferAttributes.getWaferID().getValue());

            if (!CimObjectUtils.isEmpty(processResourceInfo) && !CimStringUtils.isEmpty(processResourceInfo.getProcessWafer())){
                // remove information from source PO
                aSourcePosPO.removeAssignedProcessResourceInfo(lotWaferAttributes.getWaferID().getValue());

                // add informaiton to dest PO
                aDestPosPO.addAssignedProcessResourceInfo(processResourceInfo);
            }
        }
        // b.   Inside Chamber wafer position
        List<ProcessDTO.ProcessResourcePositionInfo> processResourcePositionInfoList = aSourcePosPO.allAssignedWaferPositionInProcessResourceInfo();
        if(!CimObjectUtils.isEmpty(processResourcePositionInfoList)){
            for (ProcessDTO.ProcessResourcePositionInfo processResourcePositionInfo : processResourcePositionInfoList){
                List<ProcessDTO.WaferPositionInProcessResourceInfo> waferPositionInProcessResourceList = processResourcePositionInfo.getWaferPositionInProcessResourceInfoList();
                ObjectIdentifier processResourceID = processResourcePositionInfo.getProcessResourceID();
                ProcessDTO.ProcessResourcePositionInfo tmpProcessResourcePositionInfo = new ProcessDTO.ProcessResourcePositionInfo();
                tmpProcessResourcePositionInfo.setProcessResourceID(processResourceID);
                List<ProcessDTO.WaferPositionInProcessResourceInfo> tmpWaferPositionInProcessResourceInfoList = new ArrayList<>();
                tmpProcessResourcePositionInfo.setWaferPositionInProcessResourceInfoList(tmpWaferPositionInProcessResourceInfoList);
                ProcessDTO.ProcessResourcePositionInfo tmpSourceProcessResourcePositionInfo = new ProcessDTO.ProcessResourcePositionInfo();
                tmpSourceProcessResourcePositionInfo.setProcessResourceID(processResourceID);
                List<ProcessDTO.WaferPositionInProcessResourceInfo> tmpSourceWaferPositionInProcessResourceInfoList = new ArrayList<>();
                tmpSourceProcessResourcePositionInfo.setWaferPositionInProcessResourceInfoList(tmpSourceWaferPositionInProcessResourceInfoList);
                for (ProcessDTO.WaferPositionInProcessResourceInfo waferPositionInProcessResourceInfo : waferPositionInProcessResourceList){
                    destWaferFoundFlag = false;
                    for (Infos.LotWaferAttributes lotWaferAttributes : destWaferIDs){
                        if (ObjectIdentifier.equalsWithValue(lotWaferAttributes.getWaferID(), waferPositionInProcessResourceInfo.getWaferID())){
                            // found destination waferID
                            destWaferFoundFlag = true;
                            // set wafer to destPO
                            ProcessDTO.WaferPositionInProcessResourceInfo tmpWaferPositionInProcessResourceInfo = new ProcessDTO.WaferPositionInProcessResourceInfo();
                            tmpWaferPositionInProcessResourceInfo.setLotID(waferPositionInProcessResourceInfo.getLotID());
                            tmpWaferPositionInProcessResourceInfo.setWaferID(waferPositionInProcessResourceInfo.getWaferID());
                            tmpWaferPositionInProcessResourceInfo.setPosition(waferPositionInProcessResourceInfo.getPosition());
                            tmpWaferPositionInProcessResourceInfo.setProcessReportedTimeStamp(waferPositionInProcessResourceInfo.getProcessReportedTimeStamp());
                            tmpWaferPositionInProcessResourceInfoList.add(tmpWaferPositionInProcessResourceInfo);
                            break;
                        }
                    }
                    if (!destWaferFoundFlag){
                        // this wafer is not destWafer. so keep it in source
                        ProcessDTO.WaferPositionInProcessResourceInfo tmpSourceWaferPositionInProcessResourceInfo = new ProcessDTO.WaferPositionInProcessResourceInfo();
                        tmpSourceWaferPositionInProcessResourceInfoList.add(tmpSourceWaferPositionInProcessResourceInfo);
                        tmpSourceWaferPositionInProcessResourceInfo.setLotID(waferPositionInProcessResourceInfo.getLotID());
                        tmpSourceWaferPositionInProcessResourceInfo.setWaferID(waferPositionInProcessResourceInfo.getWaferID());
                        tmpSourceWaferPositionInProcessResourceInfo.setPosition(waferPositionInProcessResourceInfo.getPosition());
                        tmpSourceWaferPositionInProcessResourceInfo.setProcessReportedTimeStamp(waferPositionInProcessResourceInfo.getProcessReportedTimeStamp());
                    }
                }
                if(!CimObjectUtils.isEmpty(tmpProcessResourcePositionInfo.getWaferPositionInProcessResourceInfoList())){
                    // add this posProcessResourcePositionInfo to destPO
                    aDestPosPO.addAssignedWaferPositionInProcessResourceInfo(tmpProcessResourcePositionInfo);
                    // change the posProcessResourcePositionInfo of sourcePO
                    if(!CimObjectUtils.isEmpty(tmpSourceProcessResourcePositionInfo.getWaferPositionInProcessResourceInfoList())){
                        processResourcePositionInfo = tmpSourceProcessResourcePositionInfo;
                    } else {
                        // no wafer goes through this resource
                        aSourcePosPO.removeAssignedWaferPositionInProcessResourceInfo(processResourceID.getValue());
                    }
                }
            }
        }
        // c.   Processed wafers (Sampling wafers)
        List<ProcessDTO.PosProcessWafer> processWaferList = aSourcePosPO.getProcessWafers();
        List<ProcessDTO.PosProcessWafer> destProcessWaferList = null;
        List<ProcessDTO.PosProcessWafer> sourceProcessWaferList = null;
        if (!CimObjectUtils.isEmpty(processWaferList)){
            destProcessWaferList = new ArrayList<>();
            sourceProcessWaferList = new ArrayList<>();
            for (ProcessDTO.PosProcessWafer processWafer : processWaferList){
                destWaferFoundFlag = false;
                for (Infos.LotWaferAttributes destLotWaferAttributes : destWaferIDs){
                    if (ObjectIdentifier.equalsWithValue(destLotWaferAttributes.getWaferID(), processWafer.getWaferID())){
                        // Found the wafer
                        destWaferFoundFlag = true;
                        destProcessWaferList.add(processWafer);
                        break;
                    }
                }
                if(!destWaferFoundFlag){
                    // this wafer should stay in source process wafer
                    sourceProcessWaferList.add(processWafer);
                }
            }
            aDestPosPO.setProcessWafers(destProcessWaferList);
            if (!CimObjectUtils.isEmpty(destProcessWaferList)){
                aSourcePosPO.setProcessWafers(sourceProcessWaferList);
            }
        }
        // Get actual start info
        ProcessDTO.ActualStartInformationForPO actualStartInfo = aSourcePosPO.getActualStartInfo(true);
        // d.   Assigned Recipe parameters
        List<ProcessDTO.StartRecipeParameterSetInfo> startRecipeParameterSetInfoList = actualStartInfo.getAssignedRecipeParameterSets();
        if (!CimObjectUtils.isEmpty(startRecipeParameterSetInfoList)){
            List<ProcessDTO.StartRecipeParameterSetInfo> sourceStartRecipeParameterSetInfoList = new ArrayList<>();
            List<ProcessDTO.StartRecipeParameterSetInfo>destStartRecipeParameterSetInfoList = new ArrayList<>();
            int sourceSetCount = 0;
            int destSetCount = 0;
            for (ProcessDTO.StartRecipeParameterSetInfo startRecipeParameterSetInfo : startRecipeParameterSetInfoList){
                List<ProcessDTO.ParameterApplyWaferInfo> destParameterApplyWaferInfoList = new ArrayList<>();
                List<ProcessDTO.ParameterApplyWaferInfo> sourceParameterApplyWaferInfoList = new ArrayList<>();
                ProcessDTO.StartRecipeParameterSetInfo tmpStartRecipeParameterSetInfo = new ProcessDTO.StartRecipeParameterSetInfo();
                tmpStartRecipeParameterSetInfo.setRecipeParameterList(startRecipeParameterSetInfo.getRecipeParameterList());
                tmpStartRecipeParameterSetInfo.setMachineRecipe(startRecipeParameterSetInfo.getMachineRecipe());
                tmpStartRecipeParameterSetInfo.setPhysicalRecipe(startRecipeParameterSetInfo.getPhysicalRecipe());
                for (ProcessDTO.ParameterApplyWaferInfo parameterApplyWaferInfo : startRecipeParameterSetInfo.getApplyWaferInfoList()){
                    destWaferFoundFlag = false;
                    for (Infos.LotWaferAttributes lotWaferAttributes : destWaferIDs){
                        if (ObjectIdentifier.equalsWithValue(parameterApplyWaferInfo.getWaferID(), lotWaferAttributes.getWaferID())){
                            // found the wafer
                            destWaferFoundFlag = true;
                            destParameterApplyWaferInfoList.add(parameterApplyWaferInfo);
                            break;
                        }
                    }
                    if(!destWaferFoundFlag){
                        // this wafer should stay in sourcePO
                        sourceParameterApplyWaferInfoList.add(parameterApplyWaferInfo);
                    }
                }
                if (!CimObjectUtils.isEmpty(destParameterApplyWaferInfoList)){
                    // set for dest lotPO
                    tmpStartRecipeParameterSetInfo.setSetNumber(destSetCount + 1);
                    tmpStartRecipeParameterSetInfo.setApplyWaferInfoList(destParameterApplyWaferInfoList);
                    destStartRecipeParameterSetInfoList.add(tmpStartRecipeParameterSetInfo);
                    destSetCount++;
                    // set for source lotPO
                    if (!CimObjectUtils.isEmpty(sourceParameterApplyWaferInfoList)){
                        tmpStartRecipeParameterSetInfo.setSetNumber(sourceSetCount + 1);
                        tmpStartRecipeParameterSetInfo.setApplyWaferInfoList(sourceParameterApplyWaferInfoList);
                        sourceStartRecipeParameterSetInfoList.add(tmpStartRecipeParameterSetInfo);
                        sourceSetCount++;
                    }
                }
            }
            if (destSetCount > 0){
                aDestPosPO.setAssignedRecipeParameterSets(destStartRecipeParameterSetInfoList);
                if (sourceSetCount > 0){
                    aSourcePosPO.setAssignedRecipeParameterSets(sourceStartRecipeParameterSetInfoList);
                }
            }
        }
        // e.   Collected data
        List<ProcessDTO.DataCollectionInfo> dataCollectionInfoList = actualStartInfo.getAssignedDataCollections();
        if (!CimObjectUtils.isEmpty(dataCollectionInfoList)){
            List<ProcessDTO.DataCollectionInfo> sourceDataCollectionInfoList = new ArrayList<>();
            List<ProcessDTO.DataCollectionInfo> destDataCollectionInfoList = new ArrayList<>();
            int count = 0;
            for (ProcessDTO.DataCollectionInfo dataCollectionInfo : dataCollectionInfoList){
                List<ProcessDTO.DataCollectionItemInfo> destDataCollectionItemInfoList = new ArrayList<>();
                List<ProcessDTO.DataCollectionItemInfo> sourceDataCollectionItemInfoList = new ArrayList<>();

                ProcessDTO.DataCollectionInfo tmpDataCollectionInfo = new ProcessDTO.DataCollectionInfo();
                tmpDataCollectionInfo.setDataCollectionDefinitionID(dataCollectionInfo.getDataCollectionDefinitionID());
                tmpDataCollectionInfo.setDescription(dataCollectionInfo.getDescription());
                tmpDataCollectionInfo.setDataCollectionType(dataCollectionInfo.getDataCollectionType());
                tmpDataCollectionInfo.setCalculationRequiredFlag(dataCollectionInfo.getCalculationRequiredFlag());
                tmpDataCollectionInfo.setSpecCheckRequiredFlag(dataCollectionInfo.getSpecCheckRequiredFlag());
                tmpDataCollectionInfo.setDataCollectionSpecificationID(dataCollectionInfo.getDataCollectionSpecificationID());
                tmpDataCollectionInfo.setDcSpecDescription(dataCollectionInfo.getDcSpecDescription());
                tmpDataCollectionInfo.setDcSpecs(dataCollectionInfo.getDcSpecs());
                tmpDataCollectionInfo.setPreviousDataCollectionDefinitionID(dataCollectionInfo.getPreviousDataCollectionDefinitionID());
                tmpDataCollectionInfo.setPreviousOperationID(dataCollectionInfo.getPreviousOperationID());
                tmpDataCollectionInfo.setPreviousOperationNumber(dataCollectionInfo.getPreviousOperationNumber());
                for (ProcessDTO.DataCollectionItemInfo dataCollectionItemInfo : dataCollectionInfo.getDcItems()){
                    destWaferFoundFlag = false;
                    if (CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJ, dataCollectionItemInfo.getMeasurementType())){
                        for (ProcessDTO.PosProcessWafer destProcessWafer : destProcessWaferList){
                            if(CimStringUtils.equals(dataCollectionItemInfo.getWaferPosition(), destProcessWafer.getPrcsJobPosition())){
                                // found the wafer
                                destWaferFoundFlag = true;
                                destDataCollectionItemInfoList.add(dataCollectionItemInfo);
                                break;
                            }
                        }
                    } else {
                        for(Infos.LotWaferAttributes destLotWaferAttributes : destWaferIDs){
                            if (ObjectIdentifier.equalsWithValue(dataCollectionItemInfo.getWaferID(), destLotWaferAttributes.getWaferID())){
                                // found the wafer
                                destWaferFoundFlag = true;
                                destDataCollectionItemInfoList.add(dataCollectionItemInfo);
                                break;
                            }
                        }
                    }
                    if (!destWaferFoundFlag){
                        // this wafer should stay in sourcePO
                        sourceDataCollectionItemInfoList.add(dataCollectionItemInfo);
                    }
                }
                if (!CimObjectUtils.isEmpty(destDataCollectionItemInfoList)){
                    // set for dest lotPO
                    tmpDataCollectionInfo.setDcItems(destDataCollectionItemInfoList);
                    destDataCollectionInfoList.add(tmpDataCollectionInfo);
                    // set for source lotPO
                    if (!CimObjectUtils.isEmpty(sourceDataCollectionItemInfoList)){
                        tmpDataCollectionInfo.setDcItems(sourceDataCollectionItemInfoList);
                        sourceDataCollectionInfoList.add(tmpDataCollectionInfo);
                    }
                } else {
                    if (count == 0){
                        // no raw data for dest wafer. no need to continue
                        break;
                    }
                }
                count++;
            }
            if(!CimObjectUtils.isEmpty(destDataCollectionInfoList)){
                aDestPosPO.setDataCollectionInfo(destDataCollectionInfoList);
                if (!CimObjectUtils.isEmpty(sourceDataCollectionInfoList)){
                    aSourcePosPO.setDataCollectionInfo(sourceDataCollectionInfoList);
                }
            }
        }
        // f.   Assigned reticles
        List<ProcessDTO.StartReticleInfo> startReticleInfoList = actualStartInfo.getAssignedReticles();
        aDestPosPO.setAssignedReticles(startReticleInfoList);
        // g.   Assigned fixtures
        List<ProcessDTO.StartFixtureInfo> startFixtureInfoList = actualStartInfo.getAssignedFixtures();
        aDestPosPO.setAssignedFixtures(startFixtureInfoList);
        // Copy following PO data from parent PO to child lot
        ProcessDTO.ActualStartInformationForPO destActualStartInfo = aDestPosPO.getActualStartInfo(true);
        //     a.   Assigned equipment
        ObjectIdentifier machineID = actualStartInfo.getAssignedMachine();
        destActualStartInfo.setAssignedMachine(machineID);
        //     b.   Assigned port group
        String portGroup = actualStartInfo.getAssignedPortGroup();
        destActualStartInfo.setAssignedPortGroup(portGroup);
        //     d.   Assigned recipe
        ObjectIdentifier machineRecipe = actualStartInfo.getAssignedMachineRecipe();
        destActualStartInfo.setAssignedMachineRecipe(machineRecipe);
        //     e.   Assigned physical recipe
        String physicalRecipe = actualStartInfo.getAssignedPhysicalRecipe();
        destActualStartInfo.setAssignedPhysicalRecipe(physicalRecipe);
        //     f.   Assigned recipe parameter change type
        String recipeParameterChangeType = actualStartInfo.getAssignedRecipeParameterChangeType();
        destActualStartInfo.setAssignedRecipeParameterChangeType(recipeParameterChangeType);
        //     g.   Assigned dc flag
        boolean dataCollectionFlag = actualStartInfo.getAssignedDataCollectionFlag();
        destActualStartInfo.setAssignedDataCollectionFlag(dataCollectionFlag);
        // set actual start info into destLot PO
        aDestPosPO.setActualStartInfo(destActualStartInfo);
    }

    @Override
    public Outputs.ObjLotPostProcessPreviousBranchAndReturnInfoGetDRout lotPostProcessPreviousBranchAndReturnInfoGetDR(Infos.ObjCommon objCommon,ObjectIdentifier lotID) {
        Outputs.ObjLotPostProcessPreviousBranchAndReturnInfoGetDRout getDRout = new Outputs.ObjLotPostProcessPreviousBranchAndReturnInfoGetDRout();
        /*--------------------*/
        /*   Get Lot Object   */
        /*--------------------*/
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        CimProcessOperation aPrevPosProcessOperation = aLot.getPreviousProcessOperation();
        Validations.check(aPrevPosProcessOperation == null, retCodeConfig.getNotFoundOperation());
        CimProcessDefinition previousRoute = aPrevPosProcessOperation.getMainProcessDefinition();
        Validations.check(previousRoute == null, retCodeConfig.getNotFoundMainRoute());

        String previousMainPDID = previousRoute.getIdentifier();
        String processFlowType = previousRoute.getProcessFlowType();
        if (!CimStringUtils.equals(processFlowType, BizConstant.SP_FLOWTYPE_SUB)){
            return getDRout;
        }
        CimProcessOperation aPosProcessOperation = aLot.getProcessOperation();
        Validations.check(aPosProcessOperation == null, retCodeConfig.getNotFoundOperation());

        CimProcessDefinition currentRoute = aPosProcessOperation.getMainProcessDefinition();
        Validations.check(currentRoute == null, retCodeConfig.getNotFoundMainRoute());

        String currentMainPDID = currentRoute.getIdentifier();
        // Previous route is not different from current route
        if (CimStringUtils.equals(previousMainPDID, currentMainPDID)){
            return getDRout;
        }
        //------------------------------------------
        //   Get first branch information
        //------------------------------------------
        String sql = "SELECT OMPROPE.MAIN_PROCESS_ID,\n" +
                "                        OMPROPE.MAIN_PROCESS_RKEY,\n" +
                "                        OMPROPE.OPE_NO\n" +
                "                   FROM OMLOT,\n" +
                "                        OMPRFCX,\n" +
                "                        OMPRFCX_BCKPROPESEQ,\n" +
                "                        OMPROPE\n" +
                "                  WHERE OMLOT.LOT_ID = ?\n" +
                "                    AND OMLOT.PRFCX_RKEY=OMPRFCX.ID\n" +
                "                    AND OMPRFCX.ID=OMPRFCX_BCKPROPESEQ.REFKEY\n" +
                "                    AND OMPRFCX_BCKPROPESEQ.IDX_NO = 0\n" +
                "                    AND OMPROPE.ID=OMPRFCX_BCKPROPESEQ.PROPE_RKEY";
        List<Object[]> queryResult1 = cimJpaRepository.query(sql, new Object[]{lotID.getValue()});
        if (!CimObjectUtils.isEmpty(queryResult1)){
            Object[] object = queryResult1.get(0);
            getDRout.setBranchRouteID(new ObjectIdentifier((String) object[0], (String)object[1]));
            getDRout.setBranchOperationNumber((String)object[2]);
        }
        //------------------------------------------
        //   Get first return information
        //------------------------------------------
        sql = "SELECT OMPRF.PRP_ID,\n" +
                "                        OMPRF.PRP_RKEY,\n" +
                "                        OMPRFCX_RTNSEQ.OPE_NO\n" +
                "                   FROM OMLOT,\n" +
                "                        OMPRFCX,\n" +
                "                        OMPRFCX_RTNSEQ,\n" +
                "                        OMPRF\n" +
                "                  WHERE OMLOT.LOT_ID = ?\n" +
                "                    AND OMLOT.PRFCX_RKEY=OMPRFCX.ID\n" +
                "                    AND OMPRFCX.ID=OMPRFCX_RTNSEQ.REFKEY\n" +
                "                    AND OMPRFCX_RTNSEQ.IDX_NO = 0\n" +
                "                    AND OMPRF.ID=OMPRFCX_RTNSEQ.MROUTE_PRF_RKEY";
        List<Object[]> queryResult2 = cimJpaRepository.query(sql, new Object[]{lotID.getValue()});
        if (!CimObjectUtils.isEmpty(queryResult2)){
            Object[] object = queryResult2.get(0);
            getDRout.setReturnRouteID(new ObjectIdentifier((String) object[0], (String)object[1]));
            getDRout.setReturnOperationNumber((String)object[2]);
        }
        return getDRout;
    }

    @Override
    public void lotCheckConditionForArrivalCarrierCancel(Infos.ObjCommon objCommon, ObjectIdentifier controlJobID, List<Infos.StartCassette> strStartCassette) {
       /*----------------*/
        /*                */
        /*   Initialize   */
        /*                */
        /*----------------*/
        int i, k;
        int lenCassette;
        int lenLot;

        /*-------------------------*/
        /*                         */
        /*   Check Lot Condition   */
        /*                         */
        /*-------------------------*/
        lenCassette = CimArrayUtils.getSize(strStartCassette);
        log.info(" lot_CheckConditionForArrivalCarrierCancel","Check Lot Condition  lenCassette=", lenCassette);

        for ( i=0 ; i<lenCassette; i++ ) {
            log.info(" lot_CheckConditionForArrivalCarrierCancel, loop to strNPWXferCassette.length() i--> : {}", i);

            /*-------------------------*/
            /*   Omit Empty Cassette   */
            /*-------------------------*/
            log.info(" lot_CheckConditionForArrivalCarrierCancel","Omit Empty Cassette");

            if (CimStringUtils.equals(strStartCassette.get(i).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                log.info( " lot_CheckConditionForArrivalCarrierCancel", "ObjectUtils.equalsWithValue(strStartCassette.get(i).loadPurposeType , SP_LoadPurposeType_EmptyCassette)" );
                continue;
            }



            /*-----------------------------------------*/
            /*   Get cassette associated information   */
            /*-----------------------------------------*/
            log.info( " lot_CheckConditionForArrivalCarrierCancel", "Get cassette associated information" );
            Infos.LotListInCassetteInfo  strCassette_GetLotList_out = null;
            try {
                strCassette_GetLotList_out = cassetteMethod.cassetteGetLotList(objCommon, strStartCassette.get(i).getCassetteID());
            } catch (ServiceException e) {
                if (!Validations.isEquals(retCodeConfig.getNotFoundLot(),e.getCode())){
                    throw e;
                }
            }
            lenLot = CimArrayUtils.getSize(strCassette_GetLotList_out==null?null:strCassette_GetLotList_out.getLotIDList());
            log.info(" lot_CheckConditionForArrivalCarrierCancel","strStartCassette.strLotInCassette[i].length() : {}", lenLot);
            for ( k=0 ; k<lenLot ; k++ ) {
                /*--------------------*/
                /*   Get Lot Object   */
                /*--------------------*/
                log.info( " lot_CheckConditionForArrivalCarrierCancel", "Get Lot Object" );
                CimLot aLot = baseCoreFactory.getBO(CimLot.class, strCassette_GetLotList_out.getLotIDList().get(k));
                Validations.check(null == aLot, retCodeConfig.getNotFoundLot());


                /*-------------------------------*/
                /*   Get and Check Lot's State   */
                /*-------------------------------*/
                log.info( " lot_CheckConditionForArrivalCarrierCancel", "Get and Check Lot's State" );
                String processState = aLot.getLotProcessState();

                Validations.check(CimStringUtils.equals(processState, BizConstant.SP_LOT_PROCSTATE_PROCESSING),
                        retCodeConfig.getInvalidLotProcessState(),strCassette_GetLotList_out.getLotIDList().get(k),processState);


                /*----------------------------------*/
                /*   Get controlJobID of Cassette   */
                /*----------------------------------*/
                log.info( " lot_CheckConditionForArrivalCarrierCancel", "Get controlJobID of Cassette" );
                CimControlJob aControlJob = aLot.getControlJob();
                Validations.check(null != aControlJob, new OmCode(retCodeConfig.getLotControlJobidFilled()
                        , aLot.getIdentifier(), aControlJob == null ? null : aControlJob.getIdentifier()));

            }
        }

    }

    @Override
    public Outputs.ObjLotPreviousOperationDataCollectionInformationGetOut lotPreviousOperationDataCollectionInformationGet(Infos.ObjCommon objCommon,
                                                                                                                           ObjectIdentifier equipmentID,
                                                                                                                           List<ObjectIdentifier> lotIDs) {
        Outputs.ObjLotPreviousOperationDataCollectionInformationGetOut retVal = new Outputs.ObjLotPreviousOperationDataCollectionInformationGetOut();
        /*----------------------------------------------*/
        /*   Set Return Structure                       */
        /*----------------------------------------------*/
        retVal.setEquipmentID(equipmentID);
        /*-------------------------*/
        /*   Set Lot Information   */
        /*-------------------------*/
        List<Infos.StartCassette> strStartCassette = new ArrayList<>();
        retVal.setStrStartCassette(strStartCassette);
        Infos.StartCassette startCassette = new Infos.StartCassette();
        strStartCassette.add(startCassette);
        List<Infos.LotInCassette> lotInCassettes = new ArrayList<>();
        startCassette.setLotInCassetteList(lotInCassettes);
        for (ObjectIdentifier lotID : lotIDs) {
            log.info("loop to (*startCassetteInfoSeq)[0].lotInCassetteInfo.length()");
            log.info("lotID = {}", lotID);
            Infos.LotInCassette lotInCassette = new Infos.LotInCassette();
            lotInCassettes.add(lotInCassette);
            lotInCassette.setMoveInFlag(true);
            lotInCassette.setLotID(lotID);

            Inputs.ObjLotWafersGetIn objLotWafersGetIn = new Inputs.ObjLotWafersGetIn();
            objLotWafersGetIn.setLotID(lotID);
            objLotWafersGetIn.setScrapCheckFlag(true);

            List<Infos.LotWaferInfoAttributes> lotWaferInfoAttributesList = lotWaferInfoListGetDR(objCommon, objLotWafersGetIn);
            if (CimArrayUtils.isNotEmpty(lotWaferInfoAttributesList)) {
                List<Infos.LotWafer> lotWaferList = new ArrayList<>();
                lotInCassette.setLotWaferList(lotWaferList);
                for (Infos.LotWaferInfoAttributes lotWaferInfoAttributes : lotWaferInfoAttributesList) {
                    Infos.LotWafer lotWafer = new Infos.LotWafer();
                    lotWafer.setWaferID(lotWaferInfoAttributes.getWaferID());
                    lotWafer.setSlotNumber(new Long(lotWaferInfoAttributes.getSlotNumber()));
                    lotWafer.setControlWaferFlag(lotWaferInfoAttributes.getControlWaferFlag());
                    lotWaferList.add(lotWafer);
                }

                /*------------------------------------------*/
                /*   Get ProductID from LotWaferAttributs   */
                /*------------------------------------------*/
                log.info("Set ProductID");
                lotInCassette.setProductID(lotWaferInfoAttributesList.get(0).getProductID());
            }

            /*--------------------------*/
            /*   Get Lot Related Info   */
            /*--------------------------*/
            CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);

            //--------------------------------------------------------------------------
            // Get PO from Previous Operation.
            //--------------------------------------------------------------------------
            log.info("Get PO from the previous Operation.");
            CimProcessOperation aPosPO = lot.getPreviousProcessOperation();
            Validations.check(CimObjectUtils.isEmpty(aPosPO), retCodeConfig.getNotFoundProcessOperation());
            ProcessDTO.ActualStartInformationForPO actualStartInfo = aPosPO.getActualStartInfo(true);

            /*===== set Lot Info =====*/
            lotInCassette.setLotType(lot.getLotType());
            lotInCassette.setSubLotType(lot.getSubLotType());

            /*===== set Recipe Info =====*/
            lotInCassette.setRecipeParameterChangeType(actualStartInfo.getAssignedRecipeParameterChangeType());
            Infos.StartRecipe startRecipe = new Infos.StartRecipe();
            startRecipe.setLogicalRecipeID(actualStartInfo.getAssignedLogicalRecipe());
            startRecipe.setMachineRecipeID(actualStartInfo.getAssignedMachineRecipe());
            startRecipe.setPhysicalRecipeID(actualStartInfo.getAssignedPhysicalRecipe());
            startRecipe.setDataCollectionFlag(actualStartInfo.getAssignedDataCollectionFlag());
            lotInCassette.setStartRecipe(startRecipe);

            /*===== set Reticle Info =====*/
            final List<ProcessDTO.StartReticleInfo> assignedReticlesTmp = actualStartInfo.getAssignedReticles();
            List<Infos.StartReticleInfo> startReticleList = new ArrayList<>();
            if(CimArrayUtils.isNotEmpty(assignedReticlesTmp)) {
                for (ProcessDTO.StartReticleInfo startReticleInfo : assignedReticlesTmp) {
                    Infos.StartReticleInfo reticleInfo = new Infos.StartReticleInfo();
                    startReticleList.add(reticleInfo);
                    reticleInfo.setReticleID(startReticleInfo.getReticleID());
                    reticleInfo.setSequenceNumber(startReticleInfo.getSequenceNumber());
                }
            }
            startRecipe.setStartReticleList(startReticleList);

            /*===== set Fixture Info =====*/
            final List<ProcessDTO.StartFixtureInfo> assignedFixturesTmp = actualStartInfo.getAssignedFixtures();
            List<Infos.StartFixtureInfo> startFixtureList = new ArrayList<>();
            if(CimArrayUtils.isNotEmpty(assignedFixturesTmp)) {
                for (ProcessDTO.StartFixtureInfo startFixtureInfo : assignedFixturesTmp) {
                    Infos.StartFixtureInfo fixtureInfo = new Infos.StartFixtureInfo();
                    startFixtureList.add(fixtureInfo);
                    startFixtureInfo.setFixtureID(startFixtureInfo.getFixtureID());
                    startFixtureInfo.setFixtureCategory(startFixtureInfo.getFixtureCategory());
                }
            }
            startRecipe.setStartFixtureList(startFixtureList);

            /*===== set Recipe Parameter Info =====*/
            List<ProcessDTO.StartRecipeParameterSetInfo> assignedRecipeParameterSets = actualStartInfo.getAssignedRecipeParameterSets();
            if (CimArrayUtils.getSize(assignedRecipeParameterSets) == 1) {
                log.info("rpsetLen == 1");
                List<ProcessDTO.StartRecipeParameter> recipeParameterList = assignedRecipeParameterSets.get(0).getRecipeParameterList();
                if (CimArrayUtils.getSize(recipeParameterList) == 1) {
                    log.info("rparmLen == 1");
                    ProcessDTO.StartRecipeParameter startRecipeParameter0 = recipeParameterList.get(0);
                    if (CimObjectUtils.isEmpty(startRecipeParameter0.getParameterName())
                            && CimObjectUtils.isEmpty(startRecipeParameter0.getParameterValue())
                            && CimObjectUtils.isEmpty(startRecipeParameter0.getTargetValue())) {
                        assignedRecipeParameterSets.clear();
                    }
                }
            }

            if (CimArrayUtils.isNotEmpty(assignedRecipeParameterSets)) {
                log.info("actualStartInfo->assignedRecipeParameterSets.length() > 0");
                List<ProcessDTO.StartRecipeParameter> recipeParameterList = actualStartInfo.getAssignedRecipeParameterSets().get(0).getRecipeParameterList();
                final int lotWaferInfoAttriLen = CimArrayUtils.getSize(lotWaferInfoAttributesList);
                for (int i = 0, j = lotWaferInfoAttriLen; i < j; i++) {
                    if (CimStringUtils.equals(actualStartInfo.getAssignedRecipeParameterChangeType(), BizConstant.SP_RPARM_CHANGETYPE_BYLOT)) {
                        log.info("actualStartInfo->recipeParameterChangeType == SP_Rparm_ChangeType_ByLot");

                        List<Infos.StartRecipeParameter> startRecipeParameterList = new ArrayList<>();
                        for (ProcessDTO.StartRecipeParameter startRecipeParameter : recipeParameterList) {
                            Infos.StartRecipeParameter recipeParameter = new Infos.StartRecipeParameter();
                            startRecipeParameterList.add(recipeParameter);
                            recipeParameter.setParameterName(startRecipeParameter.getParameterName());
                            recipeParameter.setParameterValue(startRecipeParameter.getParameterValue());
                            recipeParameter.setTargetValue(startRecipeParameter.getTargetValue());
                            recipeParameter.setUseCurrentSettingValueFlag(startRecipeParameter.getUseCurrentSettingValueFlag());
                        }
                        lotInCassette.getLotWaferList().get(i).setStartRecipeParameterList(startRecipeParameterList);
                    } else {
                        log.info("actualStartInfo->recipeParameterChangeType != SP_Rparm_ChangeType_ByLot");
                        for (ProcessDTO.StartRecipeParameterSetInfo assignedRecipeParameterSet : assignedRecipeParameterSets) {
                            log.info("loop to actualStartInfo->assignedRecipeParameterSets.length()");
                            if (ObjectIdentifier.equalsWithValue(lotInCassette.getLotWaferList().get(i).getWaferID(), assignedRecipeParameterSet.getApplyWaferInfoList().get(0).getWaferID())) {
                                log.info("strLot_previousOperation_DataCollectionInformation_Get_out.strStartCassette[0].strLotInCassette[j].strLotWafer[w].waferID.identifier == actualStartInfo->assignedRecipeParameterSets[rs].applyWafers[0].waferID");
                                List<Infos.StartRecipeParameter> startRecipeParameterList = new ArrayList<>();
                                for (ProcessDTO.StartRecipeParameter startRecipeParameter : recipeParameterList) {
                                    Infos.StartRecipeParameter recipeParameter = new Infos.StartRecipeParameter();
                                    startRecipeParameterList.add(recipeParameter);
                                    recipeParameter.setParameterName(startRecipeParameter.getParameterName());
                                    recipeParameter.setParameterValue(startRecipeParameter.getParameterValue());
                                    recipeParameter.setTargetValue(startRecipeParameter.getTargetValue());
                                    recipeParameter.setUseCurrentSettingValueFlag(startRecipeParameter.getUseCurrentSettingValueFlag());
                                }
                                lotInCassette.getLotWaferList().get(i).setStartRecipeParameterList(startRecipeParameterList);
                                break;
                            }
                        }
                    }
                }
            }

            /*===== set Data Collection Info =====*/
            if (CimBooleanUtils.isTrue(actualStartInfo.getAssignedDataCollectionFlag())) {
                log.info("actualStartInfo->assignedDataCollectionFlag == TRUE");
                List<ProcessDTO.DataCollectionInfo> assignedDataCollections = actualStartInfo.getAssignedDataCollections();
                List<Infos.DataCollectionInfo> dcDefList = new ArrayList<>();
                for (ProcessDTO.DataCollectionInfo assignedDataCollection : assignedDataCollections) {
                    Infos.DataCollectionInfo collectionInfo = new Infos.DataCollectionInfo();
                    dcDefList.add(collectionInfo);

                    collectionInfo.setDataCollectionDefinitionID(assignedDataCollection.getDataCollectionDefinitionID());
                    collectionInfo.setDescription(assignedDataCollection.getDescription());
                    collectionInfo.setDataCollectionType(assignedDataCollection.getDataCollectionType());
                    collectionInfo.setCalculationRequiredFlag(assignedDataCollection.getCalculationRequiredFlag());
                    collectionInfo.setSpecCheckRequiredFlag(assignedDataCollection.getSpecCheckRequiredFlag());
                    collectionInfo.setDataCollectionSpecificationID(assignedDataCollection.getDataCollectionSpecificationID());
                    collectionInfo.setDcSpecDescription(assignedDataCollection.getDcSpecDescription());
                    collectionInfo.setPreviousDataCollectionDefinitionID(assignedDataCollection.getPreviousDataCollectionDefinitionID());
                    collectionInfo.setPreviousOperationID(assignedDataCollection.getPreviousOperationID());
                    collectionInfo.setPreviousOperationNumber(assignedDataCollection.getPreviousOperationNumber());

                    final List<ProcessDTO.DataCollectionSpecInfo> dcSpecsTmp = assignedDataCollection.getDcSpecs();
                    List<Infos.DataCollectionSpecInfo> dcSpecs = new ArrayList<>();
                    collectionInfo.setDcSpecs(dcSpecs);
                    if(CimArrayUtils.isNotEmpty(dcSpecsTmp)) {
                        for (ProcessDTO.DataCollectionSpecInfo dataCollectionSpecInfo : dcSpecsTmp) {
                            Infos.DataCollectionSpecInfo specInfo = new Infos.DataCollectionSpecInfo();
                            dcSpecs.add(specInfo);
                            specInfo.setDataItemName(dataCollectionSpecInfo.getDataItemName());
                            specInfo.setScreenLimitUpperRequired(dataCollectionSpecInfo.getScreenLimitUpperRequired());
                            specInfo.setScreenLimitUpper(dataCollectionSpecInfo.getScreenLimitUpper());
                            specInfo.setActionCodesUscrn(dataCollectionSpecInfo.getActionCodesUscrn());
                            specInfo.setScreenLimitLowerRequired(dataCollectionSpecInfo.getScreenLimitLowerRequired());
                            specInfo.setScreenLimitLower(dataCollectionSpecInfo.getScreenLimitLower());
                            specInfo.setActionCodesLscrn(dataCollectionSpecInfo.getActionCodesLscrn());
                            specInfo.setSpecLimitUpperRequired(dataCollectionSpecInfo.getSpecLimitUpperRequired());
                            specInfo.setSpecLimitUpper(dataCollectionSpecInfo.getSpecLimitUpper());
                            specInfo.setActionCodesUsl(dataCollectionSpecInfo.getActionCodesUsl());
                            specInfo.setSpecLimitLowerRequired(dataCollectionSpecInfo.getSpecLimitLowerRequired());
                            specInfo.setSpecLimitLower(dataCollectionSpecInfo.getSpecLimitLower());
                            specInfo.setActionCodesLsl(dataCollectionSpecInfo.getActionCodesLsl());
                            specInfo.setControlLimitUpperRequired(dataCollectionSpecInfo.getControlLimitUpperRequired());
                            specInfo.setControlLimitUpper(dataCollectionSpecInfo.getControlLimitUpper());
                            specInfo.setActionCodesUcl(dataCollectionSpecInfo.getActionCodesUcl());
                            specInfo.setControlLimitLowerRequired(dataCollectionSpecInfo.getControlLimitLowerRequired());
                            specInfo.setControlLimitLower(dataCollectionSpecInfo.getControlLimitLower());
                            specInfo.setActionCodesLcl(dataCollectionSpecInfo.getActionCodesLcl());
                            specInfo.setTarget(dataCollectionSpecInfo.getTarget());
                            specInfo.setTag(dataCollectionSpecInfo.getTag());
                            specInfo.setDcSpecGroup(dataCollectionSpecInfo.getDcSpecGroup());
                        }
                    }

                    final List<ProcessDTO.DataCollectionItemInfo> dcItemsTmp = assignedDataCollection.getDcItems();
                    List<Infos.DataCollectionItemInfo> dcItems = new ArrayList<>();
                    collectionInfo.setDcItems(dcItems);
                    if(CimArrayUtils.isNotEmpty(dcItemsTmp)) {
                        for (ProcessDTO.DataCollectionItemInfo dataCollectionItemInfo : dcItemsTmp) {
                            Infos.DataCollectionItemInfo itemInfo = new Infos.DataCollectionItemInfo();
                            dcItems.add(itemInfo);
                            itemInfo.setDataCollectionItemName(dataCollectionItemInfo.getDataCollectionItemName());
                            itemInfo.setDataCollectionMode(dataCollectionItemInfo.getDataCollectionMode());
                            itemInfo.setDataCollectionUnit(dataCollectionItemInfo.getDataCollectionUnit());
                            itemInfo.setDataType(dataCollectionItemInfo.getDataType());
                            itemInfo.setItemType(dataCollectionItemInfo.getItemType());
                            itemInfo.setMeasurementType(dataCollectionItemInfo.getMeasurementType());
                            itemInfo.setWaferID(dataCollectionItemInfo.getWaferID());
                            itemInfo.setWaferPosition(dataCollectionItemInfo.getWaferPosition());
                            itemInfo.setSitePosition(dataCollectionItemInfo.getSitePosition());
                            itemInfo.setHistoryRequiredFlag(dataCollectionItemInfo.getHistoryRequiredFlag());
                            itemInfo.setCalculationType(dataCollectionItemInfo.getCalculationType());
                            itemInfo.setCalculationExpression(dataCollectionItemInfo.getCalculationExpression());
                            itemInfo.setDataValue(dataCollectionItemInfo.getDataValue());
                            itemInfo.setTargetValue(dataCollectionItemInfo.getTargetValue());
                            itemInfo.setSpecCheckResult(dataCollectionItemInfo.getSpecCheckResult());
                            itemInfo.setActionCodes(dataCollectionItemInfo.getActionCodes());
                        }
                    }
                }

                startRecipe.setDcDefList(dcDefList);
            }

            //------------------------------------------
            // Get sampled waferIDs on PO
            //------------------------------------------
            log.info("Get sampled waferIDs on PO.");
            List<String> assignedSamplingWafers = actualStartInfo.getAssignedSamplingWafers();
            /*===== set processJobExecFlag Info =====*/
            if (CimArrayUtils.isNotEmpty(assignedSamplingWafers)) {
                log.info("assignedSamplingWafersLen > 0");
                List<Infos.LotWafer> lotWaferList = lotInCassette.getLotWaferList();
                for (Infos.LotWafer lotWafer : lotWaferList) {
                    int i, j;
                    final int assignedSamplingWafersLen = CimArrayUtils.getSize(assignedSamplingWafers);
                    for (i = 0, j = assignedSamplingWafersLen; i < j; i++) {
                        if (ObjectIdentifier.equalsWithValue(lotWafer.getWaferID(), assignedSamplingWafers.get(i))) {
                            lotWafer.setProcessJobExecFlag(true);
                            break;
                        }
                    }
                    if (i == assignedSamplingWafersLen) {
                        lotWafer.setProcessJobExecFlag(true);
                    }
                }
            } else {
                log.info("assignedSamplingWafersLen = 0, No wafer sampling set up");
                List<Infos.LotWafer> lotWaferList = lotInCassette.getLotWaferList();
                for (Infos.LotWafer lotWafer : lotWaferList) {
                    lotWafer.setProcessJobExecFlag(true);
                }
            }
        }
        return retVal;
    }


    @Override
    public Outputs.ObjLotCurrentOperationDataCollectionInformationGetOut lotCurrentOperationDataCollectionInformationGet(Infos.ObjCommon objCommon,
                                                                                                                  ObjectIdentifier equipmentID,
                                                                                                                  List<ObjectIdentifier> lotIDs) {
        Outputs.ObjLotCurrentOperationDataCollectionInformationGetOut retVal = new Outputs.ObjLotCurrentOperationDataCollectionInformationGetOut();
        /*----------------------------------------------*/
        /*   Set Return Structure                       */
        /*----------------------------------------------*/
        retVal.setEquipmentID(equipmentID);
        /*-------------------------*/
        /*   Set Lot Information   */
        /*-------------------------*/
        List<Infos.StartCassette> strStartCassette = new ArrayList<>();
        retVal.setStrStartCassette(strStartCassette);
        Infos.StartCassette startCassette = new Infos.StartCassette();
        strStartCassette.add(startCassette);
        List<Infos.LotInCassette> lotInCassettes = new ArrayList<>();
        startCassette.setLotInCassetteList(lotInCassettes);

        for (ObjectIdentifier lotID : lotIDs) {
            log.info("loop to (*startCassetteInfoSeq)[0].lotInCassetteInfo.length()");
            log.info("lotID = {}", lotID);
            Infos.LotInCassette lotInCassette = new Infos.LotInCassette();
            lotInCassettes.add(lotInCassette);
            lotInCassette.setMoveInFlag(true);
            lotInCassette.setLotID(lotID);

            Inputs.ObjLotWafersGetIn objLotWafersGetIn = new Inputs.ObjLotWafersGetIn();
            objLotWafersGetIn.setLotID(lotID);
            objLotWafersGetIn.setScrapCheckFlag(true);

            List<Infos.LotWaferInfoAttributes> lotWaferInfoAttributesList = lotWaferInfoListGetDR(objCommon, objLotWafersGetIn);
            if (CimArrayUtils.isNotEmpty(lotWaferInfoAttributesList)) {
                List<Infos.LotWafer> lotWaferList = new ArrayList<>();
                lotInCassette.setLotWaferList(lotWaferList);
                for (Infos.LotWaferInfoAttributes lotWaferInfoAttributes : lotWaferInfoAttributesList) {
                    Infos.LotWafer lotWafer = new Infos.LotWafer();
                    lotWafer.setWaferID(lotWaferInfoAttributes.getWaferID());
                    lotWafer.setSlotNumber(new Long(lotWaferInfoAttributes.getSlotNumber()));
                    lotWafer.setControlWaferFlag(lotWaferInfoAttributes.getControlWaferFlag());
                    lotWaferList.add(lotWafer);
                }

                /*------------------------------------------*/
                /*   Get ProductID from LotWaferAttributs   */
                /*------------------------------------------*/
                log.info("Set ProductID");
                lotInCassette.setProductID(lotWaferInfoAttributesList.get(0).getProductID());
            }

            /*--------------------------*/
            /*   Get Lot Related Info   */
            /*--------------------------*/
            CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);

            //--------------------------------------------------------------------------
            // Get PO from Previous Operation.
            //--------------------------------------------------------------------------
            log.info("Get PO from the current Operation.");
            CimProcessOperation aPosPO = lot.getProcessOperation();
            Validations.check(CimObjectUtils.isEmpty(aPosPO), retCodeConfig.getNotFoundProcessOperation());
            ProcessDTO.ActualStartInformationForPO actualStartInfo = aPosPO.getActualStartInfo(true);

            /*===== set Lot Info =====*/
            lotInCassette.setLotType(lot.getLotType());
            lotInCassette.setSubLotType(lot.getSubLotType());

            /*===== set Recipe Info =====*/
            lotInCassette.setRecipeParameterChangeType(actualStartInfo.getAssignedRecipeParameterChangeType());
            Infos.StartRecipe startRecipe = new Infos.StartRecipe();
            startRecipe.setLogicalRecipeID(actualStartInfo.getAssignedLogicalRecipe());
            startRecipe.setMachineRecipeID(actualStartInfo.getAssignedMachineRecipe());
            startRecipe.setPhysicalRecipeID(actualStartInfo.getAssignedPhysicalRecipe());
            startRecipe.setDataCollectionFlag(actualStartInfo.getAssignedDataCollectionFlag());
            lotInCassette.setStartRecipe(startRecipe);

            /*===== set Reticle Info =====*/
            final List<ProcessDTO.StartReticleInfo> assignedReticlesTmp = actualStartInfo.getAssignedReticles();
            List<Infos.StartReticleInfo> startReticleList = new ArrayList<>();
            if(CimArrayUtils.isNotEmpty(assignedReticlesTmp)) {
                for (ProcessDTO.StartReticleInfo startReticleInfo : assignedReticlesTmp) {
                    Infos.StartReticleInfo reticleInfo = new Infos.StartReticleInfo();
                    startReticleList.add(reticleInfo);
                    reticleInfo.setReticleID(startReticleInfo.getReticleID());
                    reticleInfo.setSequenceNumber(startReticleInfo.getSequenceNumber());
                }
            }
            startRecipe.setStartReticleList(startReticleList);

            /*===== set Fixture Info =====*/
            final List<ProcessDTO.StartFixtureInfo> assignedFixturesTmp = actualStartInfo.getAssignedFixtures();
            List<Infos.StartFixtureInfo> startFixtureList = new ArrayList<>();
            if(CimArrayUtils.isNotEmpty(assignedFixturesTmp)) {
                for (ProcessDTO.StartFixtureInfo startFixtureInfo : assignedFixturesTmp) {
                    Infos.StartFixtureInfo fixtureInfo = new Infos.StartFixtureInfo();
                    startFixtureList.add(fixtureInfo);
                    startFixtureInfo.setFixtureID(startFixtureInfo.getFixtureID());
                    startFixtureInfo.setFixtureCategory(startFixtureInfo.getFixtureCategory());
                }
            }
            startRecipe.setStartFixtureList(startFixtureList);

            /*===== set Recipe Parameter Info =====*/
            List<ProcessDTO.StartRecipeParameterSetInfo> assignedRecipeParameterSets = actualStartInfo.getAssignedRecipeParameterSets();
            if (CimArrayUtils.getSize(assignedRecipeParameterSets) == 1) {
                log.info("rpsetLen == 1");
                List<ProcessDTO.StartRecipeParameter> recipeParameterList = assignedRecipeParameterSets.get(0).getRecipeParameterList();
                if (CimArrayUtils.getSize(recipeParameterList) == 1) {
                    log.info("rparmLen == 1");
                    ProcessDTO.StartRecipeParameter startRecipeParameter0 = recipeParameterList.get(0);
                    if (CimObjectUtils.isEmpty(startRecipeParameter0.getParameterName())
                            && CimObjectUtils.isEmpty(startRecipeParameter0.getParameterValue())
                            && CimObjectUtils.isEmpty(startRecipeParameter0.getTargetValue())) {
                        assignedRecipeParameterSets.clear();
                    }
                }
            }

            if (CimArrayUtils.isNotEmpty(assignedRecipeParameterSets)) {
                log.info("actualStartInfo->assignedRecipeParameterSets.length() > 0");
                List<ProcessDTO.StartRecipeParameter> recipeParameterList = actualStartInfo.getAssignedRecipeParameterSets().get(0).getRecipeParameterList();
                final int lotWaferInfoAttriLen = CimArrayUtils.getSize(lotWaferInfoAttributesList);
                for (int i = 0, j = lotWaferInfoAttriLen; i < j; i++) {
                    if (CimStringUtils.equals(actualStartInfo.getAssignedRecipeParameterChangeType(), BizConstant.SP_RPARM_CHANGETYPE_BYLOT)) {
                        log.info("actualStartInfo->recipeParameterChangeType == SP_Rparm_ChangeType_ByLot");

                        List<Infos.StartRecipeParameter> startRecipeParameterList = new ArrayList<>();
                        for (ProcessDTO.StartRecipeParameter startRecipeParameter : recipeParameterList) {
                            Infos.StartRecipeParameter recipeParameter = new Infos.StartRecipeParameter();
                            startRecipeParameterList.add(recipeParameter);
                            recipeParameter.setParameterName(startRecipeParameter.getParameterName());
                            recipeParameter.setParameterValue(startRecipeParameter.getParameterValue());
                            recipeParameter.setTargetValue(startRecipeParameter.getTargetValue());
                            recipeParameter.setUseCurrentSettingValueFlag(startRecipeParameter.getUseCurrentSettingValueFlag());
                        }
                        lotInCassette.getLotWaferList().get(i).setStartRecipeParameterList(startRecipeParameterList);
                    } else {
                        log.info("actualStartInfo->recipeParameterChangeType != SP_Rparm_ChangeType_ByLot");
                        for (ProcessDTO.StartRecipeParameterSetInfo assignedRecipeParameterSet : assignedRecipeParameterSets) {
                            log.info("loop to actualStartInfo->assignedRecipeParameterSets.length()");
                            if (ObjectIdentifier.equalsWithValue(lotInCassette.getLotWaferList().get(i).getWaferID(), assignedRecipeParameterSet.getApplyWaferInfoList().get(0).getWaferID())) {
                                log.info("strLot_previousOperation_DataCollectionInformation_Get_out.strStartCassette[0].strLotInCassette[j].strLotWafer[w].waferID.identifier == actualStartInfo->assignedRecipeParameterSets[rs].applyWafers[0].waferID");
                                List<Infos.StartRecipeParameter> startRecipeParameterList = new ArrayList<>();
                                for (ProcessDTO.StartRecipeParameter startRecipeParameter : recipeParameterList) {
                                    Infos.StartRecipeParameter recipeParameter = new Infos.StartRecipeParameter();
                                    startRecipeParameterList.add(recipeParameter);
                                    recipeParameter.setParameterName(startRecipeParameter.getParameterName());
                                    recipeParameter.setParameterValue(startRecipeParameter.getParameterValue());
                                    recipeParameter.setTargetValue(startRecipeParameter.getTargetValue());
                                    recipeParameter.setUseCurrentSettingValueFlag(startRecipeParameter.getUseCurrentSettingValueFlag());
                                }
                                lotInCassette.getLotWaferList().get(i).setStartRecipeParameterList(startRecipeParameterList);
                                break;
                            }
                        }
                    }
                }
            }

            /*===== set Data Collection Info =====*/
            if (CimBooleanUtils.isTrue(actualStartInfo.getAssignedDataCollectionFlag())) {
                log.info("actualStartInfo->assignedDataCollectionFlag == TRUE");
                List<ProcessDTO.DataCollectionInfo> assignedDataCollections = actualStartInfo.getAssignedDataCollections();
                List<Infos.DataCollectionInfo> dcDefList = new ArrayList<>();
                for (ProcessDTO.DataCollectionInfo assignedDataCollection : assignedDataCollections) {
                    Infos.DataCollectionInfo collectionInfo = new Infos.DataCollectionInfo();
                    dcDefList.add(collectionInfo);

                    collectionInfo.setDataCollectionDefinitionID(assignedDataCollection.getDataCollectionDefinitionID());
                    collectionInfo.setDescription(assignedDataCollection.getDescription());
                    collectionInfo.setDataCollectionType(assignedDataCollection.getDataCollectionType());
                    collectionInfo.setCalculationRequiredFlag(assignedDataCollection.getCalculationRequiredFlag());
                    collectionInfo.setSpecCheckRequiredFlag(assignedDataCollection.getSpecCheckRequiredFlag());
                    collectionInfo.setDataCollectionSpecificationID(assignedDataCollection.getDataCollectionSpecificationID());
                    collectionInfo.setDcSpecDescription(assignedDataCollection.getDcSpecDescription());
                    collectionInfo.setPreviousDataCollectionDefinitionID(assignedDataCollection.getPreviousDataCollectionDefinitionID());
                    collectionInfo.setPreviousOperationID(assignedDataCollection.getPreviousOperationID());
                    collectionInfo.setPreviousOperationNumber(assignedDataCollection.getPreviousOperationNumber());

                    final List<ProcessDTO.DataCollectionSpecInfo> dcSpecsTmp = assignedDataCollection.getDcSpecs();
                    List<Infos.DataCollectionSpecInfo> dcSpecs = new ArrayList<>();
                    collectionInfo.setDcSpecs(dcSpecs);
                    if(CimArrayUtils.isNotEmpty(dcSpecsTmp)) {
                        for (ProcessDTO.DataCollectionSpecInfo dataCollectionSpecInfo : dcSpecsTmp) {
                            Infos.DataCollectionSpecInfo specInfo = new Infos.DataCollectionSpecInfo();
                            dcSpecs.add(specInfo);
                            specInfo.setDataItemName(dataCollectionSpecInfo.getDataItemName());
                            specInfo.setScreenLimitUpperRequired(dataCollectionSpecInfo.getScreenLimitUpperRequired());
                            specInfo.setScreenLimitUpper(dataCollectionSpecInfo.getScreenLimitUpper());
                            specInfo.setActionCodesUscrn(dataCollectionSpecInfo.getActionCodesUscrn());
                            specInfo.setScreenLimitLowerRequired(dataCollectionSpecInfo.getScreenLimitLowerRequired());
                            specInfo.setScreenLimitLower(dataCollectionSpecInfo.getScreenLimitLower());
                            specInfo.setActionCodesLscrn(dataCollectionSpecInfo.getActionCodesLscrn());
                            specInfo.setSpecLimitUpperRequired(dataCollectionSpecInfo.getSpecLimitUpperRequired());
                            specInfo.setSpecLimitUpper(dataCollectionSpecInfo.getSpecLimitUpper());
                            specInfo.setActionCodesUsl(dataCollectionSpecInfo.getActionCodesUsl());
                            specInfo.setSpecLimitLowerRequired(dataCollectionSpecInfo.getSpecLimitLowerRequired());
                            specInfo.setSpecLimitLower(dataCollectionSpecInfo.getSpecLimitLower());
                            specInfo.setActionCodesLsl(dataCollectionSpecInfo.getActionCodesLsl());
                            specInfo.setControlLimitUpperRequired(dataCollectionSpecInfo.getControlLimitUpperRequired());
                            specInfo.setControlLimitUpper(dataCollectionSpecInfo.getControlLimitUpper());
                            specInfo.setActionCodesUcl(dataCollectionSpecInfo.getActionCodesUcl());
                            specInfo.setControlLimitLowerRequired(dataCollectionSpecInfo.getControlLimitLowerRequired());
                            specInfo.setControlLimitLower(dataCollectionSpecInfo.getControlLimitLower());
                            specInfo.setActionCodesLcl(dataCollectionSpecInfo.getActionCodesLcl());
                            specInfo.setTarget(dataCollectionSpecInfo.getTarget());
                            specInfo.setTag(dataCollectionSpecInfo.getTag());
                            specInfo.setDcSpecGroup(dataCollectionSpecInfo.getDcSpecGroup());
                        }
                    }

                    final List<ProcessDTO.DataCollectionItemInfo> dcItemsTmp = assignedDataCollection.getDcItems();
                    List<Infos.DataCollectionItemInfo> dcItems = new ArrayList<>();
                    collectionInfo.setDcItems(dcItems);
                    if(CimArrayUtils.isNotEmpty(dcItemsTmp)) {
                        for (ProcessDTO.DataCollectionItemInfo dataCollectionItemInfo : dcItemsTmp) {
                            Infos.DataCollectionItemInfo itemInfo = new Infos.DataCollectionItemInfo();
                            dcItems.add(itemInfo);
                            itemInfo.setDataCollectionItemName(dataCollectionItemInfo.getDataCollectionItemName());
                            itemInfo.setDataCollectionMode(dataCollectionItemInfo.getDataCollectionMode());
                            itemInfo.setDataCollectionUnit(dataCollectionItemInfo.getDataCollectionUnit());
                            itemInfo.setDataType(dataCollectionItemInfo.getDataType());
                            itemInfo.setItemType(dataCollectionItemInfo.getItemType());
                            itemInfo.setMeasurementType(dataCollectionItemInfo.getMeasurementType());
                            itemInfo.setWaferID(dataCollectionItemInfo.getWaferID());
                            itemInfo.setWaferPosition(dataCollectionItemInfo.getWaferPosition());
                            itemInfo.setSitePosition(dataCollectionItemInfo.getSitePosition());
                            itemInfo.setHistoryRequiredFlag(dataCollectionItemInfo.getHistoryRequiredFlag());
                            itemInfo.setCalculationType(dataCollectionItemInfo.getCalculationType());
                            itemInfo.setCalculationExpression(dataCollectionItemInfo.getCalculationExpression());
                            itemInfo.setDataValue(dataCollectionItemInfo.getDataValue());
                            itemInfo.setTargetValue(dataCollectionItemInfo.getTargetValue());
                            itemInfo.setSpecCheckResult(dataCollectionItemInfo.getSpecCheckResult());
                            itemInfo.setActionCodes(dataCollectionItemInfo.getActionCodes());
                        }
                    }
                }

                startRecipe.setDcDefList(dcDefList);
            }

            //------------------------------------------
            // Get sampled waferIDs on PO
            //------------------------------------------
            log.info("Get sampled waferIDs on PO.");
            List<String> assignedSamplingWafers = actualStartInfo.getAssignedSamplingWafers();
            /*===== set processJobExecFlag Info =====*/
            if (CimArrayUtils.isNotEmpty(assignedSamplingWafers)) {
                log.info("assignedSamplingWafersLen > 0");
                List<Infos.LotWafer> lotWaferList = lotInCassette.getLotWaferList();
                for (Infos.LotWafer lotWafer : lotWaferList) {
                    int i, j;
                    final int assignedSamplingWafersLen = CimArrayUtils.getSize(assignedSamplingWafers);
                    for (i = 0, j = assignedSamplingWafersLen; i < j; i++) {
                        if (ObjectIdentifier.equalsWithValue(lotWafer.getWaferID(), assignedSamplingWafers.get(i))) {
                            lotWafer.setProcessJobExecFlag(true);
                            break;
                        }
                    }
                    if (i == assignedSamplingWafersLen) {
                        lotWafer.setProcessJobExecFlag(true);
                    }
                }
            } else {
                log.info("assignedSamplingWafersLen = 0, No wafer sampling set up");
                List<Infos.LotWafer> lotWaferList = lotInCassette.getLotWaferList();
                for (Infos.LotWafer lotWafer : lotWaferList) {
                    lotWafer.setProcessJobExecFlag(true);
                }
            }
        }
        return retVal;
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param lotID
     * @param routeID
     * @param operationNumber
     * @return com.fa.cim.common.support.RetCode<java.lang.Object>
     * @exception
     * @author Ho
     * @date 2019/9/17 13:36
     */
    public void  lotFutureReworkRequestDelete(
            Infos.ObjCommon strObjCommonIn,
            ObjectIdentifier                 lotID,
            ObjectIdentifier                 routeID,
            String                             operationNumber ){

        log.info("lotFutureReworkRequestDelete");

        productManager.removeFutureReworkRequestFor( lotID.getValue(), routeID.getValue(), operationNumber );

        log.info("lotFutureReworkRequestDelete");
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param updateFlag
     * @param lotID
     * @param routeID
     * @param operationNumber
     * @param strFutureReworkDetailInfoSeq
     * @return com.fa.cim.common.support.RetCode<java.lang.Object>
     * @exception
     * @author Ho
     * @date 2019/9/17 13:40
     */
    public void lotFutureReworkRequestRegist(
            Infos.ObjCommon strObjCommonIn,
            Boolean updateFlag,
            ObjectIdentifier lotID,
            ObjectIdentifier routeID,
            String operationNumber,
            List<Infos.FutureReworkDetailInfo> strFutureReworkDetailInfoSeq) {

        //---------------------------------------------
        // Prepare FutureReworkRequest data
        //---------------------------------------------
        //===== Get current time of being used as the update time =======//
        // The update time is used as a part of the key, Future Rework ID, at the method PosProductManager::createFutureReworkRequest().
        // Therefore, the value of the input parameter strObjCommonIn.strTimeStamp.reportTimeStamp must be not used as the update time.
//        rc = calendar_GetCurrentTimeDR( strCalendar_GetCurrentTimeDR_out, strObjCommonIn );
//        if( rc != RC_OK )
//        {
//            PPT_METHODTRACE_V1("", "calendar_GetCurrentTimeDR() != RC_OK");
//            strLot_futureReworkRequest_Regist_out.strResult = strCalendar_GetCurrentTimeDR_out.strResult;
//            return rc;
//        }

        ProductDTO.FutureReworkRequestInfo aPosFutureReworkRequestInfo = new ProductDTO.FutureReworkRequestInfo();
        aPosFutureReworkRequestInfo.setLotID(lotID);
        aPosFutureReworkRequestInfo.setRouteID(routeID);
        aPosFutureReworkRequestInfo.setOperationNumber(operationNumber);
        aPosFutureReworkRequestInfo.setLastClaimedTimeStamp(strObjCommonIn.getTimeStamp().getReportTimeStamp());
        aPosFutureReworkRequestInfo.setModifier(strObjCommonIn.getUser().getUserID());
        int detailLen = CimArrayUtils.getSize(strFutureReworkDetailInfoSeq);
        aPosFutureReworkRequestInfo.setFutureReworkRequestDetails(new ArrayList<>());
        for (int i = 0; i < detailLen; i++) {
            ProductDTO.FutureReworkRequestDetail futureReworkRequestDetail = new ProductDTO.FutureReworkRequestDetail();
            futureReworkRequestDetail.setTrigger(strFutureReworkDetailInfoSeq.get(i).getTrigger());
            futureReworkRequestDetail.setReworkRouteID(strFutureReworkDetailInfoSeq.get(i).getReworkRouteID());
            futureReworkRequestDetail.setReturnOperationNumber(strFutureReworkDetailInfoSeq.get(i).getReturnOperationNumber());
            futureReworkRequestDetail.setReasonCode(strFutureReworkDetailInfoSeq.get(i).getReasonCodeID());
            aPosFutureReworkRequestInfo.getFutureReworkRequestDetails().add(futureReworkRequestDetail);
        }

        CimFutureReworkRequest aPosFutureReworkRequest = productManager.findFutureReworkRequestFor(lotID.getValue(), routeID.getValue(), operationNumber);
        //---------------------------------------------
        // Set FutureReworkRequest data
        //---------------------------------------------
        if (CimObjectUtils.isEmpty(aPosFutureReworkRequest) && !updateFlag) {
            aPosFutureReworkRequest = productManager.createFutureReworkRequest(aPosFutureReworkRequestInfo);
        } else if (!CimObjectUtils.isEmpty(aPosFutureReworkRequest) && updateFlag) {
            aPosFutureReworkRequest.setFutureReworkRequestInfo(aPosFutureReworkRequestInfo);
        } else {
            if (updateFlag) {
                log.info("To update FutureReworkRequest is requested, but the object is not found.");
            } else {
                log.info("To add FutureReworkRequest is requested, but the object already exists.");
            }
            Validations.check(!updateFlag, retCodeConfigEx.getFtrwkRegistFail());
        }
    }

    @Override
    public Infos.InterFabMonitorGroups lotMonitoredLotsGetDR(Infos.ObjCommon objCommon, ObjectIdentifier monitorGroupID) {
        Infos.InterFabMonitorGroups interFabMonitorGroups = new Infos.InterFabMonitorGroups();
        CimMonitorGroupDO cimMonitorGroupExample = new CimMonitorGroupDO();
        cimMonitorGroupExample.setMonitorGroupID(ObjectIdentifier.fetchValue(monitorGroupID));
        CimMonitorGroupDO monitorGroup = cimJpaRepository.findOne(Example.of(cimMonitorGroupExample)).orElse(null);
        Validations.check(null == monitorGroup, retCodeConfig.getNotFoundMonitorgroup());
        CimMonitorGroupLotDO cimMonitorGroupLotExample = new CimMonitorGroupLotDO();
        cimMonitorGroupLotExample.setReferenceKey(monitorGroup.getId());
        List<CimMonitorGroupLotDO> monitorGroupLots = cimJpaRepository.findAll(Example.of(cimMonitorGroupLotExample));

        List<Infos.InterFabMonitoredLots> interFabMonitoredLots = new ArrayList<>();
        if (CimArrayUtils.isNotEmpty(monitorGroupLots)) {
            for (CimMonitorGroupLotDO monitorGroupLot : monitorGroupLots) {
                Infos.InterFabMonitoredLots interFabMonitoredLots1 = new Infos.InterFabMonitoredLots();
                interFabMonitoredLots1.setLotID(ObjectIdentifier.build(monitorGroupLot.getLotID(),monitorGroupLot.getLotObj()));
                interFabMonitoredLots1.setPoObj(monitorGroupLot.getPoObj());
                interFabMonitoredLots.add(interFabMonitoredLots1);
            }
        }
        interFabMonitorGroups.setMonitorGroupID(monitorGroupID);
        interFabMonitorGroups.setMonitorLotID(ObjectIdentifier.build(monitorGroup.getMonitorLotId(), monitorGroup.getMonitorLotObj()));
        interFabMonitorGroups.setStrInterFabMonitoredLotsSeq(interFabMonitoredLots);
        return interFabMonitorGroups;
    }

    @Override
    public List<Infos.EntityIdentifier> lotEntityIDListGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier equipmentID) {
        List<Infos.EntityIdentifier> entityIdentifiers = new ArrayList<>();

        CimLotDO example = new CimLotDO();
        example.setLotID(ObjectIdentifier.fetchValue(lotID));
        CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        // getting production specification
        ObjectIdentifier productSpecificationID = new ObjectIdentifier(lot.getProductSpecificationID(), lot.getProductSpecificationObj());
        if (ObjectIdentifier.isNotEmptyWithValue(productSpecificationID)) {
            Infos.EntityIdentifier entityIdentifier = new Infos.EntityIdentifier();
            entityIdentifier.setObjectID(productSpecificationID);
            entityIdentifier.setClassName(BizConstant.SP_INHIBITCLASSID_PRODUCT);
            entityIdentifier.setAttribution(BizConstant.EMPTY);
            entityIdentifiers.add(entityIdentifier);
        }

        // getting main process definition and operation
        ObjectIdentifier routeID = new ObjectIdentifier(lot.getRouteID(), lot.getRouteObj());
        String operationNumber = lot.getOperationNumber();
        if (ObjectIdentifier.isNotEmptyWithValue(routeID) && CimStringUtils.isNotEmpty(operationNumber)) {
            entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_ROUTE, routeID, String.valueOf(operationNumber)));
        }

        // getting current process definition
        //String poObj = lot.getProcessOperationID();
        ObjectIdentifier currentPDID = null;
        String currentPOS = null;
        String moduleNo = null;
        String mainProcessFlowObj = null;
        if (!CimStringUtils.isEmpty(lot.getProcessOperationObj())) {
            Outputs.ObjLotCurrentOperationInfoGetDROut drResult = lotMethod.lotCurrentOperationInfoGetDR(objCommon, lotID);

            if (drResult != null) {
                currentPDID = drResult.getOperationID();
                currentPOS = drResult.getModulePOS();
                moduleNo = drResult.getModuleNo();
                mainProcessFlowObj = drResult.getMainPFforModulePD();

                entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_PROCESS, currentPDID));
                entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_MODULEPD, drResult.getModulePDID()));
                entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_STAGE, drResult.getStageID()));
            }
        }

        // getting machine
        if (ObjectIdentifier.isNotEmptyWithValue(equipmentID)) {
            entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_EQUIPMENT, equipmentID));
        }

        // getting entity information from logical recipe
        if (ObjectIdentifier.isNotEmptyWithValue(productSpecificationID) &&
                ObjectIdentifier.isNotEmptyWithValue(currentPDID) &&
                ObjectIdentifier.isNotEmptyWithValue(equipmentID)) {

            ObjectIdentifier recipeOut = logicalRecipeMethod.processLogicalRecipeGetDR(objCommon, productSpecificationID, currentPDID);
            ObjectIdentifier logicalRecipeID = recipeOut;
            if (ObjectIdentifier.isNotEmptyWithValue(logicalRecipeID)) {
                // getting default recipe setting
                Infos.DefaultRecipeSetting defaultRecipeSetting = logicalRecipeMethod.logicalRecipeDefaultRecipeSettingGetDR(objCommon, lotID, equipmentID, logicalRecipeID, true, false, false);
                // Set Machine Recipe
                ObjectIdentifier recipe = defaultRecipeSetting.getRecipe();
                if (ObjectIdentifier.isNotEmptyWithValue(recipe)) {
                    entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_MACHINERECIPE, recipe));
                }
                // Set Chambe Info
                if (!CimArrayUtils.isEmpty(defaultRecipeSetting.getChamberSeq())) {
                    for (Infos.Chamber chamber : defaultRecipeSetting.getChamberSeq()) {
                        ObjectIdentifier chamberID = chamber.getChamberID();
                        if (ObjectIdentifier.isNotEmptyWithValue(chamberID) && chamber.getState()) {
                            entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_CHAMBER, equipmentID, chamberID.getValue()));
                        }
                    }
                }
            }
        }

        // getting reticle groups
        List<ObjectIdentifier> reticleGroupList = lotMethod.lotReticleGroupsGetDR(objCommon, lotID, equipmentID, "");

        if (!CimArrayUtils.isEmpty(reticleGroupList)) {
            reticleGroupList.forEach(reticleGroup -> entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_RETICLEGROUP, reticleGroup)));
        }

        // checking entity information for target operation in flow batch
        CimProcessOperationSpecificationDO processOperationSpecifications = cimJpaRepository.queryOne("SELECT * FROM OMPRSS WHERE ID = ?1", CimProcessOperationSpecificationDO.class, currentPOS);

        ObjectIdentifier flowBatchID = new ObjectIdentifier(lot.getFlowBatchID(), lot.getFlowBatchObj());
        // If current operation is target operation, no need to attatch the target infomation as the entities.
        if (processOperationSpecifications != null && !CimBooleanUtils.isTrue(processOperationSpecifications.getBatchTargetFlag())) {
            CimFlowBatchDO flowBatch = cimJpaRepository.queryOne("SELECT * FROM OMFLOWB WHERE FLOWB_ID = ?1", CimFlowBatchDO.class, ObjectIdentifier.fetchValue(flowBatchID));
            ObjectIdentifier flowBatchTargetEqpID = null;
            if (null != flowBatch) {
                flowBatchTargetEqpID = new ObjectIdentifier(flowBatch.getEquipmentID(), flowBatch.getEquipmentObj());
            }
            if (null != flowBatch && CimStringUtils.isNotEmpty(flowBatch.getEquipmentID())) {
                entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_EQUIPMENT, flowBatchTargetEqpID));
            }

            if (null != flowBatch || CimBooleanUtils.isTrue(processOperationSpecifications.getBatchEntryFlag())) {
                Infos.FlowBatchLotInfo flowBatchLotInfo = lotMethod.lotFlowBatchSectionInfoGetDR(objCommon, lotID);

                if (flowBatchLotInfo.getFlowBatchControl() != null && !CimArrayUtils.isEmpty(flowBatchLotInfo.getFlowBatchSectionList())) {
                    for (Infos.FlowBatchSection section : flowBatchLotInfo.getFlowBatchSectionList()) {
                        if (CimBooleanUtils.isTrue(section.getTargetOperationFlag()) && CimStringUtils.equals(flowBatchLotInfo.getFlowBatchControl().getName(), processOperationSpecifications.getBatchName())) {
                            if (CimStringUtils.isNotEmpty(moduleNo)) {
                                String aModuleOpeNo = section.getOperationNumber();
                                StringBuffer sb = new StringBuffer();
                                if (!CimStringUtils.isEmpty(aModuleOpeNo)) {
                                    sb.append(moduleNo);
                                    sb.append(BizConstant.DOT);
                                    sb.append(aModuleOpeNo);
                                }
                                if (!CimObjectUtils.isEmpty(sb.toString())) {
                                    entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_ROUTE, new ObjectIdentifier(lot.getRouteID(), lot.getRouteObj()), sb.toString()));
                                }

                                ObjectIdentifier operationID = section.getOperationID();
                                if (ObjectIdentifier.isNotEmptyWithValue(operationID)) {
                                    entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_PROCESS, operationID));

                                    // getting entity information from logical recipe for flowBatch
                                    ObjectIdentifier logicalRecipeID = logicalRecipeMethod.processLogicalRecipeGetDR(objCommon, productSpecificationID, operationID);

                                    // If specified lot is batched and has target eqp ID, then use it.
                                    // In other case, use specified eqp, which must be target eqp of a lot in batch entry process.
                                    ObjectIdentifier tmpBatchTargetEqpID = ObjectIdentifier.isEmpty(flowBatchTargetEqpID) ? equipmentID : flowBatchTargetEqpID;

                                    if (!ObjectIdentifier.isEmpty(tmpBatchTargetEqpID) && !ObjectIdentifier.isEmpty(logicalRecipeID)) {
                                        //-------------------------------------------------------
                                        // getting default recipe setting for target operation
                                        //-------------------------------------------------------
                                        Boolean processResourceReqFlag = true;
                                        Boolean recipeParameterReqFlag = false ;
                                        Boolean fixtureRequireFlag     = false ;
                                        Infos.DefaultRecipeSetting defaultRecipeSetting = logicalRecipeMethod.logicalRecipeDefaultRecipeSettingGetDR(objCommon, lotID, tmpBatchTargetEqpID, logicalRecipeID, processResourceReqFlag, recipeParameterReqFlag, fixtureRequireFlag);
                                        //-------------------------
                                        // Set Machine Recipe
                                        //-------------------------
                                        if (!ObjectIdentifier.isEmpty(defaultRecipeSetting.getRecipe())) {
                                            entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_MACHINERECIPE, defaultRecipeSetting.getRecipe()));
                                        }
                                        //-----------------------
                                        // Set Chambe Info
                                        //-----------------------
                                        int chamberLen = CimArrayUtils.getSize(defaultRecipeSetting.getChamberSeq());
                                        for (int i = 0; i < chamberLen; i++) {
                                            if (!ObjectIdentifier.isEmpty(defaultRecipeSetting.getChamberSeq().get(i).getChamberID()) && defaultRecipeSetting.getChamberSeq().get(i).getState()) {
                                                entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_CHAMBER, tmpBatchTargetEqpID, defaultRecipeSetting.getChamberSeq().get(i).getChamberID().getValue()));
                                            }
                                        }
                                    }
                                    // getting photo layer for target operation
                                    CimProcessFlowContextDO processFlowContext = cimJpaRepository.queryOne("SELECT * FROM OMPRFCX WHERE ID = ?1", CimProcessFlowContextDO.class, lot.getProcessFlowContextObj());
                                    Validations.check(null == processFlowContext, retCodeConfig.getNotFoundPfx());

                                    String photoLayer = null;

                                    String processFlowObject = processFlowContext.getProcessFlowObj();
                                    CimPFPosListDO processFlowPosList = cimJpaRepository.queryOne("SELECT * FROM OMPRF_PRSSSEQ WHERE REFKEY = ?1 AND LINK_KEY = ?2", CimPFPosListDO.class, processFlowObject, sb.toString());
                                    if (processFlowPosList != null) {
                                        String posID = processFlowPosList.getProcessOperationSpecificationsObj();
                                        if (!CimStringUtils.isEmpty(posID)) {
                                            CimProcessOperationSpecificationDO pos = cimJpaRepository.queryOne("SELECT * FROM OMPRSS WHERE ID = ?1 ", CimProcessOperationSpecificationDO.class, posID);
                                            photoLayer = pos.getPhotoLayer();
                                            photoLayer = CimStringUtils.isEmpty(photoLayer) ? "" : photoLayer;
                                        }
                                    }
                                    // getting reticle groups for target operation
                                    if (!CimStringUtils.isEmpty(lot.getReticleSetObj())) {
                                        List<ObjectIdentifier> reticleGroups1 = lotMethod.lotReticleGroupsGetDR(objCommon, lotID, flowBatchTargetEqpID, photoLayer);
                                        if (!CimArrayUtils.isEmpty(reticleGroups1)) {
                                            reticleGroupList.forEach(reticleGroup -> entityIdentifiers.add(new Infos.EntityIdentifier(BizConstant.SP_INHIBITCLASSID_RETICLEGROUP, reticleGroup)));
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        return entityIdentifiers;
    }

    @Override
    public Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut lotEqpMonitorSectionInfoGetForJob(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut result = new Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut();

        Infos.EqpMonitorJobLotInfo  monitorJobGetOut = this.lotEqpMonitorJobGet(objCommon, lotID);
        if (ObjectIdentifier.isEmpty(monitorJobGetOut.getEqpMonitorJobID())) {
            return result;
        }

        List<Infos.EqpMonitorLabelInfo> labelGetOut = this.lotEqpMonitorOperationLabelGet(objCommon, lotID);
        // Compare monitorOpeKey between data get on step 1 and step 2
        log.debug("compare monitorOpeKey between data get on step 1 and step 2");
        if (CimBooleanUtils.isTrue(monitorJobGetOut.getExitFlag())) {
            // If exitFlag for eqpMonitor lot is "TRUE", it means that this process is "Exit" operation for EqpMonitorJob
            // <= This is checked in OpeStart or GatePass(Before process move) and search label whose ExitFlag=TRUE
            // Label is determined uniquely because EqpMonitor job section (Monitor-Exit) doesn't lap over each other
            if (!CimArrayUtils.isEmpty(labelGetOut)) {
                for (Infos.EqpMonitorLabelInfo eqpMonitorLabelInfo : labelGetOut) {
                    if (eqpMonitorLabelInfo.isExitFlag()) {
                        result.setExitFlag(eqpMonitorLabelInfo.isExitFlag());
                        result.setOperationLabel(eqpMonitorLabelInfo.getOperationLabel());
                        result.setMonitorOperationPosObjRef(eqpMonitorLabelInfo.getMonitorOperationPosObjRef());
                        result.setEquipmentMonitorID(monitorJobGetOut.getEqpMonitorID());
                        result.setEquipmentMonitorJobID(monitorJobGetOut.getEqpMonitorJobID());
                        break;
                    }
                }
            }
        } else {
            log.debug("FALSE == strLot_eqpMonitorJob_Get_out.strEqpMonitorJobLotInfo.exitFlag");
            if (!CimArrayUtils.isEmpty(labelGetOut)) {
                for (Infos.EqpMonitorLabelInfo eqpMonitorLabelInfo : labelGetOut) {
                    if (CimStringUtils.equals(monitorJobGetOut.getMonitorOpeKey()
                            , eqpMonitorLabelInfo.getMonitorOperationKey())) {
                        result.setOperationLabel(eqpMonitorLabelInfo.getOperationLabel());
                        result.setExitFlag(eqpMonitorLabelInfo.isExitFlag());
                        result.setMonitorOperationPosObjRef(eqpMonitorLabelInfo.getMonitorOperationPosObjRef());
                        result.setEquipmentMonitorID(monitorJobGetOut.getEqpMonitorID());
                        result.setEquipmentMonitorJobID(monitorJobGetOut.getEqpMonitorJobID());
                        break;
                    }
                }
            }
        }
        return result;
    }

    @Override
    public List<Infos.EqpMonitorLabelInfo> lotEqpMonitorOperationLabelGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot, new OmCode(retCodeConfig.getNotFoundLot(), ObjectIdentifier.fetchValue(lotID)));

        List<Infos.EqpMonitorLabelInfo> retVal = new ArrayList<>();

        boolean currentProcessOperationFlag = true;
        if (TransactionIDEnum.equals(TransactionIDEnum.OPERATION_COMP_WITH_DATA_REQ, objCommon.getTransactionID())
         || TransactionIDEnum.equals(TransactionIDEnum.OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ, objCommon.getTransactionID())
         || TransactionIDEnum.equals(TransactionIDEnum.FORCE_OPERATION_COMP_REQ, objCommon.getTransactionID())
         || TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ, objCommon.getTransactionID())
         || TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ, objCommon.getTransactionID())) {
            Boolean processOperation = this.lotCheckConditionForPO(objCommon, lotID);

            currentProcessOperationFlag = CimBooleanUtils.isTrue(processOperation);
            if (currentProcessOperationFlag) {
                log.debug("Get PO from the current Operation.");
            } else {
                log.debug("Get PO from the previous Operation");
            }
        }

        com.fa.cim.newcore.bo.pd.CimProcessOperation po = currentProcessOperationFlag ? lot.getProcessOperation() : lot.getPreviousProcessOperation();
        Validations.check(null == po, new OmCode(retCodeConfig.getNotFoundProcessOperation(), ""));
        String operationNumber = po.getOperationNumber();  // operationNumber = destModuleNo + "." +  destModuleOpeNo

        if (null == operationNumber || !operationNumber.contains(".")) {
            throw new ServiceException(retCodeConfig.getSystemError());
        }
        String destModuleNo = operationNumber.substring(0, operationNumber.indexOf("."));
        String destModuleOpeNo = operationNumber.substring(operationNumber.indexOf(".") + 1);
        com.fa.cim.newcore.bo.pd.CimProcessFlow modulePF = po.getModuleProcessFlow();
        Validations.check(null == modulePF, new OmCode(retCodeConfig.getNotFoundProcessFlow(), ""));
        List<ProcessDTO.EqpMonitorLabelInfo> eqpMonitorLabelInfos = modulePF.getEqpMonitorLabels(destModuleOpeNo);

        CimProcessFlowContext processFlowContext = lot.getProcessFlowContext();
        if (CimArrayUtils.isNotEmpty(eqpMonitorLabelInfos)) {
            for (ProcessDTO.EqpMonitorLabelInfo object : eqpMonitorLabelInfos) {
                CimProcessOperationSpecification processOperationSpecification = baseCoreFactory.getBO(CimProcessOperationSpecification.class, object.getMonitorOperationPosObjRef());
                String monitorModuleOperationNumber = processOperationSpecification.getOperationNumber();
                String monitorOperationNumber = String.format("%s.%s", destModuleNo, monitorModuleOperationNumber);
                object.setMonitorOperationKey(processFlowContext.getEqpMonOperationKey(monitorOperationNumber));

                Infos.EqpMonitorLabelInfo labelInfo = new Infos.EqpMonitorLabelInfo();
                retVal.add(labelInfo);
                labelInfo.setOperationLabel(object.getOperationLabel());
                labelInfo.setExitFlag(object.isExitFlag());
                labelInfo.setMonitorOperationPosObjRef(object.getMonitorOperationPosObjRef());
                labelInfo.setMonitorOperationKey(object.getMonitorOperationKey());
                labelInfo.setCustomField(object.getCustomField());
            }
        }

        return retVal;
    }

    @Override
    public List<Infos.LoadingVerifiedLot> loadedLotVerifiedInfoCheckConditionForForceLoad(Infos.ObjCommon objCommon, int code, List<Infos.LoadingVerifiedLot> verifiedLots, ObjectIdentifier equipmentID, ObjectIdentifier cassetteID, ObjectIdentifier portID, String lotPurposeType) {
        List<Infos.LoadingVerifiedLot> loadingVerifiedLots = verifiedLots;
        //-----------------------------------------------------------
        // ForceLoad is not performed when user is TCS.
        //-----------------------------------------------------------
        if (!CimStringUtils.equals(BizConstant.SP_TCS_PERSON, ObjectIdentifier.fetchValue(objCommon.getUser().getUserID()))) {
            return loadingVerifiedLots;
        }
        //-----------------------------------------------------------
        // ForceLoad is not performed when EQP is OFFLINE and AccessMode is Manual.
        //-----------------------------------------------------------
        Outputs.ObjPortResourceCurrentOperationModeGetOut portResourceCurrentOperationMode = portMethod.portResourceCurrentOperationModeGet(objCommon, equipmentID, portID);
        if (CimStringUtils.equals(portResourceCurrentOperationMode.getOperationMode().getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)
                || CimStringUtils.equals(portResourceCurrentOperationMode.getOperationMode().getAccessMode(), BizConstant.SP_EQP_ACCESSMODE_MANUAL)) {
            return loadingVerifiedLots;
        }
        CimCassette cassette = baseCoreFactory.getBO(CimCassette.class, cassetteID);
        Validations.check(null == cassette, new OmCode(retCodeConfig.getNotFoundCassette(), ObjectIdentifier.fetchValue(cassetteID)));
        //-----------------------------------------------------------
        // ForceLoad is not performed when cassette is EI.
        //-----------------------------------------------------------
        if (code == retCodeConfig.getInvalidCassetteTransferState().getCode()) {
          //  String transferStatus = cassette.getTransferState();
            String transferStatus = cassette.getTransportState();
            if (CimStringUtils.equals(transferStatus, BizConstant.SP_TRANSSTATE_EQUIPMENTIN)) {
                return loadingVerifiedLots;
            }
        }
        if (CimArrayUtils.isEmpty(verifiedLots) && !cassette.isEmpty()) {
            // ForceLoad does not perform.
            return loadingVerifiedLots;
        }
        //------------------------------------------------------------------------------------------
        // From the result of LotVerifyForLoading, judges whether Carrier is ForceLoaded.
        //
        //  RC_NOT_CANDIDATE_LOT_FOR_OPE_START
        //        : HoldLot, NotWaitingLot, NotOnFloorLot, InhibitLot, NotAvailableEqp
        //
        //  RC_NEED_TO_SPECIFY_ALL_LOT_IN_CAST
        //        : lot did not gather in spite of batch type in InternalBufferEQP.
        //
        //  RC_CAST_CTRLJOBID_BLANK
        //        : After reserving two Carriers, when the 1st loading of a Carrier goes wrong,
        //          the 2nd Carrier does not have CJ.
        //          Therefore, Carrier must be loaded when Carrier does not have CJ.
        //
        //  RC_INVALID_CAST_XFERSTAT
        //        : Fail XferStatus of Carrier.
        //------------------------------------------------------------------------------------------
        if (code == retCodeConfig.getNotCandidateLotForOperationStart().getCode()
                || code == retCodeConfig.getNeedToSpecifyAllLotInCassette().getCode()
                || code == retCodeConfig.getCastControlJobIdBlank().getCode()
                || code == retCodeConfig.getInvalidCassetteTransferState().getCode()
                || code == retCodeConfig.getLoadNotMatchNpwRsv().getCode()) {
            throw new ServiceException(retCodeConfig.getCastForceLoaded(), loadingVerifiedLots);
        }
        return loadingVerifiedLots;
    }

    @Override
    public List<Infos.LoadingVerifiedLot> loadedLotVerifiedInfoChangeForForceLoad(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier cassetteID, ObjectIdentifier portID, String lotPurposeType, List<Infos.LoadingVerifiedLot> verifiedLots) {
        int nLotVerify = CimArrayUtils.getSize(verifiedLots);
        //--------------------------------------------------
        // Change LotVerify result's OpeStartFlag to OFF.
        //--------------------------------------------------
        for (int i = 0; i < nLotVerify; i++) {
            verifiedLots.get(i).setMoveInFlag(false);
        }
        //---------------------------------------------
        // Change ControlJob's OpeStartFlag to OFF.
        //---------------------------------------------
        ObjectIdentifier controlJobID = cassetteMethod.cassetteControlJobIDGet(objCommon, cassetteID);

        if (!ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            CimControlJob aControlJob = baseCoreFactory.getBO(CimControlJob.class, controlJobID);
            Validations.check(aControlJob == null, retCodeConfig.getNotFoundControlJob());
            List<ProductDTO.PosStartCassetteInfo> startCassetteInfo = aControlJob.getStartCassetteInfo();
            int lenCast = CimArrayUtils.getSize(startCassetteInfo);
            for (int i = 0; i < lenCast; i++) {
                List<ProductDTO.PosLotInCassetteInfo> lotInCassetteInfo = startCassetteInfo.get(i).getLotInCassetteInfo();
                int lenLot = CimArrayUtils.getSize(lotInCassetteInfo);
                for (int j = 0; j < lenLot; j++) {
                    lotInCassetteInfo.get(j).setOperationStartFlag(false);
                }
            }
            aControlJob.setStartCassetteInfo(startCassetteInfo);
        }
        return verifiedLots;
    }

    @Override
    //@Transactional(rollbackFor = Exception.class)
    public void lotQtimeDeleteDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        //---------------------------------------------
        //  Gets record from parent table
        //---------------------------------------------
        String querySql = String.format("SELECT ID\n" +
                "            FROM   OMQT\n" +
                "            WHERE  LOT_ID = '%s'", lotID.getValue());
        List<com.fa.cim.newcore.bo.pd.CimQTimeRestriction> qtimeRestrictionList = baseCoreFactory.getBOListByCustom(com.fa.cim.newcore.bo.pd.CimQTimeRestriction.class, querySql);
        if (!CimArrayUtils.isEmpty(qtimeRestrictionList)){
            for (com.fa.cim.newcore.bo.pd.CimQTimeRestriction qTimeRestriction : qtimeRestrictionList){
                //------------------------------------------------
                //  Delete record from child table(FRQTIME_ACTION)
                //  Delete record from child table (FRQTIME_UDATA)
                //  Delete record from table FRQTIME
                //---------------------------------------------
                qTimeRestriction.remove();
            }
        }
        //---------------------------------------------
        //  Deletes record from parent table
        //---------------------------------------------
        /*
        querySql = String.format("DELETE FROM FRQTIME WHERE LOT_ID = '%s'", lotID.getValue());
        cimJpaRepository.query(querySql);
        */
    }

    @Override
    public Outputs.lotFutureReworkListGetDROut lotFutureReworkListGetDR(Infos.ObjCommon objCommon, Params.FutureActionDetailInfoInqParams params) {
        Outputs.lotFutureReworkListGetDROut out = new Outputs.lotFutureReworkListGetDROut();
        CimFutureReworkDO example = new CimFutureReworkDO();
        if (!ObjectIdentifier.isEmpty(params.getLotID())) {
            example.setLotID(ObjectIdentifier.fetchValue(params.getLotID()));
        }
        if (!ObjectIdentifier.isEmpty(params.getOperationFutureActionAttributes().getRouteID())) {
            example.setMainProcessDefinitionID(ObjectIdentifier.fetchValue(params.getOperationFutureActionAttributes().getRouteID()));
        }
        if (!CimStringUtils.isEmpty(params.getOperationFutureActionAttributes().getOperationNumber())) {
            example.setOperationNumber(params.getOperationFutureActionAttributes().getOperationNumber());
        }
        //===== Get future rework requests =======
        //----- PREPARE : FRFTRWK -------
        List<CimFutureReworkDO> futureReworkInfos = cimJpaRepository.findAll(Example.of(example));
        List<Infos.FutureReworkInfo> futureReworkInfoList = new ArrayList<>();
        for (CimFutureReworkDO futureReworkInfo : futureReworkInfos) {
            Infos.FutureReworkInfo futureReworkDetailInfo = new Infos.FutureReworkInfo();
            futureReworkDetailInfo.setLotID(ObjectIdentifier.build(futureReworkInfo.getLotID(), futureReworkInfo.getLotObj()));
            futureReworkDetailInfo.setRouteID(ObjectIdentifier.build(futureReworkInfo.getMainProcessDefinitionID(), futureReworkInfo.getMainProcessDefinitionObj()));
            futureReworkDetailInfo.setOperationNumber(futureReworkInfo.getOperationNumber());
            futureReworkDetailInfo.setModifyTimeStamp(String.valueOf(futureReworkInfo.getUpdateTime()));
            futureReworkDetailInfo.setModifyUserID(ObjectIdentifier.build(futureReworkInfo.getModifierID(), futureReworkInfo.getModifierObj()));
            //===== Get rework routes =======//
            //----- DECLATE : FRFTRWK_RWKRT -------//
            CimFutureReworkRouteDO cimFutureReworkRouteExample = new CimFutureReworkRouteDO();
            cimFutureReworkRouteExample.setReferenceKey(futureReworkInfo.getId());
            List<CimFutureReworkRouteDO> futureReworkRoutes = cimJpaRepository.findAll(Example.of(cimFutureReworkRouteExample));
            List<Infos.FutureReworkDetailInfo> futureReworkDetailInfoList = new ArrayList<>();
            for (CimFutureReworkRouteDO futureReworkRoute : futureReworkRoutes) {
                Infos.FutureReworkDetailInfo fReworkDetailInfo = new Infos.FutureReworkDetailInfo();
                fReworkDetailInfo.setTrigger(futureReworkRoute.getTrigger());
                fReworkDetailInfo.setReworkRouteID(ObjectIdentifier.build(futureReworkRoute.getFutureRouteID(), futureReworkRoute.getFutureRouteObj()));
                fReworkDetailInfo.setReturnOperationNumber(futureReworkRoute.getReturnOperationNumber());
                fReworkDetailInfo.setReasonCodeID(ObjectIdentifier.build(futureReworkRoute.getReasonID(), futureReworkRoute.getReasonObj()));
                futureReworkDetailInfoList.add(fReworkDetailInfo);
            }
            futureReworkDetailInfo.setFutureReworkDetailInfoList(futureReworkDetailInfoList);
            futureReworkInfoList.add(futureReworkDetailInfo);
        }
        out.setFutureReworkDetailInfoList(futureReworkInfoList);
        return out;
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     *
     * @param strObjCommonIn
     * @param strLotProcessHistory_GetDR_in
     * @return com.fa.cim.common.support.RetCode<com.fa.cim.dto.Infos.LotProcessHistoryGetDROut>
     * @exception
     * @author Ho
     * @date 2019/4/29 16:39
     */
    @Override
    public Infos.LotProcessHistoryGetDROut lotProcessHistoryGetDR(Infos.ObjCommon strObjCommonIn, Infos.LotProcessHistoryGetDRIn strLotProcessHistory_GetDR_in) {
        Validations.check( !CimStringUtils.equals( strLotProcessHistory_GetDR_in.getHistoryCategory(), BizConstant.SP_HISTORYCATEGORY_PROCESS ),new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"History Category should be Process"));


        Boolean hFHWCPHSFlag = false;
        Boolean hFHPROCRSCWPOSFlag = false;
        Boolean hFHPJCHS_PJFlag = false;
        Boolean hFHPJCHS_RPARMFlag = false;

        String hFHWCPHSTableName ;
        String hFHPROCRSCWPOSTableName ;
        String hFHPJCHS_PJTableName ;
        String hFHPJCHS_RPARMTableName ;
        String hFHPJCHSOPE_CATEGORY_RPRM ;

        String hControlJobID ;
        String hLotID;
        String hLotID_Select;
        String hProcessJobID;

        String hTableName       ;
        String hCLAIM_TIME      ;
        String hLOT_ID          ;
        String hPRCSJOB_ID      ;
        String hPRCS_ST         ;
        String hCUR_STATE       ;
        String hWAFER_ID        ;
        String hALIAS_WAFER_NAME;
        String hWAFER_POSITION  ;
        String hPROCRSC_ID      ;
        String hACTION          ;
        String hPROC_TIME       ;
        String hCLAIM_USER_ID   ;
        String hCLAIM_MEMO      ;

        hControlJobID="";
        hLotID="";
        hProcessJobID="";
        hLotID_Select="";

        //add fromTimeStamp and toTimeStamp for runcard history
        String fromTimeStamp  = strLotProcessHistory_GetDR_in.getFromTimeStamp();
        String toTimeStamp    = strLotProcessHistory_GetDR_in.getToTimeStamp();
        SearchCondition searchCondition    = strLotProcessHistory_GetDR_in.getSearchCondition();

        Validations.check( 4 < CimArrayUtils.getSize(strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq()),new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"unsupported table is requested."));

        int targetTabLen = CimArrayUtils.getSize(strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq());
        int iCnt1 = 0;
        int iCnt2 = 0;
        for ( iCnt1 = 0; iCnt1 < targetTabLen; iCnt1++ ) {
            int hashInfoLen = CimArrayUtils.getSize(strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getStrHashedInfoSeq());
            if ( CimStringUtils.equals( strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getTableName(),
                    BizConstant.SP_HISTORYTABLENAME_FHWCPHS)) {
                hFHWCPHSFlag = true;

                List<Infos.HashedInfo> strHashedInfoSeq = strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getStrHashedInfoSeq();

                for (iCnt2 = 0; iCnt2 < hashInfoLen; iCnt2++) {
                    if ( CimStringUtils.equals( strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_CONTROLJOBID )) {
                        if ( 0 < CimStringUtils.length(hControlJobID)
                                && !CimStringUtils.equals(hControlJobID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different controlJobID is specified."));
                        } else if ( 0 == CimStringUtils.length(hControlJobID)) {
                            hControlJobID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    } else if ( CimStringUtils.equals (strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_LOTID)) {
                        if ( 0 <  CimStringUtils.length(hLotID)
                                && !CimStringUtils.equals(hLotID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different lotID is specified."));
                        } else if ( 0 == CimStringUtils.length(hLotID) ) {
                            hLotID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    } else if ( CimStringUtils.equals( strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBID)) {
                        if ( 0 < CimStringUtils.length(hProcessJobID)
                                && !CimStringUtils.equals(hProcessJobID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different processJobID is specified."));
                        } else if ( 0 == CimStringUtils.length(hProcessJobID) )  {
                            hProcessJobID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    }
                }
                if (0 == CimStringUtils.length(hControlJobID)){
                    Validations.check( 0 == CimStringUtils.length(hControlJobID),new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"ControlJob ID is mandatory."));
                } else
                    Validations.check( 0 < CimStringUtils.length(hLotID) && 0< CimStringUtils.length(hProcessJobID) ,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Either Lot ID or Process Job ID can be supported."));
            } else if ( CimStringUtils.equals( strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getTableName(), BizConstant.SP_HISTORYTABLENAME_FHPROCRSCWPOS)) {
                hFHPROCRSCWPOSFlag = true;
                List<Infos.HashedInfo> strHashedInfoSeq = strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getStrHashedInfoSeq();

                for ( iCnt2 = 0; iCnt2 < hashInfoLen; iCnt2++ ) {
                    if ( CimStringUtils.equals( strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_CONTROLJOBID )) {
                        if ( 0 < CimStringUtils.length(hControlJobID)
                                && !CimStringUtils.equals(hControlJobID,  strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different controlJobID is specified."));
                        } else if ( 0 == CimStringUtils.length(hControlJobID) ) {
                            hControlJobID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    } else if ( CimStringUtils.equals( strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_LOTID)) {
                        if ( 0 < CimStringUtils.length(hLotID)
                                && !CimStringUtils.equals(hLotID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different lotID is specified."));
                        } else if ( 0 == CimStringUtils.length(hLotID)) {
                            hLotID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    }
                    else if ( CimStringUtils.equals(strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBID)) {
                        if ( 0 < CimStringUtils.length(hProcessJobID)
                                && !CimStringUtils.equals(hProcessJobID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different processJobID is specified."));
                        } else if (0 == CimStringUtils.length(hProcessJobID)) {
                            hProcessJobID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    }
                }
                if (0 == CimStringUtils.length(hControlJobID)){
                    Validations.check( 0 == CimStringUtils.length(hControlJobID) ,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"ControlJob ID is mandatory."));
                } else
                    Validations.check( 0 < CimStringUtils.length(hLotID) && 0 < CimStringUtils.length(hProcessJobID),new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Either Lot ID or Process Job ID can be supported."));

            } else if ( CimStringUtils.equals( strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getTableName(), BizConstant.SP_HISTORYTABLENAME_FHPJCHS_PJ )) {
                hFHPJCHS_PJFlag = true;
                List<Infos.HashedInfo> strHashedInfoSeq = strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getStrHashedInfoSeq();

                for (iCnt2 = 0; iCnt2 < hashInfoLen; iCnt2++) {
                    if ( CimStringUtils.equals( strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_CONTROLJOBID )) {
                        if ( 0 < CimStringUtils.length(hControlJobID)
                                && !CimStringUtils.equals( hControlJobID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different controlJobID is specified."));
                        } else if ( 0 == CimStringUtils.length(hControlJobID)) {
                            hControlJobID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    } else if ( CimStringUtils.equals (strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_LOTID)) {
                        if ( 0 <  CimStringUtils.length(hLotID)
                                && !CimStringUtils.equals(hLotID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different lotID is specified."));
                        }
                        else if ( 0 == CimStringUtils.length(hLotID) )
                        {
                            hLotID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    } else if ( CimStringUtils.equals( strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBID)) {
                        if ( 0 < CimStringUtils.length(hProcessJobID)
                                && !CimStringUtils.equals(hProcessJobID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different processJobID is specified."));
                        }
                        else if ( 0 == CimStringUtils.length(hProcessJobID) )
                        {
                            hProcessJobID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    }
                }
                if (0 == CimStringUtils.length(hControlJobID)){
                    Validations.check( 0 == CimStringUtils.length(hControlJobID),new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"ControlJob ID is mandatory."));
                } else
                    Validations.check( 0 < CimStringUtils.length(hLotID) && 0< CimStringUtils.length(hProcessJobID) ,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Either Lot ID or Process Job ID can be supported."));
            } else if ( CimStringUtils.equals( strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getTableName(),
                    BizConstant.SP_HISTORYTABLENAME_FHPJCHS_RPARM)) {
                hFHPJCHS_RPARMFlag = true;

                List<Infos.HashedInfo> strHashedInfoSeq = strLotProcessHistory_GetDR_in.getStrTargetTableInfoSeq().get(iCnt1).getStrHashedInfoSeq();
                for (iCnt2 = 0; iCnt2 < hashInfoLen; iCnt2++) {
                    if ( CimStringUtils.equals( strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_CONTROLJOBID )) {
                        if ( 0 < CimStringUtils.length(hControlJobID)
                                && !CimStringUtils.equals(hControlJobID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different controlJobID is specified."));
                        } else if ( 0 == CimStringUtils.length(hControlJobID)) {
                            hControlJobID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    } else if ( CimStringUtils.equals (strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_LOTID)) {
                        if ( 0 <  CimStringUtils.length(hLotID)
                                && !CimStringUtils.equals(hLotID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different lotID is specified."));
                        }
                        else if ( 0 == CimStringUtils.length(hLotID) ) {
                            hLotID= strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    } else if ( CimStringUtils.equals( strHashedInfoSeq.get(iCnt2).getHashKey(), BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBID)) {
                        if ( 0 < CimStringUtils.length(hProcessJobID)
                                && !CimStringUtils.equals(hProcessJobID, strHashedInfoSeq.get(iCnt2).getHashData())) {
                            Validations.check(true,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Different processJobID is specified."));
                        } else if ( 0 == CimStringUtils.length(hProcessJobID) ) {
                            hProcessJobID = strHashedInfoSeq.get(iCnt2).getHashData();
                        }
                    }
                }
                if (0 == CimStringUtils.length(hControlJobID)){
                    Validations.check( 0 == CimStringUtils.length(hControlJobID),new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"ControlJob ID is mandatory."));
                } else
                    Validations.check( 0 < CimStringUtils.length(hLotID) && 0< CimStringUtils.length(hProcessJobID) ,new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Either Lot ID or Process Job ID can be supported."));
            }
        }


        int tableCount = 0;
        Infos.LotProcessHistoryGetDROut strLotProcessHistory_GetDR_out=new Infos.LotProcessHistoryGetDROut();
        List<Infos.TableRecordInfo> strTableRecordInfoSeq=new ArrayList<>();
        strLotProcessHistory_GetDR_out.setStrTableRecordInfoSeq(strTableRecordInfoSeq);
        if ( CimBooleanUtils.isTrue(hFHWCPHSFlag) ) {
            Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
            strTableRecordInfoSeq.add(strTableRecordInfo);
            strTableRecordInfo.setTableName (BizConstant.SP_HISTORYTABLENAME_FHWCPHS);
            List<String> columnNames=new ArrayList<>();
            strTableRecordInfo.setColumnNames(columnNames);
            int columnCount = 0;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERALIASNAME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CHAMBERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ACTIONCODE );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PROCESSTIME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_USERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMMEMO );
            columnCount++;
            tableCount++;
        }
        if ( CimBooleanUtils.isTrue(hFHPROCRSCWPOSFlag) ) {
            Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
            strTableRecordInfoSeq.add(strTableRecordInfo);
            strTableRecordInfo.setTableName (BizConstant.SP_HISTORYTABLENAME_FHPROCRSCWPOS);
            List<String> columnNames=new ArrayList<>();
            strTableRecordInfo.setColumnNames(columnNames);
            int columnCount = 0;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERALIASNAME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERPOS );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CHAMBERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ACTIONCODE );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PROCESSTIME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_USERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMMEMO );
            columnCount++;
            tableCount++;
        }
        if ( CimBooleanUtils.isTrue(hFHPJCHS_PJFlag) ) {
            Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
            strTableRecordInfoSeq.add(strTableRecordInfo);
            strTableRecordInfo.setTableName (BizConstant.SP_HISTORYTABLENAME_FHPJCHS_PJ);
            List<String> columnNames=new ArrayList<>();
            strTableRecordInfo.setColumnNames(columnNames);
            int columnCount = 0;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBSTART );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBSTATUS );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ACTIONCODE );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_USERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMMEMO );
            columnCount++;
            tableCount++;
        }
        if ( CimBooleanUtils.isTrue(hFHPJCHS_RPARMFlag) ) {
            Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
            strTableRecordInfoSeq.add(strTableRecordInfo);
            strTableRecordInfo.setTableName (BizConstant.SP_HISTORYTABLENAME_FHPJCHS_RPARM);
            List<String> columnNames=new ArrayList<>();
            strTableRecordInfo.setColumnNames(columnNames);
            int columnCount = 0;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBSTART );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_USERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMMEMO );
            columnCount++;
            tableCount++;
        }

        hFHPJCHSOPE_CATEGORY_RPRM = BizConstant.SP_PROCESSJOBOPECATEGORY_RECIPEPARAMETERADJUST;
        hFHWCPHSTableName = BizConstant.SP_HISTORYTABLENAME_FHWCPHS;
        hFHPROCRSCWPOSTableName = BizConstant.SP_HISTORYTABLENAME_FHPROCRSCWPOS;
        hFHPJCHS_PJTableName = BizConstant.SP_HISTORYTABLENAME_FHPJCHS_PJ;
        hFHPJCHS_RPARMTableName = BizConstant.SP_HISTORYTABLENAME_FHPJCHS_RPARM;

        if ( 0 == CimStringUtils.length(hProcessJobID)) {
            hLotID_Select = hLotID;
            if ( 0 == CimStringUtils.length(hLotID)) {
                hLotID = "%";
            }
            //add fromTimeStamp and toTimeStamp for runcard history query
            String sql_hFHWCPHSTableName = "select\n" +
                    "\'" + hFHWCPHSTableName +"\' as hTableName,\n" +
                    "                    OHWFCMB.TRX_TIME as hCLAIM_TIME,\n" +
                    "                    OHWFCMB.LOT_ID as hLOT_ID,\n" +
                    "                    '' as hPRCSJOB_ID,\n" +
                    "                    '' as hPRCS_ST,\n" +
                    "                    '' as hCUR_STATE,\n" +
                    "                    OHWFCMB.WAFER_ID as hWAFER_ID,\n" +
                    "                    OMWAFER.ALIAS_WAFER_NAME as hALIAS_WAFER_NAME,\n" +
                    "                    '' as hWAFER_POSITION,\n" +
                    "                    OHWFCMB.PROCRES_ID as hPROCRSC_ID,\n" +
                    "                    OHWFCMB.ACTION_CODE as hACTION,\n" +
                    "                    to_char(OHWFCMB.PROC_TIME) as hPROC_TIME,\n" +
                    "                    OHWFCMB.TRX_USER_ID as hCLAIM_USER_ID,\n" +
                    "                    OHWFCMB.TRX_MEMO as hCLAIM_MEMO\n" +
                    "            from OHWFCMB, OMWAFER\n" +
                    "            where   1 = " + (hFHWCPHSFlag ? 1 : 0) + "\n" +
                    "            and    OHWFCMB.CJ_ID = '" + hControlJobID + "'\n" +
                    "            and    OHWFCMB.LOT_ID LIKE '" + hLotID + "'\n" +
                    "            and    OHWFCMB.WAFER_ID = OMWAFER.WAFER_ID\n";

            //add fromTimeStamp and toTimeStamp for history query
            String sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql_hFHWCPHSTableName += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql_hFHWCPHSTableName += sqlTemp ;
            }

            String sql_hFHPROCRSCWPOSTableName = "select\n" +
                    "\'" + hFHPROCRSCWPOSTableName + "\' as hTableName,\n" +
                    "                    OHPRCRESWP.TRX_TIME as hCLAIM_TIME,\n" +
                    "                    OHPRCRESWP.LOT_ID as hLOT_ID,\n" +
                    "                    '' as hPRCSJOB_ID,\n" +
                    "                    '' as hPRCS_ST,\n" +
                    "                    '' as hCUR_STATE,\n" +
                    "                    OHPRCRESWP.WAFER_ID as hWAFER_ID,\n" +
                    "                    OMWAFER.ALIAS_WAFER_NAME as hALIAS_WAFER_NAME,\n" +
                    "                    OHPRCRESWP.WAFER_POSITION as hWAFER_POSITION,\n" +
                    "                    OHPRCRESWP.PROCRES_ID as hPROCRSC_ID,\n" +
                    "                    '' as hACTION,\n" +
                    "                    to_char(OHPRCRESWP.CHAMBER_PROC_TIME) as hPROC_TIME,\n" +
                    "                    OHPRCRESWP.TRX_USER_ID as hCLAIM_USER_ID,\n" +
                    "                    OHPRCRESWP.TRX_MEMO as hCLAIM_MEMO\n" +
                    "            from OHPRCRESWP, OMWAFER\n" +
                    "            where   1 = " + (hFHPROCRSCWPOSFlag ? 1 : 0) + "\n" +
                    "            and    OHPRCRESWP.CJ_ID = '" + hControlJobID + "'\n" +
                    "            and    OHPRCRESWP.LOT_ID LIKE '" + hLotID + "'\n" +
                    "            and    OHPRCRESWP.WAFER_ID = OMWAFER.WAFER_ID\n";
            sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql_hFHPROCRSCWPOSTableName += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql_hFHPROCRSCWPOSTableName += sqlTemp ;
            }

            String sql_hFHPJCHS_PJTableName = "            select\n" +
                    "\'" + hFHPJCHS_PJTableName + "\' as hTableName,\n" +
                    "                    TRX_TIME as hCLAIM_TIME,\n" +
                    (CimStringUtils.isEmpty(hLotID_Select) ? "\'\'": "\'" + hLotID_Select + "\'") + " as hLOT_ID,\n" +
                    "                PJ_ID as hPRCSJOB_ID,\n" +
                    "                PROCESS_START_FLAG as hPRCS_ST,\n" +
                    "                CUR_STATE as hCUR_STATE,\n" +
                    "                '' as hWAFER_ID,\n" +
                    "                '' as hALIAS_WAFER_NAME,\n" +
                    "                '' as hWAFER_POSITION,\n" +
                    "                '' as hPROCRSC_ID,\n" +
                    "                OPE_CATEGORY as hACTION,\n" +
                    "                '' as hPROC_TIME,\n" +
                    "                TRX_USER_ID as hCLAIM_USER_ID,\n" +
                    "                TRX_MEMO as hCLAIM_MEMO\n" +
                    "            from OHPJCHG\n" +
                    "            where   1 = " + (hFHPJCHS_PJFlag == true ? 1 : 0) +"\n" +
                    "            and    OHPJCHG.CJ_ID = '" + hControlJobID + "'\n" +
                    "            and    OHPJCHG.OPE_CATEGORY <> '" + hFHPJCHSOPE_CATEGORY_RPRM + "'\n" +
                    "            and    OHPJCHG.PJ_ID IN (\n" +
                    "                select distinct OHPJCHG_WAFER.PJ_ID from OHPJCHG, OHPJCHG_WAFER\n" +
                    "            where   OHPJCHG_WAFER.PJ_ID = OHPJCHG.PJ_ID\n" +
                    "            and    LOT_ID LIKE '" + hLotID + "'\n" +
                    "            and    CJ_ID = '" + hControlJobID + "')\n";
            sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql_hFHPJCHS_PJTableName += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql_hFHPJCHS_PJTableName += sqlTemp ;
            }

            String sql_hFHPJCHS_RPARMTableName = "            select\n" +
                    "\'" + hFHPJCHS_RPARMTableName + "\' as hTableName,\n" +
                    "                    TRX_TIME as hCLAIM_TIME,\n" +
                    (CimStringUtils.isEmpty(hLotID_Select) ? "\'\'": "\'" + hLotID_Select + "\'") + " as hLOT_ID,\n" +
                    "                PJ_ID as hPRCSJOB_ID,\n" +
                    "                PROCESS_START_FLAG as hPRCS_ST,\n" +
                    "                '' as hCUR_STATE,\n" +
                    "                '' as hWAFER_ID,\n" +
                    "                '' as hALIAS_WAFER_NAME,\n" +
                    "                '' as hWAFER_POSITION,\n" +
                    "                '' as hPROCRSC_ID,\n" +
                    "                '' as hACTION,\n" +
                    "                '' as hPROC_TIME,\n" +
                    "                TRX_USER_ID as hCLAIM_USER_ID,\n" +
                    "                TRX_MEMO as hCLAIM_MEMO\n" +
                    "            from OHPJCHG\n" +
                    "            where   1 = " + (hFHPJCHS_RPARMFlag == true ? 1 : 0) + "\n" +
                    "            and    OHPJCHG.CJ_ID = '"+ hControlJobID + "'\n" +
                    "            and    OHPJCHG.OPE_CATEGORY = '"+ hFHPJCHSOPE_CATEGORY_RPRM +"'\n" +
                    "            and    OHPJCHG.PJ_ID IN (\n" +
                    "                select distinct OHPJCHG_WAFER.PJ_ID from OHPJCHG, OHPJCHG_WAFER\n" +
                    "            where   OHPJCHG_WAFER.PJ_ID = OHPJCHG.PJ_ID\n" +
                    "            and    LOT_ID LIKE '"+ hLotID +"'\n" +
                    "            and    CJ_ID = '" +hControlJobID +"')\n";
            sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql_hFHPJCHS_RPARMTableName += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql_hFHPJCHS_RPARMTableName += sqlTemp ;
            }

            String sql = new StringBuilder(sql_hFHWCPHSTableName).append(" UNION ALL\n").
                    append(sql_hFHPROCRSCWPOSTableName).append(" UNION ALL\n").
                    append(sql_hFHPJCHS_PJTableName).append(" UNION ALL\n").
                    append(sql_hFHPJCHS_RPARMTableName).append(" ORDER BY hCLAIM_TIME ").toString();

//            String sql="select\n" +
//                    "\'" + hFHWCPHSTableName +"\' as hTableName,\n" +
//                    "                    OHPRCRESWP.TRX_TIME as hCLAIM_TIME,\n" +
//                    "                    OHPRCRESWP.LOT_ID as hLOT_ID,\n" +
//                    "                    '' as hPRCSJOB_ID,\n" +
//                    "                    '' as hPRCS_ST,\n" +
//                    "                    '' as hCUR_STATE,\n" +
//                    "                    OHPRCRESWP.WAFER_ID as hWAFER_ID,\n" +
//                    "                    FRWAFER.ALIAS_WAFER_NAME as hALIAS_WAFER_NAME,\n" +
//                    "                    '' as hWAFER_POSITION,\n" +
//                    "                    OHPRCRESWP.PROCRES_ID as hPROCRSC_ID,\n" +
//                    "                    OHPRCRESWP.CHAMBER_EVENT_CODE as hACTION,\n" +
//                    "                    to_char(OHPRCRESWP.CHAMBER_PROC_TIME) as hPROC_TIME,\n" +
//                    "                    OHPRCRESWP.TRX_USER_ID as hCLAIM_USER_ID,\n" +
//                    "                    OHPRCRESWP.TRX_MEMO as hCLAIM_MEMO\n" +
//                    "            from OHPRCRESWP, FRWAFER\n" +
//                    "            where   1 = " + (hFHWCPHSFlag == true ? 1 : 0) + "\n" +
//                    "            and    OHPRCRESWP.CJ_ID = '" + hControlJobID + "'\n" +
//                    "            and    OHPRCRESWP.LOT_ID LIKE '" + hLotID + "'\n" +
//                    "            and    OHPRCRESWP.WAFER_ID = FRWAFER.WAFER_ID\n" +
//                    "            UNION ALL\n" +
//                    "            select\n" +
//                    "\'" + hFHPROCRSCWPOSTableName + "\' as hTableName,\n" +
//                    "                    OHPRCRESWP.TRX_TIME as hCLAIM_TIME,\n" +
//                    "                    OHPRCRESWP.LOT_ID as hLOT_ID,\n" +
//                    "                    '' as hPRCSJOB_ID,\n" +
//                    "                    '' as hPRCS_ST,\n" +
//                    "                    '' as hCUR_STATE,\n" +
//                    "                    OHPRCRESWP.WAFER_ID as hWAFER_ID,\n" +
//                    "                    FRWAFER.ALIAS_WAFER_NAME as hALIAS_WAFER_NAME,\n" +
//                    "                    OHPRCRESWP.WAFER_POSITION as hWAFER_POSITION,\n" +
//                    "                    OHPRCRESWP.PROCRES_ID as hPROCRSC_ID,\n" +
//                    "                    '' as hACTION,\n" +
//                    "                    to_char(OHPRCRESWP.PROC_TIME) as hPROC_TIME,\n" +
//                    "                    OHPRCRESWP.TRX_USER_ID as hCLAIM_USER_ID,\n" +
//                    "                    OHPRCRESWP.TRX_MEMO as hCLAIM_MEMO\n" +
//                    "            from OHPRCRESWP, FRWAFER\n" +
//                    "            where   1 = " + (hFHPROCRSCWPOSFlag == true ? 1 : 0) + "\n" +
//                    "            and    OHPRCRESWP.CJ_ID = '" + hControlJobID + "'\n" +
//                    "            and    OHPRCRESWP.LOT_ID LIKE '" + hLotID + "'\n" +
//                    "            and    OHPRCRESWP.WAFER_ID = FRWAFER.WAFER_ID\n" +
//                    "            UNION ALL\n" +
//                    "            select\n" +
//                    "\'" + hFHPJCHS_PJTableName + "\' as hTableName,\n" +
//                    "                    TRX_TIME as hCLAIM_TIME,\n" +
//                    (StringUtils.isEmpty(hLotID_Select) ? "\'\'": hLotID_Select) + " as hLOT_ID,\n" +
//                    "                PJ_ID as hPRCSJOB_ID,\n" +
//                    "                PROCESS_START_FLAG as hPRCS_ST,\n" +
//                    "                CUR_STATE as hCUR_STATE,\n" +
//                    "                '' as hWAFER_ID,\n" +
//                    "                '' as hALIAS_WAFER_NAME,\n" +
//                    "                '' as hWAFER_POSITION,\n" +
//                    "                '' as hPROCRSC_ID,\n" +
//                    "                OPE_CATEGORY as hACTION,\n" +
//                    "                '' as hPROC_TIME,\n" +
//                    "                TRX_USER_ID as hCLAIM_USER_ID,\n" +
//                    "                TRX_MEMO as hCLAIM_MEMO\n" +
//                    "            from OHPJCHG\n" +
//                    "            where   1 = " + (hFHPJCHS_PJFlag == true ? 1 : 0) +"\n" +
//                    "            and    OHPJCHG.CJ_ID = '" + hControlJobID + "'\n" +
//                    "            and    OHPJCHG.OPE_CATEGORY <> '" + hFHPJCHSOPE_CATEGORY_RPRM + "'\n" +
//                    "            and    OHPJCHG.PJ_ID IN (\n" +
//                    "                select distinct OHPJCHG_WAFER.PJ_ID from OHPJCHG, OHPJCHG_WAFER\n" +
//                    "            where   OHPJCHG_WAFER.PJ_ID = OHPJCHG.PJ_ID\n" +
//                    "            and    LOT_ID LIKE '" + hLotID + "'\n" +
//                    "            and    CJ_ID = '" + hControlJobID + "')\n" +
//                    "            UNION ALL\n" +
//                    "            select\n" +
//                    "\'" + hFHPJCHS_RPARMTableName + "\' as hTableName,\n" +
//                    "                    TRX_TIME as hCLAIM_TIME,\n" +
//                    (StringUtils.isEmpty(hLotID_Select) ? "\'\'": hLotID_Select) + " as hLOT_ID,\n" +
//                    "                PJ_ID as hPRCSJOB_ID,\n" +
//                    "                PROCESS_START_FLAG as hPRCS_ST,\n" +
//                    "                '' as hCUR_STATE,\n" +
//                    "                '' as hWAFER_ID,\n" +
//                    "                '' as hALIAS_WAFER_NAME,\n" +
//                    "                '' as hWAFER_POSITION,\n" +
//                    "                '' as hPROCRSC_ID,\n" +
//                    "                '' as hACTION,\n" +
//                    "                '' as hPROC_TIME,\n" +
//                    "                TRX_USER_ID as hCLAIM_USER_ID,\n" +
//                    "                TRX_MEMO as hCLAIM_MEMO\n" +
//                    "            from OHPJCHG\n" +
//                    "            where   1 = " + (hFHPJCHS_RPARMFlag == true ? 1 : 0) + "\n" +
//                    "            and    OHPJCHG.CJ_ID = '"+ hControlJobID + "'\n" +
//                    "            and    OHPJCHG.OPE_CATEGORY = '"+ hFHPJCHSOPE_CATEGORY_RPRM +"'\n" +
//                    "            and    OHPJCHG.PJ_ID IN (\n" +
//                    "                select distinct OHPJCHG_WAFER.PJ_ID from OHPJCHG, OHPJCHG_WAFER\n" +
//                    "            where   OHPJCHG_WAFER.PJ_ID = OHPJCHG.PJ_ID\n" +
//                    "            and    LOT_ID LIKE '"+ hLotID +"'\n" +
//                    "            and    CJ_ID = '" +hControlJobID +"')\n" +
//                    "            ORDER BY hCLAIM_TIME ";
            List<Object[]> lotProc1=null;
            Page<Object[]> queryPage=null;
            if (searchCondition!=null){
                queryPage = cimJpaRepository.query(sql, searchCondition);
                lotProc1=queryPage.getContent();
            }else {
                lotProc1=cimJpaRepository.query(sql);
            }

            int increasedDataLen = 100;
            int count = 0;
            List<Infos.TableRecordValue> strTableRecordValueSeq=new ArrayList<>();
            strLotProcessHistory_GetDR_out.setStrTableRecordValueSeq(strTableRecordValueSeq);
            int tableValueCount = 0;
            if (lotProc1!=null)
            for (Object[] obj:lotProc1 ) {
                hTableName="";
                hCLAIM_TIME="";
                hLOT_ID="";
                hPRCSJOB_ID="";
                hPRCS_ST="";
                hCUR_STATE="";
                hWAFER_ID="";
                hALIAS_WAFER_NAME="";
                hWAFER_POSITION="";
                hPROCRSC_ID="";
                hACTION="";
                hPROC_TIME="";
                hCLAIM_USER_ID="";
                hCLAIM_MEMO="";

                hTableName       = CimObjectUtils.toString(obj[0]);
                hCLAIM_TIME      = CimObjectUtils.toString(obj[1]);
                hLOT_ID          = CimObjectUtils.toString(obj[2]);
                hPRCSJOB_ID      = CimObjectUtils.toString(obj[3]);
                hPRCS_ST         = CimObjectUtils.toString(obj[4]);
                hCUR_STATE       = CimObjectUtils.toString(obj[5]);
                hWAFER_ID        = CimObjectUtils.toString(obj[6]);
                hALIAS_WAFER_NAME = CimObjectUtils.toString(obj[7]);
                hWAFER_POSITION  = CimObjectUtils.toString(obj[8]);
                hPROCRSC_ID      = CimObjectUtils.toString(obj[9]);
                hACTION          = CimObjectUtils.toString(obj[10]);
                hPROC_TIME       = CimObjectUtils.toString(obj[11]);
                hCLAIM_USER_ID   = CimObjectUtils.toString(obj[12]);
                hCLAIM_MEMO      = CimObjectUtils.toString(obj[13]);


                if ( tableValueCount >= increasedDataLen ) {
                    increasedDataLen += 100;
                }

                if ( CimStringUtils.equals( hTableName, hFHWCPHSTableName) ) {
                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValue.setTableName ( hFHWCPHSTableName );
                    strTableRecordValue.setReportTimeStamp ( hCLAIM_TIME );

                    List<Object> columnValues=new ArrayList<>();
                    int columnCount = 0;
                    columnValues.add( hCLAIM_TIME );
                    columnCount++;
                    columnValues.add( hLOT_ID );
                    columnCount++;
                    columnValues.add( hWAFER_ID );
                    columnCount++;
                    columnValues.add( hALIAS_WAFER_NAME );
                    columnCount++;
                    columnValues.add( hPROCRSC_ID );
                    columnCount++;
                    columnValues.add( hACTION );
                    columnCount++;
                    columnValues.add( hPROC_TIME );
                    columnCount++;
                    columnValues.add( hCLAIM_USER_ID );
                    columnCount++;
                    columnValues.add( hCLAIM_MEMO );
                    columnCount++;

                    strTableRecordValue.setColumnValues(columnValues);
                    strTableRecordValueSeq.add(strTableRecordValue);
                    tableValueCount++;
                } else if ( CimStringUtils.equals( hTableName, hFHPROCRSCWPOSTableName)) {
                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValue.setTableName (hFHPROCRSCWPOSTableName);
                    strTableRecordValue.setReportTimeStamp (hCLAIM_TIME);

                    List<Object> columnValues=new ArrayList<>();
                    int columnCount = 0;
                    columnValues.add( hCLAIM_TIME );
                    columnCount++;
                    columnValues.add( hLOT_ID );
                    columnCount++;
                    columnValues.add( hWAFER_ID );
                    columnCount++;
                    columnValues.add( hALIAS_WAFER_NAME );
                    columnCount++;
                    columnValues.add( hWAFER_POSITION );
                    columnCount++;
                    columnValues.add( hPROCRSC_ID );
                    columnCount++;
                    columnValues.add( hACTION );
                    columnCount++;
                    columnValues.add( hPROC_TIME );
                    columnCount++;
                    columnValues.add( hCLAIM_USER_ID );
                    columnCount++;
                    columnValues.add( hCLAIM_MEMO );
                    columnCount++;

                    strTableRecordValue.setColumnValues (columnValues);
                    strTableRecordValueSeq.add(strTableRecordValue);
                    tableValueCount++;
                } else if ( CimStringUtils.equals(hTableName, hFHPJCHS_PJTableName)) {
                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValue.setTableName ( hFHPJCHS_PJTableName );
                    strTableRecordValue.setReportTimeStamp ( hCLAIM_TIME );

                    List<Object> columnValues=new ArrayList<>();
                    int columnCount = 0;
                    columnValues.add( hCLAIM_TIME );
                    columnCount++;
                    columnValues.add( hLotID );
                    columnCount++;
                    columnValues.add( hPRCSJOB_ID );
                    columnCount++;
                    columnValues.add( hPRCS_ST );
                    columnCount++;
                    columnValues.add( hCUR_STATE );
                    columnCount++;
                    columnValues.add( hACTION );
                    columnCount++;
                    columnValues.add( hCLAIM_USER_ID );
                    columnCount++;
                    columnValues.add( hCLAIM_MEMO );
                    columnCount++;

                    strTableRecordValue.setColumnValues (columnValues);
                    strTableRecordValueSeq.add(strTableRecordValue);
                    tableValueCount++;
                } else if ( CimStringUtils.equals( hTableName, hFHPJCHS_RPARMTableName) ) {
                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValue.setTableName ( hFHPJCHS_RPARMTableName );
                    strTableRecordValue.setReportTimeStamp ( hCLAIM_TIME );

                    List<Object> columnValues=new ArrayList<>();
                    int columnCount = 0;
                    columnValues.add( hCLAIM_TIME );
                    columnCount++;
                    columnValues.add( hLotID );
                    columnCount++;
                    columnValues.add( hPRCSJOB_ID );
                    columnCount++;
                    columnValues.add( hPRCS_ST );
                    columnCount++;
                    columnValues.add( hCLAIM_USER_ID );
                    columnCount++;
                    columnValues.add( hCLAIM_MEMO );
                    columnCount++;

                    strTableRecordValue.setColumnValues (columnValues);
                    strTableRecordValueSeq.add(strTableRecordValue);
                    tableValueCount++;
                }

            }
            if (searchCondition!=null){
                strLotProcessHistory_GetDR_out.setStrTableRecordValuePage(CimPageUtils.convertListToPage(strTableRecordValueSeq,searchCondition.getPage(),searchCondition.getSize(),queryPage.getTotalElements()));
            }
        } else {
            String hFHPJCHSCLAIM_TIME="";
            String hFHPJCHSOPE_CATEGORY="";
            hFHPJCHSOPE_CATEGORY = BizConstant.SP_PROCESSJOBOPECATEGORY_CREATED;
            String sql=String.format("SELECT MAX(TRX_TIME)\n" +
                            "            FROM  OHPJCHG\n" +
                            "            WHERE CJ_ID = %s\n" +
                            "            AND PJ_ID = %s\n" +
                            "            AND OPE_CATEGORY = %s","\'" + hControlJobID + "\'"
                    ,"\'" + hProcessJobID + "\'"
                    ,"\'" + hFHPJCHSOPE_CATEGORY + "\'");
            Object[] queryOne = cimJpaRepository.queryOne(sql);
            hFHPJCHSCLAIM_TIME= CimObjectUtils.toString(queryOne[0]);

            String sql_one = String.format("select\n" +
                    "            %s as hTableName,\n" +
                    "                    OHWFCMB.TRX_TIME as hCLAIM_TIME,\n" +
                    "                    OHWFCMB.LOT_ID as hLOT_ID,\n" +
                    "                    '' as hPRCSJOB_ID,\n" +
                    "                    '' as hPRCS_ST,\n" +
                    "                    '' as hCUR_STATE,\n" +
                    "                    OHWFCMB.WAFER_ID as hWAFER_ID,\n" +
                    "                    OMWAFER.ALIAS_WAFER_NAME as hALIAS_WAFER_NAME,\n" +
                    "                    '' as hWAFER_POSITION,\n" +
                    "                    OHWFCMB.PROCRES_ID as hPROCRSC_ID,\n" +
                    "                    OHWFCMB.ACTION_CODE as hACTION,\n" +
                    "                    to_char(OHWFCMB.PROC_TIME) as hPROC_TIME,\n" +
                    "                    OHWFCMB.TRX_USER_ID as hCLAIM_USER_ID,\n" +
                    "                    OHWFCMB.TRX_MEMO as hCLAIM_MEMO\n" +
                    "            from OHWFCMB, OMWAFER\n" +
                    "            where   1 = %s\n" +
                    "            and    OHWFCMB.CJ_ID = %s\n" +
                    "            and    OHWFCMB.WAFER_ID IN (\n" +
                    "                select WAFER_ID from OHPJCHG_WAFER\n" +
                    "            where PJ_ID = %s\n" +
                    "            and TRX_TIME = %s) \n" +
                    "            and    OHWFCMB.WAFER_ID = OMWAFER.WAFER_ID\n"
                    , "\'" + hFHWCPHSTableName + "\'"
                    , hFHWCPHSFlag ? 1 : 0
                    , "\'" + hControlJobID + "\'"
                    , "\'" + hProcessJobID + "\'"
                    , "\'" + hFHPJCHSCLAIM_TIME + "\'"
                    );

            String sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql_one += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql_one += sqlTemp ;
            }

            String sql_two = String.format("            select\n" +
                    "            %s as hTableName,\n" +
                    "                    OHPRCRESWP.TRX_TIME as hCLAIM_TIME,\n" +
                    "                    OHPRCRESWP.LOT_ID as hLOT_ID,\n" +
                    "                    '' as hPRCSJOB_ID,\n" +
                    "                    '' as hPRCS_ST,\n" +
                    "                    '' as hCUR_STATE,\n" +
                    "                    OHPRCRESWP.WAFER_ID as hWAFER_ID,\n" +
                    "                    OMWAFER.ALIAS_WAFER_NAME as hALIAS_WAFER_NAME,\n" +
                    "                    OHPRCRESWP.WAFER_POSITION as hWAFER_POSITION,\n" +
                    "                    OHPRCRESWP.PROCRES_ID as hPROCRSC_ID,\n" +
                    "                    '' as hACTION,\n" +
                    "                    to_char(OHPRCRESWP.CHAMBER_PROC_TIME) as hPROC_TIME,\n" +
                    "                    OHPRCRESWP.TRX_USER_ID as hCLAIM_USER_ID,\n" +
                    "                    OHPRCRESWP.TRX_MEMO as hCLAIM_MEMO\n" +
                    "            from OHPRCRESWP, OMWAFER\n" +
                    "            where   1 = %s\n" +
                    "            and    OHPRCRESWP.CJ_ID = %s\n" +
                    "            and    OHPRCRESWP.WAFER_ID IN (\n" +
                    "                select WAFER_ID from OHPJCHG_WAFER\n" +
                    "            where PJ_ID = %s\n" +
                    "            and TRX_TIME = %s)\n" +
                    "            and    OHPRCRESWP.WAFER_ID = OMWAFER.WAFER_ID\n"
                    , "\'" + hFHPROCRSCWPOSTableName + "\'"
                    , hFHPROCRSCWPOSFlag == true ? 1 : 0
                    , "\'" + hControlJobID + "\'"
                    , "\'" + hProcessJobID + "\'"
                    , "\'" + hFHPJCHSCLAIM_TIME + "\'"
            );

            sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql_two += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql_two += sqlTemp ;
            }

            String sql_three = String.format("            select\n" +
                    "            %s as hTableName,\n" +
                    "                    TRX_TIME as hCLAIM_TIME,\n" +
                    "                    %s as hLOT_ID,\n" +
                    "                PJ_ID as hPRCSJOB_ID,\n" +
                    "                PROCESS_START_FLAG as hPRCS_ST,\n" +
                    "                CUR_STATE as hCUR_STATE,\n" +
                    "                '' as hWAFER_ID,\n" +
                    "                '' as hALIAS_WAFER_NAME,\n" +
                    "                '' as hWAFER_POSITION,\n" +
                    "                '' as hPROCRSC_ID,\n" +
                    "                OPE_CATEGORY as hACTION,\n" +
                    "                '' as hPROC_TIME,\n" +
                    "                TRX_USER_ID as hCLAIM_USER_ID,\n" +
                    "                TRX_MEMO as hCLAIM_MEMO\n" +
                    "            from OHPJCHG\n" +
                    "            where   1 = %s\n" +
                    "            and    OHPJCHG.CJ_ID = %s\n" +
                    "            and    OHPJCHG.OPE_CATEGORY <> %s\n" +
                    "            and    OHPJCHG.PJ_ID = %s\n"
                    ,"\'" + hFHPJCHS_PJTableName + "\'"
                    , CimStringUtils.isEmpty(hLotID_Select) ? "\'\'" : hLotID_Select
                    , hFHPJCHS_PJFlag==true ? 1 : 0
                    , "\'" + hControlJobID + "\'"
                    , "\'" + hFHPJCHSOPE_CATEGORY_RPRM + "\'"
                    , "\'" + hProcessJobID + "\'"
                    );

            sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql_three += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql_three += sqlTemp ;
            }

            String sql_four = String.format("            select\n" +
                    "            %s as hTableName,\n" +
                    "                    TRX_TIME as hCLAIM_TIME,\n" +
                    "                    %s as hLOT_ID,\n" +
                    "                PJ_ID as hPRCSJOB_ID,\n" +
                    "                PROCESS_START_FLAG as hPRCS_ST,\n" +
                    "                '' as hCUR_STATE,\n" +
                    "                '' as hWAFER_ID,\n" +
                    "                '' as hALIAS_WAFER_NAME,\n" +
                    "                '' as hWAFER_POSITION,\n" +
                    "                '' as hPROCRSC_ID,\n" +
                    "                '' as hACTION,\n" +
                    "                '' as hPROC_TIME,\n" +
                    "                TRX_USER_ID as hCLAIM_USER_ID,\n" +
                    "                TRX_MEMO as hCLAIM_MEMO\n" +
                    "            from OHPJCHG\n" +
                    "            where   1 = %s\n" +
                    "            and    OHPJCHG.CJ_ID = %s\n" +
                    "            and    OHPJCHG.OPE_CATEGORY = %s\n" +
                    "            and    OHPJCHG.PJ_ID = %s\n"
                    , "\'" + hFHPJCHS_RPARMTableName + "\'"
                    , CimStringUtils.isEmpty(hLotID_Select) ? "\'\'" : hLotID_Select
                    , hFHPJCHS_RPARMFlag == true ? 1 : 0
                    , "\'" + hControlJobID + "\'"
                    , "\'" + hFHPJCHSOPE_CATEGORY_RPRM + "\'"
                    , "\'" + hProcessJobID + "\'"
                    );

            sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql_four += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql_four += sqlTemp ;
            }

            sql = new StringBuilder(sql_one).append(" UNION ALL\n").
                    append(sql_two).append(" UNION ALL\n").
                    append(sql_three).append(" UNION ALL\n").
                    append(sql_four).append(" ORDER BY hCLAIM_TIME ").toString();
//
//            sql=String.format("select\n" +
//                            "            %s as hTableName,\n" +
//                            "                    OHPRCRESWP.TRX_TIME as hCLAIM_TIME,\n" +
//                            "                    OHPRCRESWP.LOT_ID as hLOT_ID,\n" +
//                            "                    '' as hPRCSJOB_ID,\n" +
//                            "                    '' as hPRCS_ST,\n" +
//                            "                    '' as hCUR_STATE,\n" +
//                            "                    OHPRCRESWP.WAFER_ID as hWAFER_ID,\n" +
//                            "                    FRWAFER.ALIAS_WAFER_NAME as hALIAS_WAFER_NAME,\n" +
//                            "                    '' as hWAFER_POSITION,\n" +
//                            "                    OHPRCRESWP.PROCRES_ID as hPROCRSC_ID,\n" +
//                            "                    OHPRCRESWP.CHAMBER_EVENT_CODE as hACTION,\n" +
//                            "                    to_char(OHPRCRESWP.CHAMBER_PROC_TIME) as hPROC_TIME,\n" +
//                            "                    OHPRCRESWP.TRX_USER_ID as hCLAIM_USER_ID,\n" +
//                            "                    OHPRCRESWP.TRX_MEMO as hCLAIM_MEMO\n" +
//                            "            from OHPRCRESWP, FRWAFER\n" +
//                            "            where   1 = %s\n" +
//                            "            and    OHPRCRESWP.CJ_ID = %s\n" +
//                            "            and    OHPRCRESWP.WAFER_ID IN (\n" +
//                            "                select WAFER_ID from OHPJCHG_WAFER\n" +
//                            "            where PJ_ID = %s\n" +
//                            "            and TRX_TIME = %s) \n" +
//                            "            and    OHPRCRESWP.WAFER_ID = FRWAFER.WAFER_ID\n" +
//                            "            UNION ALL\n" +
//                            "            select\n" +
//                            "            %s as hTableName,\n" +
//                            "                    OHPRCRESWP.TRX_TIME as hCLAIM_TIME,\n" +
//                            "                    OHPRCRESWP.LOT_ID as hLOT_ID,\n" +
//                            "                    '' as hPRCSJOB_ID,\n" +
//                            "                    '' as hPRCS_ST,\n" +
//                            "                    '' as hCUR_STATE,\n" +
//                            "                    OHPRCRESWP.WAFER_ID as hWAFER_ID,\n" +
//                            "                    FRWAFER.ALIAS_WAFER_NAME as hALIAS_WAFER_NAME,\n" +
//                            "                    OHPRCRESWP.WAFER_POSITION as hWAFER_POSITION,\n" +
//                            "                    OHPRCRESWP.PROCRES_ID as hPROCRSC_ID,\n" +
//                            "                    '' as hACTION,\n" +
//                            "                    to_char(OHPRCRESWP.CHAMBER_PROC_TIME) as hPROC_TIME,\n" +
//                            "                    OHPRCRESWP.TRX_USER_ID as hCLAIM_USER_ID,\n" +
//                            "                    OHPRCRESWP.TRX_MEMO as hCLAIM_MEMO\n" +
//                            "            from OHPRCRESWP, FRWAFER\n" +
//                            "            where   1 = %s\n" +
//                            "            and    OHPRCRESWP.CJ_ID = %s\n" +
//                            "            and    OHPRCRESWP.WAFER_ID IN (\n" +
//                            "                select WAFER_ID from OHPJCHG_WAFER\n" +
//                            "            where PJ_ID = %s\n" +
//                            "            and TRX_TIME = %s)\n" +
//                            "            and    OHPRCRESWP.WAFER_ID = FRWAFER.WAFER_ID\n" +
//                            "            UNION ALL\n" +
//                            "            select\n" +
//                            "            %s as hTableName,\n" +
//                            "                    TRX_TIME as hCLAIM_TIME,\n" +
//                            "                    %s as hLOT_ID,\n" +
//                            "                PJ_ID as hPRCSJOB_ID,\n" +
//                            "                PROCESS_START_FLAG as hPRCS_ST,\n" +
//                            "                CUR_STATE as hCUR_STATE,\n" +
//                            "                '' as hWAFER_ID,\n" +
//                            "                '' as hALIAS_WAFER_NAME,\n" +
//                            "                '' as hWAFER_POSITION,\n" +
//                            "                '' as hPROCRSC_ID,\n" +
//                            "                OPE_CATEGORY as hACTION,\n" +
//                            "                '' as hPROC_TIME,\n" +
//                            "                TRX_USER_ID as hCLAIM_USER_ID,\n" +
//                            "                TRX_MEMO as hCLAIM_MEMO\n" +
//                            "            from OHPJCHG\n" +
//                            "            where   1 = %s\n" +
//                            "            and    OHPJCHG.CJ_ID = %s\n" +
//                            "            and    OHPJCHG.OPE_CATEGORY <> %s\n" +
//                            "            and    OHPJCHG.PJ_ID = %s\n" +
//                            "            UNION ALL\n" +
//                            "            select\n" +
//                            "            %s as hTableName,\n" +
//                            "                    TRX_TIME as hCLAIM_TIME,\n" +
//                            "                    %s as hLOT_ID,\n" +
//                            "                PJ_ID as hPRCSJOB_ID,\n" +
//                            "                PROCESS_START_FLAG as hPRCS_ST,\n" +
//                            "                '' as hCUR_STATE,\n" +
//                            "                '' as hWAFER_ID,\n" +
//                            "                '' as hALIAS_WAFER_NAME,\n" +
//                            "                '' as hWAFER_POSITION,\n" +
//                            "                '' as hPROCRSC_ID,\n" +
//                            "                '' as hACTION,\n" +
//                            "                '' as hPROC_TIME,\n" +
//                            "                TRX_USER_ID as hCLAIM_USER_ID,\n" +
//                            "                TRX_MEMO as hCLAIM_MEMO\n" +
//                            "            from OHPJCHG\n" +
//                            "            where   1 = %s\n" +
//                            "            and    OHPJCHG.CJ_ID = %s\n" +
//                            "            and    OHPJCHG.OPE_CATEGORY = %s\n" +
//                            "            and    OHPJCHG.PJ_ID = %s\n" +
//                            "            ORDER BY hCLAIM_TIME"
//                    , "\'" + hFHWCPHSTableName + "\'"
//                    , hFHWCPHSFlag == true ? 1 : 0
//                    , "\'" + hControlJobID + "\'"
//                    , "\'" + hProcessJobID + "\'"
//                    , "\'" + hFHPJCHSCLAIM_TIME + "\'"
//                    , "\'" + hFHPROCRSCWPOSTableName + "\'"
//                    , hFHPROCRSCWPOSFlag == true ? 1 : 0
//                    , "\'" + hControlJobID + "\'"
//                    , "\'" + hProcessJobID + "\'"
//                    , "\'" + hFHPJCHSCLAIM_TIME + "\'"
//                    ,"\'" + hFHPJCHS_RPARMTableName + "\'"
//                    ,StringUtils.isEmpty(hLotID_Select) ? "\'\'" : hLotID_Select
//                    , hFHPJCHS_PJFlag==true ? 1 : 0
//                    , "\'" + hControlJobID + "\'"
//                    , "\'" + hFHPJCHSOPE_CATEGORY_RPRM + "\'"
//                    , "\'" + hProcessJobID + "\'"
//                    , "\'" + hFHPJCHS_RPARMTableName + "\'"
//                    , StringUtils.isEmpty(hLotID_Select) ? "\'\'" : hLotID_Select
//                    , hFHPJCHS_RPARMFlag == true ? 1 : 0
//                    , "\'" + hControlJobID + "\'"
//                    , "\'" + hFHPJCHSOPE_CATEGORY_RPRM + "\'"
//                    , "\'" + hProcessJobID + "\'");
            Page<Object[]> queryPage = null;
            List<Object[]> lotProc2 = null;
            if (searchCondition!=null){
                queryPage = cimJpaRepository.query(sql, searchCondition);
                lotProc2=queryPage.getContent();
            }else{
                lotProc2=cimJpaRepository.query(sql);
            }


            int increasedDataLen = 100;
            int count = 0;

            List<Infos.TableRecordValue> strTableRecordValueSeq=new ArrayList<>();
            strLotProcessHistory_GetDR_out.setStrTableRecordValueSeq(strTableRecordValueSeq);
            int tableValueCount = 0;
            if (lotProc2!=null)
            for (Object[] obj:lotProc2) {
                hTableName  = "";
                hCLAIM_TIME  = "";
                hLOT_ID  = "";
                hPRCSJOB_ID  = "";
                hPRCS_ST  = "";
                hCUR_STATE  = "";
                hWAFER_ID  = "";
                hALIAS_WAFER_NAME  = "";
                hWAFER_POSITION  = "";
                hPROCRSC_ID  = "";
                hACTION  = "";
                hPROC_TIME  = "";
                hCLAIM_USER_ID  = "";
                hCLAIM_MEMO  = "";

                hTableName      = CimObjectUtils.toString(obj[0]);
                hCLAIM_TIME     = CimObjectUtils.toString(obj[1]);
                hLOT_ID         = CimObjectUtils.toString(obj[2]);
                hPRCSJOB_ID     = CimObjectUtils.toString(obj[3]);
                hPRCS_ST        = CimObjectUtils.toString(obj[4]);
                hCUR_STATE      = CimObjectUtils.toString(obj[5]);
                hWAFER_ID       = CimObjectUtils.toString(obj[6]);
                hALIAS_WAFER_NAME = CimObjectUtils.toString(obj[7]);
                hWAFER_POSITION = CimObjectUtils.toString(obj[8]);
                hPROCRSC_ID     = CimObjectUtils.toString(obj[9]);
                hACTION         = CimObjectUtils.toString(obj[10]);
                hPROC_TIME      = CimObjectUtils.toString(obj[11]);
                hCLAIM_USER_ID  = CimObjectUtils.toString(obj[12]);
                hCLAIM_MEMO     = CimObjectUtils.toString(obj[13]);

                if ( tableValueCount >= increasedDataLen ) {
                    increasedDataLen += 100;
                }

                if ( CimStringUtils.equals( hTableName, hFHWCPHSTableName) ) {
                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValue.setTableName ( hFHWCPHSTableName );
                    strTableRecordValue.setReportTimeStamp ( hCLAIM_TIME );

                    List<Object> columnValues=new ArrayList<>();
                    int columnCount = 0;
                    columnValues.add( hCLAIM_TIME );
                    columnCount++;
                    columnValues.add( hLOT_ID );
                    columnCount++;
                    columnValues.add( hWAFER_ID );
                    columnCount++;
                    columnValues.add( hALIAS_WAFER_NAME );
                    columnCount++;
                    columnValues.add( hPROCRSC_ID );
                    columnCount++;
                    columnValues.add( hACTION );
                    columnCount++;
                    columnValues.add( hPROC_TIME );
                    columnCount++;
                    columnValues.add( hCLAIM_USER_ID );
                    columnCount++;
                    columnValues.add( hCLAIM_MEMO );
                    columnCount++;

                    strTableRecordValue.setColumnValues (columnValues);
                    strTableRecordValueSeq.add(strTableRecordValue);
                    tableValueCount++;
                } else if ( CimStringUtils.equals( hTableName, hFHPROCRSCWPOSTableName) ) {
                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValue.setTableName ( hFHPROCRSCWPOSTableName );
                    strTableRecordValue.setReportTimeStamp ( hCLAIM_TIME );

                    List<Object> columnValues=new ArrayList<>();
                    int columnCount = 0;
                    columnValues.add( hCLAIM_TIME );
                    columnCount++;
                    columnValues.add( hLOT_ID );
                    columnCount++;
                    columnValues.add( hWAFER_ID );
                    columnCount++;
                    columnValues.add( hALIAS_WAFER_NAME );
                    columnCount++;
                    columnValues.add( hWAFER_POSITION );
                    columnCount++;
                    columnValues.add( hPROCRSC_ID );
                    columnCount++;
                    columnValues.add( hACTION );
                    columnCount++;
                    columnValues.add( hPROC_TIME );
                    columnCount++;
                    columnValues.add( hCLAIM_USER_ID );
                    columnCount++;
                    columnValues.add( hCLAIM_MEMO );
                    columnCount++;

                    strTableRecordValue.setColumnValues (columnValues);
                    strTableRecordValueSeq.add(strTableRecordValue);
                    tableValueCount++;
                } else if( CimStringUtils.equals(hTableName, hFHPJCHS_PJTableName) ) {
                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValue.setTableName ( hFHPJCHS_PJTableName );
                    strTableRecordValue.setReportTimeStamp ( hCLAIM_TIME );

                    List<Object> columnValues=new ArrayList<>();
                    int columnCount = 0;
                    columnValues.add( hCLAIM_TIME );
                    columnCount++;
                    columnValues.add( hLotID );
                    columnCount++;
                    columnValues.add( hPRCSJOB_ID );
                    columnCount++;
                    columnValues.add( hPRCS_ST );
                    columnCount++;
                    columnValues.add( hCUR_STATE );
                    columnCount++;
                    columnValues.add( hACTION );
                    columnCount++;
                    columnValues.add( hCLAIM_USER_ID );
                    columnCount++;
                    columnValues.add( hCLAIM_MEMO );
                    columnCount++;

                    strTableRecordValue.setColumnValues (columnValues);
                    strTableRecordValueSeq.add(strTableRecordValue);
                    tableValueCount++;
                } else if( CimStringUtils.equals(hTableName, hFHPJCHS_RPARMTableName) ) {
                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValue.setTableName ( hFHPJCHS_RPARMTableName );
                    strTableRecordValue.setReportTimeStamp ( hCLAIM_TIME );

                    List<Object> columnValues=new ArrayList<>();
                    int columnCount = 0;
                    columnValues.add( hCLAIM_TIME );
                    columnCount++;
                    columnValues.add( hLotID );
                    columnCount++;
                    columnValues.add( hPRCSJOB_ID );
                    columnCount++;
                    columnValues.add( hPRCS_ST );
                    columnCount++;
                    columnValues.add( hCLAIM_USER_ID );
                    columnCount++;
                    columnValues.add( hCLAIM_MEMO );
                    columnCount++;

                    strTableRecordValue.setColumnValues(columnValues);
                    strTableRecordValueSeq.add(strTableRecordValue);
                    tableValueCount++;
                }

            }
            if (searchCondition!=null){
                strLotProcessHistory_GetDR_out.setStrTableRecordValuePage(CimPageUtils.convertListToPage(strTableRecordValueSeq,searchCondition.getPage(),searchCondition.getSize(),queryPage.getTotalElements()));
            }
        }

        return strLotProcessHistory_GetDR_out;
    }

    @Override
    public Outputs.ObjLotQTimeGetDROut lotQTimeGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        String querySql = String.format("SELECT LOT_ID,\n" +
                "                   LOT_RKEY,\n" +
                "                   TRIGGER_PRP_ID,\n" +
                "                   TRIGGER_PRP_RKEY,\n" +
                "                   TRIGGER_OPE_NO,\n" +
                "                   TRIGGER_TIME,\n" +
                "                   TARGET_PRP_ID,\n" +
                "                   TARGET_PRP_RKEY,\n" +
                "                   TARGET_OPE_NO,\n" +
                "                   TARGET_TIME\n" +
                "            FROM   OMQT\n" +
                "            WHERE  TIMER_FLAG     = 1 \n" +
                "            AND    ACTION_COMPLETE_FLAG = 0 \n" +
                "            AND    LOT_ID           = '%s'\n" +
                "            AND    LOT_RKEY          = '%s'\n" +
                "            ORDER BY LOT_ID, TARGET_TIME", lotID.getValue(), lotID.getReferenceKey());
        List<CimQTimeDO> qTimeDOList = cimJpaRepository.query(querySql, CimQTimeDO.class);
        Outputs.ObjLotQTimeGetDROut objLotQTimeGetDROut = new Outputs.ObjLotQTimeGetDROut();
        List<Infos.LotQtimeInfo> strLotQtimeInfoList = new ArrayList<>();
        List<Infos.LotQtimeInfo> tmpQactionList = new ArrayList<>();
        objLotQTimeGetDROut.setStrLotQtimeInfoList(strLotQtimeInfoList);
        if (!CimArrayUtils.isEmpty(qTimeDOList)){
            for (CimQTimeDO cimQTimeDO : qTimeDOList){
                Infos.LotQtimeInfo lotQtimeInfo = new Infos.LotQtimeInfo();
                strLotQtimeInfoList.add(lotQtimeInfo);
                if (objLotQTimeGetDROut == null
                        || (objLotQTimeGetDROut != null && ObjectIdentifier.equalsWithValue(objLotQTimeGetDROut.getLotID(), cimQTimeDO.getLotID()))){
                    objLotQTimeGetDROut.setLotID(new ObjectIdentifier(cimQTimeDO.getLotID(), cimQTimeDO.getLotObj()));
                }
                lotQtimeInfo.setQrestrictionTriggerRouteID(new ObjectIdentifier(cimQTimeDO.getTriggerMainProcessDefinitionID(), cimQTimeDO.getTriggerMainProcessDefinitionObj()));
                lotQtimeInfo.setQrestrictionTriggerOperationNumber(cimQTimeDO.getTriggerOperationNumber());
                lotQtimeInfo.setQrestrictionTriggerTimeStamp(CimDateUtils.convertToSpecString(cimQTimeDO.getTriggerTime()));
                lotQtimeInfo.setQrestrictionTargetRouteID(new ObjectIdentifier(cimQTimeDO.getTargetMainProcessDefinitionID(), cimQTimeDO.getTargetMainProcessDefinitionObj()));
                lotQtimeInfo.setQrestrictionTargetOperationNumber(cimQTimeDO.getTargetOperationNumber());
                lotQtimeInfo.setQrestrictionTargetTimeStamp(CimDateUtils.convertToSpecString(cimQTimeDO.getTargetTime()));
                lotQtimeInfo.setWatchDogRequired("Y");
                lotQtimeInfo.setActionDoneFlag("N");
                if (CimObjectUtils.isEmpty(cimQTimeDO.getTargetTime()) || CimStringUtils.equals(cimQTimeDO.getTargetTime().toString(), BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING)){
                    lotQtimeInfo.setQrestrictionRemainTime("-");
                    tmpQactionList.add(lotQtimeInfo);
                } else {
                    //---------------------------------
                    //   Calcurate remain seconds
                    //---------------------------------
                    Timestamp aTimeStamp = cimQTimeDO.getTargetTime();
                    Timestamp aTmp = objCommon.getTimeStamp().getReportTimeStamp();
                    long aDuration = aTimeStamp.getTime() - aTmp.getTime();
                    double remainSeconds = Math.abs(aDuration / 1000);
                    if (CimDateUtils.compare(aTmp, aTimeStamp) > 0){
                        remainSeconds = -1 * remainSeconds;
                    }
                    lotQtimeInfo.setQrestrictionRemainTime(String.valueOf(remainSeconds));
                }
            }
        } else {
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundEntry()));
        }
        objLotQTimeGetDROut.setLotID(lotID);
        /********************************/
        /*  Append Q-actions if exists  */
        /********************************/
        if (!CimArrayUtils.isEmpty(tmpQactionList)){
            strLotQtimeInfoList.addAll(tmpQactionList);
        }
        objLotQTimeGetDROut.setStrLotQtimeInfoList(strLotQtimeInfoList);
        return objLotQTimeGetDROut;
    }
    @Override
    public void lotBondingGroupUpdateByOperation(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier controlJobID, List<Infos.StartCassette> strStartCassette, String operation) {
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentID);
        if (!CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERBONDING, eqpBrInfo.getEquipmentCategory()))
            return;

        //******************************************************************************************
        // Check Process
        //******************************************************************************************
        log.info("### Check Process ###############################################");
        List<Infos.BondingGroupInfo> strBondingGroupInfoSeq = new ArrayList<>();

        if (CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATION, operation) ||
                CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATIONFORSLM, operation)) {
            log.info("#### Check Process ### operation", operation);
            //----------------------------------------------------------------------------------//
            //   Check following items                                                          //
            //     1: All Start Lots in Start Cassette are reserved to Bonding Group.           //
            //     2: All Wafers in Start Lots are selected to start process.                   //
            //     3: All Wafers / Lots in Bonding Group are selected to start process.         //
            //     4: Input Equipment is the same as Target Equipment defined in Bonding Group. //
            //     5: Bonding Group State is SP_BondingGroupState_Created.                      //
            //----------------------------------------------------------------------------------//
            int bndGrpCnt = 0;
            int startWfrCnt = 0;
            //--------------------------------------------------------------------------------------//
            //   1: Check whether All Start Lots in Start Cassette are reserved to Bonding Group.   //
            //--------------------------------------------------------------------------------------//
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    // skip not start lot
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    //--------------------------------------------------------------------------------//
                    //   2: Check whether All Wafers in Start Lots are selected to start process.     //
                    //--------------------------------------------------------------------------------//
                    List<Infos.LotWafer> lotWaferList = lotInCassette.getLotWaferList();
                    for (Infos.LotWafer lotWafer : lotWaferList) {
                        Validations.check(CimBooleanUtils.isFalse(lotWafer.getProcessJobExecFlag()), retCodeConfig.getInvalidInputWafer());
                        startWfrCnt++;
                    }

                    // skip lot which is reserved to Bonding Group
                    boolean bReserved = false;
                    for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                        List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                        for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                            // check base lot
                            if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getBaseLotID(), lotInCassette.getLotID())) {
                                bReserved = true;
                                break;
                            }
                            // check top lot
                            if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getPlanTopLotID(), lotInCassette.getLotID())) {
                                bReserved = true;
                                break;
                            }
                        }
                        if (bReserved) {
                            break;
                        }
                    }
                    if (bReserved) {
                        log.info("This Lot is reserved to Bonding Group.");
                        continue;
                    }

                    //----------------------------------//
                    //   Get Bonding Group Information  //
                    //----------------------------------//
                    String bondingGroupID = this.lotBondingGroupIDGetDR(objCommon, lotInCassette.getLotID());
                    Validations.check(CimObjectUtils.isEmpty(bondingGroupID), retCodeConfig.getNotFoundBondingGroupForLot());

                    Outputs.ObjBondingGroupInfoGetDROut objBondingGroupInfoGetDROut = bondingGroupMethod.bondingGroupInfoGetDR(objCommon, bondingGroupID, true);
                    log.info("Bonding Group Found!");

                    // Set Bonding Group Information to list
                    if (bndGrpCnt >= strBondingGroupInfoSeq.size())
                        strBondingGroupInfoSeq.add(objBondingGroupInfoGetDROut.getBondingGroupInfo());
                    bndGrpCnt++;
                }
            }

            //----------------------------------------------------------------------------------------//
            //   3: Check whether All Wafers / Lots in Bonding Group are selected to start process.   //
            //----------------------------------------------------------------------------------------//
            int bndWfrCnt = 0;
            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                    if (!ObjectIdentifier.isEmpty(bondingMapInfo.getBaseWaferID()) && !ObjectIdentifier.isEmpty(bondingMapInfo.getPlanTopWaferID())) {
                        bndWfrCnt += 2;
                    }
                }

                //------------------------------------------------------------------------------------------------//
                //   4: Check whether Input Equipment is the same as Target Equipment defined in Bonding Group.   //
                //------------------------------------------------------------------------------------------------//
                if (ObjectIdentifier.isEmpty(bondingGroupInfo.getTargetEquipmentID())) {
                    bondingGroupInfo.setTargetEquipmentID(equipmentID);
                } else if (!ObjectIdentifier.equalsWithValue(bondingGroupInfo.getTargetEquipmentID(), equipmentID)) {
                    Validations.check(true, retCodeConfigEx.getBondgrpTargetEqpMismatch(),equipmentID.getValue(),bondingGroupInfo.getTargetEquipmentID().getValue(),bondingGroupInfo.getBondingGroupID());
                }

                //---------------------------------------------------------------------------//
                //   5: Check whether Bonding Group State is SP_BondingGroupState_Created.   //
                //---------------------------------------------------------------------------//
                Validations.check(!CimStringUtils.equals(BizConstant.SP_BONDINGGROUPSTATE_CREATED, bondingGroupInfo.getBondingGroupState()), new OmCode(retCodeConfigEx.getBondgrpStateInvalid(), bondingGroupInfo.getBondingGroupState(), operation));
            }
            Validations.check(bndWfrCnt != startWfrCnt, retCodeConfigEx.getBondgrpNotAllReserved());
        }

        if (CimStringUtils.equals(BizConstant.SP_OPERATION_STARTRESERVATIONCANCEL, operation)) {
            log.info("#### Check Process ### operation {}", operation);

            //----------------------------------//
            //   Get Bonding Group Information  //
            //----------------------------------//
            Outputs.ObjBondingGroupInfoByEqpGetDROut objBondingGroupInfoByEqpGetDROut = bondingGroupMethod.bondingGroupInfoByEqpGetDR(objCommon, equipmentID, controlJobID, false);
            strBondingGroupInfoSeq = objBondingGroupInfoByEqpGetDROut.getBondingGroupInfoList();
        }

        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_LOADINGLOT) ||
                CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART) ||
                CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTARTBYWAFER)) {
            log.info("#### Check Process ### operation {}", operation);
            Validations.check(ObjectIdentifier.isEmpty(controlJobID), new OmCode(retCodeConfigEx.getBondEqpCtrljobRequired()), operation);
        }

        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_LOADINGLOT)) {
            log.info("#### Check Process ### operation", operation);

            //----------------------------------------------------------------------------------//
            //   Check following items                                                          //
            //     1: All Start Lots in Start Cassette are reserved to Bonding Group.           //
            //     2: Input Equipment is the same as Target Equipment defined in Bonding Group. //
            //     3: Bonding Group State is SP_BondingGroupState_Reserved.                     //
            //----------------------------------------------------------------------------------//
            //--------------------------------------------------------------------------------------//
            //   1: Check whether All Start Lots in Start Cassette are reserved to Bonding Group.   //
            //--------------------------------------------------------------------------------------//
            //----------------------------------//
            //   Get Bonding Group Information  //
            //----------------------------------//
            Outputs.ObjBondingGroupInfoByEqpGetDROut objBondingGroupInfoByEqpGetDROut = bondingGroupMethod.bondingGroupInfoByEqpGetDR(objCommon, equipmentID, controlJobID, true);
            strBondingGroupInfoSeq = objBondingGroupInfoByEqpGetDROut.getBondingGroupInfoList();
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    // skip not start lot
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    int tmpBndGrpLen = 0;
                    for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                        List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                        for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                            if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getBaseLotID(), lotInCassette.getLotID())) {
                                tmpBndGrpLen++;
                                break;
                            }
                            if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getPlanTopLotID(), lotInCassette.getLotID())) {
                                tmpBndGrpLen++;
                                break;
                            }
                        }
                    }
                    Validations.check(tmpBndGrpLen != 1, retCodeConfig.getNotFoundBondingGroupForLot());
                }
            }

            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                //------------------------------------------------------------------------------------------------//
                //   2: Check whether Input Equipment is the same as Target Equipment defined in Bonding Group.   //
                //------------------------------------------------------------------------------------------------//
                Validations.check(ObjectIdentifier.isEmpty(bondingGroupInfo.getTargetEquipmentID()) || !ObjectIdentifier.equalsWithValue(bondingGroupInfo.getTargetEquipmentID(), equipmentID),
                        new OmCode(retCodeConfigEx.getBondgrpTargetEqpMismatch(), ObjectIdentifier.fetchValue(bondingGroupInfo.getTargetEquipmentID()), bondingGroupInfo.getBondingGroupID()));

                //---------------------------------------------------------------------------//
                //   3: Check whether Bonding Group State is SP_BondingGroupState_Reserved.  //
                //---------------------------------------------------------------------------//
                Validations.check(!CimStringUtils.equals(bondingGroupInfo.getBondingGroupState(), BizConstant.SP_BONDINGGROUPSTATE_RESERVED),
                        new OmCode(retCodeConfigEx.getBondgrpStateInvalid(), bondingGroupInfo.getBondingGroupState(), operation));
            }
        }

        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART) ||
                CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTARTBYWAFER)) {

            //----------------------------------------------------------------------------------//
            //   Check following items                                                          //
            //     1: All Start Lots in Start Cassette are reserved to Bonding Group.           //
            //     (If SP_Operation_OpeStart)                                                   //
            //     2: All Wafers in Start Lots are selected to start process.                   //
            //     (If SP_Operation_OpeStartByWafer)                                            //
            //     2: Start Wafers are Base Wafer and Top Wafer specified in Bonding Map.       //
            //     3: All Wafers / Lots in Bonding Group are selected to start process.         //
            //     4: Input Equipment is the same as Target Equipment defined in Bonding Group. //
            //     5: Bonding Group State is SP_BondingGroupState_Reserved.                     //
            //----------------------------------------------------------------------------------//
            int startWfrCnt = 0;

            //--------------------------------------------------------------------------------------//
            //   1: Check whether All Start Lots in Start Cassette are reserved to Bonding Group.   //
            //--------------------------------------------------------------------------------------//
            //----------------------------------//
            //   Get Bonding Group Information  //
            //----------------------------------//
            Outputs.ObjBondingGroupInfoByEqpGetDROut objBondingGroupInfoByEqpGetDROut = bondingGroupMethod.bondingGroupInfoByEqpGetDR(objCommon, equipmentID, controlJobID, true);
            strBondingGroupInfoSeq = objBondingGroupInfoByEqpGetDROut.getBondingGroupInfoList();
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    // skip not start lot
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    int tmpBndGrpLen = 0;
                    for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                        List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                        for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                            if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getBaseLotID(), lotInCassette.getLotID())) {
                                tmpBndGrpLen++;
                                break;
                            }
                            if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getPlanTopLotID(), lotInCassette.getLotID())) {
                                tmpBndGrpLen++;
                                break;
                            }
                        }
                    }
                    Validations.check(tmpBndGrpLen != 1, new OmCode(retCodeConfig.getNotFoundBondingGroupForLot(), ObjectIdentifier.fetchValue(lotInCassette.getLotID())));

                    List<Infos.LotWafer> lotWaferList = lotInCassette.getLotWaferList();
                    for (Infos.LotWafer lotWafer : lotWaferList) {
                        //--------------------------------------------------------------------------------//
                        //  If SP_Operation_OpeStart                                                      //
                        //   2: Check whether All Wafers in Start Lots are selected to start process.     //
                        //--------------------------------------------------------------------------------//
                        Validations.check(CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART) && CimBooleanUtils.isFalse(lotWafer.getProcessJobExecFlag()),
                                retCodeConfig.getInvalidInputWafer());
                        //----------------------------------------------------------------------------------------//
                        //  If SP_Operation_OpeStartByWafer                                                       //
                        //   2: Check whether Start Wafers are Base Wafer and Top Wafer specified in Bonding Map. //
                        //----------------------------------------------------------------------------------------//
                        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTARTBYWAFER) &&
                                CimBooleanUtils.isTrue(lotWafer.getProcessJobExecFlag())) {
                            // search target wafer
                            ObjectIdentifier targetWaferID = null;
                            boolean bFoundWafer = false;
                            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                                List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                                for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                                    if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getBaseWaferID(),
                                            lotWafer.getWaferID())) {
                                        targetWaferID = bondingMapInfo.getPlanTopWaferID();
                                        bFoundWafer = TRUE;
                                        break;
                                    }
                                    if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getPlanTopWaferID(),
                                            lotWafer.getWaferID())) {
                                        targetWaferID = bondingMapInfo.getBaseWaferID();
                                        bFoundWafer = true;
                                        break;
                                    }
                                }
                                if (bFoundWafer) {
                                    break;
                                }
                            }

                            // check whether processJobExecFlag of target wafer is TRUE
                            for (Infos.StartCassette startCassette1 : strStartCassette) {
                                List<Infos.LotInCassette> lotInCassetteList1 = startCassette1.getLotInCassetteList();
                                for (Infos.LotInCassette lotInCassette1 : lotInCassetteList1) {
                                    // skip not start lot
                                    if (CimBooleanUtils.isFalse(lotInCassette1.getMoveInFlag())) {
                                        continue;
                                    }

                                    List<Infos.LotWafer> lotWaferList1 = lotInCassette1.getLotWaferList();
                                    for (Infos.LotWafer wafer1 : lotWaferList1) {
                                        Validations.check(ObjectIdentifier.equalsWithValue(targetWaferID, wafer1.getWaferID()) && CimBooleanUtils.isFalse(wafer1.getProcessJobExecFlag()),
                                                retCodeConfig.getInvalidInputWafer());
                                    }
                                }
                            }
                        }
                        startWfrCnt++;
                    } // nWfr
                } // nLot
            } // nCast

            //----------------------------------------------------------------------------------------//
            //   3: Check whether All Wafers / Lots in Bonding Group are selected to start process.   //
            //----------------------------------------------------------------------------------------//
            int bndWfrCnt = 0;
            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                    if (!ObjectIdentifier.isEmpty(bondingMapInfo.getBaseWaferID()) && !ObjectIdentifier.isEmpty(bondingMapInfo.getPlanTopWaferID())) {
                        bndWfrCnt += 2;
                    }
                }

                //------------------------------------------------------------------------------------------------//
                //   4: Check whether Input Equipment is the same as Target Equipment defined in Bonding Group.   //
                //------------------------------------------------------------------------------------------------//
                Validations.check(ObjectIdentifier.isEmpty(bondingGroupInfo.getTargetEquipmentID()) || !ObjectIdentifier.equalsWithValue(bondingGroupInfo.getTargetEquipmentID(), equipmentID),
                        new OmCode(retCodeConfigEx.getBondgrpTargetEqpMismatch(), ObjectIdentifier.fetchValue(equipmentID), ObjectIdentifier.fetchValue(bondingGroupInfo.getTargetEquipmentID()), bondingGroupInfo.getBondingGroupID()));

                //---------------------------------------------------------------------------//
                //   5: Check whether Bonding Group State is SP_BondingGroupState_Reserved.   //
                //---------------------------------------------------------------------------//
                Validations.check(!CimStringUtils.equals(bondingGroupInfo.getBondingGroupState(), BizConstant.SP_BONDINGGROUPSTATE_RESERVED),
                        new OmCode(retCodeConfigEx.getBondgrpStateInvalid(), bondingGroupInfo.getBondingGroupState(), operation));
            }

            Validations.check(bndWfrCnt != startWfrCnt, retCodeConfig.getInvalidInputWafer());
        }

        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATION) ||
                CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATIONFORSLM) ||
                CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART) ||
                CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTARTBYWAFER)) {
            //----------------------------------//
            //   Check Bonding Map Consistency  //
            //----------------------------------//
            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                try {
                    bondingMapMethod.bondingMapInfoConsistencyCheck(objCommon, bondingGroupInfo.getBondingMapInfoList(), bondingGroupInfo.getTargetEquipmentID(), false);
                } catch (ServiceException ex) {
                    if (!Validations.isEquals(retCodeConfigEx.getNotSameRecipe(), ex.getCode())) throw ex;
                }

                //----------------------------------------------------------------------//
                //   Check Machine Recipe Consistency again because it might be changed //
                //----------------------------------------------------------------------//
                ObjectIdentifier baseLotID = null, topLotID = null;
                List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                    ObjectIdentifier baseMRID = null, topMRID = null;
                    if (ObjectIdentifier.equalsWithValue(bondingMapInfo.getBaseLotID(), baseLotID) &&
                            ObjectIdentifier.equalsWithValue(bondingMapInfo.getPlanTopLotID(), topLotID)) {
                        log.info("Same combination of Base Lot & Top Lot. Already checked. Skip..");
                        continue;
                    }
                    baseLotID = bondingMapInfo.getBaseLotID();
                    topLotID = bondingMapInfo.getPlanTopLotID();

                    for (Infos.StartCassette startCassette : strStartCassette) {
                        List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                        for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                            if (ObjectIdentifier.equalsWithValue(lotInCassette.getLotID(), baseLotID)) {
                                baseMRID = lotInCassette.getStartRecipe().getMachineRecipeID();
                            }
                            if (ObjectIdentifier.equalsWithValue(lotInCassette.getLotID(), topLotID)) {
                                topMRID = lotInCassette.getStartRecipe().getMachineRecipeID();
                            }
                            if (!ObjectIdentifier.isEmpty(baseMRID) && !ObjectIdentifier.isEmpty(topMRID)) {
                                break;
                            }
                        }
                    }
                    log.info("Machine Recipe for baseLot {} {}", baseLotID, baseMRID);
                    log.info("Machine Recipe for topLot {} {}", topLotID, topMRID);
                    Validations.check(!ObjectIdentifier.equalsWithValue(baseMRID, topMRID), new OmCode(retCodeConfigEx.getNotSameRecipe(), ObjectIdentifier.fetchValue(topLotID)));
                }
            }
            //------------------------------------------------------------//
            //   Check whether Top Lot would be included in Monitor Group //
            //------------------------------------------------------------//
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                        List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                        for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                            if (ObjectIdentifier.equalsWithValue(lotInCassette.getLotID(), bondingMapInfo.getPlanTopLotID())) {
                                // check if Top Lot is specified as monitoring lot in start cassette
                                Validations.check(CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag()) && CimBooleanUtils.isTrue(lotInCassette.getMonitorLotFlag()),
                                        new OmCode(retCodeConfigEx.getToplotSpecifiedAsMonitoringlot(), ObjectIdentifier.fetchValue(lotInCassette.getLotID())));

                                // check if Top Lot is included in monitor group as monitoring lot
                                CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotInCassette.getLotID());
                                Validations.check(CimObjectUtils.isEmpty(aLot), retCodeConfig.getNotFoundLot());
                                CimMonitorGroup controlMonitorGroup = aLot.getControlMonitorGroup();
                                Validations.check(!CimObjectUtils.isEmpty(controlMonitorGroup), retCodeConfigEx.getToplotSpecifiedAsMonitoringlot());

                                // check if Top Lot is included in monitor group as monitoring lot
                                List<CimMonitorGroup> strPosMonitorGroups = aLot.allMonitorGroups();
                                Validations.check(!CimObjectUtils.isEmpty(strPosMonitorGroups), retCodeConfigEx.getToplotIncludedInMonitorgroup(), aLot.getLotID().getValue());
                            }
                        }
                    }
                }
            }
            //--------------------------------------------------------------------------//
            //   Check MonitorLotCount and OperationStartLotCount again without Top Lot //
            //--------------------------------------------------------------------------//
            int nStartLotCnt = 0;
            int nMonitorLotCnt = 0;
            for (Infos.StartCassette startCassette : strStartCassette) {
                if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_PROCESSLOT)
                        || CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT)) {
                    List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                    for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                        if (CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag())) {
                            boolean bTopLot = false;
                            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                                List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                                for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                                    if (ObjectIdentifier.equalsWithValue(lotInCassette.getLotID(),
                                            bondingMapInfo.getPlanTopLotID())) {
                                        log.info("Lot is Top Lot.");
                                        bTopLot = TRUE;
                                        break;
                                    }
                                }
                                if (bTopLot) {
                                    break;
                                }
                            }
                            if (!bTopLot) {
                                log.info("Lot is Base Lot. Count as start lot for check.");
                                nStartLotCnt++;
                            }
                            if (CimBooleanUtils.isTrue(lotInCassette.getMonitorLotFlag())) {
                                nMonitorLotCnt++;
                            }
                        }
                    }
                }
            }
            Validations.check(nMonitorLotCnt == 1 && nStartLotCnt == 1, new OmCode(retCodeConfig.getInvalidInputLotCount(), String.valueOf(nStartLotCnt), "2", "n"));
        }

        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTARTCANCEL)) {
            //-----------------------------------------------------------------//
            //   Check whether Bonding Map Result has not been reported yet.   //
            //-----------------------------------------------------------------//
            log.info("Check whether Bonding Map Result has not been reported yet.");
            //----------------------------------//
            //   Get Bonding Group Information  //
            //----------------------------------//
            Outputs.ObjBondingGroupInfoByEqpGetDROut objBondingGroupInfoByEqpGetDROut = bondingGroupMethod.bondingGroupInfoByEqpGetDR(objCommon, equipmentID, controlJobID, true);
            strBondingGroupInfoSeq = objBondingGroupInfoByEqpGetDROut.getBondingGroupInfoList();
            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                    Validations.check(CimStringUtils.equals(bondingMapInfo.getBondingProcessState(), BizConstant.SP_BONDINGPROCESSSTATE_COMPLETED),
                            new OmCode(retCodeConfigEx.getAlreadyBondingMapResultReported(), ObjectIdentifier.fetchValue(bondingMapInfo.getBaseLotID()), ObjectIdentifier.fetchValue(bondingMapInfo.getBaseWaferID())));
                }
            }
        }

        //******************************************************************************************
        // Update Process
        //******************************************************************************************
        log.info("### Update Process ###############################################");
        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATION) ||
                CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATIONFORSLM)) {
            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                bondingGroupMethod.bondingGroupStateUpdateDR(objCommon, bondingGroupInfo.getBondingGroupID(), BizConstant.SP_BONDINGGROUPSTATE_RESERVED, bondingGroupInfo.getTargetEquipmentID(), controlJobID);
            }
        }

        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_STARTRESERVATIONCANCEL)) {
            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                bondingGroupMethod.bondingGroupStateUpdateDR(objCommon, bondingGroupInfo.getBondingGroupID(), BizConstant.SP_BONDINGGROUPSTATE_CREATED, bondingGroupInfo.getTargetEquipmentID(), null);
            }
        }

        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTART) ||
                CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTARTBYWAFER)) {
            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                bondingGroupMethod.bondingGroupStateUpdateDR(objCommon, bondingGroupInfo.getBondingGroupID(), BizConstant.SP_BONDINGGROUPSTATE_PROCESSED, null, null);
            }
        }

        if (CimStringUtils.equals(operation, BizConstant.SP_OPERATION_OPESTARTCANCEL)) {
            for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                bondingGroupMethod.bondingGroupStateUpdateDR(objCommon, bondingGroupInfo.getBondingGroupID(), BizConstant.SP_BONDINGGROUPSTATE_ERROR, null, null);
            }
        }
    }

    @Override
    public Outputs.ObjLotBondingOperationInfoGetDROut lotBondingOperationInfoGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLotDO example = new CimLotDO();
        example.setLotID(ObjectIdentifier.fetchValue(lotID));
        CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
        Validations.check(CimObjectUtils.isEmpty(lot), retCodeConfig.getNotFoundLot());
        Outputs.ObjLotBondingOperationInfoGetDROut objLotBondingOperationInfoGetDROut = new Outputs.ObjLotBondingOperationInfoGetDROut();
        objLotBondingOperationInfoGetDROut.setBondingFlowSectionName(lot.getBondFlowName());
        objLotBondingOperationInfoGetDROut.setProductID(new ObjectIdentifier(lot.getProductSpecificationID(), lot.getProductSpecificationObj()));

        String moduleNo = null, operationNo = null, processDefinitionID = null, processDefinitionObj = null;
        //---------------------------------------
        // Get Target Operation information
        //---------------------------------------
        String processOperationObj = lot.getProcessOperationObj();
        if (!CimObjectUtils.isEmpty(processOperationObj)) {
            CimProcessOperationDO processOperation = cimJpaRepository.queryOne("SELECT OMPROPE.ROUTE_NO, OMPROPE.ROUTE_PRF_RKEY, OMPROPE.MAIN_PROCESS_ID, OMPROPE.MAIN_PROCESS_RKEY, OMPROPE.OPE_NO, OMPROPE.STEP_ID, OMPROPE.STEP_RKEY FROM OMPROPE WHERE OMPROPE.ID = ?1", CimProcessOperationDO.class, processOperationObj);
            objLotBondingOperationInfoGetDROut.setTargetRouteID(new ObjectIdentifier(processOperation.getMainProcessDefinitionID(), processOperation.getMainProcessDefinitionObj()));
            moduleNo = processOperation.getModuleNumber();

            if (CimObjectUtils.isEmpty(objLotBondingOperationInfoGetDROut.getBondingFlowSectionName())) {
                objLotBondingOperationInfoGetDROut.setTargetOperationNumber(processOperation.getOperationNumber());
                objLotBondingOperationInfoGetDROut.setTargetOperationID(new ObjectIdentifier(processOperation.getProcessDefinitionID(), processOperation.getProcessDefinitionObj()));
            } else {
                CimProcessOperationSpecificationDO processOperationSpecification = cimJpaRepository.queryOne("select POS.OPE_NO, POS.STEP_ID, POS.STEP_RKEY from OMPRSS POS inner join OMPRF_PRSSSEQ POSLIST on POSLIST.PRSS_RKEY = POS.ID inner join OMPRF PF on PF.ID = POSLIST.REFKEY " +
                                "where PF.ID = ?1 and POS.SECTION_CONTROL = ?2 and POS.SECTION_NAME = ?3 and POS.SECTION_END_FLAG = 1",
                        CimProcessOperationSpecificationDO.class, processOperation.getModuleProcessFlowObj(), BizConstant.SP_FLOWSECTIONCONTROLCATEGORY_BONDINGFLOW, lot.getBondFlowName());

                if(CimObjectUtils.isEmpty(processOperationSpecification)){
                    return objLotBondingOperationInfoGetDROut;
                }
                operationNo = processOperationSpecification.getOperationNumber();
                processDefinitionID = processOperationSpecification.getProcessDefinitionID();
                processDefinitionObj = processOperationSpecification.getProcessDefinitionObj();
                //----------------------------------------------------------------------
                //   Getting Active Version of Route
                //----------------------------------------------------------------------
                String version = BaseStaticMethod.extractVersionFromID(processDefinitionID);
                if (CimStringUtils.equals(version, BizConstant.SP_ACTIVE_VERSION)) {
                    log.debug("Operation is Version Controlled");
                    CimProcessDefinitionDO processDefinition = cimJpaRepository.queryOne("select OPEPD.ACTIVE_VER_ID, OPEPD.ACTIVE_VER_RKEY from OMPRP OPEPD where OPEPD.PRP_ID = ?1 and OPEPD.PRP_LEVEL = ?2",
                            CimProcessDefinitionDO.class, processDefinitionID, BizConstant.SP_PD_FLOWLEVEL_OPERATION);
                    processDefinitionID = processDefinition.getActiveID();
                    processDefinitionObj = processDefinition.getActiveObj();
                }

                objLotBondingOperationInfoGetDROut.setTargetOperationNumber(BaseStaticMethod.convertModuleOpeNoToOpeNo(moduleNo, operationNo));
                objLotBondingOperationInfoGetDROut.setTargetOperationID(new ObjectIdentifier(processDefinitionID, processDefinitionObj));
            }

        }
        return objLotBondingOperationInfoGetDROut;
    }

    @Override
    public Outputs.ObjLotEffectiveFPCInfoForOperationGetOut lotEffectiveFPCInfoForOperationGet(Infos.ObjCommon objCommon, String exchangeType, ObjectIdentifier equipmentID, ObjectIdentifier lotID, ObjectIdentifier routeID, String operationNumber) {
        Outputs.ObjLotEffectiveFPCInfoForOperationGetOut objLotEffectiveFPCInfoForOperationGetOut = new Outputs.ObjLotEffectiveFPCInfoForOperationGetOut();
        // Null EqpID Request or not?
        boolean nullEQPRequest = false;
        if (ObjectIdentifier.isEmpty(equipmentID)) {
            log.info("Input EquipmentID is NULL");
            nullEQPRequest = true;
        }

        // Check Adopt Flag
        String tmpFPCAdoptFlag = StandardProperties.OM_DOC_ENABLE_FLAG.getValue();
        if (Integer.valueOf(tmpFPCAdoptFlag) != 1) return objLotEffectiveFPCInfoForOperationGetOut;

        // Exchange control Flags
        boolean EquipmentRequest = false;
        boolean MachineRecipeRequest = false;
        boolean RecipeParameterRequest = false;
        boolean ReticleRequest = false;
        boolean DCDefRequest = false;
        boolean DCSpecRequest = false;
        boolean CorrespondOpeRequest = false;

        if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEINFO)) {
            MachineRecipeRequest = true;
            RecipeParameterRequest = true;
        } else if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEREQ)) {
            DCDefRequest = true;
            DCSpecRequest = true;
            ReticleRequest = true;
        } else if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_OPECOMPREQ)) {
            CorrespondOpeRequest = true;
        } else if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_ALL)) {
            MachineRecipeRequest = true;
            RecipeParameterRequest = true;
            DCDefRequest = true;
            DCSpecRequest = true;
            ReticleRequest = true;
        } else if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_BONDINGGROUP)) {
            EquipmentRequest = true;
            MachineRecipeRequest = true;
        } else {
            Validations.check(retCodeConfig.getInvalidParameter());
        }

        //------------------------------------------------------
        // Get DOC Information at Specified operation.
        //------------------------------------------------------
        Inputs.ObjLotFPCInfoForOperationGetIn operationGetIn = new Inputs.ObjLotFPCInfoForOperationGetIn();
        operationGetIn.setWaferIDInfoGetFlag(true);
        operationGetIn.setRecipeParmInfoGetFlag(RecipeParameterRequest);
        operationGetIn.setReticleInfoGetFlag(ReticleRequest);
        operationGetIn.setDcSpecItemInfoGetFlag(DCSpecRequest);
        operationGetIn.setCorresOpeInfoGetFlag(CorrespondOpeRequest);
        operationGetIn.setLotID(lotID);
        operationGetIn.setEquipmentID(equipmentID);
        operationGetIn.setRouteID(routeID);
        operationGetIn.setOperationNumber(operationNumber);
        List<Infos.FPCInfo> fpcInfos = lotFPCInfoForOperationGet(objCommon, operationGetIn);
        int FPCInfoCount = CimArrayUtils.getSize(fpcInfos);
        if (0 == FPCInfoCount) {
            // DOC Info does not exist. now return OK and do nothing.
            return objLotEffectiveFPCInfoForOperationGetOut;
        }

        // check FPCInfo consistency
        List<Infos.FPCDispatchEqpInfo> fpcDispatchEqpInfos = fpcMethod.fpcInfoConsistencyCheck(objCommon, fpcInfos, operationGetIn.getRecipeParmInfoGetFlag(), operationGetIn.getDcSpecItemInfoGetFlag());
        log.info("FPCInfo's consistency check is OK.");


        // Extract effective FPCInfo

        // at first, count groups in FPCInfo.
        int groupCount = CimArrayUtils.getSize(fpcDispatchEqpInfos);

        // next, extract effective FPCInfo.
        //   Acquired FPCInfo's equipmentID is "" or input equipmentID.
        //   If both of them exists, equipmentID filled FPCInfo has priority over blank one. - if input equipmentID is filled.
        List<Infos.FPCInfo> strEffectiveFPCInfoList = new ArrayList<>();
        int effectiveFPCInfoCount = 0;
        for (int i = 0; i < FPCInfoCount; i++) {
            int j = 0;
            boolean toBeAdded = true;
            Infos.FPCInfo fpcInfo = fpcInfos.get(i);
            for (j = 0; j < effectiveFPCInfoCount; j++) {
                if (fpcInfo.getFpcGroupNumber() == strEffectiveFPCInfoList.get(j).getFpcGroupNumber()) {
                    toBeAdded = false;  // to be replace case.
                    break;
                }
            }

            if (toBeAdded) {
                strEffectiveFPCInfoList.add(fpcInfo);
                effectiveFPCInfoCount++;
            } else if (!nullEQPRequest && ObjectIdentifier.equalsWithValue(fpcInfo.getEquipmentID(), equipmentID)) {
                strEffectiveFPCInfoList.set(j, fpcInfo);
            } else {
                Infos.FPCInfo fpcInfoJ = strEffectiveFPCInfoList.get(j);
                fpcInfoJ.setFpcID("");

                // following 'Merge' logics must be taken place at the first time.
                if (ObjectIdentifier.isEmpty(fpcInfoJ.getMachineRecipeID())) {
                    log.info("    Merge GroupData : MachineRecipe");
                    fpcInfoJ.setMachineRecipeID(fpcInfo.getMachineRecipeID());
                }

                if (CimObjectUtils.isEmpty(fpcInfoJ.getRecipeParameterChangeType())) {
                    log.info("    Merge GroupData : RecipeParameter");
                    fpcInfoJ.setRecipeParameterChangeType(fpcInfo.getRecipeParameterChangeType());
                    fpcInfoJ.setLotWaferInfoList(fpcInfo.getLotWaferInfoList());
                }

                if (CimObjectUtils.isEmpty(fpcInfoJ.getReticleInfoList())) {
                    log.info("    Merge GroupData : Reticle");
                    fpcInfoJ.setReticleInfoList(fpcInfo.getReticleInfoList());
                }

                if (ObjectIdentifier.isEmpty(fpcInfoJ.getDcDefineID())) {
                    log.info("    Merge GroupData : dcDef");
                    fpcInfoJ.setDcDefineID(fpcInfo.getDcDefineID());
                }

                if (ObjectIdentifier.isEmpty(fpcInfoJ.getDcSpecID())) {
                    log.info("    Merge GroupData : dcSpec");
                    fpcInfoJ.setDcSpecID(fpcInfo.getDcSpecID());
                    fpcInfoJ.setDcSpecList(fpcInfo.getDcSpecList());
                }

                if (CimObjectUtils.isEmpty(fpcInfoJ.getCorrespondOperationNumber())) {
                    log.info("    Merge GroupData : correspondingOpeNo");
                    fpcInfoJ.setCorrespondOperationNumber(fpcInfo.getCorrespondOperationNumber());
                }

                if (CimObjectUtils.isEmpty(fpcInfoJ.getCorrespondingOperationInfoList())) {
                    log.info("    Merge GroupData : CorrespondingOperation");
                    fpcInfoJ.setCorrespondingOperationInfoList(fpcInfo.getCorrespondingOperationInfoList());
                }
            }
        }

        // Note : effectiveFPCInfoCount must be equal to groupCount...

        if (0 == effectiveFPCInfoCount) {
            // Effective DOC Info does not exist. now return RC_OK and do nothing.
            return objLotEffectiveFPCInfoForOperationGetOut;
        }

        // Get Wafers in Lot
        List<Infos.LotWaferAttributes> lotWaferAttributes = lotMaterialsGetWafers(objCommon, lotID);
        int waferCountInLot = CimArrayUtils.getSize(lotWaferAttributes);
        if (0 == waferCountInLot)
        {
            return objLotEffectiveFPCInfoForOperationGetOut;
        }

        List<ObjectIdentifier> lotWaferIDList = lotWaferAttributes.stream().map(Infos.LotWaferAttributes::getWaferID).collect(Collectors.toList());

        // Find the FPCInfo which used by the lot wafer,
        // and check the using FPCInfo is same all over the lot wafer
        List<Integer> usedFPCInfoByWafer = new ArrayList<>();
        for (int i = 0; i < lotWaferAttributes.size(); i++) {
            usedFPCInfoByWafer.add(-1);
            int j = 0;
            for (j = 0; j < effectiveFPCInfoCount; j++) {
                int waferCountInFPCInfo = CimArrayUtils.getSize(strEffectiveFPCInfoList.get(j).getLotWaferInfoList());
                int k = 0;
                for (k = 0; k < waferCountInFPCInfo; k++) {
                    if (ObjectIdentifier.equalsWithValue(lotWaferIDList.get(i), strEffectiveFPCInfoList.get(j).getLotWaferInfoList().get(k).getWaferID())) {
                        usedFPCInfoByWafer.set(i, j);
                        break;
                    }
                }
                if (usedFPCInfoByWafer.get(i) >= 0) {
                    break;  // to the next wafer
                }
            }
        }

        int usedFPCInfo = -1;    //initialize
        if (!nullEQPRequest) {
            // compare usedFPCInfo for all wafers in lot.
            log.info("Check Wafer-Group relation.");
            usedFPCInfo = usedFPCInfoByWafer.get(0);
            boolean uniqueFPCInfo = true;
            for (int i = 1; i < waferCountInLot; i++) {
                if (usedFPCInfo != usedFPCInfoByWafer.get(i)) {
                    uniqueFPCInfo = false;
                    break;
                }
            }
            Validations.check(!uniqueFPCInfo, retCodeConfig.getFpcWaferMismatchInFpcGroup());
        } else {
            log.info("Merge All usedFPCInfo by wafers.");
            List<Infos.RecipeParameterInfo> RecipeParamMerged = new ArrayList<>();
            Infos.FPCInfo FPCInfoMerged = new Infos.FPCInfo();
            List<Integer> mergedFPCInfoNo = new ArrayList<>();
            int mergedCount = 0;

            List<ObjectIdentifier> FPCUseWaferIDList = new ArrayList<>();
            int FPCUseWaferCount = 0;

            usedFPCInfo = -1;    //Initialize
            for (int i = 0; i < waferCountInLot; i++) {
                if (0 > usedFPCInfoByWafer.get(i)) {
                    continue;
                }


                // add Wafers to List which uses FPCInfo
                FPCUseWaferIDList.add(FPCUseWaferCount, lotWaferIDList.get(i));
                FPCUseWaferCount++;

                Infos.FPCInfo fpcInfoUsed = strEffectiveFPCInfoList.get(usedFPCInfoByWafer.get(i));
                if (-1 == usedFPCInfo) {
                    usedFPCInfo = 0;
                    FPCInfoMerged = fpcInfoUsed;
                    RecipeParamMerged = fpcInfoUsed.getLotWaferInfoList().get(0).getRecipeParameterInfoList();
                    mergedFPCInfoNo.add(mergedCount, usedFPCInfoByWafer.get(i));
                    mergedCount++;
                } else {
                    int j = 0;
                    for (j = 0; j < mergedCount; j++) {
                        if (Objects.equals(mergedFPCInfoNo.get(j), usedFPCInfoByWafer.get(i))) {
                            break;
                        }
                    }
                    if (j != mergedCount) {
                        continue;  //to the next wafer;
                    }

                    mergedFPCInfoNo.add(mergedCount, usedFPCInfoByWafer.get(i));
                    mergedCount++;

                    FPCInfoMerged.setFpcID("");

                    //Machine Recipe
                    if (ObjectIdentifier.isEmpty(FPCInfoMerged.getMachineRecipeID())) {
                        FPCInfoMerged.setMachineRecipeID(fpcInfoUsed.getMachineRecipeID());
                    }

                    //Recipe Parameter
                    if (CimObjectUtils.isEmpty(FPCInfoMerged.getRecipeParameterChangeType())) {
                        FPCInfoMerged.setRecipeParameterChangeType(fpcInfoUsed.getRecipeParameterChangeType());
                        RecipeParamMerged = fpcInfoUsed.getLotWaferInfoList().get(0).getRecipeParameterInfoList();
                    }

                    //Reticle
                    if (CimObjectUtils.isEmpty(FPCInfoMerged.getReticleInfoList())) {
                        FPCInfoMerged.setReticleInfoList(fpcInfoUsed.getReticleInfoList());
                    }

                    //DCDef
                    if (ObjectIdentifier.isEmpty(FPCInfoMerged.getDcDefineID())) {
                        FPCInfoMerged.setDcDefineID(fpcInfoUsed.getDcDefineID());
                    }

                    //DCSpec
                    if (ObjectIdentifier.isEmpty(FPCInfoMerged.getDcSpecID())) {
                        FPCInfoMerged.setDcSpecID(fpcInfoUsed.getDcSpecID());
                        FPCInfoMerged.setDcSpecList(fpcInfoUsed.getDcSpecList());
                    }

                    //Corresponding Operation
                    if (CimObjectUtils.isEmpty(FPCInfoMerged.getCorrespondOperationNumber())) {
                        FPCInfoMerged.setCorrespondOperationNumber(fpcInfoUsed.getCorrespondOperationNumber());
                    }

                    if (CimObjectUtils.isEmpty(FPCInfoMerged.getCorrespondingOperationInfoList())) {
                        FPCInfoMerged.setCorrespondingOperationInfoList(fpcInfoUsed.getCorrespondingOperationInfoList());
                    }
                }
            }
            if (0 == usedFPCInfo) {
                for (int i = 0; i < FPCUseWaferCount; i++) {
                    FPCInfoMerged.getLotWaferInfoList().get(i).setWaferID(FPCUseWaferIDList.get(i));
                    FPCInfoMerged.getLotWaferInfoList().get(i).setRecipeParameterInfoList(RecipeParamMerged);
                }
                strEffectiveFPCInfoList.set(0, FPCInfoMerged);
            }
        }

        if (usedFPCInfo < 0) //it is -1 when effective FPCInfo not found.
        {
            return objLotEffectiveFPCInfoForOperationGetOut;
        }


        // set the selected FPCInfo for output.
        Infos.FPCInfo fpcInfoUsedFPC = strEffectiveFPCInfoList.get(usedFPCInfo);
        objLotEffectiveFPCInfoForOperationGetOut.setStrFPCInfo(fpcInfoUsedFPC);
        // Check the items of fpcInfoUsedFPC before use it for exchange.

        if (EquipmentRequest) {
            log.info("Equipment Exchange requested.");

            if (!ObjectIdentifier.isEmpty(fpcInfoUsedFPC.getEquipmentID())) {
                objLotEffectiveFPCInfoForOperationGetOut.setEquipmentActionRequired(true);
            } else {
                log.info("Equipment will not be changed.");
            }
        }

        if (MachineRecipeRequest) {
            log.info("MachineRecipe Exchange requested.");

            if (!ObjectIdentifier.isEmpty(fpcInfoUsedFPC.getMachineRecipeID())) {
                objLotEffectiveFPCInfoForOperationGetOut.setMachineRecipeActionRequired(true);
            } else {
                log.info("MachineRecipe will not be changed.");
            }
        }

        if (RecipeParameterRequest) {
            log.info("RecipeParameter Exchange requested.");
            // All wafers in group must have same recipeParameter Name.(But the value or order might be different when paramChangeType is "ByWafer")
            // That is already checked in FPC_infoConsistency_Check()
            if (!CimObjectUtils.isEmpty(fpcInfoUsedFPC.getRecipeParameterChangeType())) {
                int tmpWaferCount = CimArrayUtils.getSize(fpcInfoUsedFPC.getLotWaferInfoList());

                Validations.check(tmpWaferCount == 0, retCodeConfig.getSystemError());

                int tmpRecipeParamCount = CimArrayUtils.getSize(fpcInfoUsedFPC.getLotWaferInfoList().get(0).getRecipeParameterInfoList());
                if (!nullEQPRequest)    // recipe parameter check requires input EquipmentID.
                {
                    log.info("RecipeParameter Check start.");
                    List<String> recipeParamNameList = new ArrayList<>();
                    for (int i = 0; i < tmpRecipeParamCount; i++) {
                        recipeParamNameList.add(fpcInfoUsedFPC.getLotWaferInfoList().get(0).getRecipeParameterInfoList().get(i).getParameterName());
                    }

                    fpcMethod.fpcRecipeParameterConsistencyCheck(objCommon, equipmentID, recipeParamNameList);
                    log.info("RecipeParameter Check ok.");
                }
                log.info("RecipeParameter action Required.");
                objLotEffectiveFPCInfoForOperationGetOut.setRecipeParameterActionRequired(true);
            } else {
                log.info("RecipeParameter will not be changed.");
            }
        }

        if (ReticleRequest) {
            int FPCReticleCount = CimArrayUtils.getSize(fpcInfoUsedFPC.getReticleInfoList());
            if (FPCReticleCount > 0) {
                log.info("Reticle will be changed.");
                objLotEffectiveFPCInfoForOperationGetOut.setReticleActionRequired(true);
            } else {
                log.info("There is no DOC Reticle. Not be exchanged.");
            }
        }

        if (DCDefRequest) {
            log.info("DCDef Exchange requested.");
            if (!ObjectIdentifier.isEmpty(fpcInfoUsedFPC.getDcDefineID())) {
                objLotEffectiveFPCInfoForOperationGetOut.setDcDefActionRequired(true);

                // check delta dcDef
                if (CimStringUtils.equals(exchangeType, BizConstant.SP_FPC_EXCHANGETYPE_STARTRESERVEREQ)) {
                    Results.EDCPlanInfoInqResult edcPlanInfoInqResult = dataCollectionMethod.dcDefDetailInfoGetDR(objCommon, fpcInfoUsedFPC.getDcDefineID());
                    List<Infos.DCItem> strDCItemList = edcPlanInfoInqResult.getStrDCItemList();

                    for (Infos.DCItem dcItem : strDCItemList) {
                        Validations.check(CimStringUtils.equals(dcItem.getCalculationType(), BizConstant.SP_DCDEF_CALC_DELTA), retCodeConfig.getFpcInvalidDcinfo(), fpcInfoUsedFPC.getDcDefineID());
                    }
                }
            } else {
                log.info("DCDef will not be changed");
            }
        }

        if (DCSpecRequest) {
            log.info("DCSpec Exchange requested.");
            int FPCDCSpecItemCount = CimArrayUtils.getSize(fpcInfoUsedFPC.getDcSpecList());

            if (!ObjectIdentifier.isEmpty(fpcInfoUsedFPC.getDcSpecID()) && 0 != FPCDCSpecItemCount) {
                log.info("DCSpec and the Item found in FPCInfo. They will be override the startCassette's one. Now check them.");
                if (!nullEQPRequest) {
                    log.info("DCSpec Item Check start.");
                    List<String> dcSpecItemNameList = new ArrayList<>();
                    for (int i = 0; i < FPCDCSpecItemCount; i++) {
                        dcSpecItemNameList.add(fpcInfoUsedFPC.getDcSpecList().get(i).getDataItemName());
                    }

                    fpcMethod.fpcDcSpecItemConsistencyCheck(objCommon, fpcInfoUsedFPC.getDcSpecID(), dcSpecItemNameList);

                    log.info("DCSpec check ok.");
                }
                log.info("DCSpec Action Required.");
                objLotEffectiveFPCInfoForOperationGetOut.setDcSpecActionRequired(true);
            } else {
                log.info("DCSpecID or (and) DCSpecItem of FPCInfo are not filled. Not be changed.");
            }
        }

        if (CorrespondOpeRequest) {
            log.info("Exchange Corresponding Operation");
            if (!CimObjectUtils.isEmpty(fpcInfoUsedFPC.getCorrespondOperationNumber())) {
                objLotEffectiveFPCInfoForOperationGetOut.setCorrespondingOperationActionRequired(true);
            } else {
                log.info("Corresponding Operation Number is not filled. Not be changed.");
            }
            int FPCCorresCount = CimArrayUtils.getSize(fpcInfoUsedFPC.getCorrespondingOperationInfoList());

            log.info("CorrespondingOperationInfo Count", FPCCorresCount);
            if (FPCCorresCount > 0) {
                log.info("Multiple Corresponding Operation Info will be changed.");
                objLotEffectiveFPCInfoForOperationGetOut.setMultipleCorrespondingOperationActionRequired(true);
            } else {
                log.info("There is no DOC Multiple Corresponding Operation Info. Not be exchanged.");
            }
        }
        return objLotEffectiveFPCInfoForOperationGetOut;
    }

    @Override
    public Infos.FPCDispatchEqpInfo lotFPCdispatchEqpInfoGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier routeID, String operationNumber) {
        Infos.FPCDispatchEqpInfo tmpInfo = new Infos.FPCDispatchEqpInfo();
        tmpInfo.setDispatchEqpIDs(new ArrayList<>());
        tmpInfo.setWaferIDs(new ArrayList<>());
        tmpInfo.setRestrictEqpFlag(false);

        // Check Adopt Flag
        if (!CimStringUtils.equals(StandardProperties.OM_DOC_ENABLE_FLAG.getValue(),"1")) {
            return tmpInfo;
        }

        //------------------------------------------------------
        // Get DOC Information at Specified operation.
        //------------------------------------------------------
        Inputs.ObjLotFPCInfoForOperationGetIn operationGetIn = new Inputs.ObjLotFPCInfoForOperationGetIn();
        operationGetIn.setWaferIDInfoGetFlag(true);
        operationGetIn.setRecipeParmInfoGetFlag(false);
        operationGetIn.setReticleInfoGetFlag(false);
        operationGetIn.setDcSpecItemInfoGetFlag(false);
        operationGetIn.setCorresOpeInfoGetFlag(false);
        operationGetIn.setLotID(lotID);
        operationGetIn.setRouteID(routeID);
        operationGetIn.setOperationNumber(operationNumber);
        List<Infos.FPCInfo> fpcInfos = lotFPCInfoForOperationGet(objCommon, operationGetIn);

        if (CimObjectUtils.isEmpty(fpcInfos)) {
            // DOC Info does not exist. now return OK and do nothing.
            return tmpInfo;
        }


        // check FPCInfo consistency
        List<Infos.FPCDispatchEqpInfo> fpcDispatchEqpInfos = fpcMethod.fpcInfoConsistencyCheck(objCommon, fpcInfos, operationGetIn.getRecipeParmInfoGetFlag(), operationGetIn.getDcSpecItemInfoGetFlag());
        int groupCount = CimArrayUtils.getSize(fpcDispatchEqpInfos);

        // Get Wafers in Lot
        List<Infos.LotWaferAttributes> lotWaferAttributes = lotMaterialsGetWafers(objCommon, lotID);
        int waferCountInLot = CimArrayUtils.getSize(lotWaferAttributes);

        if (CimObjectUtils.isEmpty(lotWaferAttributes)) {
            return tmpInfo;
        }

        // Find the FPCDispatchEqpInfo which used by the lot wafer,
        // and check the using FPCDispatchEqpInfo is same all over the lot wafer
        List<Integer> usedInfoByWafer = new ArrayList<>();
        for (int i = 0; i < waferCountInLot; i++) {
            usedInfoByWafer.add(-1);
            int j;
            for (j = 0; j < groupCount; j++) {
                int waferCountInInfo = CimArrayUtils.getSize(fpcDispatchEqpInfos.get(j).getWaferIDs());
                int k = 0;
                for (k = 0; k < waferCountInInfo; k++) {
                    if (ObjectIdentifier.equalsWithValue(lotWaferAttributes.get(i).getWaferID(), fpcDispatchEqpInfos.get(j).getWaferIDs().get(k))) {
                        usedInfoByWafer.set(i, j);
                        break;
                    }
                }
                if (usedInfoByWafer.get(i) >= 0) {
                    break;  // to the next wafer
                }
            }
        }

        // compare usedFPCInfo for all wafers in lot.
        log.info("Check Wafer-Group relation.");

        int usedInfo = usedInfoByWafer.get(0);
        boolean uniqueInfo = true;
        for (int i = 1; i < waferCountInLot; i++) {
            if (usedInfo != usedInfoByWafer.get(i)) {
                uniqueInfo = false;
                break;
            }
        }

        Validations.check(!uniqueInfo, retCodeConfig.getFpcWaferMismatchInFpcGroup());
        if (usedInfo < 0) //it is -1 when effective FPCInfo not found.
        {
            return tmpInfo;
        }
        return fpcDispatchEqpInfos.get(usedInfo);
    }

    @Override
    public List<Infos.FPCInfo> lotFPCInfoForOperationGet(Infos.ObjCommon objCommon, Inputs.ObjLotFPCInfoForOperationGetIn objLotFPCInfoForOperationGetIn) {
        List<Infos.FPCInfo> fpcInfos = new ArrayList<>();

        ObjectIdentifier lotID = objLotFPCInfoForOperationGetIn.getLotID();
        ObjectIdentifier routeID = objLotFPCInfoForOperationGetIn.getRouteID();
        String operationNumber = objLotFPCInfoForOperationGetIn.getOperationNumber();

        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(aLot), retCodeConfig.getNotFoundLot());

        // FPC_info_GetDR call parameters
        List<String> dummyFPCIDs = new ArrayList<>();
        ObjectIdentifier currentMainPDID = null, originalMainPDID = null, subOrigMainPDID = null;
        String currentOpeNo = null, originalOpeNo = null, subOrigOpeNo = null;

        // Get Lot's current mainPD ID
        com.fa.cim.newcore.bo.pd.CimProcessDefinition currentMainPD = aLot.getMainProcessDefinition();
        Validations.check(CimObjectUtils.isEmpty(currentMainPD), retCodeConfig.getNotFoundMainRoute());
        currentMainPDID = new ObjectIdentifier(currentMainPD.getIdentifier(), currentMainPD.getPrimaryKey());

        Validations.check(!ObjectIdentifier.isEmpty(routeID) && !ObjectIdentifier.equalsWithValue(routeID, currentMainPDID), retCodeConfig.getInvalidInputParam());

        if (!CimObjectUtils.isEmpty(operationNumber)) {
            currentOpeNo = operationNumber;
        } else {
            currentOpeNo = aLot.getOperationNumber();
        }

        // Get Lot's original routeID and OpeNo
        com.fa.cim.newcore.bo.pd.CimProcessFlowContext aPFX = aLot.getProcessFlowContext();
        Validations.check(CimObjectUtils.isEmpty(aPFX), retCodeConfig.getNotFoundPfx());

        List<ProcessDTO.BackupOperation> backupPOListPtr = aPFX.allBackupOperations();
        int branchNestLevel = CimArrayUtils.getSize(backupPOListPtr);
        if (branchNestLevel > 2) {
        } else {
            log.info("branchNestLevel OK.");
            String tmpPDIDStr, tmpOpeNoStr;

            for (int level = 0; level < branchNestLevel; level++) {
                String reworkOutKey = backupPOListPtr.get(level).getReworkOutKey();
                if (!CimObjectUtils.isEmpty(reworkOutKey)) {
                    log.info("This Lot is reworked on level");

                    //===== Divide reworkOutKey to RouteID and OpeNo =======//
                    //reworkOutKey = "MainPD ID" + '.' + "MainPD Version" + '.' + "Module No" + '.' + "Module OpeNo"
                    String[] split = reworkOutKey.split(".");
                    tmpPDIDStr = split[0] + "." + split[1];
                    tmpOpeNoStr = split[2] + "." + split[3];
                } else {
                    com.fa.cim.newcore.bo.pd.CimProcessOperation aPO = baseCoreFactory.getBO(com.fa.cim.newcore.bo.pd.CimProcessOperation.class, new ObjectIdentifier(backupPOListPtr.get(level).getProcessOperation()));
                    Validations.check(CimObjectUtils.isEmpty(aPO), retCodeConfig.getNotFoundProcessOperation(), "", lotID);

                    com.fa.cim.newcore.bo.pd.CimProcessDefinition anOrigMainPD = aPO.getMainProcessDefinition();
                    Validations.check(CimObjectUtils.isEmpty(anOrigMainPD), retCodeConfig.getNotFoundMainRoute());

                    tmpPDIDStr = anOrigMainPD.getIdentifier();
                    tmpOpeNoStr = aPO.getOperationNumber();
                }

                if (branchNestLevel - level == 1) {
                    originalMainPDID = new ObjectIdentifier(tmpPDIDStr);
                    originalOpeNo = tmpOpeNoStr;
                } else if (branchNestLevel - level == 2) {
                    subOrigMainPDID = new ObjectIdentifier(tmpPDIDStr);
                    subOrigOpeNo = tmpOpeNoStr;
                }
            }

            // call FPC_info_GetDR
            Inputs.ObjFPCInfoGetDRIn fpcInfoGetDRIn = new Inputs.ObjFPCInfoGetDRIn();
            fpcInfoGetDRIn.setFPCIDs(dummyFPCIDs);
            fpcInfoGetDRIn.setLotID(lotID);
            fpcInfoGetDRIn.setMainPDID(currentMainPDID);
            fpcInfoGetDRIn.setMainOperNo(currentOpeNo);
            fpcInfoGetDRIn.setOrgMainPDID(originalMainPDID);
            fpcInfoGetDRIn.setOrgOperNo(originalOpeNo);
            fpcInfoGetDRIn.setSubMainPDID(subOrigMainPDID);
            fpcInfoGetDRIn.setSubOperNo(subOrigOpeNo);
            fpcInfoGetDRIn.setEquipmentID(objLotFPCInfoForOperationGetIn.getEquipmentID());
            fpcInfoGetDRIn.setWaferIDInfoGetFlag(objLotFPCInfoForOperationGetIn.getWaferIDInfoGetFlag());
            fpcInfoGetDRIn.setRecipeParmInfoGetFlag(objLotFPCInfoForOperationGetIn.getRecipeParmInfoGetFlag());
            fpcInfoGetDRIn.setReticleInfoGetFlag(objLotFPCInfoForOperationGetIn.getReticleInfoGetFlag());
            fpcInfoGetDRIn.setDcSpecItemInfoGetFlag(objLotFPCInfoForOperationGetIn.getDcSpecItemInfoGetFlag());
            fpcInfos = fpcMethod.fpcInfoGetDR(objCommon, fpcInfoGetDRIn);
        }
        return fpcInfos;
    }

    @Override
    public void lotWafersDelete(Infos.ObjCommon objCommon, ObjectIdentifier preparationCancelledLotID, List<ObjectIdentifier> deleteWaferIDList) {
        // Initialize
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, preparationCancelledLotID);

        // Remove wafers from lot and Delete wafer objects
        for(ObjectIdentifier waferID : deleteWaferIDList){
            CimWafer aWafer = baseCoreFactory.getBO(CimWafer.class, waferID);

            aLot.removeMaterial(aWafer);

            productManager.removeWafer(aWafer);
        }

        aLot.refreshQuantity();
    }

    @Override
    public ObjectIdentifier lotCassetteSameCheckDR(Infos.ObjCommon objCommon, List<ObjectIdentifier> lotIDs) {

        ObjectIdentifier cassetteID = null;
        for (int i = 0, j = lotIDs.size(); i < j; i++) {
            CimLot lot = baseCoreFactory.getBO(CimLot.class, lotIDs.get(i));
            Validations.check(null == lot, retCodeConfig.getNotFoundLot());

            List<MaterialContainer> lotMaterialContainers = lot.materialContainers();
            Validations.check(CimArrayUtils.isEmpty(lotMaterialContainers), retCodeConfig.getNotFoundCassette());

            MaterialContainer lotMaterialContainer = lotMaterialContainers.get(0);
            Validations.check(null == lotMaterialContainer, retCodeConfig.getNotFoundCassette());

            CimCassetteDO cimCassetteExample = new CimCassetteDO();
            cimCassetteExample.setId(lotMaterialContainer.getPrimaryKey());
            CimCassetteDO cassette = cimJpaRepository.findOne(Example.of(cimCassetteExample)).orElse(null);
            ObjectIdentifier lotCassetteID = null;
            if (null != cassette) {
                lotCassetteID = new ObjectIdentifier(cassette.getCassetteID(), cassette.getId());
            }

            // 判断多个批次的晶舟是否相同
            if (i == 0) {
                cassetteID = lotCassetteID;
            } else {
                Validations.check(!ObjectIdentifier.equalsWithValue(cassetteID, lotCassetteID), retCodeConfig.getLotCastUnmatch());
            }
        }
        return cassetteID;
    }

    @Override
    public ObjectIdentifier lotCassetteListGetDR(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLotDO example = new CimLotDO();
        example.setLotID(ObjectIdentifier.fetchValue(lotID));
        CimLotDO lot = cimJpaRepository.findOne(Example.of(example)).orElse(null);
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());
        CimLotMaterialContainerDO cimLotMaterialContainerExample = new CimLotMaterialContainerDO();
        cimLotMaterialContainerExample.setReferenceKey(lot.getId());
        CimLotMaterialContainerDO lotMaterialContainer = cimJpaRepository.findOne(Example.of(cimLotMaterialContainerExample)).orElse(null);
        Validations.check(null == lotMaterialContainer, retCodeConfig.getNotFoundCassette());

        return new ObjectIdentifier(lotMaterialContainer.getMaterialContainerID(),lotMaterialContainer.getMaterialContainerObj());
    }

    @Override
    public Infos.LotControlJobHistoryGetDROut lotControlJobHistoryGetDR(Infos.ObjCommon strObjCommonIn, Infos.LotControlJobHistoryGetDRIn strLotControlJobHistory_GetDR_in) {

        if ( !CimStringUtils.equals( strLotControlJobHistory_GetDR_in.getHistoryCategory(), BizConstant.SP_HISTORYCATEGORY_PROCESSWAFERINCJ)
                && !CimStringUtils.equals( strLotControlJobHistory_GetDR_in.getHistoryCategory(), BizConstant.SP_HISTORYCATEGORY_PROCESSJOBINCJ)) {
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"History Category is not correct"));
        }


        if ( 1 != CimArrayUtils.getSize(strLotControlJobHistory_GetDR_in.getStrTargetTableInfoSeq()) ) {
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Invalid table is requested"));
        }

        //add fromTimeStamp and toTimeStamp for runcard history
        String fromTimeStamp  = strLotControlJobHistory_GetDR_in.getFromTimeStamp();
        String toTimeStamp    = strLotControlJobHistory_GetDR_in.getToTimeStamp();
        SearchCondition searchCondition = strLotControlJobHistory_GetDR_in.getSearchCondition();


        String controlJob = ("");

        String hFHPJCHSPRCSJOB_ID          = "";
        String hFHPJCHS_WAFERWAFER_ID      = "";
        String hFRWAFERALIAS_WAFER_NAME    = "";
        String hFHPJCHS_WAFERLOT_ID        = "";
        String hFHPJCHSCLAIM_TIME          = "";
        String hFRPOCCTRLJOB_ID            = "";

        int hashInfoLen = CimArrayUtils.getSize(strLotControlJobHistory_GetDR_in.getStrTargetTableInfoSeq().get(0).getStrHashedInfoSeq());
        Validations.check(1 != hashInfoLen , new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"Invalid hashInfoLen is requested"));

        if ( CimStringUtils.equals(strLotControlJobHistory_GetDR_in.getStrTargetTableInfoSeq().get(0).getStrHashedInfoSeq().get(0).getHashKey(),
                BizConstant.SP_HISTORYCOLUMNNAME_CONTROLJOBID)) {
            controlJob = ( strLotControlJobHistory_GetDR_in.getStrTargetTableInfoSeq().get(0).getStrHashedInfoSeq().get(0).getHashData() );
        }

        Validations.check(CimStringUtils.isEmpty(controlJob), new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"ControlJob ID is mandatory."));
        Infos.LotControlJobHistoryGetDROut strLotControlJobHistory_GetDR_out=new Infos.LotControlJobHistoryGetDROut();
        if ( CimStringUtils.equals( strLotControlJobHistory_GetDR_in.getHistoryCategory(), BizConstant.SP_HISTORYCATEGORY_PROCESSWAFERINCJ )) {
            List<Infos.TableRecordInfo> strTableRecordInfoSeq=new ArrayList<>();
            strLotControlJobHistory_GetDR_out.setStrTableRecordInfoSeq(strTableRecordInfoSeq);
            Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
            strTableRecordInfoSeq.add(strTableRecordInfo);
            strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHPJCHS_PJ );

            List<String> columnNames=new ArrayList<>();
            strTableRecordInfo.setColumnNames(columnNames);
            int columnCount = 0;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERID );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERALIASNAME );
            columnCount++;
            columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTID );
            columnCount++;

            String hFHPJCHSCTRLJOB_ID = controlJob;

            hFHPJCHSCLAIM_TIME      ="";
            String hFHPJCHSOPE_CATEGORY = BizConstant.SP_PROCESSJOBOPECATEGORY_CREATED;

            String sql=String.format("SELECT MAX(TRX_TIME)\n" +
                            "            FROM  OHPJCHG\n" +
                            "            WHERE OHPJCHG.CJ_ID = '%s'\n" +
                            "            AND OHPJCHG.OPE_CATEGORY = '%s'",hFHPJCHSCTRLJOB_ID
                    , hFHPJCHSOPE_CATEGORY);

            //add fromTimeStamp and toTimeStamp for history query
            String sqlTemp = "";
            if (CimStringUtils.isNotEmpty( fromTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME >= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", fromTimeStamp);
                sql += sqlTemp ;
            }
            if (CimStringUtils.isNotEmpty( toTimeStamp )) {
                sqlTemp = String.format(" AND EVENT_CREATE_TIME <= TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')", toTimeStamp);
                sql += sqlTemp ;
            }

            Object[] query=cimJpaRepository.queryOne(sql);

            hFHPJCHSCLAIM_TIME=query==null?null: CimObjectUtils.toString(query[0]);
            if(query!=null)  {
                sql=String.format("SELECT OHPJCHG.PJ_ID,\n" +
                                "                    OHPJCHG_WAFER.WAFER_ID,\n" +
                                "                    OMWAFER.ALIAS_WAFER_NAME,\n" +
                                "                    OHPJCHG_WAFER.LOT_ID\n" +
                                "                FROM   OHPJCHG, OHPJCHG_WAFER, OMWAFER\n" +
                                "                WHERE  OHPJCHG.CJ_ID = '%s'\n" +
                                "                AND   OHPJCHG.TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff')\n" +
                                "                AND   OHPJCHG.PJ_ID = OHPJCHG_WAFER.PJ_ID\n" +
                                "                AND   OHPJCHG.TRX_TIME = OHPJCHG_WAFER.TRX_TIME\n" +
                                "                AND   OHPJCHG_WAFER.WAFER_ID = OMWAFER.WAFER_ID",hFHPJCHSCTRLJOB_ID
                        ,hFHPJCHSCLAIM_TIME);
                List<Object[]> FHPJCHS1=null;
                Page<Object[]> queryPage =null;
                if (searchCondition!=null) {
                    queryPage = cimJpaRepository.query(sql,searchCondition);
                    FHPJCHS1=queryPage.getContent();
                } else {
                    FHPJCHS1=cimJpaRepository.query(sql);
                }

                int count = 0;
                int increasedDataLen = 25;
                List<Infos.TableRecordValue> strTableRecordValueSeq=new ArrayList<>();
                strLotControlJobHistory_GetDR_out.setStrTableRecordValueSeq(strTableRecordValueSeq);

                if (FHPJCHS1!=null)
                for (Object[] obj:FHPJCHS1) {
                    hFHPJCHSPRCSJOB_ID            ="";
                    hFHPJCHS_WAFERWAFER_ID        ="";
                    hFRWAFERALIAS_WAFER_NAME      ="";
                    hFHPJCHS_WAFERLOT_ID          ="";

                    hFHPJCHSPRCSJOB_ID = CimObjectUtils.toString(obj[0]);
                    hFHPJCHS_WAFERWAFER_ID = CimObjectUtils.toString(obj[1]);
                    hFRWAFERALIAS_WAFER_NAME = CimObjectUtils.toString(obj[2]);
                    hFHPJCHS_WAFERLOT_ID = CimObjectUtils.toString(obj[3]);

                    if ( count >= increasedDataLen ) {
                        increasedDataLen += 10;
                    }

                    Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                    strTableRecordValueSeq.add(strTableRecordValue);
                    strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHPJCHS_PJ );
                    strTableRecordValue.setReportTimeStamp ( hFHPJCHSCLAIM_TIME );

                    List<Object> columnValues=new ArrayList<>();
                    strTableRecordValue.setColumnValues(columnValues);
                    columnCount = 0;
                    columnValues.add( hFHPJCHSPRCSJOB_ID );
                    columnCount++;
                    columnValues.add( hFHPJCHS_WAFERWAFER_ID );
                    columnCount++;
                    columnValues.add( hFRWAFERALIAS_WAFER_NAME );
                    columnCount++;
                    columnValues.add( hFHPJCHS_WAFERLOT_ID );
                    columnCount++;
                    count++;
                }
                if (searchCondition!=null){
                    strLotControlJobHistory_GetDR_out.setStrTableRecordValuePage(CimPageUtils.convertListToPage(strTableRecordValueSeq,searchCondition.getPage(),searchCondition.getSize(),queryPage.getTotalElements()));
                }
            }

        } else if ( CimStringUtils.equals( strLotControlJobHistory_GetDR_in.getHistoryCategory(), BizConstant.SP_HISTORYCATEGORY_PROCESSJOBINCJ )) {
            List<Infos.TableRecordInfo> strTableRecordInfoSeq = new ArrayList<>();
            strLotControlJobHistory_GetDR_out.setStrTableRecordInfoSeq(strTableRecordInfoSeq);
            Infos.TableRecordInfo strTableRecordInfo = new Infos.TableRecordInfo();
            strTableRecordInfoSeq.add(strTableRecordInfo);
            strTableRecordInfo.setTableName(BizConstant.SP_HISTORYTABLENAME_FRPO_SMPL);

            List<String> columnNames = new ArrayList<>();
            strTableRecordInfo.setColumnNames(columnNames);
            int columnCount = 0;
            columnNames.add(BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBID);
            columnCount++;
            columnNames.add(BizConstant.SP_HISTORYCOLUMNNAME_PROCESSJOBPOS);
            columnCount++;

            hFRPOCCTRLJOB_ID = controlJob;

            String sql = String.format("SELECT DISTINCT OMPROPE_WAFERJOB.PJ_ID,\n" +
                    "                OMPROPE_WAFERJOB.PJ_POSITION\n" +
                    "            FROM   OMPROPE, OMPROPE_WAFERJOB\n" +
                    "            WHERE  OMPROPE.ID = OMPROPE_WAFERJOB.REFKEY\n" +
                    "            AND   OMPROPE.CJ_ID = '%s'", hFRPOCCTRLJOB_ID);

            Page<Object[]> queryPage=null;
            List<Object[]> FRPOSMPL1=null;
            if (searchCondition!=null){
                queryPage = cimJpaRepository.query(sql, searchCondition);
                FRPOSMPL1=queryPage.getContent();
            }else{
                FRPOSMPL1 = cimJpaRepository.query(sql);
            }


            int count = 0;
            int increasedDataLen = 10;
            List<Infos.TableRecordValue> strTableRecordValueSeq = new ArrayList<>();
            strLotControlJobHistory_GetDR_out.setStrTableRecordValueSeq(strTableRecordValueSeq);

            if (FRPOSMPL1!=null)
            for (Object[] obj : FRPOSMPL1) {
                String hFRPO_SMPLPRCSJOB_ID = "";
                String hFRPO_SMPLPRCSJOB_POS = "";

                hFRPO_SMPLPRCSJOB_ID = CimObjectUtils.toString(obj[0]);
                hFRPO_SMPLPRCSJOB_POS = CimObjectUtils.toString(obj[1]);


                if (count >= increasedDataLen) {
                    increasedDataLen += 10;
                }

                Infos.TableRecordValue strTableRecordValue = new Infos.TableRecordValue();
                strTableRecordValueSeq.add(strTableRecordValue);
                strTableRecordValue.setTableName(BizConstant.SP_HISTORYTABLENAME_FRPO_SMPL);
                strTableRecordValue.setReportTimeStamp(BizConstant.SP_TIMESTAMP_NIL_OBJECT_STRING);

                List<Object> columnValues = new ArrayList<>();
                strTableRecordValue.setColumnValues(columnValues);
                columnCount = 0;
                columnValues.add(hFRPO_SMPLPRCSJOB_ID);
                columnCount++;
                columnValues.add(hFRPO_SMPLPRCSJOB_POS);
                columnCount++;
                count++;
            }
            if (searchCondition!=null){
                strLotControlJobHistory_GetDR_out.setStrTableRecordValuePage(CimPageUtils.convertListToPage(strTableRecordValueSeq,searchCondition.getPage(),searchCondition.getSize(),queryPage.getTotalElements()));
            }
        }
        return strLotControlJobHistory_GetDR_out;
    }

    @Override
    public Results.FloatingBatchListInqResult lotFillInTxDSQ002DR(Results.FloatingBatchListInqResult flowBatchData, Infos.ObjCommon objCommon) {
        List<Infos.FloatBatch> floatBatches = flowBatchData.getFloatBatches();

        int seqOutLen = CimArrayUtils.getSize(floatBatches);
        for (int i = 0; i < seqOutLen; i++) {
            Infos.FloatBatch floatBatch = floatBatches.get(i);
            List<Infos.FlowBatchedLotInfo> flowBatchedLotInfos = floatBatch.getFlowBatchedLotInfos();
            if (floatBatch.getCassetteID() != null){
                CimCassette cassette = baseCoreFactory.getBO(CimCassette.class, floatBatch.getCassetteID());
                Validations.check(cassette == null, new OmCode(retCodeConfig.getNotFoundCassette(), ObjectIdentifier.fetchValue(floatBatch.getCassetteID())));

                int seqInLen = CimArrayUtils.getSize(flowBatchedLotInfos);
                for (int j = 0; j < seqInLen; j++) {
                    Infos.FlowBatchedLotInfo flowBatchedLotInfo = flowBatchedLotInfos.get(j);

                    CimLot lot = baseCoreFactory.getBO(CimLot.class, flowBatchedLotInfo.getLotID());
                    Validations.check(CimObjectUtils.isEmpty(lot), retCodeConfig.getNotFoundLot(), objCommon.getTransactionID());

                    flowBatchedLotInfo.setLotStatus(lot.getState());
                    flowBatchedLotInfo.setTransferStatus(cassette.getTransportState());

                    Machine machine = cassette.currentAssignedMachine();

                    ObjectIdentifier eqpID;
                    if (null != machine) {
                        if (CimBooleanUtils.isFalse(machine.isStorageMachine())) {
                            flowBatchedLotInfo.setEquipmentID(new ObjectIdentifier(machine.getIdentifier(), machine.getPrimaryKey()));
                            eqpID = flowBatchedLotInfo.getEquipmentID();
                        } else {
                            flowBatchedLotInfo.setStockerID(new ObjectIdentifier(machine.getIdentifier(), machine.getPrimaryKey()));
                            eqpID = flowBatchedLotInfo.getStockerID();
                        }
                    }

                    flowBatchedLotInfo.setPriorityClass(String.valueOf(lot.getPriorityClass()));

                    CimProductSpecification productSpecification = lot.getProductSpecification();
                    flowBatchedLotInfo.setProductID(new ObjectIdentifier(productSpecification.getIdentifier(), productSpecification.getPrimaryKey()));

                    /*----------------------------*/
                    /*   Get EntityInhitib Info   */
                    /*----------------------------*/
                    List<Infos.EntityInhibitInfo> entityInhibitInfoList = constraintMethod.constraintCheckForLot(objCommon, flowBatchedLotInfo.getLotID(), flowBatchedLotInfo.getEquipmentID());

                    if (!CimArrayUtils.isEmpty(entityInhibitInfoList)) {
                        List<Infos.EntityInhibitAttributes> entityInhibitions = new ArrayList<>();
                        for (Infos.EntityInhibitInfo entityInhibitInfo : entityInhibitInfoList) {
                            entityInhibitions.add(entityInhibitInfo.getEntityInhibitAttributes());
                        }
                        flowBatchedLotInfo.setEntityInhibitions(entityInhibitions);
                    }
                }
            }
        }

        return  flowBatchData;
    }

    @Override
    public Outputs.ObjMonitorLotSTBInfoGetOut monitorLotSTBInfoGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Outputs.ObjMonitorLotSTBInfoGetOut out = new Outputs.ObjMonitorLotSTBInfoGetOut();
        //-----------------------------------------
        // Retrieve object reference of input lot
        //-----------------------------------------
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(null == lot,retCodeConfig.getNotFoundLot());
        //-----------------------------------------
        // Check lot Process State
        //-----------------------------------------
        Validations.check(!BizConstant.SP_LOT_PROCSTATE_PROCESSING.equals(lot.getLotProcessState()),retCodeConfig.getInvalidLotStat(),lot.getLotProcessState());    // bug-6323 find in bug 6323

        //-----------------------------------------
        // Retrieve object reference of PO
        //-----------------------------------------
        com.fa.cim.newcore.bo.pd.CimProcessOperation aPO = lot.getProcessOperation();
        Validations.check(null == aPO,retCodeConfig.getNotFoundProcessOperation());
        //-----------------------------------------
        // Retrieve object reference of logicalrecipe
        //-----------------------------------------
        com.fa.cim.newcore.bo.recipe.CimLogicalRecipe aPosLR = aPO.getAssignedLogicalRecipe();
        Validations.check(null == aPosLR,retCodeConfig.getNotFoundLogicRecipe());
        //-----------------------------------------
        // Retrieve Monitor lot Product ID which is
        // specified in Logical Recipe
        //-----------------------------------------
        CimProductSpecification productSpecification = aPosLR.getMonitorProduct();
        Validations.check(null == productSpecification,retCodeConfig.getNotFoundProductSpec());

        ObjectIdentifier tmpMontior = ObjectIdentifier.build(productSpecification.getIdentifier(), productSpecification.getPrimaryKey());
        out.setMonitorLotProductID(tmpMontior);

        //-----------------------------------------
        // Retrieve Monitor lot's subLot Type to be STBed
        //-----------------------------------------
        String subLotType = aPosLR.getSubLotType();
        //-----------------------------------------
        // Set output structure
        //-----------------------------------------
        out.setLotType(BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT);
        out.setSubLotType(subLotType);
        return out;
    }

    @Override
    public Outputs.ObjLotWIPInfoResetOut lotWIPInfoReset(Infos.ObjCommon objCommon, Inputs.ObjLotWIPInfoResetIn in) {
        ObjectIdentifier lotID = in.getLotID();
        long updateLevel = in.getUpdateLevel();
        Outputs.ObjLotWIPInfoResetOut out = new Outputs.ObjLotWIPInfoResetOut();

        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        //prepare data for history
        out.setOpehsAddFlag(true);
        Event.LotEventData lotEventData = lot.getEventData();
        Inputs.OldCurrentPOData oldCurrentPOData = new Inputs.OldCurrentPOData();
        oldCurrentPOData.setRouteID(lotEventData.getRouteID());
        oldCurrentPOData.setOperationNumber(lotEventData.getOperationNumber());
        oldCurrentPOData.setOperationID(lotEventData.getOperationID());
        oldCurrentPOData.setOperationPassCount(lotEventData.getOperationPassCount().intValue());
        oldCurrentPOData.setObjrefPOS(lotEventData.getObjrefPOS());
        oldCurrentPOData.setObjrefMainPF(lotEventData.getObjrefMainPF());
        oldCurrentPOData.setObjrefModulePOS(lotEventData.getObjrefModulePOS());
        out.setOldCurrentPOData(oldCurrentPOData);
        if (0 == updateLevel) {
            log.info("updateLevel==0");
            String lotHoldState = lotHoldStateGet(objCommon, lotID);

            if (CimStringUtils.equals(lotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD)) {
                log.info("Lot is NotOnHold, refresh the dispatch queue");
                //-------------------------------------------------
                // Remove Lot from Queue then add again to refresh
                //-------------------------------------------------
                dispatchingManager.removeFromQueue(lot);
                dispatchingManager.addToQueue(lot);
            } else {
                log.info("Lot is OnHold, do nothing");
                out.setOpehsAddFlag(false);
            }
        } else {
            log.info("updateLevel==1");

            //----------------------------------------------------------------
            //  Get current operation info for the lotID
            //----------------------------------------------------------------
            Inputs.ObjProcessOperationProcessRefListForLotIn objProcessOperationProcessRefListForLotIn = new Inputs.ObjProcessOperationProcessRefListForLotIn();
            objProcessOperationProcessRefListForLotIn.setSearchDirection(true);
            objProcessOperationProcessRefListForLotIn.setPosSearchFlag(false);
            objProcessOperationProcessRefListForLotIn.setSearchCount(1);
            objProcessOperationProcessRefListForLotIn.setSearchRouteID(in.getRouteID());
            objProcessOperationProcessRefListForLotIn.setSearchOperationNumber(in.getOperationNumber());
            objProcessOperationProcessRefListForLotIn.setCurrentFlag(true);
            objProcessOperationProcessRefListForLotIn.setLotID(lotID);
            List<Infos.OperationProcessRefListAttributes> operationProcessRefListAttributes = processMethod.processOperationProcessRefListForLot(objCommon, objProcessOperationProcessRefListForLotIn);

            Infos.ProcessRef processRef = operationProcessRefListAttributes.get(0).getProcessRef();
            processMethod.processLocate(objCommon, lotID, processRef, operationProcessRefListAttributes.get(0).getSeqno());
        }
        return out;
    }

    @Override
    public Outputs.ObjLotFutureReworkInfoCheckOut lotFutureReworkInfoCheck(Infos.ObjCommon objCommon, ObjectIdentifier lotID, ObjectIdentifier routeID, String operationNumber, Infos.FutureReworkDetailInfo strFutureReworkDetailInfo) {
        Outputs.ObjLotFutureReworkInfoCheckOut out = new Outputs.ObjLotFutureReworkInfoCheckOut();
        //------------------------------------------------------------
        // Check for the target future rework request's consistency
        //------------------------------------------------------------
        //===== Get the target future rework request =======//
        List<Infos.FutureReworkInfo> futureReworkInfos = lotFutureReworkListGetDR(objCommon, lotID, routeID, operationNumber);
        Validations.check(CimArrayUtils.getSize(futureReworkInfos) > 1, retCodeConfig.getInvalidInputParam());

        //===== Classify the target future rework request's registration =======//
        OmCode classifiedResult = retCodeConfig.getSucc();

        if (CimArrayUtils.getSize(futureReworkInfos) < 1) {
            log.info("No future rework request is found.");
            out.setUpdateFlag(false);
            List<Infos.FutureReworkDetailInfo> futureReworkDetailInfos = new ArrayList<>();
            futureReworkDetailInfos.add(strFutureReworkDetailInfo);
            out.setFutureReworkDetailInfos(futureReworkDetailInfos);
        } else {
            log.info("One future rework request is found.");
            out.setUpdateFlag(true);
            List<Infos.FutureReworkDetailInfo> strFutureReworkDetailInfoList = futureReworkInfos.get(0).getFutureReworkDetailInfoList();
            //----- The item trigger, except target time -------//
            // Trigger(FRFTRWK_RWKRT.TRIGGER) = "LotID" + "." + "RouteID" + "." + "TriggerOpeNo" + "." + "TargetOpeNo" + "." + "TargetTime"
            //   - The length of FRFTRWK_RWKRT.TRIGGER is 256.
            //   - "TargetTime" is a value of timestamp type, and the length of timestamp type is 26.
            String trigger = strFutureReworkDetailInfo.getTrigger();
            String searchTrigger = trigger.substring(0, trigger.length() - 20); //获取不包含时间的trigger，NP127633.98A.1250IP0.01.0300.200.0300.200.2020-09-29 23:21:26 -> NP127633.98A.1250IP0.01.0300.200.0300.200

            int updateDetail = 0;
            int definedDetailLen = strFutureReworkDetailInfoList.size();
            for (int i = 0, j = strFutureReworkDetailInfoList.size(); i < j; i++) {
                Infos.FutureReworkDetailInfo futureReworkDetailInfo = strFutureReworkDetailInfoList.get(i);
                //----- The item trigger which is registered, except target time -------//
                String dtrigger = futureReworkDetailInfo.getTrigger();
                String definedTrigger = dtrigger.substring(0, dtrigger.length() - 20); //获取不包含时间的trigger，NP127633.98A.1250IP0.01.0300.200.0300.200.2020-09-29 23:21:26 -> NP127633.98A.1250IP0.01.0300.200.0300.200

                if (!ObjectIdentifier.equalsWithValue(strFutureReworkDetailInfo.getReworkRouteID(), futureReworkDetailInfo.getReworkRouteID()) ||
                        !ObjectIdentifier.equalsWithValue(strFutureReworkDetailInfo.getReasonCodeID(), futureReworkDetailInfo.getReasonCodeID())) {
                    if (CimStringUtils.equals(searchTrigger, definedTrigger)) {
                        if (Validations.isEquals(retCodeConfig.getSucc(), classifiedResult)) {
                            updateDetail = i;

                            log.info("The trigger is same at the defined one in part, but the rework route or the reason code is not same.");
                            classifiedResult = retCodeConfigEx.getFtrwkUpdate();
                        } else if (!Validations.isEquals(retCodeConfigEx.getFtrwkReadded(), classifiedResult)) {
                            updateDetail = 0;

                            log.info("The trigger is same as two or more triggers, which had been defined, in part.");
                            classifiedResult = retCodeConfigEx.getFtrwkDuplicate();
                        }
                    }
                } else {
                    /////// The combination of trigger operation and target operation is same /////////
                    if (CimStringUtils.equals(searchTrigger, definedTrigger)) {
                        out.setFutureReworkDetailInfos(strFutureReworkDetailInfoList);
                        log.info("The rework route and the reason code are same as the defined one, and the trigger is same in part.");
                        classifiedResult = retCodeConfigEx.getFtrwkAlreadyExist();
                        break;
                    }
                    /////// The items trigger operation and target operation are different /////////
                    else {
                        log.info("The rework route and the reason code are same as the defined one, but the trigger is not same at all.");
                        classifiedResult = retCodeConfigEx.getFtrwkReadded();
                    }
                }
            }

            if (Validations.isEquals(retCodeConfigEx.getFtrwkAlreadyExist(), classifiedResult)) {
                log.info("The defined future rework request doesn't need to update.");
            } else if (Validations.isEquals(classifiedResult, retCodeConfigEx.getFtrwkUpdate())) {
                log.info("The defined future rework request is updated in part like the target.");

                strFutureReworkDetailInfoList.add(updateDetail, strFutureReworkDetailInfo);
                out.setFutureReworkDetailInfos(strFutureReworkDetailInfoList);
            } else    //else if( classifiedResult == RC_OK || classifiedResult == RC_FTRWK_DUPLICATE || classifiedResult == RC_FTRWK_READDED )
            {
                log.info("The defined future rework request is updated by addition of the target.");
                strFutureReworkDetailInfoList.add(definedDetailLen, strFutureReworkDetailInfo);
                out.setFutureReworkDetailInfos(strFutureReworkDetailInfoList);

                if (Validations.isEquals(retCodeConfig.getSucc(), classifiedResult))    //The target trigger is not set to the defined request redundantly
                {
                    classifiedResult = retCodeConfigEx.getFtrwkDuplicate();
                }
            }
        }

        //===== Verify that the target future rework request doesn't overlap with another future rework requests =======//
        if (!Validations.isEquals(retCodeConfigEx.getFtrwkAlreadyExist(), classifiedResult)) {
            /////// Get related future rework requests /////////
            List<Infos.FutureReworkInfo> futureReworkInfosforAnother = lotFutureReworkListGetDR(objCommon, lotID, routeID, null);

            /////// Check whether the target overlaps with the another one /////////
            log.info("Check the relation between the target future rework request and an another one.");

            String returnOperationNumber = strFutureReworkDetailInfo.getReturnOperationNumber();
            log.info("The target future rework request's operation number {} and return operation number {}", operationNumber, returnOperationNumber);

            for (Infos.FutureReworkInfo futureReworkInfo : futureReworkInfosforAnother) {
                String operNumAnother = futureReworkInfo.getOperationNumber();
                if (CimStringUtils.equals(operationNumber, operNumAnother)) {
                    log.info("The recurrent check for the target future rework request is not needed.");
                    continue;
                }

                CimProcessFlowContext aPFX = null;
                if (CimObjectUtils.isEmpty(aPFX)) {
                    /////// Get the target lot's process flow context /////////
                    CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
                    Validations.check(CimObjectUtils.isEmpty(aLot), retCodeConfig.getNotFoundLot(), lotID);
                    aPFX = aLot.getProcessFlowContext();

                    Validations.check(CimObjectUtils.isEmpty(aPFX), retCodeConfig.getNotFoundPfx());
                }

                List<Infos.FutureReworkDetailInfo> strAnotherDetails = futureReworkInfo.getFutureReworkDetailInfoList();
                for (Infos.FutureReworkDetailInfo strAnotherDetail : strAnotherDetails) {
                    String returnOperNumAnother = strAnotherDetail.getReturnOperationNumber();

                    log.info("An another future rework request's operation number {} and return operation number {}", operNumAnother, returnOperNumAnother);
                    boolean forOpeOpeAnother = aPFX.isAfterOperationNumber(operationNumber, operNumAnother);
                    boolean forRetAnotherOpe = aPFX.isAfterOperationNumber(returnOperNumAnother, operationNumber);
                    boolean forOpeAnotherOpe = aPFX.isAfterOperationNumber(operNumAnother, operationNumber);
                    boolean forRetOpeAnother = aPFX.isAfterOperationNumber(returnOperationNumber, operNumAnother);

                    if ((forOpeOpeAnother && forRetAnotherOpe) || (forOpeAnotherOpe && forRetOpeAnother)) {
                        log.info("The target future rework request overlaps with an another one. {} {} {} {}",
                                (forOpeOpeAnother ? "TRUE" : "FALSE"), (forRetAnotherOpe ? "TRUE" : "FALSE"),
                                (forOpeAnotherOpe ? "TRUE" : "FALSE"), (forRetOpeAnother ? "TRUE" : "FALSE"));
                        OmCode ftrwkDataInvalid = retCodeConfigEx.getFtrwkDataInvalid();
                        if (forOpeOpeAnother && forRetAnotherOpe) {
                            ftrwkDataInvalid = new OmCode(ftrwkDataInvalid, BizConstant.SP_FUTUREREWORK_ITEM_OPENO, operationNumber);
                        } else    // else if( forOpeAnotherOpe == TRUE && forRetOpeAnother == TRUE )
                        {
                            ftrwkDataInvalid = new OmCode(ftrwkDataInvalid, BizConstant.SP_FUTUREREWORK_ITEM_RETURNOPENO, returnOperationNumber);
                        }
                        Validations.check(ftrwkDataInvalid);
                    } else {
                        log.info("The target future rework request doesn't overlap with an another one.");
                    }
                }
            }
        }

        Validations.check(!Validations.isEquals(retCodeConfig.getSucc(), classifiedResult), out, classifiedResult);
        return out;
    }


    @Override
    public void lotCheckConditionForBondingGroup(Infos.ObjCommon objCommon, String action, List<ObjectIdentifier> bondingLotIDSeq) {

        boolean isCreate = CimStringUtils.equals(action, BizConstant.SP_BONDINGGROUPACTION_CREATE);
        boolean isPartialRelease = CimStringUtils.equals(action, BizConstant.SP_BONDINGGROUPACTION_PARTIALRELEASE);
        for (ObjectIdentifier data : bondingLotIDSeq) {
            /*--------------------*/
            /*   Get Lot Object   */
            /*--------------------*/
            CimLot aLot = baseCoreFactory.getBO(CimLot.class, data);
            /*---------------------------------*/
            /*   Get and Check Lot's Content   */
            /*---------------------------------*/
            String lotContents = aLot.getLotContents();
            log.debug("lotContents : " + lotContents);
            Validations.check(!CimStringUtils.equals(lotContents, BizConstant.SP_PRODTYPE_WAFER), retCodeConfig.getInvalidLotContents());
            /*-------------------------------*/
            /*   Get and Check Lot's State   */
            /*-------------------------------*/
            String lotState = aLot.getLotState();
            log.debug("lotState : " + lotState);
            Validations.check(!CimStringUtils.equals(lotState, BizConstant.CIMFW_LOT_STATE_ACTIVE), retCodeConfig.getInvalidLotStat(),lotState);    //bug-6323 find in bug 6323 code:936
            String lotProcessState = aLot.getLotProcessState();
            log.debug("processState : " + lotProcessState);
            Validations.check(!CimStringUtils.equals(lotProcessState, BizConstant.SP_LOT_PROCSTATE_WAITING), retCodeConfig.getInvalidLotProcessState(), ObjectIdentifier.fetchValue(aLot.getLotID()), lotProcessState);
            String lotInventoryState = aLot.getLotInventoryState();
            log.debug("inventoryState : " + lotInventoryState);
            Validations.check(!CimStringUtils.equals(lotInventoryState, BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR), retCodeConfig.getInvalidLotInventoryStat(),
                    ObjectIdentifier.fetchValue(aLot.getLotID()), lotInventoryState);

            if (isCreate) {
                String lotHoldState = aLot.getLotHoldState();
                log.debug("holdState : " + lotHoldState);
                Validations.check(!CimStringUtils.equals(lotHoldState, BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD), retCodeConfig.getInvalidLotHoldStat());
                //------------------------------------
                //  Check InPostProcessFlag of Lot
                //------------------------------------
                boolean postProcessFlagOn = aLot.isPostProcessFlagOn();
                Validations.check(postProcessFlagOn, retCodeConfig.getInvalidLotProcessState());
                /*--------------------------------*/
                /*  Check Bonding Group existence  */
                /*--------------------------------*/
                String bondingGroupID = this.lotBondingGroupIDGetDR(objCommon, data);
                Validations.check(CimStringUtils.isNotEmpty(bondingGroupID), retCodeConfig.getLotHasBondingGroup(),data.getValue(),bondingGroupID);
            }

            /*------------------------------*/
            /*   Get Lot's Control Job ID   */
            /*------------------------------*/
            CimControlJob controlJob = aLot.getControlJob();
            Validations.check(null != controlJob, retCodeConfig.getLotControlJobidFilled());

            if (isPartialRelease) {
                /*------------------------------------------------------------------------*/
                /*   Check if the wafers in lot don't have machine container position     */
                /*------------------------------------------------------------------------*/
                List<Infos.EqpContainerPosition> eqpContainerPositions = equipmentMethod.equipmentContainerPositionInfoGetByLotDR(objCommon, data);
                Validations.check(CimArrayUtils.getSize(eqpContainerPositions) > 0, retCodeConfig.getWaferInLotHaveContainerPosition());
            }
        }

        if (isPartialRelease) {
            /*-------------------------------*/
            /*   Check SorterJob existence   */
            /*-------------------------------*/
            Inputs.ObjWaferSorterJobCheckForOperation objWaferSorterJobCheckForOperation = new Inputs.ObjWaferSorterJobCheckForOperation();
            objWaferSorterJobCheckForOperation.setLotIDList(bondingLotIDSeq);
            objWaferSorterJobCheckForOperation.setOperation(BizConstant.SP_OPERATION_FOR_LOT);
            waferMethod.waferSorterSorterJobCheckForOperation(objCommon, objWaferSorterJobCheckForOperation);
        }
    }

    @Override
    public Outputs.ObjLotStackedWaferInfoGetDROut lotStackedWaferInfoGetDR(Infos.ObjCommon objCommon, Inputs.ObjLotStackedWaferInfoGetDRIn lotStackedWaferInfoGetDRIn) {
        Validations.check(null == lotStackedWaferInfoGetDRIn, retCodeConfig.getInvalidParameter());

        Outputs.ObjLotStackedWaferInfoGetDROut retVal = null;
        //----------------------------------------------------------------------
        //   Preparing Search SQL
        //----------------------------------------------------------------------
        String SQL = "select  " +
                "BASE.CARRIER_ID, " +         // 0
                "BASE.CARRIER_RKEY, " +        // 1
                "BASE.POSITION, " +              // 2
                "BASE.LOT_ID, " +                // 3
                "BASE.LOT_RKEY, " +               // 4
                "BASE.WAFER_ID, " +              // 5
                "BASE.ID, " +                    // 6
                "BASE.ALIAS_WAFER_NAME, " +      // 7
                "BASE.SCRAP_STATE, " +           // 8
                "STKD.PRE_ALIAS_WAFER_NAME, " +  // 9
                "STKD.TOP_LOT_ID, " +            // 10
                "STKD.TOP_LOT_RKEY, " +           // 11
                "STKD.TOP_WAFER_ID, " +          // 12
                "STKD.TOP_WAFER_RKEY, " +         // 13
                "STKD.TOP_WAFER_ALIAS, " +  // 14
                "STKD.STACK_TIME, " +            // 15
                "STKD.WAFER_OFFSET, " +           // 16
                "STKD.FAB_ID " +                 // 17
                "from OMWAFER BASE, OMWAFER_BONDWFR STKD " +
                "where STKD.REFKEY = BASE.ID ";
        if (!ObjectIdentifier.isEmptyWithValue(lotStackedWaferInfoGetDRIn.getBaseCarrierID())) {
            log.info("baseCarrierID != 0");
            SQL = String.format(SQL + " and BASE.CARRIER_ID = '%s' ", lotStackedWaferInfoGetDRIn.getBaseCarrierID().getValue());
        }

        List<ObjectIdentifier> baseLotIDSeq = lotStackedWaferInfoGetDRIn.getBaseLotIDSeq();
        if (CimArrayUtils.isNotEmpty(baseLotIDSeq)) {
            log.info("baseLotLen != 0");
            SQL = String.format(SQL + " and BASE.LOT_ID in ('%s'", baseLotIDSeq.get(0).getValue());
            int size = baseLotIDSeq.size();
            for (int i = 1; i < size; i++) {
                SQL = String.format(SQL + ",'%s'", baseLotIDSeq.get(i).getValue());
            }
            SQL += ") ";
        }

        List<ObjectIdentifier> topLotIDSeq = lotStackedWaferInfoGetDRIn.getTopLotIDSeq();
        if (CimArrayUtils.isNotEmpty(topLotIDSeq)) {
            log.info("topLotLen != 0");
            SQL = String.format(SQL + "and STKD.TOP_LOT_ID in ('%s'", topLotIDSeq.get(0).getValue());
            int size = topLotIDSeq.size();
            for (int i = 1; i < size; i++) {
                SQL = String.format(SQL + ",'%s'", topLotIDSeq.get(i).getValue());
            }
            SQL += ") ";
        }

        SQL += " order  by BASE.CARRIER_ID, BASE.POSITION ,STKD.WAFER_OFFSET";
        log.info("SQL: " + SQL);
        //----------------------------------------------------------------------
        //   Getting Stacked Wafer Info
        //----------------------------------------------------------------------
        List<Object[]> results = cimJpaRepository.query(SQL);

        if (CimArrayUtils.isNotEmpty(results)) {
            retVal = new Outputs.ObjLotStackedWaferInfoGetDROut();
            List<Infos.StackedWaferInfo> stackedWaferInfoRetVal = new ArrayList<>();
            Set<ObjectIdentifier> baseLotIDRetVal = new HashSet<>();
            results.forEach(data -> {
                Infos.StackedWaferInfo stackedWafer = new Infos.StackedWaferInfo();
                stackedWaferInfoRetVal.add(stackedWafer);
                stackedWafer.setCassetteID(ObjectIdentifier.build(String.valueOf(data[0]), String.valueOf(data[1])));
                stackedWafer.setSlotNo(Long.valueOf(String.valueOf(data[2])));
                stackedWafer.setBaseLotID(ObjectIdentifier.build(String.valueOf(data[3]), String.valueOf(data[4])));
                stackedWafer.setBaseWaferID(ObjectIdentifier.build(String.valueOf(data[5]), String.valueOf(data[6])));
                stackedWafer.setBaseAliasWaferName(String.valueOf(data[7]));
                stackedWafer.setState(String.valueOf(data[8]));
                stackedWafer.setBasePreviousAliasWaferName(String.valueOf(data[9]));
                stackedWafer.setTopLotID(ObjectIdentifier.build(String.valueOf(data[10]), String.valueOf(data[11])));
                stackedWafer.setTopWaferID(ObjectIdentifier.build(String.valueOf(data[12]), String.valueOf(data[13])));
                stackedWafer.setTopAliasWaferName(String.valueOf(data[14]));
                stackedWafer.setStackedTime(String.valueOf(data[15]));
                stackedWafer.setMaterialOffset(Long.valueOf(String.valueOf(data[16])));
                stackedWafer.setFabID(String.valueOf(data[17]));

                baseLotIDRetVal.add(stackedWafer.getBaseLotID());
            });
            retVal.setBaseLotIDSeq(new ArrayList<>(baseLotIDRetVal));
            retVal.setStrStackedWaferInfoSeq(stackedWaferInfoRetVal);
        }
        return retVal;
    }

    @Override
    public Outputs.ObjLotProductProcessOperationInfoGetOut lotProductProcessOperationInfoGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Outputs.ObjLotProductProcessOperationInfoGetOut objLotProductProcessOperationInfoGetOut = new Outputs.ObjLotProductProcessOperationInfoGetOut();
        /*---------------------------*/
        /*   Get Lot Object   */
        /*---------------------------*/
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(aLot == null, new OmCode(retCodeConfig.getNotFoundLot(), lotID.getValue()));
        // -------------------------------------
        // Get product information
        // -------------------------------------
        String manufacturingLayer = aLot.getMFGLayer();
        ObjectIdentifier reticleSetID = null;
        CimReticleSet aReticleSet = aLot.getReticleSet();
        if (aReticleSet != null){
            reticleSetID = new ObjectIdentifier(aReticleSet.getIdentifier(), aReticleSet.getPrimaryKey());
        }
        // Get ProductSpec Object
        CimProductSpecification aProductSpec = aLot.getProductSpecification();
        Validations.check(aProductSpec == null, new OmCode(retCodeConfig.getNotFoundProductSpec()));
        ObjectIdentifier productID = new ObjectIdentifier(aProductSpec.getIdentifier(), aProductSpec.getPrimaryKey());
        String productType = aProductSpec.getProductType();
        //Get bomID
        CimBom aBom = aProductSpec.getBom();
        log.info("Get BOM ID");
        ObjectIdentifier bomID = null;
        if (aBom != null){
            bomID = new ObjectIdentifier(aBom.getIdentifier(), aBom.getPrimaryKey());
        }
        // Get Product Group Object
        CimProductGroup aPosProductGroup = aProductSpec.getProductGroup();
        Validations.check(aPosProductGroup == null, new OmCode(retCodeConfig.getNotFoundProductGroup(), ""));
        ObjectIdentifier productGroupID = new ObjectIdentifier(aPosProductGroup.getIdentifier(), aPosProductGroup.getPrimaryKey());
        // Get Technology Object
        CimTechnology aPosTechnology = aPosProductGroup.getTechnology();
        Validations.check(aPosTechnology == null, new OmCode(retCodeConfig.getNotFoundProductGroup(), productGroupID.getValue()));
        ObjectIdentifier technologyID = new ObjectIdentifier(aPosTechnology.getIdentifier(), aPosTechnology.getPrimaryKey());
        //--- Set to return structure ---//
        Infos.LotProductInfo strLotProductInfo = new Infos.LotProductInfo();
        objLotProductProcessOperationInfoGetOut.setStrLotProductInfo(strLotProductInfo);
        strLotProductInfo.setProductID(productID);
        strLotProductInfo.setProductType(productType);
        strLotProductInfo.setProductGroupID(productGroupID);
        strLotProductInfo.setTechnologyCode(technologyID.getValue());
        strLotProductInfo.setManufacturingLayer(manufacturingLayer);
        strLotProductInfo.setReticleSetID(ObjectIdentifier.fetchValue(reticleSetID));
        strLotProductInfo.setBomID(bomID);

        // -------------------------------------
        // Get Operation information
        // -------------------------------------
        CimProcessOperation aPosPO = aLot.getProcessOperation();
        Infos.ProcessOperationInformation strProcessOperationInformation = new Infos.ProcessOperationInformation();
        objLotProductProcessOperationInfoGetOut.setStrProcessOperationInformation(strProcessOperationInformation);
        if (aPosPO == null){
            strProcessOperationInformation.setMandatoryOperationFlag(false);
            strProcessOperationInformation.setReworkCount(String.valueOf(0));
            return objLotProductProcessOperationInfoGetOut;
        }
        CimProcessDefinition aMainProcessDefinition = aLot.getMainProcessDefinition();
        ObjectIdentifier routeID = new ObjectIdentifier(aMainProcessDefinition.getIdentifier(), aMainProcessDefinition.getPrimaryKey());
        CimProcessDefinition aProcessDefinition = aPosPO.getProcessDefinition();
        Validations.check(aProcessDefinition == null, new OmCode(retCodeConfig.getNotFoundProcessDefinition(), ""));
        ObjectIdentifier operationID = new ObjectIdentifier(aProcessDefinition.getIdentifier(), aProcessDefinition.getPrimaryKey());
        String operationNumber = aLot.getOperationNumber();
        String operationName = aLot.getOperationName();
        Boolean mandatoryOperationFlag = aPosPO.isMandatoryOperation();
        CimStage aStage = aPosPO.getStage();
        ObjectIdentifier stageID = new ObjectIdentifier(aStage.getIdentifier(), aStage.getPrimaryKey());
        String maskLevel = aPosPO.getPhotoLayer();
        String department = aProcessDefinition.getResponsibleDepartment();
        String planStartTimeStamp = CimDateUtils.convertToSpecString(aPosPO.getPlannedStartTimeStamp());
        String planEndTimeStamp = CimDateUtils.convertToSpecString(aPosPO.getPlannedCompTimeStamp());
        CimMachine aMachine = aPosPO.getPlannedMachine();
        ObjectIdentifier plannedEquipmentID = null;
        if (aMachine != null){
            plannedEquipmentID = new ObjectIdentifier(aMachine.getIdentifier(), aMachine.getPrimaryKey());
        }
        CimTestSpecification aTestSpecification = aPosPO.findTestSpecification(aProductSpec);
        ObjectIdentifier testSpecID = null;
        if (aTestSpecification != null){
            testSpecID = new ObjectIdentifier(aTestSpecification.getIdentifier(), aTestSpecification.getPrimaryKey());
        }
        String inspectionType = aProcessDefinition.getInspectionType();
        String queuedTimeStamp = CimDateUtils.convertToSpecString(aLot.getQueuedTimeStamp());
        //--- Set to return structure ---//
        strProcessOperationInformation.setRouteID(routeID);
        strProcessOperationInformation.setOperationID(operationID);
        strProcessOperationInformation.setOperationNumber(operationNumber);
        strProcessOperationInformation.setOperationName(operationName);
        strProcessOperationInformation.setMandatoryOperationFlag(mandatoryOperationFlag);
        strProcessOperationInformation.setStageID(stageID);
        strProcessOperationInformation.setMaskLevel(maskLevel);
        strProcessOperationInformation.setDepartment(department);
        strProcessOperationInformation.setPlanStartTimeStamp(planStartTimeStamp);
        strProcessOperationInformation.setPlanEndTimeStamp(planEndTimeStamp);
        strProcessOperationInformation.setPlannedEquipmentID(plannedEquipmentID);
        strProcessOperationInformation.setTestSpecID(testSpecID);
        strProcessOperationInformation.setInspectionType(inspectionType);
        strProcessOperationInformation.setReworkCount(String.valueOf(0));
        strProcessOperationInformation.setQueuedTimeStamp(queuedTimeStamp);
        return objLotProductProcessOperationInfoGetOut;
    }

    @Override
    public void lotCheckConditionForWaferStacking(Infos.ObjCommon objCommon, List<ObjectIdentifier> stackingLotIDSeq) {
        /*-------------------------*/
        /*   Check Lot Condition   */
        /*-------------------------*/
        Optional.ofNullable(stackingLotIDSeq).ifPresent(list -> list.forEach(lotID -> {
            /*--------------------*/
            /*   Get Lot Object   */
            /*--------------------*/
            CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
            Validations.check(null == aLot, retCodeConfig.getNotFoundLot());
            /*-------------------------------*/
            /*   Get and Check Lot's State   */
            /*-------------------------------*/
            String lotState = aLot.getLotState();
            Validations.check(!CimStringUtils.equals(lotState, BizConstant.CIMFW_LOT_STATE_ACTIVE), retCodeConfig.getInvalidLotStat(),lotState);
            String processState = aLot.getLotProcessState();
            Validations.check(!CimStringUtils.equals(processState, BizConstant.SP_LOT_PROCSTATE_WAITING), new OmCode(retCodeConfig.getInvalidLotProcstat(),aLot.getIdentifier(),processState));
            String inventoryState = aLot.getLotInventoryState();
            Validations.check(!CimStringUtils.equals(inventoryState, BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR), retCodeConfig.getInvalidLotInventoryStat(),
                    ObjectIdentifier.fetchValue(aLot.getLotID()), inventoryState);
        }));
    }

    @Override
    public void lotCheckConditionForWaferStackingCancel(Infos.ObjCommon objCommon, List<ObjectIdentifier> baseLotIDSeq, List<ObjectIdentifier> topLotIDSeq) {
        /*-----------------------------*/
        /*   Check Top Lot Condition   */
        /*-----------------------------*/
        Optional.ofNullable(topLotIDSeq).ifPresent(list -> list.forEach(topLot -> {
            CimLot aLot = baseCoreFactory.getBO(CimLot.class, topLot);
            Validations.check(null == aLot, retCodeConfig.getNotFoundLot());

            /*-------------------------------*/
            /*   Get and Check Lot's State   */
            /*-------------------------------*/
            Validations.check( !CimStringUtils.equals(aLot.getLotState(),BizConstant.CIMFW_LOT_STATE_FINISHED), retCodeConfig.getInvalidLotStat());
            Validations.check( !CimStringUtils.equals(aLot.getLotFinishedState(), BizConstant.SP_LOT_FINISHED_STATE_STACKED), retCodeConfig.getInvalidLotFinishStat());
        }));

        /*-----------------------------*/
        /*   Check Base Lot Condition  */
        /*-----------------------------*/
        Optional.ofNullable(baseLotIDSeq).ifPresent(list -> list.forEach(baseLot -> {
            CimLot aLot = baseCoreFactory.getBO(CimLot.class, baseLot);
            Validations.check(null == aLot, retCodeConfig.getNotFoundLot());

            /*-------------------------------*/
            /*   Get and Check Lot's State   */
            /*-------------------------------*/
            Validations.check(!CimStringUtils.equals(aLot.getLotState(), BizConstant.CIMFW_LOT_STATE_ACTIVE), retCodeConfig.getInvalidLotStat());
            Validations.check(!CimStringUtils.equals(aLot.getLotProcessState(), BizConstant.SP_LOT_PROCSTATE_WAITING),
                    retCodeConfig.getInvalidLotProcessState(), ObjectIdentifier.fetchValue(aLot.getLotID()),aLot.getLotProcessState());
            Validations.check(!CimStringUtils.equals(aLot.getLotInventoryState(), BizConstant.SP_LOT_INVENTORYSTATE_ONFLOOR),
                    retCodeConfig.getInvalidLotInventoryStat(), ObjectIdentifier.fetchValue(aLot.getLotID()), aLot.getLotInventoryState());

            /*-------------------------------*/
            /*  Check Control Job            */
            /*-------------------------------*/
            CimControlJob controlJob = aLot.getControlJob();
            Validations.check(null != controlJob, retCodeConfig.getLotControlJobidFilled());

            /*-------------------------------*/
            /*  Lot should be in PostProcess */
            /*-------------------------------*/
            Validations.check(aLot.isPostProcessFlagOn(), retCodeConfig.getLotInPostProcess());

            /*-------------------------------*/
            /*   Check SorterJob existence   */
            /*-------------------------------*/
            Inputs.ObjWaferSorterJobCheckForOperation objWaferSorterJobCheckForOperation = new Inputs.ObjWaferSorterJobCheckForOperation();
            objWaferSorterJobCheckForOperation.setLotIDList(Collections.singletonList(baseLot));
            objWaferSorterJobCheckForOperation.setOperation(BizConstant.SP_OPERATION_FOR_LOT);
            waferMethod.waferSorterSorterJobCheckForOperation(objCommon, objWaferSorterJobCheckForOperation);
        }));
    }

    @Override
    public void lotWaferStackMake(Infos.ObjCommon objCommon, List<ObjectIdentifier> topLotIDSeq) {

    }

    @Override
    public void lotWaferStackCancel(Infos.ObjCommon objCommon, List<ObjectIdentifier> baseLotIDSeq, List<ObjectIdentifier> topLotIDSeq, List<Infos.StackedWaferInfo> strStackedWaferInfoSeq) {
        CimPerson aPerson = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == aPerson, retCodeConfig.getNotFoundPerson());

        /*-------------------------------*/
        /*   Check Base Wafer ID         */
        /*-------------------------------*/
        Optional.ofNullable(baseLotIDSeq).ifPresent(list -> list.forEach(baseLotID -> {
            log.info("Base Lot ID: " + baseLotID.getValue());
            //--------------------------------------------------
            // Get Lot Object
            //--------------------------------------------------
            CimLot aBaseLot = baseCoreFactory.getBO(CimLot.class, baseLotID);
            Validations.check(null == aBaseLot, retCodeConfig.getNotFoundLot());
            List<Product> prodSeq = aBaseLot.allProducts();
            Optional.ofNullable(prodSeq).ifPresent(products -> products.forEach(wafer -> {
                Optional.ofNullable(strStackedWaferInfoSeq).ifPresent(stackedWaferInfos -> {
                    boolean waferFound = false;
                    for (Infos.StackedWaferInfo stackedWaferInfo : stackedWaferInfos) {
                        if (CimStringUtils.equals(stackedWaferInfo.getBaseWaferID().getValue(), wafer.getIdentifier())) {
                            waferFound = true;
                            break;
                        }
                    }
                    if (!waferFound) {
                        log.error("Top Lot to Base Wafer is not specified.");
                        throw new ServiceException(retCodeConfigEx.getBondingToplotNotSpecified());
                    }
                });
            }));
        }));

        /*-------------------------------*/
        /*   Change state before stack   */
        /*-------------------------------*/
        Optional.ofNullable(topLotIDSeq).ifPresent(topLotIDs -> topLotIDs.forEach(topLotID -> {
            CimLot aTopLot = baseCoreFactory.getBO(CimLot.class, topLotID);
            Validations.check(null == aTopLot, retCodeConfig.getNotFoundLot());

            aTopLot.makeStackCancel();

            //--------------------------------------------------
            // Set State Changed Record
            //--------------------------------------------------
            aTopLot.setStateChangedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            aTopLot.setStateChangedPerson(aPerson);
        }));

        /*-------------------------------------*/
        /*   Restore Stacked Wafer information */
        /*-------------------------------------*/
        Optional.ofNullable(strStackedWaferInfoSeq).ifPresent(stackedWaferInfos -> stackedWaferInfos.forEach(stackedWaferInfo -> {
            log.info("Base Wafer ID: " + stackedWaferInfo.getBaseWaferID().getValue());
            log.info("Top Wafer ID : " + stackedWaferInfo.getTopWaferID().getValue());
            //--------------------------------------------------
            // Get Wafer Object
            //--------------------------------------------------
            CimWafer aBaseWafer = baseCoreFactory.getBO(CimWafer.class, stackedWaferInfo.getBaseWaferID());
            Validations.check(null == aBaseWafer, retCodeConfig.getNotFoundWafer());

            CimWafer aTopWafer = baseCoreFactory.getBO(CimWafer.class, stackedWaferInfo.getTopWaferID());
            Validations.check(null == aTopWafer, retCodeConfig.getNotFoundWafer());

            aTopWafer.makeActive();

            List<ProductDTO.StackedWafer> baseStackedWaferSeq = aBaseWafer.allStackedWafers();
            List<ProductDTO.StackedWafer> topStackedWaferSeq = aTopWafer.allStackedWafers();

            //--------------------------------------------------
            // Get Stacked Wafer Info
            //--------------------------------------------------
            ProductDTO.StackedWafer stackedWafer = new ProductDTO.StackedWafer();
            stackedWafer.setTopLotID(stackedWaferInfo.getTopLotID());
            stackedWafer.setTopWaferID(stackedWaferInfo.getTopWaferID());
            ProductDTO.StackedWafer outPosStackedWafer = aBaseWafer.findStackedWafer(stackedWafer);
            Validations.check(null == outPosStackedWafer, retCodeConfigEx.getNotFoundStackedWafer());

            Optional.ofNullable(baseStackedWaferSeq).ifPresent(stackedWafers -> stackedWafers.forEach(wafer -> {
                Timestamp date1 = CimDateUtils.convertToOrInitialTime(wafer.getStackedTimeStamp());
                Timestamp date2 = CimDateUtils.convertToOrInitialTime(outPosStackedWafer.getStackedTimeStamp());
                assert null != date1 && null != date2;
                if (date1.compareTo(date2) > 0) {
                    log.error("Newer Stacked Wafer Information Entry Found.");
                    throw new ServiceException(new OmCode(retCodeConfigEx.getStackCancelOtherWaferStacked(),
                            wafer.getTopWaferID().getValue(), stackedWaferInfo.getTopWaferID().getValue(),stackedWaferInfo.getBaseWaferID().getValue()));
                }
            }));

            Optional.ofNullable(topStackedWaferSeq).ifPresent(list -> list.forEach(aBaseWafer::removeStackedWafer));

            aBaseWafer.removeStackedWafer(outPosStackedWafer);

            if (0 > outPosStackedWafer.getMaterialOffset()) {
                baseStackedWaferSeq = aBaseWafer.allStackedWafers();
                Optional.ofNullable(baseStackedWaferSeq).ifPresent(list -> list.forEach(data -> {
                    aBaseWafer.removeStackedWafer(data);
                    data.setMaterialOffset(Math.abs(data.getMaterialOffset()));
                    aBaseWafer.addStackedWafer(data);
                }));
                aBaseWafer.setAliasWaferName(outPosStackedWafer.getPreviousAliasWaferName());
            }

            //--------------------------------------------------
            // Set Last Claimed Record
            //--------------------------------------------------
            aBaseWafer.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            aTopWafer.setLastClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());

            aBaseWafer.setLastClaimedPerson(aPerson);
            aTopWafer.setLastClaimedPerson(aPerson);
        }));
    }

    @Override
    public List<ObjectIdentifier> lotCassetteListGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot cimLot = baseCoreFactory.getBO(CimLot.class, lotID);
        List<MaterialContainer> cassetteSeq = cimLot.materialContainers();
        Validations.check(CimArrayUtils.isEmpty(cassetteSeq), retCodeConfig.getNotFoundCassette());
        List<ObjectIdentifier> result = new ArrayList<>(cassetteSeq.size());
        cassetteSeq.forEach(cassette -> result.add(ObjectIdentifier.build(cassette.getIdentifier(), cassette.getPrimaryKey())));
        return result;
    }

    @Override
    public List<Infos.StartCassette> lotAPCRecipeParameterResponse(Infos.ObjCommon objCommon, List<Infos.StartCassette> strStartCassette, List<Infos.APCRecipeParameterResponse> strAPCRecipeParameterResponse) {
        List<Infos.LotInCassette> strRecipeParameter_AdjustLotInfo = new ArrayList<>();
        //--------------------------------------------------------------------------
        // Checking of OperationStartFlag, LotID, WaferID and SlotNumber Combination
        //---------------------------------------------------------------------------
        int nLenResp = CimArrayUtils.getSize(strAPCRecipeParameterResponse);
        int iResp1 = 0;
        //----------------------------
        // For Response Parameter Loop
        //----------------------------
        for (iResp1 = 0; iResp1 < nLenResp; iResp1++){
            List<Infos.ApcBaseCassette> strAPCBaseCassette = strAPCRecipeParameterResponse.get(iResp1).getStrAPCBaseCassette();
            int nLenRespCas = CimArrayUtils.getSize(strAPCBaseCassette);
            int iResp2 = 0;
            for (iResp2 = 0; iResp2 < nLenRespCas; iResp2++){
                List<Infos.ApcBaseLot> apcBaseLotList = strAPCBaseCassette.get(iResp2).getApcBaseLotList();
                int nLenRespLot = CimArrayUtils.getSize(apcBaseLotList);
                int iResp3 = 0;
                for (iResp3 = 0; iResp3 < nLenRespLot; iResp3++){
                    String tmpRespLotID = apcBaseLotList.get(iResp3).getLotID();
                    String tmpRespWafer;
                    Long tmpRespSlot = 0L;
                    //----------------------------------
                    // For Start Cassette Parameter Loop
                    //----------------------------------
                    int nLenStartCas = CimArrayUtils.getSize(strStartCassette);
                    int iStartCas1 = 0;
                    boolean findLotFlag = false;
                    for (iStartCas1 = 0; iStartCas1 < nLenStartCas; iStartCas1++){
                        List<Infos.LotInCassette> lotInCassetteList = strStartCassette.get(iStartCas1).getLotInCassetteList();
                        int nLenStartLotInCas = CimArrayUtils.getSize(lotInCassetteList);
                        int iStartCas2 = 0;
                        for (iStartCas2 = 0; iStartCas2 < nLenStartLotInCas; iStartCas2++){
                            String tmpStartLotID = lotInCassetteList.get(iStartCas2).getLotID().getValue();
                            String tmpStartWafer;
                            Long tmpStartSlot = 0L;
                            if (CimStringUtils.equals(tmpRespLotID, tmpStartLotID)){
                                findLotFlag = true;
                                List<Infos.ApcBaseWafer> apcBaseWaferList = apcBaseLotList.get(iResp3).getApcBaseWaferList();
                                int nLenRespWafer = CimArrayUtils.getSize(apcBaseWaferList);
                                int iResp4 = 0;
                                for (iResp4 = 0; iResp4 < nLenRespWafer; iResp4++){
                                    tmpRespWafer = apcBaseWaferList.get(iResp4).getWaferID();
                                    tmpRespSlot = apcBaseWaferList.get(iResp4).getSlotNumber();
                                    List<Infos.LotWafer> lotWaferList = lotInCassetteList.get(iStartCas2).getLotWaferList();
                                    int nLenStartWafer = CimArrayUtils.getSize(lotWaferList);
                                    int iStartCas3 = 0;
                                    boolean findWaferFlag = false;
                                    for (iStartCas3 = 0; iStartCas3 < nLenStartWafer; iStartCas3++){
                                        tmpStartWafer = lotWaferList.get(iStartCas3).getWaferID().getValue();
                                        tmpStartSlot = lotWaferList.get(iStartCas3).getSlotNumber();
                                        if (CimStringUtils.equals(tmpStartWafer, tmpRespWafer) && Objects.equals(tmpStartSlot, tmpRespSlot)){
                                            findWaferFlag = true;
                                            break;
                                        }
                                    }
                                    //------------------------------------------------
                                    // Judgement of In-Parameter Combination for Wafer
                                    //------------------------------------------------
                                    Validations.check(!findWaferFlag, retCodeConfigEx.getApcReturnInvalidParam());
                                }
                                break;
                            }
                        }
                        if (findLotFlag){
                            log.info("APC-Lot is found and APC-Wafer information is correct. Go to next APC-Lot.");
                            break;
                        }
                    }

                    //----------------------------------------------
                    // Judgement of In-Parameter Combination for Lot
                    //----------------------------------------------
                    Validations.check(!findLotFlag, retCodeConfigEx.getApcReturnInvalidParam());
                }
            }
        }

        //----------------------------------------------------------------------------------------
        //   Check waferID,parameterName of strAPCRecipeParameterResponse and tmpStartCassette,
        //     based on lotID,waferID,parameterName of strAPCRecipeParameterResponse.
        //----------------------------------------------------------------------------------------
        int nLen1 = CimArrayUtils.getSize(strAPCRecipeParameterResponse);
        for (int loop1=0; loop1<nLen1; loop1++){
            List<Infos.ApcBaseCassette> strAPCBaseCassette = strAPCRecipeParameterResponse.get(loop1).getStrAPCBaseCassette();
            int nLen2 = CimArrayUtils.getSize(strAPCBaseCassette);
            for(int loop2=0; loop2<nLen2; loop2++){
                List<Infos.ApcBaseLot> apcBaseLotList = strAPCBaseCassette.get(loop2).getApcBaseLotList();
                int nLen3 = CimArrayUtils.getSize(apcBaseLotList);
                for (int loop3=0; loop3<nLen3; loop3++){
                    List<Infos.ApcBaseWafer> apcBaseWaferList = apcBaseLotList.get(loop3).getApcBaseWaferList();
                    int nLen4 = CimArrayUtils.getSize(apcBaseWaferList);
                    for (int loop4=0; loop4<nLen4; loop4++){
                        List<Infos.ApcBaseRecipeParameter> apcBaseRecipeParameterList = apcBaseWaferList.get(loop4).getApcBaseRecipeParameterList();
                        int nLen5 = CimArrayUtils.getSize(apcBaseRecipeParameterList);
                        for (int loop5=0; loop5<nLen5; loop5++){
                            int adjLotPos = -1;
                            int adjWaferPos = -1;
                            //-----------------------------------------
                            //   Check lotID, waferID, parameterName
                            //   Not exit -> return error
                            //-----------------------------------------
                            int nLen6 = CimArrayUtils.getSize(strRecipeParameter_AdjustLotInfo);
                            for (int loop6=0; loop6<nLen6; loop6++){
                                if (ObjectIdentifier.equalsWithValue(strRecipeParameter_AdjustLotInfo.get(loop6).getLotID(), apcBaseLotList.get(loop3).getLotID())){
                                    adjLotPos = loop6;
                                    List<Infos.LotWafer> lotWaferList = strRecipeParameter_AdjustLotInfo.get(loop6).getLotWaferList();
                                    int nLen7 = CimArrayUtils.getSize(lotWaferList);
                                    for (int loop7=0; loop7<nLen7; loop7++){
                                        if (ObjectIdentifier.equalsWithValue(lotWaferList.get(loop7).getWaferID(), apcBaseWaferList.get(loop4).getWaferID())){
                                            adjWaferPos = loop7;
                                            List<Infos.StartRecipeParameter> startRecipeParameterList = lotWaferList.get(loop7).getStartRecipeParameterList();
                                            int nLen8 = CimArrayUtils.getSize(startRecipeParameterList);
                                            for (int loop8=0; loop8<nLen8; loop8++){
                                                if (CimStringUtils.equals(startRecipeParameterList.get(loop8).getParameterName(), apcBaseRecipeParameterList.get(loop5).getName())){
                                                    throw new ServiceException(retCodeConfig.getApcReturnDuplicateParametername());
                                                }
                                            }
                                            break;
                                        }
                                    }
                                    break;
                                }
                            }
                            nLen6 = CimArrayUtils.getSize(strStartCassette);
                            for (int loop6=0; loop6<nLen6; loop6++){
                                List<Infos.LotInCassette> lotInCassetteList = strStartCassette.get(loop6).getLotInCassetteList();
                                int nLen7 = CimArrayUtils.getSize(lotInCassetteList);
                                int loop7=0;
                                for (loop7=0; loop7<nLen7; loop7++){
                                    if(ObjectIdentifier.equalsWithValue(lotInCassetteList.get(loop7).getLotID(), apcBaseLotList.get(loop3).getLotID()) && lotInCassetteList.get(loop7).getMoveInFlag()){
                                        Infos.LotInCassette addLotInfo = null;
                                        if (adjLotPos < 0){
                                            addLotInfo = new Infos.LotInCassette();
                                            strRecipeParameter_AdjustLotInfo.add(addLotInfo);
                                            addLotInfo.setLotID(lotInCassetteList.get(loop7).getLotID());
                                        } else {
                                            addLotInfo = strRecipeParameter_AdjustLotInfo.get(adjLotPos);
                                        }
                                        List<Infos.LotWafer> lotWaferList = lotInCassetteList.get(loop7).getLotWaferList();
                                        int nLen8 = CimArrayUtils.getSize(lotWaferList);
                                        for (int loop8=0; loop8<nLen8; loop8++){
                                            if (ObjectIdentifier.equalsWithValue(lotWaferList.get(loop8).getWaferID(), apcBaseWaferList.get(loop4).getWaferID())){
                                                lotWaferList.get(loop8).setProcessJobExecFlag(apcBaseWaferList.get(loop4).isProcessFlag());
                                                int adjustWaferLen = CimArrayUtils.getSize(addLotInfo.getLotWaferList());
                                                Infos.LotWafer addstrWafer = null;
                                                if (adjWaferPos < 0){
                                                    List<Infos.LotWafer> tmpLotWaferList = addLotInfo.getLotWaferList();
                                                    if (CimArrayUtils.isEmpty(tmpLotWaferList)){
                                                        tmpLotWaferList = new ArrayList<>();
                                                        addLotInfo.setLotWaferList(tmpLotWaferList);
                                                    }
                                                    addstrWafer = new Infos.LotWafer();
                                                    tmpLotWaferList.add(addstrWafer);
                                                    addstrWafer.setWaferID(lotWaferList.get(loop8).getWaferID());
                                                } else {
                                                    addstrWafer = addLotInfo.getLotWaferList().get(adjWaferPos);
                                                }
                                                List<Infos.StartRecipeParameter> startRecipeParameterList = lotWaferList.get(loop8).getStartRecipeParameterList();
                                                int nLen9 = CimArrayUtils.getSize(startRecipeParameterList);
                                                for (int loop9=0; loop9<nLen9; loop9++){
                                                    if (CimStringUtils.equals(startRecipeParameterList.get(loop9).getParameterName(), apcBaseRecipeParameterList.get(loop5).getName())){
                                                        List<Infos.StartRecipeParameter> tmpStartRecipeParameterList = addstrWafer.getStartRecipeParameterList();
                                                        if (CimArrayUtils.isEmpty(tmpStartRecipeParameterList)){
                                                            tmpStartRecipeParameterList = new ArrayList<>();
                                                            addstrWafer.setStartRecipeParameterList(tmpStartRecipeParameterList);
                                                        }
                                                        Infos.StartRecipeParameter addReciPara = new Infos.StartRecipeParameter();
                                                        tmpStartRecipeParameterList.add(addReciPara);
                                                        addReciPara.setParameterName(startRecipeParameterList.get(loop9).getParameterName());
                                                        startRecipeParameterList.get(loop9).setParameterValue(apcBaseRecipeParameterList.get(loop5).getValue());
                                                        startRecipeParameterList.get(loop9).setUseCurrentSettingValueFlag(apcBaseRecipeParameterList.get(loop5).isUseCurrentValueFlag());
                                                        if (startRecipeParameterList.get(loop9).getUseCurrentSettingValueFlag()){
                                                            log.info("useCurrentSettingValueFlag == TURE");
                                                        } else {
                                                            log.info("useCurrentSettingValueFlag == FLASE");
                                                        }
                                                        break;
                                                    }
                                                }
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                }
                                if (loop7 < nLen7){
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
        //---------------------------------------------------------------------
        // Check adjusted Parameter Condition and Set RecipeParameterChangeType
        //---------------------------------------------------------------------
        int nLenCast = CimArrayUtils.getSize(strStartCassette);
        int i1;
        for (i1 = 0; i1 < nLenCast; i1++){
            List<Infos.LotInCassette> lotInCassetteList = strStartCassette.get(i1).getLotInCassetteList();
            int nLenLotInCas = CimArrayUtils.getSize(lotInCassetteList);
            int i2;
            for (i2 = 0; i2 < nLenLotInCas; i2++){
                //---------------------------------
                // Judgement of Operaton Start Flag
                //---------------------------------
                if (lotInCassetteList.get(i2).getMoveInFlag()){
                    List<Infos.LotWafer> lotWaferList = lotInCassetteList.get(i2).getLotWaferList();
                    int nLenWafer = CimArrayUtils.getSize(lotWaferList);
                    int  i3;
                    boolean byWaferFlag = false;
                    List<String> tmpParamNames = null;
                    List<String> tmpParamVals = null;
                    for (i3 = 0; i3 < nLenWafer; i3++){
                        List<Infos.StartRecipeParameter> startRecipeParameterList = lotWaferList.get(i3).getStartRecipeParameterList();
                        int nLenParam = CimArrayUtils.getSize(startRecipeParameterList);
                        int i4;
                        //-------------------------------------------------------
                        //Store Prameter Name and Parameter Value for comparetion
                        //-------------------------------------------------------
                        if (i3 == 0){
                            //-----------
                            //First Wafer
                            //-----------
                            tmpParamNames = new ArrayList<>();
                            tmpParamVals = new ArrayList<>();
                            for (i4 = 0; i4 < nLenParam; i4++){
                                tmpParamNames.add(startRecipeParameterList.get(i4).getParameterName());
                                tmpParamVals.add(startRecipeParameterList.get(i4).getParameterValue());
                            }
                        } else {
                            //-----------------
                            //After First Wafer
                            //-----------------
                            int nLenTmpParam = CimArrayUtils.getSize(tmpParamNames);
                            //Parameter Loop
                            for (i4 = 0; i4 < nLenParam; i4++){
                                String wokParamName = startRecipeParameterList.get(i4).getParameterName();
                                String wokParamVal = startRecipeParameterList.get(i4).getParameterValue();
                                int i5;
                                for (i5 = 0; i5 < nLenTmpParam; i5++){
                                    if (CimStringUtils.equals(tmpParamNames.get(i5), wokParamName)){
                                        if (!CimStringUtils.equals(tmpParamVals.get(i5), wokParamVal)){
                                            //Break tmpParam Loop
                                            byWaferFlag = true;
                                            break;
                                        }
                                    }
                                }
                                //Break Parameter Loop
                                if (byWaferFlag) break;
                            }
                        }
                        if (byWaferFlag) break;
                    }
                    //----------------------------------
                    // Set for recipeParameterChangeType
                    //----------------------------------
                    if (byWaferFlag){
                        lotInCassetteList.get(i2).setRecipeParameterChangeType(BizConstant.SP_RPARM_CHANGETYPE_BYWAFER);
                    } else {
                        lotInCassetteList.get(i2).setRecipeParameterChangeType(BizConstant.SP_RPARM_CHANGETYPE_BYLOT);
                    }
                }
            }
        }
        return strStartCassette;
    }


    @Override
    public Infos.RunCardHistoryGetDROut runCardPsmDocHisotryGetDR(Infos.ObjCommon strObjCommonIn, Infos.RunCardHistoryGetDRIn runCardHistoryGetDRIn) {
        //init result
        Infos.RunCardHistoryGetDROut result = new Infos.RunCardHistoryGetDROut();

        List<Infos.TableRecordInfo> strTableRecordInfoSeq = new ArrayList<>();
        List<Infos.TableRecordValue> strTableRecordValueSeq = new ArrayList<>();

        SearchCondition searchCondition = runCardHistoryGetDRIn.getSearchCondition();

        result.setStrTableRecordInfoSeq(strTableRecordInfoSeq);
        result.setStrTableRecordValueSeq(strTableRecordValueSeq);

        //check input
        if ( !CimStringUtils.equals( runCardHistoryGetDRIn.getHistoryCategory(), BizConstant.SP_HISTORYCATEGORY_RUNCARD)){
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(),"History Category is not correct"));
        }

        String sqlTemp = "";

        List<Infos.TargetTableInfo> strTargetTableInfoSeq = runCardHistoryGetDRIn.getStrTargetTableInfoSeq();
        if (CimArrayUtils.isNotEmpty(strTargetTableInfoSeq)){
            for (Infos.TargetTableInfo targetTableInfo : strTargetTableInfoSeq) {
                //OHRUNCARD table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_OHRUNCARD,targetTableInfo.getTableName())){
                    //hashKey for runCard
                    String runCardID = "";
                    String lotID = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_OHRUNCARD );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMUSERID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ACTION );
                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDSTATE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_OWNREID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_EXTAPROVALFLAG );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CREATETIME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_UPDATETIME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_APPROVERS );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMMEMO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDTYPE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_AUTOCOMPLETEFLAG );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            /*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }
                            */
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_LOTID,hashedInfo.getHashKey())){
                                lotID = hashedInfo.getHashData();
                            }
                        }
                    }
                    String sql = "SELECT " +
                            "TO_TIMESTAMP(EVENT_TIME,'yyyy-mm-dd-hh24:mi:ss.ff'), " +
                            "TRX_USER_ID, " +
                            "OPE_CATEGORY, " +
                            "RUNCARD_ID, " +
                            "LOT_ID," +
                            "RUNCARD_STATE, " +
                            "OWNER_ID, " +
                            "EXT_APROVAL_FLAG, " +
                            "CREATE_TIME, " +
                            "UPDATE_TIME, " +
                            "APPROVERS, " +
                            "TRX_MEMO, " +
                            "RUNCARD_TYPE, " +
                            "AUTO_COMPLETE_FLAG " +
                            "FROM OHRUNCARD ";

                    if (CimStringUtils.isNotEmpty(runCardID)){
                        sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(lotID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND LOT_ID = '%s' ",lotID);
                        }else {
                            sqlTemp = String.format(" WHERE LOT_ID = '%s' ",lotID);
                        }
                        sql += sqlTemp;
                    }
                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_OHRUNCARD );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : String.valueOf(queryResult[2]) );
//                            columnValues.add( queryResult[3] == null ? null : String.valueOf(queryResult[3]) );
                            columnValues.add( queryResult[4] == null ? null : String.valueOf(queryResult[4]) );
                            columnValues.add( queryResult[5] == null ? null : String.valueOf(queryResult[5]) );
                            columnValues.add( queryResult[6] == null ? null : String.valueOf(queryResult[6]) );
                            columnValues.add( CimBooleanUtils.getBoolean(String.valueOf(queryResult[7])) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[8]) ) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[9]) ) );
                            columnValues.add( queryResult[10] == null ? null : String.valueOf(queryResult[10]) );
                            columnValues.add( queryResult[11] == null ? null : String.valueOf(queryResult[11]) );
                            columnValues.add( queryResult[12] == null ? null : String.valueOf(queryResult[12]) );
                            columnValues.add( queryResult[13] == null ? null : CimBooleanUtils.getBoolean(String.valueOf(queryResult[13])) );
                        }
                    }
                }
                // psm history table
                //PSM OHPSM table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_FHPLSPHS,targetTableInfo.getTableName())){

                    //hashKey for psm
                    String lotFamilyID = "";
                    String psmJobID = "";
                    String runCardID = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHPLSPHS );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP ); //calim_time
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ACTION );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTFAMILYID);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPLITMAINPDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPLITOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ORIGMAINPDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ORIGOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_MAILACTION );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_HOLDACTION );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SEQNO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SUBROUTEID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RETURNOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_MERGEOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARENTLOTID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CHILDLOTID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_MEMO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMUSERID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMMEMO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_STOREDTIMESTAMP );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PLANSPLITJOBID );
                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_LOTFAMILYID,hashedInfo.getHashKey())){
                                lotFamilyID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_PLANSPLITJOBID,hashedInfo.getHashKey())){
                                psmJobID = hashedInfo.getHashData();
                            }
                            /*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }
                            */
                        }
                    }
                    String sql = "SELECT " +
                            "TRX_TIME, " +
                            "TASK_TYPE, " +
                            "LOTFAMILY_ID, " +
                            "SPLIT_PROCESS_ID, " +
                            "SPLIT_OPE_NO," +
                            "ORIG_PROCESS_ID, " +
                            "ORIG_OPE_NO, " +
                            "MAIL_ACTION, " +
                            "HOLD_ACTION, " +
                            "IDX_NO, " +
                            "SUB_PROCESS_ID, " +
                            "RETURN_OPE_NO, " +
                            "MERGE_OPE_NO, " +
                            "PARENT_LOT_ID, " +
                            "CHILD_LOT_ID, " +
                            "TEST_MEMO, " +
                            "TRX_USER_ID, " +
                            "TRX_MEMO, " +
                            "STORE_TIME, " +
                            "PLSPLITJOB_ID,  " +
                            "RUNCARD_ID  " +
                            "FROM OHPSM ";

                    if (CimStringUtils.isNotEmpty(lotFamilyID)){
                        sqlTemp = String.format(" WHERE LOTFAMILY_ID = '%s' ",lotFamilyID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(psmJobID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND PLSPLITJOB_ID = '%s' ",psmJobID);
                        }else {
                            sqlTemp = String.format(" WHERE PLSPLITJOB_ID = '%s' ",psmJobID);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(runCardID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND RUNCARD_ID = '%s' ",runCardID);
                        }else {
                            sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        }
                        sql += sqlTemp;
                    }
                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHPLSPHS );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : String.valueOf(queryResult[2]) );
                            columnValues.add( queryResult[3] == null ? null : String.valueOf(queryResult[3]) );
                            columnValues.add( queryResult[4] == null ? null : String.valueOf(queryResult[4]) );
                            columnValues.add( queryResult[5] == null ? null : String.valueOf(queryResult[5]) );
                            columnValues.add( queryResult[6] == null ? null : String.valueOf(queryResult[6]) );

                            columnValues.add( queryResult[7] == null ? null : CimBooleanUtils.getBoolean(String.valueOf(queryResult[7])) );
                            columnValues.add( queryResult[8] == null ? null : CimBooleanUtils.getBoolean(String.valueOf(queryResult[8])) );

                            columnValues.add( queryResult[9] == null ? null : Integer.valueOf(queryResult[9].toString()) );
                            columnValues.add( queryResult[10] == null ? null : String.valueOf(queryResult[10]) );
                            columnValues.add( queryResult[11] == null ? null : String.valueOf(queryResult[11]) );
                            columnValues.add( queryResult[12] == null ? null : String.valueOf(queryResult[12]) );
                            columnValues.add( queryResult[13] == null ? null : String.valueOf(queryResult[13]) );
                            columnValues.add( queryResult[14] == null ? null : String.valueOf(queryResult[14]) );
                            columnValues.add( queryResult[15] == null ? null : String.valueOf(queryResult[15]) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[16] == null ? null : String.valueOf(queryResult[16]));
                            columnValues.add( queryResult[17] == null ? null : String.valueOf(queryResult[17]));
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[18]) ) );
                            columnValues.add( queryResult[19] == null ? null : String.valueOf(queryResult[19]) );
//                            columnValues.add( queryResult[20] == null ? null : String.valueOf(queryResult[20]) );
                        }
                    }
                }
                //PSM OHPSM_WAFER table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_FHPLSPHS_WAFER,targetTableInfo.getTableName())){

                    //hashKey for psm
                    String lotFamilyID = "";
                    String psmJobID = "";
                    String runCardID = "";
                    String cliamTime = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHPLSPHS_WAFER );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP ); //calim_time
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ACTION );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTFAMILYID);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPLITMAINPDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPLITOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ORIGMAINPDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ORIGOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SEQNO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SUBROUTEID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARENTLOTID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CHILDLOTID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SUCESSFLAG );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PLANSPLITJOBID );
                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_LOTFAMILYID,hashedInfo.getHashKey())){
                                lotFamilyID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_PLANSPLITJOBID,hashedInfo.getHashKey())){
                                psmJobID = hashedInfo.getHashData();
                            }
                            /*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }
                            */
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME,hashedInfo.getHashKey())){
                                cliamTime = hashedInfo.getHashData();
                            }
                        }
                    }

                    String sql = "SELECT " +
                            "TRX_TIME, " +
                            "ACTION, " +
                            "LOTFAMILY_ID, " +
                            "SPLIT_PROCESS_ID, " +
                            "SPLIT_OPE_NO, " +
                            "ORIG_PROCESS_ID, " +
                            "ORIG_OPE_NO, " +
                            "IDX_NO, " +
                            "SUB_PROCESS_ID, " +
                            "PARENT_LOT_ID, " +
                            "CHILD_LOT_ID, " +
                            "WAFER_ID, " +
                            "PSM_EXEC_RESULT, " +
                            "PLSPLITJOB_ID, " +
                            "RUNCARD_ID " +
                            "FROM OHPSM_WAFER ";
                    //set columnvalue
                    if (CimStringUtils.isNotEmpty(lotFamilyID)){
                        sqlTemp = String.format(" WHERE LOTFAMILY_ID = '%s' ",lotFamilyID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(psmJobID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND PLSPLITJOB_ID = '%s' ",psmJobID);
                        }else {
                            sqlTemp = String.format(" WHERE PLSPLITJOB_ID = '%s' ",psmJobID);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(runCardID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND RUNCARD_ID = '%s' ",runCardID);
                        }else {
                            sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(cliamTime)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }else {
                            sqlTemp = String.format(" WHERE TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }
                        sql += sqlTemp;
                    }
                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHPLSPHS_WAFER );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : String.valueOf(queryResult[2]) );
                            columnValues.add( queryResult[3] == null ? null : String.valueOf(queryResult[3]) );
                            columnValues.add( queryResult[4] == null ? null : String.valueOf(queryResult[4]) );
                            columnValues.add( queryResult[5] == null ? null : String.valueOf(queryResult[5]) );
                            columnValues.add( queryResult[6] == null ? null : String.valueOf(queryResult[6]) );
                            columnValues.add( queryResult[8] == null ? null : String.valueOf(queryResult[8]) );
                            columnValues.add( queryResult[7] == null ? null : Integer.valueOf(queryResult[7].toString()) );
                            columnValues.add( queryResult[9] == null ? null : String.valueOf(queryResult[9]) );
                            columnValues.add( queryResult[10] == null ? null : String.valueOf(queryResult[10]) );
                            columnValues.add( queryResult[11] == null ? null : String.valueOf(queryResult[11]) );
                            columnValues.add( queryResult[12] == null ? null : String.valueOf(queryResult[12]));
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[13] == null ? null : String.valueOf(queryResult[13]) );
//                            columnValues.add( queryResult[14] == null ? null : String.valueOf(queryResult[14]) );
                        }
                    }
                }
                //doc hsitory table
                //DOC OHDOC table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_FHFPCHS,targetTableInfo.getTableName())){
                    //hashKey for doc
                    String docJobID = "";
                    String lotFamilyID = "";
                    String cliamTime = "";
                    String runCardID = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP ); //calim_time
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ACTION );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_LOTFAMILYID);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_MAINPDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_OPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ORIGMAINPDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_ORIGOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SUBROUTEID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SUBOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCGROUPNO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCTYPE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_MERGEMAINPDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_MERGEOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCCATEGORYID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PDID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PDTYPE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CORRESPONDOPENO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SKIPFLAG );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RESTRICTEQPFLAG );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_EQUIPMENTID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RPRMCHANGETYPE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RECIPEID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DCDEFID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DCSPECID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SENDEMAILFLAG );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_HOLDLOTFLAG );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DESCRIPTION );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CREATETIME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_UPDATETIME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMUSERID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMMEMO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_STOREDTIMESTAMP );
                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_LOTFAMILYID,hashedInfo.getHashKey())){
                                lotFamilyID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_DOCID,hashedInfo.getHashKey())){
                                docJobID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME,hashedInfo.getHashKey())){
                                cliamTime = hashedInfo.getHashData();
                            }
                            /*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }
                            */
                        }
                    }

                    String sql = "SELECT " +
                            "TRX_TIME, " +
                            "TASK_TYPE, " +
                            "DOC_ID, " +
                            "LOTFAMILY_ID, " +
                            "PROCESS_ID, " +
                            "OPE_NO, " +
                            "ORIG_PROCESS_ID, " +
                            "ORIG_OPE_NO, " +
                            "SUB_PROCESS_ID, " +
                            "SUB_OPE_NO, " +
                            "DOC_GROUP_NO, " +
                            "DOC_TYPE, " +
                            "MERGE_PROCESS_ID, " +
                            "MERGE_OPE_NO, " +
                            "DOC_CATEGORY_ID, " +
                            "STEP_ID, " +
                            "STEP_TYPE, " +
                            "CORR_OPE_NO, " +
                            "SKIP_FLAG, " +
                            "LIMIT_EQP_FLAG, " +
                            "EQP_ID, " +
                            "RPARAM_CHG_TYPE, " +
                            "MRCP_ID, " +
                            "EDC_PLAN_ID, " +
                            "EDC_SPEC_ID, " +
                            "SEND_EMAIL_FLAG, " +
                            "HOLD_LOT_FLAG, " +
                            "DESCRIPTION, " +
                            "CREATE_TIME, " +
                            "UPDATE_TIME," +
                            "TRX_USER_ID, " +
                            "TRX_MEMO, " +
                            "STORE_TIME, " +
                            "RUNCARD_ID " +
                            "FROM OHDOC ";
                    //set columnvalue
                    if (CimStringUtils.isNotEmpty(lotFamilyID)){
                        sqlTemp = String.format(" WHERE LOTFAMILY_ID = '%s' ",lotFamilyID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(docJobID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND DOC_ID = '%s' ",docJobID);
                        }else {
                            sqlTemp = String.format(" WHERE DOC_ID = '%s' ",docJobID);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(cliamTime)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }else {
                            sqlTemp = String.format(" WHERE TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(runCardID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND RUNCARD_ID = '%s' ",runCardID);
                        }else {
                            sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        }
                        sql += sqlTemp;
                    }
                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : String.valueOf(queryResult[2]) );
                            columnValues.add( queryResult[3] == null ? null : String.valueOf(queryResult[3]) );
                            columnValues.add( queryResult[4] == null ? null : String.valueOf(queryResult[4]) );
                            columnValues.add( queryResult[5] == null ? null : String.valueOf(queryResult[5]) );
                            columnValues.add( queryResult[6] == null ? null : String.valueOf(queryResult[6]) );
                            columnValues.add( queryResult[7] == null ? null : String.valueOf(queryResult[7]) );
                            columnValues.add( queryResult[8] == null ? null : String.valueOf(queryResult[8]) );
                            columnValues.add( queryResult[9] == null ? null : String.valueOf(queryResult[9]) );
                            columnValues.add( queryResult[10] == null ? null : String.valueOf(queryResult[10]) );
                            columnValues.add( queryResult[11] == null ? null : String.valueOf(queryResult[11]) );
                            columnValues.add( queryResult[12] == null ? null : String.valueOf(queryResult[12]) );
                            columnValues.add( queryResult[13] == null ? null : String.valueOf(queryResult[13]) );
                            columnValues.add( queryResult[14] == null ? null : String.valueOf(queryResult[14]) );
                            columnValues.add( queryResult[15] == null ? null : String.valueOf(queryResult[15]) );
                            columnValues.add( queryResult[16] == null ? null : String.valueOf(queryResult[16]) );
                            columnValues.add( queryResult[17] == null ? null : String.valueOf(queryResult[17]) );

                            columnValues.add( queryResult[18] == null ? null : CimBooleanUtils.getBoolean(String.valueOf(queryResult[18])) );
                            columnValues.add( queryResult[19] == null ? null : CimBooleanUtils.getBoolean(String.valueOf(queryResult[19])) );

                            columnValues.add( queryResult[20] == null ? null : String.valueOf(queryResult[20]) );
                            columnValues.add( queryResult[21] == null ? null : String.valueOf(queryResult[21]) );
                            columnValues.add( queryResult[22] == null ? null : String.valueOf(queryResult[22]) );
                            columnValues.add( queryResult[23] == null ? null : String.valueOf(queryResult[23]) );
                            columnValues.add( queryResult[24] == null ? null : String.valueOf(queryResult[24]) );

                            columnValues.add( queryResult[25] == null ? null : CimBooleanUtils.getBoolean(String.valueOf(queryResult[25])) );
                            columnValues.add( queryResult[26] == null ? null : CimBooleanUtils.getBoolean(String.valueOf(queryResult[26])) );
                            columnValues.add( queryResult[27] == null ? null : String.valueOf(queryResult[27]) );

                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[28]) ) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[29]) ) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );

                            columnValues.add( queryResult[29] == null ? null : String.valueOf(queryResult[30]) );
                            columnValues.add( queryResult[30] == null ? null : String.valueOf(queryResult[31]) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[32]) ) );
//                            columnValues.add( queryResult[27] == null ? null : String.valueOf(queryResult[33]) );
                        }
                    }
                }
                //DOC OHDOC_WAFER table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_FHFPCHS_WAFER,targetTableInfo.getTableName())){

                    //hashKey for doc
                    String docJobID = "";
                    String cliamTime = "";
                    String runCardID = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_WAFER );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_DOCID,hashedInfo.getHashKey())){
                                docJobID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME,hashedInfo.getHashKey())){
                                cliamTime = hashedInfo.getHashData();
                            }
                            /*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }
                            */
                        }
                    }

                    //set columnvalue
                    String sql = "SELECT " +
                            "TRX_TIME, " +
                            "DOC_ID, " +
                            "WAFER_ID, " +
                            "RUNCARD_ID " +
                            "FROM OHDOC_WAFER ";
                    //set columnvalue
                    if (CimStringUtils.isNotEmpty(docJobID)){
                        sqlTemp = String.format(" WHERE DOC_ID = '%s' ",docJobID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(cliamTime)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }else {
                            sqlTemp = String.format(" WHERE TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(runCardID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND RUNCARD_ID = '%s' ",runCardID);
                        }else {
                            sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        }
                        sql += sqlTemp;
                    }

                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_WAFER );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : String.valueOf(queryResult[2]) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
//                            columnValues.add( queryResult[3] == null ? null : String.valueOf(queryResult[3]) );
                        }
                    }
                }
                //DOC OHDOC_WAFER_RPARAM table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_FHFPCHS_WAFER_RPARM,targetTableInfo.getTableName())){

                    //hashKey for doc
                    String docJobID = "";
                    String cliamTime = "";
                    String runCardID = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_WAFER_RPARM );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_WAFERID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SEQNO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMNAME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMUNIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMDATATYPE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMLOWNERLIMIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMUPPERLIMIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMUSECURFLAG );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMTARGETVALUE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMVALUE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_PARAMTAG );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_DOCID,hashedInfo.getHashKey())){
                                docJobID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME,hashedInfo.getHashKey())){
                                cliamTime = hashedInfo.getHashData();
                            }
                            /*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }*/
                        }
                    }

                    String sql = "SELECT " +
                            "TRX_TIME, " +
                            "DOC_ID, " +
                            "WAFER_ID, " +
                            "IDX_NO, " +
                            "RPARAM_NAME," +
                            "RPARAM_UNIT, " +
                            "RPARAM_DATA_TYPE, " +
                            "RPARAM_LOWER_LIMIT, " +
                            "RPARAM_UPPER_LIMIT, " +
                            "RPARAM_USE_CUR_FLAG, " +
                            "RPARAM_TARGET_VAL, " +
                            "RPARAM_VAL, " +
                            "RUNCARD_ID " +
                            "FROM OHDOC_WAFER_RPARAM ";
                    //set columnvalue
                    if (CimStringUtils.isNotEmpty(docJobID)){
                        sqlTemp = String.format(" WHERE DOC_ID = '%s' ",docJobID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(cliamTime)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }else {
                            sqlTemp = String.format(" WHERE TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(runCardID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND RUNCARD_ID = '%s' ",runCardID);
                        }else {
                            sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        }
                        sql += sqlTemp;
                    }
                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_WAFER_RPARM );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : String.valueOf(queryResult[2]) );
                            columnValues.add( queryResult[3] == null ? null : Integer.valueOf(queryResult[3].toString()) );
                            columnValues.add( queryResult[4] == null ? null : String.valueOf(queryResult[4]) );
                            columnValues.add( queryResult[5] == null ? null : String.valueOf(queryResult[5]) );
                            columnValues.add( queryResult[6] == null ? null : String.valueOf(queryResult[6]) );
                            columnValues.add( queryResult[7] == null ? null : String.valueOf(queryResult[7]) );
                            columnValues.add( queryResult[8] == null ? null : String.valueOf(queryResult[8]) );
                            columnValues.add( queryResult[9] == null ? null : Integer.valueOf(queryResult[9].toString()) );

                            columnValues.add( queryResult[10] == null ? null : String.valueOf(queryResult[10]) );
                            columnValues.add( queryResult[11] == null ? null : String.valueOf(queryResult[11]) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
//                            columnValues.add( queryResult[13] == null ? null : String.valueOf(queryResult[13]) );
                        }
                    }
                }
                //DOC OHDOC_EDCSPEC table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_FHFPCHS_DCSPECS,targetTableInfo.getTableName())){

                    //hashKey for doc
                    String docJobID = "";
                    String cliamTime = "";
                    String runCardID = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_DCSPECS );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DCITEMNAME );

                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SCRNUPPERREQ );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SCRNUPPERLIMIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SCRNUPPERACTIONS );

                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SCRNLOWERREQ );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SCRNLOWERLIMIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SCRNLOWERACTIONS );

                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPECUPPERREQ );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPECUPPERLIMIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPECUPPERACTIONS );

                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPECLOWERREQ );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPECLOWERLIMIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SPECUPPERACTIONS );

                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CNTLUPPERREQ );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CNTLUPPERLIMIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CNTLUPPERACTIONS );

                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CNTLLOWERREQ );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CNTLLOWERLIMIT );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CNTLLOWERACTIONS );

                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DCITEMTARGETVALUE );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DCITEMTAG );

                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DCSPECGROUP );

                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_DOCID,hashedInfo.getHashKey())){
                                docJobID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME,hashedInfo.getHashKey())){
                                cliamTime = hashedInfo.getHashData();
                            }
                            /*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }*/
                        }
                    }

                    String sql = "SELECT " +
                            "TRX_TIME, " +
                            "DOC_ID, " +
                            "EDC_ITEM_NAME, " +
                            "SCRN_UP_FLAG, " +
                            "SCRN_UP_LIMIT," +
                            "SCRN_UP_ACT, " +
                            "SCRN_LO_FLAG, " +
                            "SCRN_LO_LIMIT, " +
                            "SCRN_LO_ACT, " +
                            "SPEC_UP_FLAG, " +
                            "SPEC_UP_LIMIT, " +
                            "SPEC_UP_ACT, " +
                            "SPEC_LO_FLAG, " +
                            "SPEC_LO_LIMIT, " +
                            "SPEC_LO_ACT, " +
                            "CTRL_UP_FLAG, " +
                            "CTRL_UP_LIMIT, " +
                            "CTRL_UP_ACT, " +
                            "CTRL_LO_FLAG, " +
                            "CTRL_LO_LIMIT, " +
                            "CTRL_LO_ACT, " +
                            "EDC_ITEM_TARGET_VAL, " +
                            "EDC_ITEM_TAG, " +
                            "EDC_SPEC_GROUP, " +
                            "RUNCARD_ID " +
                            "FROM OHDOC_EDCSPEC ";
                    //set columnvalue
                    if (CimStringUtils.isNotEmpty(docJobID)){
                        sqlTemp = String.format(" WHERE DOC_ID = '%s' ",docJobID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(cliamTime)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }else {
                            sqlTemp = String.format(" WHERE TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(runCardID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND RUNCARD_ID = '%s' ",runCardID);
                        }else {
                            sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        }
                        sql += sqlTemp;
                    }
                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_DCSPECS );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : String.valueOf(queryResult[2]) );

                            columnValues.add( queryResult[3] == null ? null : Integer.valueOf(queryResult[3].toString()) );
                            columnValues.add( queryResult[4] == null ? null : Integer.valueOf(queryResult[4].toString()) );
                            columnValues.add( queryResult[5] == null ? null : String.valueOf(queryResult[5]) );

                            columnValues.add( queryResult[6] == null ? null : Integer.valueOf(queryResult[6].toString()) );
                            columnValues.add( queryResult[7] == null ? null : Integer.valueOf(queryResult[7].toString()) );
                            columnValues.add( queryResult[8] == null ? null : String.valueOf(queryResult[8]) );

                            columnValues.add( queryResult[9] == null ? null : Integer.valueOf(queryResult[9].toString()) );
                            columnValues.add( queryResult[10] == null ? null : Integer.valueOf(queryResult[10].toString()) );
                            columnValues.add( queryResult[11] == null ? null : String.valueOf(queryResult[11]) );

                            columnValues.add( queryResult[12] == null ? null : Integer.valueOf(queryResult[12].toString()) );
                            columnValues.add( queryResult[13] == null ? null : Integer.valueOf(queryResult[13].toString()) );
                            columnValues.add( queryResult[14] == null ? null : String.valueOf(queryResult[14]) );

                            columnValues.add( queryResult[15] == null ? null : Integer.valueOf(queryResult[15].toString()) );
                            columnValues.add( queryResult[16] == null ? null : Integer.valueOf(queryResult[16].toString()) );
                            columnValues.add( queryResult[17] == null ? null : String.valueOf(queryResult[17]) );

                            columnValues.add( queryResult[18] == null ? null : Integer.valueOf(queryResult[18].toString()) );
                            columnValues.add( queryResult[19] == null ? null : Integer.valueOf(queryResult[19].toString()) );
                            columnValues.add( queryResult[20] == null ? null : String.valueOf(queryResult[20]) );

                            columnValues.add( queryResult[21] == null ? null : Integer.valueOf(queryResult[21].toString()) );
                            columnValues.add( queryResult[22] == null ? null : String.valueOf(queryResult[22]) );
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));
                            columnValues.add( queryResult[23] == null ? null : String.valueOf(queryResult[23]) );
//                            columnValues.add( queryResult[24] == null ? null : String.valueOf(queryResult[24]) );
                        }
                    }
                }

                //DOC OHDOC_RTCL table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_FHFPCHS_RTCL,targetTableInfo.getTableName())){

                    //hashKey for doc
                    String docJobID = "";
                    String cliamTime = "";
                    String runCardID = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_RTCL );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SEQNO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RTCLID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RTCLFROUPID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_DOCID,hashedInfo.getHashKey())){
                                docJobID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME,hashedInfo.getHashKey())){
                                cliamTime = hashedInfo.getHashData();
                            }/*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }*/
                        }
                    }
                    String sql = "SELECT " +
                            "TRX_TIME, " +
                            "DOC_ID, " +
                            "IDX_NO, " +
                            "RTCL_ID, " +
                            "RTCL_GROUP_ID, " +
                            "RUNCARD_ID " +
                            "FROM OHDOC_RTCL ";
                    //set columnvalue
                    if (CimStringUtils.isNotEmpty(docJobID)){
                        sqlTemp = String.format(" WHERE DOC_ID = '%s' ",docJobID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(cliamTime)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }else {
                            sqlTemp = String.format(" WHERE TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(runCardID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND RUNCARD_ID = '%s' ",runCardID);
                        }else {
                            sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        }
                        sql += sqlTemp;
                    }
                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_RTCL );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : Integer.valueOf(queryResult[2].toString()) );
                            columnValues.add( queryResult[3] == null ? null : String.valueOf(queryResult[3]) );
                            columnValues.add( queryResult[4] == null ? null : String.valueOf(queryResult[4]) );
                            columnValues.add(CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));
//                            columnValues.add( queryResult[5] == null ? null : String.valueOf(queryResult[5]) );

                        }
                    }
                }

                //DOC OHDOC_MEASRELATED table search
                if (CimStringUtils.equals(BizConstant.SP_HISTORYTABLENAME_FHFPCHS_COROPE,targetTableInfo.getTableName())){

                    //hashKey for doc
                    String docJobID = "";
                    String cliamTime = "";
                    String runCardID = "";
                    sqlTemp = "";

                    Infos.TableRecordInfo strTableRecordInfo=new Infos.TableRecordInfo();
                    strTableRecordInfoSeq.add(strTableRecordInfo);
                    strTableRecordInfo.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_COROPE );

                    //set columnNames
                    List<String> columnNames=new ArrayList<>();
                    strTableRecordInfo.setColumnNames(columnNames);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_REPORTTIMESTAMP );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DOCID );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_SEQNO );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CORRESPONDOPENO);
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_DCSPECGROUP );
                    columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME );
                    //columnNames.add( BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID );

                    //set columnvalue
                    if (CimArrayUtils.isNotEmpty(targetTableInfo.getStrHashedInfoSeq())){
                        for (Infos.HashedInfo hashedInfo : targetTableInfo.getStrHashedInfoSeq()) {
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_DOCID,hashedInfo.getHashKey())){
                                docJobID = hashedInfo.getHashData();
                            }
                            if (CimStringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_CLAIMEDTIME,hashedInfo.getHashKey())){
                                cliamTime = hashedInfo.getHashData();
                            }
                            /*
                            if (StringUtils.equals(BizConstant.SP_HISTORYCOLUMNNAME_RUNCARDID,hashedInfo.getHashKey())){
                                runCardID = hashedInfo.getHashData();
                            }*/
                        }
                    }
                    String sql = "SELECT " +
                            "TRX_TIME, " +
                            "DOC_ID, " +
                            "IDX_NO, " +
                            "CORR_OPE_NO, " +
                            "EDC_SPEC_GROUP, " +
                            "RUNCARD_ID " +
                            "FROM OHDOC_MEASRELATED ";
                    //set columnvalue
                    if (CimStringUtils.isNotEmpty(docJobID)){
                        sqlTemp = String.format(" WHERE DOC_ID = '%s' ",docJobID);
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(cliamTime)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }else {
                            sqlTemp = String.format(" WHERE TRX_TIME = TO_TIMESTAMP('%s', 'yyyy-mm-dd hh24:mi:ss.ff') ",cliamTime);
                        }
                        sql += sqlTemp;
                    }
                    if (CimStringUtils.isNotEmpty(runCardID)){
                        if (CimStringUtils.isNotEmpty(sqlTemp)){
                            sqlTemp = String.format(" AND RUNCARD_ID = '%s' ",runCardID);
                        }else {
                            sqlTemp = String.format(" WHERE RUNCARD_ID = '%s' ",runCardID);
                        }
                        sql += sqlTemp;
                    }
                    List<Object[]> queryResults = cimJpaRepository.query(sql);
                    if (CimArrayUtils.isNotEmpty(queryResults)){
                        for (Object[] queryResult : queryResults) {
                            Infos.TableRecordValue strTableRecordValue=new Infos.TableRecordValue();
                            strTableRecordValueSeq.add(strTableRecordValue);
                            strTableRecordValue.setTableName ( BizConstant.SP_HISTORYTABLENAME_FHFPCHS_COROPE );
                            strTableRecordValue.setReportTimeStamp ( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));

                            List<Object> columnValues=new ArrayList<>();
                            strTableRecordValue.setColumnValues(columnValues);
                            columnValues.add( CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ) );
                            columnValues.add( queryResult[1] == null ? null : String.valueOf(queryResult[1]) );
                            columnValues.add( queryResult[2] == null ? null : Integer.valueOf(queryResult[2].toString()) );
                            columnValues.add( queryResult[3] == null ? null : String.valueOf(queryResult[3]) );
                            columnValues.add( queryResult[4] == null ? null : String.valueOf(queryResult[4]) );
                            columnValues.add(CimDateUtils.convertToSpecString((Timestamp) (queryResult[0]) ));
//                            columnValues.add( queryResult[5] == null ? null : String.valueOf(queryResult[5]) );
                        }
                    }
                }
            }
        }

        if (searchCondition!=null){
            result.setStrTableRecordValuePage(CimPageUtils.convertListToPage(strTableRecordValueSeq,searchCondition.getPage(),searchCondition.getSize()));
        }

        return result;
    }

    @Override
    public List<ObjectIdentifier> allLotTypeGet() {
        List<CimLotTypeDO> cimLotTypeDOList = cimJpaRepository.findAll(CimLotTypeDO.class);
        List<ObjectIdentifier> typeList = new ArrayList<>();
        for (CimLotTypeDO cimLotTypeDO : cimLotTypeDOList){
            typeList.add(ObjectIdentifier.build(cimLotTypeDO.getLotTypeID(),cimLotTypeDO.getId()));
        }
        return typeList;
    }

    @Override
    public ObjectIdentifier lotIDAssignByDef(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID) {
        //---------------------------------
        //   Get lotfamily SuffixNumber
        //---------------------------------
        String suffixNumber = this.lotFamilySplitNoCreate(objCommon, parentLotID);

        //----------------------
        //   Generate LotID
        //----------------------
        Validations.check(null == suffixNumber, retCodeConfig.getLotIDAssignFail());
        String lotID = ObjectIdentifier.fetchValue(parentLotID);
        // String out = String.format("%s.%s", lotID.lastIndexOf(".") > 0 ? lotID.substring(0, lotID.lastIndexOf(".")) :lotID , suffixNumber);

        // bug-6380 Lot Split SuffixNumber Enhancement:Split from a vendor lot with suffix ".0001",Child lot ‘s suffix is incorrect
        String splitNo=suffixNumber;
        String newLotID=null;
        String oldLotID=lotID;
        if((CimStringUtils.isEmpty(lotID)) || (2!= CimStringUtils.length(suffixNumber))) {
            log.debug("{}"," #### splitNo length == 0 || oldLotID == NULL ");
        } else {
            log.debug("{}{}{}"," #### oldLotID : splitNo ", oldLotID, splitNo);
            int len = CimStringUtils.length(lotID);
            String[] buf = splitNo.split("");
            String[] tmpLotID=null;

            int i=len-1;
            for (; i>=0; i--) {
                if (lotID.charAt(i) == '.') {
                    break;
                }
            }
            if ( i != -1 ) {
                int ii = i ;
                tmpLotID=Arrays.copyOf(lotID.split(""),len+3);
                if(tmpLotID.length!=0) {
                    tmpLotID[ii+1] = buf[0] ;
                    tmpLotID[ii+2] = buf[1] ;
                    newLotID = CimStringUtils.join(tmpLotID,"");
                }
            } else {
                tmpLotID = new String[len+3];
                if( tmpLotID != null ) {
                    tmpLotID=Arrays.copyOf(oldLotID.split(""),len+3);
                    tmpLotID[len]     = ".";
                    tmpLotID[len + 1] = buf[0] ;
                    tmpLotID[len + 2] = buf[1] ;
                    newLotID = CimStringUtils.join(tmpLotID,"");
                }
            }
        }
        return new ObjectIdentifier(newLotID);
    }

    @Override
    public ObjectIdentifier lotIDAssignbyEnv(Infos.ObjCommon objCommon, ObjectIdentifier parentLotID) {
        Results.LotFamilyInqResult lotFamilyInqResult = lotFamilyMethod.lotFamilyFillInTxTRQ007DR(objCommon,parentLotID);
        List<ObjectIdentifier> lotIDFamilyList = lotFamilyInqResult.getStrLotListAttributes().stream().map(i->i.getLotID()).collect(Collectors.toList());
        Integer suffix = null;
        String lotIdMsg[] = null;
        if(lotIDFamilyList.size()>1){
            lotIDFamilyList =  lotIDFamilyList.stream().sorted(Comparator.comparing(ObjectIdentifier::getValue).reversed()).collect(Collectors.toList());
            lotIdMsg = CimStringUtils.splitLastDelimiter(lotIDFamilyList.get(0).getValue(),".");
            try {
                suffix = Integer.valueOf(lotIdMsg[1]);
            }catch (NumberFormatException e){
                Validations.check(true, retCodeConfig.getInvalidInputParam());
            }
            suffix++;
            Validations.check(suffix>999,"It reached Max split count");
            return new ObjectIdentifier(lotIdMsg[0]+"."+String.format("%03d",suffix));
        }else{
            suffix = 1;
            return new ObjectIdentifier(lotIDFamilyList.get(0).getValue()+"."+String.format("%03d",suffix));
        }
    }


    @Override
    public List<Infos.HoldHistory> lotHoldDepartmentChange(Infos.ObjCommon objCommon, ObjectIdentifier lotID, List<Infos.LotHoldReq> holdReqList) {
        CimLot lotBo = baseCoreFactory.getBO(CimLot.class, lotID);
        boolean trueFalse;
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        // 【step 1】 update hold lot
        List<Infos.HoldHistory> holdHistoryList = Lists.newArrayList();
        boolean aRespOpeExistFlag = false;
        List<ProductDTO.HoldRecord> holdRecordList = lot.allHoldRecords();
        for (int i = 0; i < CimArrayUtils.getSize(holdRecordList); i++) {
            if (holdRecordList.get(i).isResponsibleOperationFlag()) {
                aRespOpeExistFlag = true;
                break;
            }
        }

        for (Infos.LotHoldReq lotHoldReq : holdReqList) {
            //Qiandao OCAP hold check start
            Validations.check(CimBooleanUtils.isTrue(
                    CimStringUtils.equals(BizConstant.OCAP_HOLD_LOT, ObjectIdentifier.fetchValue(lotHoldReq.getOldHoldReasonCodeID()))
                            || CimStringUtils.equals(BizConstant.OCAP_ADD_MEASURE_HOLD_LOT, ObjectIdentifier.fetchValue(lotHoldReq.getOldHoldReasonCodeID()))
                            || CimStringUtils.equals(BizConstant.OCAP_RE_MEASURE_HOLD_LOT, ObjectIdentifier.fetchValue(lotHoldReq.getOldHoldReasonCodeID()))
                    ),
                    retCodeConfigEx.getCanNotEditOcapHold());
            //Qiandao OCAP hold check end
            trueFalse = false;
            if (BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS.equals(lotHoldReq.getResponsibleOperationMark())) {
                CimProcessFlowContext processFlowContext = lot.getProcessFlowContext();
                Validations.check(processFlowContext == null, new OmCode(retCodeConfig.getNotFoundPfx(), ""));

                CimProcessOperation processOperation = processFlowContext.getPreviousProcessOperation();
                OmCode omCode = new OmCode(retCodeConfig.getNotFoundProcessOperation(), "*****", ObjectIdentifier.fetchValue(lotID));
                Validations.check(processOperation == null, omCode);

                lot.makeResponsibleOperation();
                trueFalse = true;
            }
            ProductDTO.HoldRecord holdRecord = new ProductDTO.HoldRecord();
            holdRecord.setHoldType(CimStringUtils.isEmpty(lotHoldReq.getHoldType()) ? BizConstant.SP_HOLDTYPE_LOTHOLD : lotHoldReq.getHoldType());
            holdRecord.setReasonCode(lotHoldReq.getHoldReasonCodeID());
            holdRecord.setHoldPerson(ObjectIdentifier.isEmpty(lotHoldReq.getHoldUserID()) ? objCommon.getUser().getUserID() : lotHoldReq.getHoldUserID());
            holdRecord.setHoldTimeStamp(objCommon.getTimeStamp().getReportTimeStamp().toString());
            holdRecord.setRelatedLot(lotHoldReq.getRelatedLotID());
            holdRecord.setResponsibleOperationFlag(trueFalse);
            holdRecord.setHoldClaimMemo(lotHoldReq.getClaimMemo());
            holdRecord.setOldHoldPerson(lotHoldReq.getOldHoldUserID());
            holdRecord.setOldReasonCode(lotHoldReq.getOldHoldReasonCodeID());
            holdRecord.setOldRelatedLot(lotHoldReq.getOldRelatedLotID());

            String department = lotHoldReq.getDepartment();
            String section = lotHoldReq.getSection();
            if (CimStringUtils.isNotEmpty(department) && CimStringUtils.isNotEmpty(section)) {
                holdRecord.setDepartmentNamePlate(department + BizConstant.DOT + section);
            }
            lotBo.updateHoldRecord(holdRecord);

            // 【step 2】 make history
            Infos.HoldHistory holdHistory = new Infos.HoldHistory();
            if (!aRespOpeExistFlag) {
                holdHistory.setMovementFlag(trueFalse);
            } else {
                holdHistory.setMovementFlag(false);
            }

            holdHistory.setResponsibleOperationExistFlag(aRespOpeExistFlag);
            holdHistory.setChangeStateFlag(false);
            holdHistory.setHoldType(lotHoldReq.getHoldType());
            holdHistory.setHoldReasonCode(lotHoldReq.getHoldReasonCodeID());
            if (!CimStringUtils.isEmpty(lotHoldReq.getHoldUserID().getValue())) {
                holdHistory.setHoldPerson(lotHoldReq.getHoldUserID());
            } else {
                holdHistory.setHoldPerson(objCommon.getUser().getUserID());
            }
            holdHistory.setHoldTime(objCommon.getTimeStamp().getReportTimeStamp().toString());
            holdHistory.setResponsibleOperationFlag(trueFalse);
            holdHistory.setHoldClaimMemo(lotHoldReq.getClaimMemo());
            holdHistory.setDepartmentNamePlate(holdRecord.getDepartmentNamePlate());
            if (trueFalse) {
                aRespOpeExistFlag = true;
            }
            holdHistoryList.add(holdHistory);
        }

        return holdHistoryList;
    }

    @Override
    public Infos.FutureHoldHistory lotFutureHoldChangeMakeEntry(Infos.ObjCommon objCommon, Params.FutureHoldReqParams params) {
        // 【step 1】 params
        String holdType = params.getHoldType();
        String claimMemo = params.getClaimMemo();
        String operationNumber = params.getOperationNumber();
        ObjectIdentifier lotID = params.getLotID();
        ObjectIdentifier routeID = params.getRouteID();
        ObjectIdentifier reasonCodeID = params.getReasonCodeID();
        ObjectIdentifier relatedLotID = params.getRelatedLotID();
        ObjectIdentifier userID = objCommon.getUser().getUserID();
        boolean postFlag = params.isPostFlag();
        boolean singleTriggerFlag = params.isSingleTriggerFlag();

        // 【step 2】 lot future hold change
        ProductDTO.FutureHoldRecord futureHoldRecord = new ProductDTO.FutureHoldRecord();
        futureHoldRecord.setHoldType(holdType);
        futureHoldRecord.setReasonCode(reasonCodeID);
        futureHoldRecord.setRequestPerson(userID);
        futureHoldRecord.setMainProcessDefinition(routeID);
        futureHoldRecord.setOperationNumber(operationNumber);
        futureHoldRecord.setRelatedLot(relatedLotID);
        futureHoldRecord.setClaimMemo(claimMemo);
        futureHoldRecord.setClaimedTimeStamp(objCommon.getTimeStamp().getReportTimeStamp().toString());
        futureHoldRecord.setPostFlag(postFlag);
        futureHoldRecord.setSingleTriggerFlag(singleTriggerFlag);
        futureHoldRecord.setOldReasonCode(params.getOldReasonCodeID());
        futureHoldRecord.setOldRequestPerson(params.getOldHoldUserID());
        futureHoldRecord.setOldRelatedLot(params.getOldRelatedLotID());
        String department = params.getDepartment();
        String section = params.getSection();

        if (CimStringUtils.isNotEmpty(department) && CimStringUtils.isNotEmpty(section)) {
            futureHoldRecord.setDepartmentNamePlate(department + BizConstant.DOT + section);
        }

        try {
            CimLot lotBO = baseCoreFactory.getBO(CimLot.class, lotID);
            lotBO.updateFutureHoldRecord(futureHoldRecord);
        } catch (DuplicateRecordException e) {
            throw new ServiceException(retCodeConfig.getDuplicateFtholdEntry());
        }

        // 【step3】 history
        Infos.FutureHoldHistory futureHoldHistory = new Infos.FutureHoldHistory();
        futureHoldHistory.setHoldType(holdType);
        futureHoldHistory.setReasonCode(reasonCodeID);
        futureHoldHistory.setPerson(userID);
        futureHoldHistory.setRouteID(routeID);
        futureHoldHistory.setOperationNumber(operationNumber);
        futureHoldHistory.setRelatedLotID(relatedLotID);
        futureHoldHistory.setPostFlag(postFlag);
        futureHoldHistory.setSingleTriggerFlag(singleTriggerFlag);
        futureHoldHistory.setClaimMemo(claimMemo);
        return futureHoldHistory;
    }

    @Override
    public void lotNpwUsageRecycleLimitUpdate(LotNpwUsageRecycleLimitUpdateParams params, Infos.ObjCommon objCommon) {
        ObjectIdentifier lotId = params.getLotID();
        int recycleCountLimit = params.getRecycleCountLimit();
        int usageCountLimit = params.getUsageCountLimit();
        // check in put params
        Validations.check(recycleCountLimit > 9999 || usageCountLimit > 9999, retCodeConfig.getInvalidInputParam());
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotId);
        Validations.check(CimObjectUtils.isEmpty(aLot), new OmCode(retCodeConfig.getNotFoundLot(),lotId.getValue()));
        String lotType = aLot.getLotType();
        //check lot type
        Validations.check(!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)
                &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_DUMMYLOT)
                &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_RECYCLELOT)
                ,new OmCode(retCodeConfig.getInvalidLotType(),lotType,lotId.getValue()));
        // update lot npw use limit
        if (!CimObjectUtils.isEmpty(recycleCountLimit)){
            aLot.setRecycleLimit(recycleCountLimit);
        }
        if (!CimObjectUtils.isEmpty(usageCountLimit)){
            aLot.setUsageLimit(usageCountLimit);
        }
    }

    @Override
    public void lotNpwUsageRecycleCountUpdate(LotNpwUsageRecycleCountUpdateParams params, Infos.ObjCommon objCommon) {
        ObjectIdentifier lotId = params.getLotID();
        List<LotNpwUsageRecycleCountUpdateParams.WaferUsageRecycleCountUpdateParams> waferUpdateParamsList = params.getWaferUpdateParamsList();
        // check in put params
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotId);
        Validations.check(CimObjectUtils.isEmpty(aLot), new OmCode(retCodeConfig.getNotFoundLot(),lotId.getValue()));
        Validations.check(CimArrayUtils.isEmpty(waferUpdateParamsList), retCodeConfig.getInvalidInputParam());
        String lotType = aLot.getLotType();
        //check lot type
        Validations.check(!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)
                        &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                        &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_DUMMYLOT)
                        &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_RECYCLELOT)
                ,new OmCode(retCodeConfig.getInvalidLotType(),lotType,lotId.getValue()));
        // get lot npw use limit
        Integer usageLimit = aLot.getUsageLimit();
        Integer recycleLimit = aLot.getRecycleLimit();
        //update by wafer
        for (LotNpwUsageRecycleCountUpdateParams.WaferUsageRecycleCountUpdateParams waferUpdateParams : waferUpdateParamsList){
            ObjectIdentifier waferID = waferUpdateParams.getWaferID();
            Integer recycleCount = waferUpdateParams.getRecycleCount();
            Integer usageCount = waferUpdateParams.getUsageCount();
            CimWafer aWafer = baseCoreFactory.getBO(CimWafer.class, waferID);
            Validations.check(CimObjectUtils.isEmpty(aWafer), retCodeConfig.getNotFoundWafer());
            if (!CimObjectUtils.isEmpty(usageCount)){
                Validations.check(!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)
                                &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                                &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_DUMMYLOT)
                        ,new OmCode(retCodeConfig.getInvalidLotType(),lotType,lotId.getValue()));
                Validations.check(usageCount >= usageLimit, retCodeConfig.getInvalidInputParam());
                aWafer.setUsageCount(usageCount);
            }
            if (!CimObjectUtils.isEmpty(recycleCount)){
                Validations.check(recycleCount >= recycleLimit, retCodeConfig.getInvalidInputParam());
                aWafer.setRecycleCount(recycleCount);
            }
        }
    }

    @Override
    public void lotNpwStbUpdate(Infos.ObjCommon objCommon, ObjectIdentifier createdLotID, List<LotStbUsageRecycleLimitParams> lotStbUsageRecycleLimitParamsList, ObjectIdentifier productID) {
        log.info("Retrieve lot used count");
        CimProductSpecification aProduct = baseCoreFactory.getBO(CimProductSpecification.class, productID);
        Integer productUsageLimit = CimObjectUtils.isEmpty(aProduct.getUsageLimit()) ? 0 : aProduct.getUsageLimit();
        Integer productRecycleLimit = CimObjectUtils.isEmpty(aProduct.getRecycleLimit()) ? 0 : aProduct.getRecycleLimit();
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, createdLotID);
        Integer sourceUsageLimit = 0, sourceRecycleLimit = 0;
        List<Integer> sourceUsageLimitList = new ArrayList<>();
        List<Integer> sourceRecycleLimitList = new ArrayList<>();
        for (LotStbUsageRecycleLimitParams limitParams : lotStbUsageRecycleLimitParamsList) {
            Boolean newLotFlag = limitParams.getNewLotFlag();
            if (newLotFlag) {
                //new lot, use product's limit
                if (productUsageLimit != 0) {
                    sourceUsageLimitList.add(productUsageLimit);
                }
                if (productRecycleLimit != 0) {
                    sourceRecycleLimitList.add(productRecycleLimit);
                }
            } else {
                //old lot, use old lot's limit
                ObjectIdentifier sourceLotID = limitParams.getSourceLotID();
                CimLot sourceLot = baseCoreFactory.getBO(CimLot.class, sourceLotID);
                if (sourceLot.getUsageLimit() != 0 && !CimObjectUtils.isEmpty(sourceLot.getUsageLimit())) {
                    sourceUsageLimitList.add(sourceLot.getUsageLimit());
                }
                if (sourceLot.getRecycleLimit() != 0 && !CimObjectUtils.isEmpty(sourceLot.getRecycleLimit())) {
                    sourceRecycleLimitList.add(sourceLot.getRecycleLimit());
                }
            }
        }
        if (CimArrayUtils.isNotEmpty(sourceUsageLimitList)) {
            sourceUsageLimit = Collections.min(sourceUsageLimitList);
        }
        if (CimArrayUtils.isNotEmpty(sourceRecycleLimitList)) {
            sourceRecycleLimit = Collections.min(sourceRecycleLimitList);
        }
        aLot.setUsageLimit(sourceUsageLimit);
        aLot.setRecycleLimit(sourceRecycleLimit);
    }

    @Override
    public boolean checkNPWLotSkipNeedReq(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot aLot = baseCoreFactory.getBO(CimLot.class, lotID);
        String lotType = aLot.getLotType();
        //check if this is a npw lot
        if (!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_DUMMYLOT)
        &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
        &&!CimStringUtils.equals(lotType,BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)){
            return false;
        }
        //check if it reach the last step of the flow
        CimProcessFlowContext processFlowContext = aLot.getProcessFlowContext();
        Boolean lastOperationForProcessFlow = processFlowContext.isLastOperationForProcessFlow();
        if (lastOperationForProcessFlow){
            //last step.check the usage count
            Integer usageLimit = aLot.getUsageLimit();
            if (CimObjectUtils.isEmpty(usageLimit) || usageLimit == 0 ){
                return true;
            }
            LotUsageRecycleCountParams usageRecycleCountByLot = waferMethod.getUsageRecycleCountByLot(objCommon,
                    lotID.getReferenceKey());
            Integer usageCount = usageRecycleCountByLot.getUsageCount();
            if (usageCount < usageLimit){
                // skip
                return true;
            }else {
                return false;
            }
        }else {
            return false;
        }
    }

    @Override
    public boolean checkLotMoveNextRequired(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Validations.check(ObjectIdentifier.isEmpty(lotID), retCodeConfig.getInvalidInputParam());

        CimLot cimLot = baseCoreFactory.getBO(CimLot.class, lotID);

        Validations.check(null == cimLot, retCodeConfig.getNotFoundLot());

        return cimLot.isPendingMoveNext();
    }

    @Override
    public void setLotMoveNextRequired(Infos.ObjCommon objCommon, ObjectIdentifier lotID, boolean requiredFlag) {
        Validations.check(ObjectIdentifier.isEmpty(lotID), retCodeConfig.getInvalidInputParam());

        CimLot cimLot = baseCoreFactory.getBO(CimLot.class, lotID);

        Validations.check(null == cimLot, retCodeConfig.getNotFoundLot());

        // Step1: change the PENDING_MOVE_NEXT_FLAG
        if (requiredFlag) {
            cimLot.makePendingMoveNext();
        } else {
            cimLot.makeNotPendingMoveNext();
        }

        // Step2: Remove the dispatch queue for Current Step.
        if (requiredFlag) {
            log.info("requiredFlag--->cimLot,{}",cimLot);
            cimLot.setQueuedMachines(Collections.emptyList());
        }
    }

    @Override
    public void checkIsTerminated(List<ObjectIdentifier> lotIDs) {
        if (CimArrayUtils.isEmpty(lotIDs))
            return;
        for (ObjectIdentifier lotID : lotIDs) {
            CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
            if (lot == null)
                continue;
            Validations.check(BizConstant.SP_LOT_FINISHED_STATE_TERMINATED.equalsIgnoreCase(lot.getLotFinishedState()),
                    retCodeConfig.getInvalidLotFinishStat(), lot.getLotFinishedState());
        }
    }

    @Override
    public void lotTerminate(Infos.ObjCommon objCommon, CimLot lot) {
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        CimPerson person = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID());

        Timestamp reportTime = objCommon.getTimeStamp().getReportTimeStamp();

        lot.makeTerminated();

        lot.setStateChangedTimeStamp(reportTime);
        lot.setStateChangedPerson(person);
        lot.setLastClaimedTimeStamp(reportTime);
        lot.setLastClaimedPerson(person);

        CimProcessDefinition processDefinition = lot.getMainProcessDefinition();
        if (processDefinition != null) {
            if (CIMStateConst.CIM_LOT_HOLD_STATE_ONHOLD.equalsIgnoreCase(lot.getLotHoldState())) {
                dispatchingManager.removeFromHoldQueue(lot);
            } else {
                dispatchingManager.removeFromQueue(lot);
            }
        }

        String envCreateType = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
        if (String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED).equalsIgnoreCase(envCreateType)
                || String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED).equalsIgnoreCase(envCreateType)) {
            CimProcessOperation processOperation = lot.getProcessOperation();
            if (!CimObjectUtils.isEmpty(processOperation)) {
                processMethod.poDelQueuePutDR(objCommon, lot.getLotID());
            }
        }
    }

    @Override
    public void lotTerminateCancel(Infos.ObjCommon objCommon, CimLot lot) {
        Validations.check(null == lot, retCodeConfig.getNotFoundLot());

        CimPerson person = baseCoreFactory.getBO(CimPerson.class, objCommon.getUser().getUserID());
        Validations.check(null == person, retCodeConfig.getNotFoundPerson(), objCommon.getUser().getUserID());

        Timestamp reportTime = objCommon.getTimeStamp().getReportTimeStamp();

        lot.makeTerminateCancel();

        lot.setStateChangedTimeStamp(reportTime);
        lot.setStateChangedPerson(person);
        lot.setLastClaimedTimeStamp(reportTime);
        lot.setLastClaimedPerson(person);

        CimProcessDefinition processDefinition = lot.getMainProcessDefinition();
        if (processDefinition != null) {
            if (CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD.equalsIgnoreCase(lot.getLotHoldState())) {
                dispatchingManager.addToQueue(lot);
            }
        }

        String envCreateType = StandardProperties.OM_MAINT_PO_EVENT_CREATE_TYPE.getValue();
        if (String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_INACTIVELOTENABLED).equalsIgnoreCase(envCreateType)
                || String.valueOf(BizConstant.SP_POMAINTEVENTCREATETYPE_ENABLED).equalsIgnoreCase(envCreateType)) {
            CimProcessOperation processOperation = lot.getProcessOperation();
            if (!CimObjectUtils.isEmpty(processOperation)) {
                processMethod.poDelQueuePutDR(objCommon, lot.getLotID());
            }
        }
    }

    @Override
    public DispatchReadinessState lotDispatchReadinessGet(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        Validations.check(ObjectIdentifier.isEmpty(lotID), retCodeConfig.getInvalidInputParam());

        CimLot cimLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(cimLot == null, retCodeConfig.getNotFoundLot());

        return cimLot.getDispatchReadiness();
    }

    @Override
    public void lotDispatchReadinessSet(Infos.ObjCommon objCommon, ObjectIdentifier lotID, DispatchReadinessState state) {
        Validations.check(ObjectIdentifier.isEmpty(lotID), retCodeConfig.getInvalidInputParam());

        CimLot cimLot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(cimLot == null, retCodeConfig.getNotFoundLot());

        cimLot.setDispatchReadiness(state);
    }
    @Override
    public int countQuantityWaferBylot(Infos.ObjCommon objCommon, String lotID,ObjectIdentifier aChildCassetteID) {
        CimWaferDO waferDO = new CimWaferDO();
        waferDO.setLotID(lotID);
        waferDO.setMaterialContainerID(ObjectIdentifier.fetchValue(aChildCassetteID));
        return CimNumberUtils.intValue(cimJpaRepository.count(Example.of(waferDO)));
    }

    @Override
    public void lotSTBCheck(Infos.ObjCommon objCommon, ObjectIdentifier productRequestID,
                            Infos.NewLotAttributes newLotAttributes) {
        //step 1 - Retrieve object reference from product request
        log.info("step 1 - Retrieve object reference from product request");
        com.fa.cim.newcore.bo.planning.CimProductRequest aProductRequest = baseCoreFactory.getBO(com.fa.cim.newcore.bo.planning.CimProductRequest.class, productRequestID);
        Validations.check(aProductRequest == null, new OmCode(retCodeConfig.getNotFoundProductRequest(), productRequestID.getValue()));
        //step 2 - Compare wafer Count
        log.info("step 2 - Compare wafer Count");
        List<Infos.NewWaferAttributes> newWaferAttributesList = newLotAttributes.getNewWaferAttributesList();
        int nInputWaferCount = CimArrayUtils.getSize(newWaferAttributesList);
        int nProdReqWaferCount = aProductRequest.getProductQuantity() == null ? 0 : aProductRequest.getProductQuantity();
        if (nInputWaferCount != nProdReqWaferCount) {
            throw new ServiceException(new OmCode(retCodeConfig.getStbWaferCountNotEnough(), String.valueOf(nInputWaferCount), productRequestID.getValue()));
        }
        //check if the source lot have contanimation level and pr Flag
        Infos.NewWaferAttributes example = newWaferAttributesList.get(0);
        ObjectIdentifier exampleLotID = example.getSourceLotID();
        CimLot exampleLot = baseCoreFactory.getBO(CimLot.class, exampleLotID);
        String contaminationLevel = exampleLot.getContaminationLevel();
        Integer prFlag = exampleLot.getPrFlag();
        for (Infos.NewWaferAttributes attributes : newWaferAttributesList) {
            ObjectIdentifier sourceLotID = attributes.getSourceLotID();
            CimLot tempLot = baseCoreFactory.getBO(CimLot.class, sourceLotID);
            Validations.check(!CimStringUtils.equals(contaminationLevel, tempLot.getContaminationLevel()),
                    retCodeConfigEx.getContaminationWaferChangeState());
            Validations.check(!prFlag.equals(tempLot.getPrFlag()) && (tempLot.getPrFlag() == 1 || prFlag == 1),
                    retCodeConfigEx.getContaminationWaferChangeState());
        }
    }

    @Override
    public List<LotMonitorGroupResults.MonitorLotDataCollectionQueryResults> monitorGroupLotGet(
            Infos.ObjCommon objCommon, String monitorGroupId) {
        // step1. check monitor group id
        Validations.check(StrUtil.isBlank(monitorGroupId), retCodeConfig.getInvalidParameter());

        String querySql = "SELECT MEAS_LOT_ID,MEAS_OPE_NO,MEAS_PASS_COUNT,MEAS_PROCESS_ID FROM OHEDC WHERE MON_GRP_ID = ?1";

        List<Object[]> resultList = cimJpaRepository.query(querySql, monitorGroupId);
        return resultList.parallelStream().map(result -> {
            LotMonitorGroupResults.MonitorLotDataCollectionQueryResults monitorLotDataCollectionQueryResults =
                    new LotMonitorGroupResults.MonitorLotDataCollectionQueryResults();

            if (ArrayUtil.isEmpty(result)) {
                monitorLotDataCollectionQueryResults.setMonitorLotId(ObjectIdentifier.emptyIdentifier());
            } else {
                monitorLotDataCollectionQueryResults
                        .setMonitorLotId(ObjectIdentifier.build(String.valueOf(result[0]), BizConstant.EMPTY));
                monitorLotDataCollectionQueryResults.setOperationNumber(String.valueOf(result[1]));
                monitorLotDataCollectionQueryResults.setOperationPassCount(String.valueOf(result[2]));
                monitorLotDataCollectionQueryResults.setRouteId(String.valueOf(result[3]));
            }
            return monitorLotDataCollectionQueryResults;
        }).collect(Collectors.toList());
    }

    @Override
    public String getLotStatus(Infos.ObjCommon objCommon, ObjectIdentifier lotID) {
        CimLot lot = baseCoreFactory.getBO(CimLot.class, lotID);
        Validations.check(CimObjectUtils.isEmpty(lot),retCodeConfig.getNotFoundLot(),ObjectIdentifier.fetchValue(lotID));
        return lot.getState();
    }
}

