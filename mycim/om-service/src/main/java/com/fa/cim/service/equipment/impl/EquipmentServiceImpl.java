package com.fa.cim.service.equipment.impl;

import com.fa.cim.annotaion.OmService;
import com.fa.cim.common.constant.BizConstant;
import com.fa.cim.common.constant.CIMStateConst;
import com.fa.cim.common.constant.TCSReqEnum;
import com.fa.cim.common.constant.TransactionIDEnum;
import com.fa.cim.common.exception.ServiceException;
import com.fa.cim.common.support.ErrorCode;
import com.fa.cim.common.support.ObjectIdentifier;
import com.fa.cim.common.support.OmCode;
import com.fa.cim.common.support.RetCode;
import com.fa.cim.common.utils.*;
import com.fa.cim.config.RetCodeConfig;
import com.fa.cim.config.RetCodeConfigEx;
import com.fa.cim.crcp.ChamberLevelRecipeReserveParam;
import com.fa.cim.dto.*;
import com.fa.cim.eqp.carrierout.CarrierOutPortInfo;
import com.fa.cim.eqp.carrierout.CarrierOutPortReqParams;
import com.fa.cim.eqp.carrierout.CarrierOutPortResults;
import com.fa.cim.eqp.carrierout.CarrierOutReqParams;
import com.fa.cim.layoutrecipe.LayoutRecipeParams;
import com.fa.cim.method.*;
import com.fa.cim.newcore.bo.dispatch.CimDispatcher;
import com.fa.cim.newcore.bo.durable.CimCassette;
import com.fa.cim.newcore.bo.durable.CimDurableControlJob;
import com.fa.cim.newcore.bo.machine.CimEqpMonitor;
import com.fa.cim.newcore.bo.machine.CimMachine;
import com.fa.cim.newcore.bo.machine.CimStorageMachine;
import com.fa.cim.newcore.bo.product.CimControlJob;
import com.fa.cim.newcore.bo.product.CimLot;
import com.fa.cim.newcore.impl.bo.env.StandardProperties;
import com.fa.cim.remote.IEAPRemoteManager;
import com.fa.cim.remote.IRTMSRemoteManager;
import com.fa.cim.service.apc.IAPCInqService;
import com.fa.cim.service.automonitor.IAutoMonitorService;
import com.fa.cim.service.bank.IBankService;
import com.fa.cim.service.bond.IBondService;
import com.fa.cim.service.cjpj.IControlJobProcessJobService;
import com.fa.cim.service.edc.IEngineerDataCollectionService;
import com.fa.cim.service.equipment.IEquipmentInqService;
import com.fa.cim.service.equipment.IEquipmentProcessOperation;
import com.fa.cim.service.equipment.IEquipmentService;
import com.fa.cim.service.lot.ILotInqService;
import com.fa.cim.service.lot.ILotService;
import com.fa.cim.service.newSorter.ISortNewService;
import com.fa.cim.service.pcs.IProcessControlScriptService;
import com.fa.cim.service.plan.IPlanInqService;
import com.fa.cim.service.plan.IPlanService;
import com.fa.cim.service.pr.IPilotRunService;
import com.fa.cim.service.processcontrol.IProcessControlService;
import com.fa.cim.service.processmonitor.IProcessMonitorService;
import com.fa.cim.service.season.ISeasoningService;
import com.fa.cim.service.system.ISystemService;
import com.fa.cim.service.tms.ITransferManagementSystemService;
import com.fa.cim.sorter.Info;
import com.fa.cim.sorter.SorterHandler;
import com.fa.cim.sorter.SorterType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;

import java.sql.Timestamp;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static java.lang.Boolean.FALSE;
import static java.lang.Boolean.TRUE;

/**
 * description:
 * <p>IEquipmentServiceImpl .<br/></p>
 * <p>
 * change history:
 * date      defect#       person     comments
 * ------------------------------------------------------------
 * ---------------------------------------------------------
 * 2020/9/9/009   ********     Decade     create file
 *
 * @author: Decade
 * @date: 2020/9/9/009 15:26
 * @copyright: 2020, FA Software (Shanghai) Co., Ltd. All Rights Reserved.
 */
@Slf4j
@OmService
public class EquipmentServiceImpl implements IEquipmentService {

    @Autowired
    private RetCodeConfig retCodeConfig;

    @Autowired
    private IEquipmentMethod equipmentMethod;

    @Autowired
    private ILotMethod lotMethod;

    @Autowired
    private IProcessMethod processMethod;

    @Autowired
    private IEventMethod eventMethod;

    @Autowired
    private IObjectMethod objectMethod;

    @Autowired
    private IObjectLockMethod lockMethod;

    @Autowired
    private IControlJobProcessJobService controlJobProcessJobService;

    @Autowired
    private ICodeMethod codeMethod;

    @Autowired
    private IControlJobMethod controlJobMethod;

    @Autowired
    private ICassetteMethod cassetteMethod;

    @Autowired
    private IObjectLockMethod objectLockMethod;

    @Autowired
    private RetCodeConfigEx retCodeConfigEx;

    @Autowired
    private IFlowBatchMethod flowBatchMethod;

    @Autowired
    private ISeasoningService seasoningService;

    @Autowired
    private IReticleMethod reticleMethod;

    @Autowired
    private IPortMethod portComp;

    @Autowired
    private ICimComp cimComp;

    @Autowired
    private IQTimeMethod qTimeMethod;

    @Autowired
    private IMinQTimeMethod minQTimeMethod;

    @Autowired
    private IPortMethod portMethod;

    @Autowired
    private IDataValueMethod dataValueMethod;

    @Autowired
    private IProcessControlService processControlService;

    @Autowired
    private ILotService lotService;

    @Autowired
    private IMachineRecipeMethod machineRecipeMethod;

    @Autowired
    private ILotInqService lotInqService;

    @Autowired
    private IEngineerDataCollectionService engineerDataCollectionService;

    @Autowired
    private ISystemService systemService;

    @Autowired
    private IBinSummaryMethod binSummaryMethod;

    @Autowired
    private IBondingGroupMethod bondingGroupMethod;

    @Autowired
    private IFixtureMethod fixtureMethod;

    @Autowired
    private IScheduleChangeReservationMethod scheduleChangeReservationMethod;

    @Autowired
    private IEquipmentContainerPositionMethod equipmentContainerPositionMethod;

    @Autowired
    private IProcessControlScriptService processControlScriptService;

    @Autowired
    private IPlanService planService;

    @Autowired
    private IDurableMethod durableMethod;

    @Autowired
    private ISeasonMethod seasonMethod;

    @Autowired
    private IStockerMethod stockerMethod;

    @Autowired
    private ITransferManagementSystemService transferManagementSystemService;

    @Autowired
    private ISLMMethod slmMethod;

    @Autowired
    private IVirtualOperationMethod virtualOperationMethod;

    @Autowired
    private IBondService bondService;

    @Autowired
    private ITCSMethod tcsMethod;

    @Autowired
    private IBankService bankService;

    @Autowired
    private IAPCMethod apcMethod;

    @Autowired
    private IAutoMonitorService autoMonitorService;

    @Autowired
    private IProcessMonitorService processMonitorService;

    @Autowired
    private IMessageMethod messageMethod;

    @Autowired
    private IAPCInqService apcInqService;

    @Autowired
    private IFPCMethod fpcMethod;

    @Autowired
    private IOperationMethod operationMethod;

    @Autowired
    private IWaferMethod waferMethod;

    @Autowired
    private IRecipeMethod recipeMethod;

    @Autowired
    private IPlanInqService planInqService;

    @Autowired
    private IEquipmentInqService equipmentInqService;

    @Autowired
    private ISorterNewMethod sorterNewMethod;

    @Autowired
    private IConstraintMethod constraintMethod;

    @Autowired
    private IPilotRunMethod pilotRunMethod;

    @Autowired
    private IPilotRunService pilotRunService;

    @Autowired
    private IContaminationMethod contaminationMethod;

    @Autowired
    private IEAPMethod eapMethod;

    @Autowired
    private ILayoutRecipeMethod layoutRecipeMethod;

    @Autowired
    private IOcapMethod ocapMethod;

    @Autowired
    private ISortNewService sortNewService;

    @Autowired
    private ISorterNewMethod sorterMethod;

    @Autowired
    private IEquipmentProcessOperation equipmentProcessOperation;

    @Autowired
    private IRTMSRemoteManager irtmsRemoteManager;

    @Autowired
    private IChamberLevelRecipeMethod chamberLevelRecipeMethod;

    @Override
    public Results.ChamberStatusChangeReqResult sxChamberStatusChangeReqV1(
            Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, List<Infos.EqpChamberStatus> chamberStatusList,
            String claimMemo) {
        Results.ChamberStatusChangeReqResult chamberStatusChangeReqResult = new Results.ChamberStatusChangeReqResult();
        boolean equipmentStatusChangeReqiredFlag = false;
        ObjectIdentifier equipmentId = ObjectIdentifier.isEmpty(equipmentID) ? null : equipmentID;

        // Step1 - object_lockMode_Get
        if (log.isDebugEnabled())
            log.debug("step1 - get lock mode of equipment {}",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.CHAMBER_STATUS_CHANGE_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        if (log.isTraceEnabled())
            log.trace("lockMode is 【{}】",lockMode);
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // Advanced Mode
            if (log.isDebugEnabled())
                log.debug("step2 - Lock Equipment Main Object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);
            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            if (log.isDebugEnabled())
                log.debug("step3 - lock equipment 【{}】",equipmentID);
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        if (log.isDebugEnabled())
            log.debug("step4 - lock equipment resource");
        int seqLen = CimArrayUtils.getSize(chamberStatusList);
        for (int i = 0; i < seqLen; i++) {
            objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID,
                    chamberStatusList.get(i).getChamberID(), BizConstant.SP_CLASSNAME_POSPROCESSRESOURCE);
        }

        if (log.isDebugEnabled())
            log.debug("step5 - Convert Chamber Status");
        Outputs.ObjProcessResourceStateConvertOut objProcessResourceStateConvertOutResult =
                processMethod.processResourceStateConvert(objCommon, equipmentId, chamberStatusList);
        List<Infos.EqpChamberStatus> eqpChamberStatuses = objProcessResourceStateConvertOutResult
                .getEqpChamberStatusCheckResults();

        if (log.isDebugEnabled())
            log.debug("step6 - Check Chamber Status Transition");
        List<Infos.EqpChamberStatusCheckResult> stateCheckTransitionResult = processMethod
                .processResourceCurrentStateCheckTransition(objCommon, equipmentId, eqpChamberStatuses,
                        false);
        for (Infos.EqpChamberStatusCheckResult eqpChamberStatusCheckResult : stateCheckTransitionResult) {
            Validations.check(eqpChamberStatusCheckResult.getResult() != retCodeConfig.getSucc().getCode(),
                    retCodeConfig.getInvalidStateTrans());
        }

        if (log.isDebugEnabled())
            log.debug("step7 - Change each Chamber status by Input data");
        Outputs.ObjProcessResourceCurrentStateChangeOut currentStateChangeOutRetCode = processMethod
                .processResourceCurrentStateChange(objCommon, equipmentId, stateCheckTransitionResult);

        if (log.isDebugEnabled())
            log.debug("step8 - Judge new eqp status if all chamber status are changed");
        ObjectIdentifier judgedEqpStatusCode = equipmentMethod.getEquipmentStateByChambers(equipmentId,
                eqpChamberStatuses);

        if (log.isDebugEnabled())
            log.debug("step9 - Convert eqp Status");
        Outputs.ObjEquipmentStateConvertOut convertOut = equipmentMethod.equipmentStateConvertV2(
                equipmentId, judgedEqpStatusCode);

        if (log.isDebugEnabled())
            log.debug("Step10 - Check estimated-new-eqp-status vs. allowed-new-staus by Current mode");
        try {
            equipmentMethod.equipmentCurrentStateCheckTransitionV2(objCommon, equipmentId,
                    convertOut.getConvertedStatusCode(), true);
            equipmentStatusChangeReqiredFlag = true;
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())
                    && !Validations.isEquals(retCodeConfig.getInvalidStateTransition(), e.getCode())) {
                throw e;
            }
        }

        /*-----------------------------------------------------------*/
        /* Change eqp status by judged new status              */
        /*-----------------------------------------------------------*/
        if (equipmentStatusChangeReqiredFlag) {
            if (log.isDebugEnabled())
                log.debug("step11 - equipment_currentState_Change");
            Outputs.ObjEquipmentCurrentStateChangeOut stateChangeOutRetCode = equipmentMethod
                    .equipmentCurrentStateChange(objCommon, equipmentId, convertOut.getConvertedStatusCode());

            if (log.isDebugEnabled())
                log.debug("step12 - Create eqp Status Change Even");
            Inputs.EquipmentStatusChangeEventMakeParams eventParams = new Inputs.EquipmentStatusChangeEventMakeParams();
            eventParams.setTransactionID(TransactionIDEnum.CHAMBER_STATUS_CHANGE_REQ.getValue());
            eventParams.setEquipmentID(equipmentID);
            eventParams.setStockerID(new ObjectIdentifier());
            eventParams.setNewEquipmentStatus(convertOut.getConvertedStatusCode());
            eventParams.setNewE10Status(stateChangeOutRetCode.getE10Status());
            eventParams.setNewActualStatus(stateChangeOutRetCode.getActualStatus());
            eventParams.setNewActualE10Status(stateChangeOutRetCode.getActualE10Status());
            eventParams.setNewOperationMode(stateChangeOutRetCode.getOperationMode());
            eventParams.setPreviousStatus(stateChangeOutRetCode.getPreviousStatus());
            eventParams.setPreviousE10Status(stateChangeOutRetCode.getPreviousE10Status());
            eventParams.setPreviousActualStatus(stateChangeOutRetCode.getPreviousActualStatus());
            eventParams.setPreviousActualE10Status(stateChangeOutRetCode.getPreviousActualE10Status());
            eventParams.setPreviousOpeMode(stateChangeOutRetCode.getPreviousOpeMode());
            eventParams.setPrevStateStartTime(stateChangeOutRetCode.getPrevStateStartTime());
            eventParams.setClaimMemo(claimMemo);
            eventMethod.equipmentStatusChangeEventMake(objCommon, eventParams);
        }
        if (log.isDebugEnabled())
            log.debug("step13 - Create Chamber Status Change Event ");
        eventMethod.chamberStatusChangeEventMake(objCommon, TransactionIDEnum.CHAMBER_STATUS_CHANGE_REQ.getValue(),
                equipmentID, currentStateChangeOutRetCode.getEqpChamberStates(), "");
        /*-----------------------------------------------------------*/
        /*  Return Result                                            */
        /*-----------------------------------------------------------*/
        chamberStatusChangeReqResult.setEquipmentID(equipmentID);
        chamberStatusChangeReqResult.setEqpChamberStatusList(eqpChamberStatuses);
        chamberStatusChangeReqResult.setEquipmentStatusCode(judgedEqpStatusCode);

        return chamberStatusChangeReqResult;
    }

    @Override
    public Results.ChamberStatusChangeReqResult sxChamberStatusChangeReq(Infos.ObjCommon objCommon,
                                                                         ObjectIdentifier equipmentID,
                                                                         List<Infos.EqpChamberStatus> chamberStatuses,
                                                                         String claimMemo) {
        return sxChamberStatusChangeReq(objCommon, equipmentID, chamberStatuses, ObjectIdentifier.emptyIdentifier(),
                claimMemo);
    }

    @Override
    public Results.ChamberStatusChangeReqResult sxChamberStatusChangeReq(Infos.ObjCommon objCommon,
                                                                         ObjectIdentifier equipmentID,
                                                                         List<Infos.EqpChamberStatus> chamberStatuses,
                                                                         ObjectIdentifier reasonCodeID,
                                                                         String claimMemo) {

        if (CimStringUtils.equals(objCommon.getTransactionID(),
                TransactionIDEnum.CHAMBER_STATUS_CHANGE_REQ.getValue())) {
            Validations.check(ObjectIdentifier.isEmptyWithValue(reasonCodeID), retCodeConfig.getInvalidInputParam());

            // check reasonCode is correct
            codeMethod.codeCheckExistanceDR(objCommon, BizConstant.SP_REASONCAT_EQUIPMENTSTATE,
                    Collections.singletonList(reasonCodeID));
        }

        // Get lock mode of equipment
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.CHAMBER_STATUS_CHANGE_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // Lock Equipment Main Object
            List<String> dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);
            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            // Lock equipment
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        if (CimArrayUtils.isNotEmpty(chamberStatuses)) {
            chamberStatuses.forEach(status ->
                    objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, status.getChamberID(),
                            BizConstant.SP_CLASSNAME_POSPROCESSRESOURCE));
        }

        // Convert chamber status
        Outputs.ObjProcessResourceStateConvertOut chamberConvertOut = processMethod.processResourceStateConvert(
                objCommon, equipmentID, chamberStatuses);

        // Check chamber status transition
        List<Infos.EqpChamberStatusCheckResult> checkResults = processMethod
                .processResourceCurrentStateCheckTransition(objCommon, equipmentID,
                        chamberConvertOut.getEqpChamberStatusCheckResults(), false);

        // Change each chamber status by Input data
        Outputs.ObjProcessResourceCurrentStateChangeOut chamberResult = processMethod
                .processResourceCurrentStateChange(objCommon, equipmentID, checkResults);

        // Judge new eqp status if all chamber status are changed
        ObjectIdentifier judgedStatus = equipmentMethod.getEquipmentStateByChambers(equipmentID,
                chamberConvertOut.getEqpChamberStatusCheckResults());

        // Convert eqp status
        Outputs.ObjEquipmentStateConvertOut eqpConvertOut = equipmentMethod.equipmentStateConvertV2(
                equipmentID, judgedStatus);

        // Check estimated-eqp-status vs. allowed-new-status by Current mode
        try {
            equipmentMethod.equipmentCurrentStateCheckTransitionV2(objCommon, equipmentID,
                    eqpConvertOut.getConvertedStatusCode(), false);
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())) {
                throw e;
            }
        }

        // exec eqp status change
        Outputs.ObjEquipmentCurrentStateChangeOut eqpResult = equipmentMethod.equipmentCurrentStateChange(
                objCommon, equipmentID, eqpConvertOut.getConvertedStatusCode());

        Inputs.EquipmentStatusChangeEventMakeParams eventParams = new Inputs.EquipmentStatusChangeEventMakeParams();
        eventParams.setTransactionID(TransactionIDEnum.CHAMBER_STATUS_CHANGE_REQ.getValue());
        eventParams.setEquipmentID(equipmentID);
        eventParams.setStockerID(ObjectIdentifier.emptyIdentifier());
        eventParams.setNewEquipmentStatus(eqpConvertOut.getConvertedStatusCode());
        eventParams.setNewE10Status(eqpResult.getE10Status());
        eventParams.setNewActualStatus(eqpResult.getActualStatus());
        eventParams.setNewActualE10Status(eqpResult.getActualE10Status());
        eventParams.setNewOperationMode(eqpResult.getOperationMode());
        eventParams.setPreviousStatus(eqpResult.getPreviousStatus());
        eventParams.setPreviousE10Status(eqpResult.getPreviousE10Status());
        eventParams.setPreviousActualStatus(eqpResult.getPreviousActualStatus());
        eventParams.setPreviousActualE10Status(eqpResult.getPreviousActualE10Status());
        eventParams.setPreviousOpeMode(eqpResult.getPreviousOpeMode());
        eventParams.setPrevStateStartTime(eqpResult.getPrevStateStartTime());
        eventParams.setReasonCodeID(ObjectIdentifier.isEmptyWithValue(reasonCodeID) ? ObjectIdentifier.emptyIdentifier()
                : reasonCodeID);
        eventParams.setClaimMemo(claimMemo);
        eventMethod.equipmentStatusChangeEventMake(objCommon, eventParams);

        eventMethod.chamberStatusChangeEventMake(objCommon, TransactionIDEnum.CHAMBER_STATUS_CHANGE_REQ.getValue(),
                equipmentID, chamberResult.getEqpChamberStates(), claimMemo);

        Results.ChamberStatusChangeReqResult out = new Results.ChamberStatusChangeReqResult();
        out.setEquipmentID(equipmentID);
        out.setEqpChamberStatusList(chamberConvertOut.getEqpChamberStatusCheckResults());
        out.setEquipmentStatusCode(judgedStatus);
        return out;
    }

    @Override
    public Results.CarrierLoadingVerifyReqResult sxCarrierLoadingVerifyForIBReq(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier portID, ObjectIdentifier cassetteID, String loadPurposeType) {
        log.debug("CarrierLoadingVerifyForIBReqService::sxCarrierLoadingVerifyForIBReq(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier portID, ObjectIdentifier cassetteID, String loadPurposeType)");
        log.debug("objCommon = {}, equipmentID = {}, portID = {}, cassetteID = {}, loadPurposeType = {}", objCommon, equipmentID, portID, cassetteID, loadPurposeType);
        Results.CarrierLoadingVerifyReqResult carrierLoadingVerifyReqResult = new Results.CarrierLoadingVerifyReqResult();

        if (ObjectIdentifier.isEmpty(equipmentID) || ObjectIdentifier.isEmpty(portID) || ObjectIdentifier.isEmpty(cassetteID)) {
            log.error("sxCarrierLoadingVerifyForIBReq::invalid input parameter");
            throw new ServiceException(retCodeConfig.getInvalidInputParam());
        }

        //-------------------------------------------------
        //  Check Scrap wafer Exsit In Carrier
        //-------------------------------------------------
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (!CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_OTHER, loadPurposeType)) {
            log.debug("step1 - select cassette scrap wafer");
            List<Infos.LotWaferMap> lotWaferMaps = cassetteMethod.cassetteScrapWaferSelectDR(objCommon, Arrays.asList(cassetteID));
            if (!CimObjectUtils.isEmpty(lotWaferMaps)) {
                log.error("ScrapWafer Found");
                throw new ServiceException(retCodeConfig.getFoundScrap());
            }
        }

        /*-----------------------------------------------------------------------*/
        /*   Check Process For Empty cassette                                    */
        /*-----------------------------------------------------------------------*/
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE, loadPurposeType)) {
            /*------------------------------------*/
            /*   Check cassette is Empty or Not   */
            /*------------------------------------*/
            log.debug("step2 - Check cassette is Empty or Not");
            cassetteMethod.cassetteCheckEmpty(cassetteID);
            /*--------------------------------------------------------*/
            /*   Check cassette Condition for Loading                 */
            /*   The following conditions are checked for Loading.    */
            /*   - controlJobID                                       */
            /*   - multiLotType                                       */
            /*   - transferState                                      */
            /*   - cassetteState                                      */
            /*--------------------------------------------------------*/
            log.debug("step3 - Check cassette Condition for Loading ");
            cassetteMethod.cassetteCheckConditionForLoading(objCommon, equipmentID, portID, cassetteID);

            /*--------------------------------------------------------*/
            /*                                                        */
            /*   Check eqp and port Condition for Loading       */
            /*                                                        */
            /*   The following conditions are checked for Loading.    */
            /*                                                        */
            /*   - controlJobID                                       */
            /*   - loadPort's reservedControlJob VS cassette's one    */
            /*   - loadPort's portUsage (Input or InOut)              */
            /*   - loadPurposeType                                    */
            /*   - portState                                          */
            /*   - allocatedMaterial                                  */
            /*                                                        */
            /*--------------------------------------------------------*/
            //TODO: equipment_CheckConditionForLoadingForInternalBuffer
            log.debug("step4 - Check eqp and port Condition for Loading ");
            equipmentMethod.equipmentCheckConditionForLoadingForInternalBuffer(objCommon, equipmentID, portID, cassetteID, loadPurposeType);

            /*---------------------------------------------------------------------------*/
            /*   Check Category for process contamination control (Copper/Non Copper)    */
            /*   It is checked in the following method whether it is the condition       */
            /*   that lot of the object is made of OpeStart.                             */
            /*   1. It is checked whether the CassetteCategory of PosCassette and        */
            /*      the CassetteCategoryCapability of PosPortResource are the same.      */
            /*   2. It is proper condition if CassetteCategoryCapability is the same     */
            /*      as RequiredCassetteCategory and CassetteCategory.                    */
            /*---------------------------------------------------------------------------*/
            log.debug("step5 - Check Category for process contamination control");
            lotMethod.lotCassetteCategoryCheckForContaminationControl(objCommon, null, cassetteID, equipmentID, portID);


            /*--------------------------------------------*/
            /*   Return to Caller (Empty cassette case)   */
            /*--------------------------------------------*/
            //result.setReturnCode(retCodeConfig.getSucc());
            return carrierLoadingVerifyReqResult;
        }

        /*-----------------------------------------------------------------------*/
        /*   Check Process For lot                                               */
        /*-----------------------------------------------------------------------*/
        /*----------------------------------------------*/
        /*   Set Input Parameters to strStartCassette   */
        /*----------------------------------------------*/
        Infos.StartCassette startCassette = new Infos.StartCassette();
        startCassette.setCassetteID(cassetteID);
        startCassette.setLoadPurposeType(loadPurposeType);
        startCassette.setLoadPortID(portID);
        startCassette.setLoadSequenceNumber(0L);

        /*---------------------------------*/
        /*   Get cassette's ControlJobID   */
        /*---------------------------------*/
        log.debug("step6 - Get cassette's ControlJobID");
        ObjectIdentifier controlJobIDOut = cassetteMethod.cassetteControlJobIDGet(objCommon, cassetteID);
        List<Infos.LotInCassette> lotInCassettes = new ArrayList<>();
        ObjectIdentifier controlJobID = controlJobIDOut;
        int lotLen = 0;
        log.trace("controlJobID is 【{}】",controlJobID);
        if (ObjectIdentifier.isEmpty(controlJobID)) {
            /*-----------------------------------*/
            /*   Get Contained lot in cassette   */
            /*-----------------------------------*/
            log.debug("step7 - Get Contained lot in cassette");
            Infos.LotListInCassetteInfo lotListOut = null;
            try {
                lotListOut = cassetteMethod.cassetteGetLotList(objCommon, cassetteID);
            } catch (ServiceException e) {
                if (!Validations.isEquals(retCodeConfig.getNotFoundLot(), e.getCode())) {
                    throw e;
                }
            }
            lotLen = lotListOut == null ? 0 : CimArrayUtils.getSize(lotListOut.getLotIDList());
            Infos.LotListInCassetteInfo lotListInCassetteInfo = lotListOut;
            if (null != lotListInCassetteInfo && !CimObjectUtils.isEmpty(lotListInCassetteInfo.getLotIDList())) {
                List<ObjectIdentifier> lotIDList = lotListInCassetteInfo.getLotIDList();
                for (ObjectIdentifier lotID : lotIDList) {
                    Infos.LotInCassette lotInCassette = new Infos.LotInCassette();
                    lotInCassette.setMoveInFlag(true);
                    lotInCassette.setLotID(lotID);
                    log.trace("loadPurposeType is 【{}】",loadPurposeType);
                    if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT, loadPurposeType)) {
                        /*------------------*/
                        /*   Get lot Type   */
                        /*------------------*/
                        log.debug("step8 - get lot type");
                        String lotType = lotMethod.lotTypeGet(objCommon, lotID);
                        log.trace("lotType is 【{}】",lotType);
                        if (CimStringUtils.equals(BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT, lotType)) {
                            lotInCassette.setMonitorLotFlag(true);
                        } else {
                            log.debug("step9 - get lot monitor route flag");
                            boolean routeFlagOut = lotMethod.lotMonitorRouteFlagGet(objCommon, lotID);
                            lotInCassette.setMonitorLotFlag(routeFlagOut);
                        }
                    } else {
                        lotInCassette.setMonitorLotFlag(false);
                    }
                    lotInCassettes.add(lotInCassette);
                }
                startCassette.setLotInCassetteList(lotInCassettes);
            }
        } else {
            log.trace("getCassetteControlJobID().controlJobID not null");
            /*-------------------------------------*/
            /*   Get Contained lot in controljob   */
            /*-------------------------------------*/
            log.debug("step10 - Get Contained Lot in ControlJob");
            List<Infos.ControlJobCassette> controlJobCassettes = controlJobMethod.controlJobContainedLotGet(objCommon, controlJobID);
            log.trace("controlJobCassettes is 【{}】",controlJobCassettes);
            if (!CimArrayUtils.isEmpty(controlJobCassettes)) {
                for (Infos.ControlJobCassette controlJobCassette : controlJobCassettes) {
                    lotLen = CimArrayUtils.getSize(controlJobCassette.getControlJobLotList());
                    log.trace("controlJobCassette cassette is 【{}】，cassetteID is 【{}】",controlJobCassette.getCassetteID(), cassetteID);
                    if (ObjectIdentifier.equalsWithValue(controlJobCassette.getCassetteID(), cassetteID)) {
                        List<Infos.ControlJobLot> controlJobLotList = controlJobCassette.getControlJobLotList();
                        log.trace("controlJobLotList is 【{}】",controlJobLotList);
                        if (CimArrayUtils.isNotEmpty(controlJobLotList)) {
                            for (Infos.ControlJobLot controlJobLot : controlJobLotList) {
                                Infos.LotInCassette lotInCassette = new Infos.LotInCassette();
                                lotInCassette.setMoveInFlag(controlJobLot.getOperationStartFlag());
                                lotInCassette.setMonitorLotFlag(controlJobLot.getMonitorLotFlag());
                                ObjectIdentifier lotID = controlJobLot.getLotID();
                                lotInCassette.setLotID(lotID);

                                log.debug("step11 - get lot type");
                                String lotType = lotMethod.lotTypeGet(objCommon, lotID);
                                lotInCassette.setLotType(lotType);
                                lotInCassettes.add(lotInCassette);
                            }
                        }
                        break;
                    }
                }
                startCassette.setLotInCassetteList(lotInCassettes);
            }
        }

        /*-------------------------------------------------------*/
        /*   Check Lot Condition for Loading                     */
        /*                                                       */
        /*   The following conditions are checked for each lot.  */
        /*                                                       */
        /*   - lot's equipmentID                                 */
        /*   - lotHoldState                                      */
        /*   - lotProcessState                                   */
        /*   - lotInventoryState                                 */
        /*   - entityInhibition                                  */
        /*   - equipment's availability for specified lot        */
        /*                                                       */
        /*   (*)                                                 */
        /*   About for reticle/fixture, whether these are        */
        /*   inhibitted or not itself is checked at later.       */
        /*   (by processDurable_CheckConditionForOpeStart)       */
        /*-------------------------------------------------------*/
        int lotIncassetteSiez = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
        List<String> verifyNGReasons = new ArrayList<>();
        for (int i = 0; i < lotIncassetteSiez; i++) {
            verifyNGReasons.add(null);  // need to set the list size, it's equal with lotIncassetteSiez
            log.trace("MoveInFlag is 【{}】",startCassette.getLotInCassetteList().get(i).getMoveInFlag());
            if (!startCassette.getLotInCassetteList().get(i).getMoveInFlag()) {
                continue;
            }
            try {
                log.debug("step12 - Check Lot Condition for Loading");
                lotMethod.lotCheckConditionForLoading(objCommon, equipmentID, startCassette.getLotInCassetteList().get(i).getLotID());
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getNotCandidateLotForOperationStart(), e.getCode())) {
                    startCassette.getLotInCassetteList().get(i).setMoveInFlag(false);
                    verifyNGReasons.set(i, e.getReasonText());
                } else {
                    throw e;
                }

            }

        }
        /*--------------------------------------------------------*/
        /*   Check Cassette Condition for Loading                 */
        /*                                                        */
        /*   The following conditions are checked for Loading.    */
        /*                                                        */
        /*   - controlJobID                                       */
        /*   - multiLotType                                       */
        /*   - transferState                                      */
        /*   - cassetteState                                      */
        /*--------------------------------------------------------*/
        try {
            log.debug("step13 - Check Cassette Condition for Loading");
            cassetteMethod.cassetteCheckConditionForLoading(objCommon, equipmentID, portID, cassetteID);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getInvalidCassetteTransferState(), e.getCode())) {
                List<Infos.LoadingVerifiedLot> loadingVerifiedLots = new ArrayList<>();
                for (int i = 0; i < lotLen; i++) {
                    Infos.LoadingVerifiedLot loadingVerifiedLot = new Infos.LoadingVerifiedLot();
                    loadingVerifiedLot.setMoveInFlag(false);
                    loadingVerifiedLot.setMonitorLotFlag(false);
                    loadingVerifiedLot.setLotID(startCassette.getLotInCassetteList().get(i).getLotID());
                    loadingVerifiedLot.setVerifyNGReason(e.getReasonText());
                    loadingVerifiedLots.add(loadingVerifiedLot);
                }
                e.setData(loadingVerifiedLots);
            }
            throw e;
        }
        /*--------------------------------------------------------*/
        /*   Check Equipment and Port Condition for Loading       */
        /*                                                        */
        /*   The following conditions are checked for Loading.    */
        /*                                                        */
        /*   - controlJobID                                       */
        /*   - loadPort's reservedControlJob VS cassette's one    */
        /*   - loadPort's portUsage (Input or InOut)              */
        /*   - loadPurposeType                                    */
        /*   - portState                                          */
        /*--------------------------------------------------------*/
        try {
            log.debug("step14 - Check Equipment and Port Condition for Loading");
            equipmentMethod.equipmentCheckConditionForLoadingForInternalBuffer(objCommon, equipmentID, portID, cassetteID, loadPurposeType);
        } catch (ServiceException e) {
            // strLoadingVerifiedLot information must be set for ForceLoad process.
            if (Validations.isEquals(retCodeConfig.getCastControlJobIdBlank(), e.getCode())
                    || Validations.isEquals(retCodeConfig.getLoadNotMatchNpwRsv(), e.getCode())) {
                List<Infos.LoadingVerifiedLot> loadingVerifiedLots = new ArrayList<>();
                log.info("lotLen {}", lotLen);
                for (int j = 0; j < lotLen; j++) {
                    Infos.LoadingVerifiedLot loadingVerifiedLot = new Infos.LoadingVerifiedLot();
                    loadingVerifiedLot.setMoveInFlag(false);
                    loadingVerifiedLot.setMonitorLotFlag(false);
                    loadingVerifiedLot.setLotID(startCassette.getLotInCassetteList().get(j).getLotID());
                    loadingVerifiedLot.setVerifyNGReason(e.getReasonText());
                    loadingVerifiedLots.add(loadingVerifiedLot);
                }
                e.setData(loadingVerifiedLots);
            }
            throw e;
        }

        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check FlowBatch Condition for Loading                               */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   1. whether in-parm's equipment has reserved flowBatchID or not      */
        /*      fill  -> in-parm's lot must have same flowBatchID                */
        /*      blank -> no check                                                */
        /*                                                                       */
        /*   2. whether lot is in flowBatch section or not                       */
        /*      in    -> lot must have flowBatchID, and flowBatch must have      */
        /*               reserved equipmentID.                                   */
        /*               if lot is on target operation, flowBatch's reserved     */
        /*               equipmentID and in-parm's equipmentID must be same.     */
        /*      out   -> no check                                                */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        log.debug("step15 - Check FlowBatch Condition for Loading");
        equipmentMethod.equipmentLotCheckFlowBatchConditionForLoading(objCommon, equipmentID, startCassette);
        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process Durable Condition for Loading                         */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   1. Whether equipment requires process durable or not                */
        /*      If no-need, return OK;                                           */
        /*                                                                       */
        /*   2. At least one of reticle / fixture for each reticleGroup /        */
        /*      fixtureGroup is in the equipment or not.                         */
        /*      Even if required reticle is in the equipment, its status must    */
        /*      be _Available or _InUse.                                         */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (!CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE, loadPurposeType)) {
            /*-----------------------------------------*/
            /*   Check Process Durable Required Flag   */
            /*-----------------------------------------*/
            try {
                log.debug("step16 - Check Process Durable Required Flag");
                equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, equipmentID);
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())
                        || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                    log.trace("rc == RC_EQP_PROCDRBL_RTCL_REQD || rc == RC_EQP_PROCDRBL_FIXT_REQD");
                    int lotInCassetteListLength = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                    for (int j = 0; j < lotInCassetteListLength; j++) {
                        Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                        if (!lotInCassette.getMoveInFlag()) {
                            log.trace("strStartCassette.strLotInCassette[j].operationStartFlag == FALSE");
                            continue;
                        }

                        /*--------------------------------*/
                        /*   check reserve reticle info   */
                        /*--------------------------------*/
                        log.trace("controlJobIDOut is 【{}】",controlJobIDOut);
                        if (!ObjectIdentifier.isEmpty(controlJobIDOut)) {
//                        Outputs.ObjControlJobStartReserveInformationGetOut objControlJobStartReserveInformationGetOut = lotMethod.controlJobStartReserveInformationGet(objCommon, objCassetteControlJobIDGetOut.getControJobId());
                            log.debug("step17 - get control job start reserve information");
                            Outputs.ObjControlJobStartReserveInformationOut objControlJobStartReserveInformationGetOut =
                                    controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                                            controlJobIDOut,
                                            false);

                            List<Infos.StartCassette> startCassettes = objControlJobStartReserveInformationGetOut.getStartCassetteList();
                            log.trace("startCassettes is 【{}】",startCassettes);
                            if (CimArrayUtils.isNotEmpty(startCassettes)) {
                                for (Infos.StartCassette tmpStartCassette : startCassettes) {
                                    log.trace("tmpStartCassette cassetteID is 【{}】，cassetteID is 【{}】",tmpStartCassette.getCassetteID(), cassetteID);
                                    if (ObjectIdentifier.equalsWithValue(tmpStartCassette.getCassetteID(), cassetteID)) {
                                        List<Infos.LotInCassette> tmpLotInCassettes = tmpStartCassette.getLotInCassetteList();
                                        for (Infos.LotInCassette tmpLotInCassette : tmpLotInCassettes) {
                                            log.trace("MoveInFlag is 【{}】",tmpLotInCassette.getMoveInFlag());
                                            if (!tmpLotInCassette.getMoveInFlag()) {
                                                continue;
                                            }
                                            List<Infos.StartReticleInfo> startReticles = tmpLotInCassette.getStartRecipe().getStartReticleList();
                                            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())
                                                    && CimArrayUtils.getSize(startReticles) > 0) {
                                                /*---------------------------------*/
                                                /*   Get and Check Reticle State   */
                                                /*     - state                     */
                                                /*     - transferState             */
                                                /*---------------------------------*/
                                                log.debug("step18 - Get and Check Reticle State");
                                                reticleMethod.reticleStateCheck170(objCommon, equipmentID, startReticles, tmpLotInCassette.getLotID());

                                                /*------------------------------*/
                                                /*   Check Reticle Inhibition   */
                                                /*------------------------------*/
                                                Infos.EntityInhibitAttributes entityInhibitAttributes = new Infos.EntityInhibitAttributes();
                                                List<Infos.EntityIdentifier> entities = new ArrayList<>();
                                                for (Infos.StartReticleInfo startReticleInfo : tmpLotInCassette.getStartRecipe().getStartReticleList()) {
                                                    Infos.EntityIdentifier entityIdentifier = new Infos.EntityIdentifier();
                                                    entityIdentifier.setClassName(BizConstant.SP_INHIBITCLASSID_RETICLE);
                                                    entityIdentifier.setObjectID(startReticleInfo.getReticleID());
                                                    entityIdentifier.setAttribution(BizConstant.EMPTY);
                                                    entityInhibitAttributes.setEntities(entities);
                                                }

                                                log.debug("step19 - check constraint for entities");
                                                Infos.EntityInhibitCheckForEntitiesOut entityInhibitCheckForEntitiesOut = constraintMethod.constraintCheckForEntities(objCommon, entityInhibitAttributes);
                                                List<Infos.EntityInhibitInfo> entityInhibitCheckForEntities = entityInhibitCheckForEntitiesOut.getEntityInhibitInfo();
                                                int lenInhibit = CimArrayUtils.getSize(entityInhibitCheckForEntities);
                                                List<Infos.EntityInhibitInfo> effectiveForLot = null;
                                                log.trace("lenInhibit is 【{}】",lenInhibit);
                                                if (lenInhibit > 0) {
                                                    Inputs.ObjEntityInhibiteffectiveForLotGetDRIn inhibiteffectiveForLotGetDRIn = new Inputs.ObjEntityInhibiteffectiveForLotGetDRIn();
                                                    inhibiteffectiveForLotGetDRIn.setStrEntityInhibitInfos(entityInhibitCheckForEntities);
                                                    inhibiteffectiveForLotGetDRIn.setLotID(tmpLotInCassette.getLotID());
                                                    log.debug("step20 - get constraint effective for lot");
                                                    effectiveForLot = constraintMethod.constraintEffectiveForLotGetDR(objCommon, inhibiteffectiveForLotGetDRIn.getStrEntityInhibitInfos(), inhibiteffectiveForLotGetDRIn.getLotID());
                                                }
                                                log.trace("effectiveForLot is 【{}】",effectiveForLot);
                                                if (CimArrayUtils.isNotEmpty(effectiveForLot)) {
                                                    throw new ServiceException(retCodeConfigEx.getEntityInhibitCreateFailed());
                                                }
                                            } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                                                log.debug("step21 - check fixture state");
                                                fixtureMethod.fixtureStateCheck(objCommon, equipmentID, tmpLotInCassette.getStartRecipe().getStartFixtureList());
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            /*-------------------------------------------------*/
                            /*   Get Lot's LogicalRecipeID / MachineRecipeID   */
                            /*-------------------------------------------------*/
                            log.debug("step22 - Get Lot's LogicalRecipeID / MachineRecipeID ");
                            Outputs.ObjLotRecipeGetOut objLotRecipeGetOut = lotMethod.lotRecipeGet(objCommon, equipmentID, lotInCassette.getLotID());

                            if (lotInCassette.getStartRecipe() == null){

                                lotInCassette.setStartRecipe(new Infos.StartRecipe());
                            }
                            lotInCassette.getStartRecipe().setLogicalRecipeID(objLotRecipeGetOut.getLogicalRecipeId());
                            lotInCassette.getStartRecipe().setMachineRecipeID(objLotRecipeGetOut.getMachineRecipeId());

                            /*--------------------------------------------------*/
                            /*   Check Process Durable Condition for OpeStart   */
                            /*    - At least one of reticle / fixture for each  */
                            /*      reticleGroup / fixtureGroup is in the       */
                            /*      equipment or not. Even if required reticle  */
                            /*      is in the equipment, its status must be     */
                            /*      _Available or _InUse.                       */
                            /*    - Found reticles must not be inhibitted.      */
                            /*--------------------------------------------------*/
                            log.debug("step23 - Check Process durable Condition for OpeStart");
                            Outputs.ObjProcessDurableCheckConditionForOperationStartOut objProcessDurableCheckConditionForOpeStartOut
                                    = null;
                            try {
                                objProcessDurableCheckConditionForOpeStartOut = processMethod.processDurableCheckConditionForOpeStart(objCommon, equipmentID,
                                        lotInCassette.getStartRecipe().getLogicalRecipeID(), lotInCassette.getStartRecipe().getMachineRecipeID(),
                                        lotInCassette.getLotID());
                            } catch (ServiceException ex) {
                                if (retCodeConfig.getNotAvailableFixture().getCode() == ex.getCode()
                                        || retCodeConfig.getNotAvailableReticle().getCode() == ex.getCode()) {
                                    log.trace("rc == RC_NOT_AVAILABLE_RETICLE || rc == RC_NOT_AVAILABLE_FIXTURE");
                                    lotInCassette.setMoveInFlag(false);
                                    verifyNGReasons.add(ex.getMessage());
                                    log.trace("Check Process durable Condition for Loading after strStartCassette.strLotInCassette[j].operationStartFlag");
                                } else {
                                    throw ex;
                                }
                            }
                        }
                    }

                } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableNotRequired(), e.getCode())) {
                    log.trace("rc == RC_EQP_PROCDRBL_NOT_REQD");
                    //result.setReturnCode(retCodeConfig.getSucc());
                } else {
                    throw e;
                }
            }
        }
        log.trace("controlJobIDOut is 【{}】",controlJobIDOut);
        if (ObjectIdentifier.isEmptyWithValue(controlJobIDOut)) {
            List<Infos.StartCassette> startCassettes = new ArrayList<>();
            startCassettes.add(startCassette);
            log.trace("LotInCassetteList is 【{}】",startCassettes.get(0).getLotInCassetteList());
            if (CimArrayUtils.isNotEmpty(startCassettes.get(0).getLotInCassetteList()))
                for (Infos.LotInCassette lotInCassette : startCassettes.get(0).getLotInCassetteList()) {
                    log.debug("MoveInFlag is 【{}】",lotInCassette.getMoveInFlag());
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }
                    //----------------------------------------------------------------------------
                    //   Get Lot's LogicalRecipeID / MachineRecipeID from standard definition.
                    //----------------------------------------------------------------------------
                    log.debug("step24 - Get Lot's LogicalRecipeID");
                    Outputs.ObjLotRecipeGetOut objLotRecipeGetOut = lotMethod.lotRecipeGet(objCommon, equipmentID, lotInCassette.getLotID());

                    Infos.StartRecipe startRecipe = lotInCassette.getStartRecipe();
                    if (null == startRecipe) {
                        startRecipe = new Infos.StartRecipe();
                        lotInCassette.setStartRecipe(startRecipe);
                    }
                    startRecipe.setLogicalRecipeID(objLotRecipeGetOut.getLogicalRecipeId());
                    startRecipe.setMachineRecipeID(objLotRecipeGetOut.getMachineRecipeId());
                }
            log.debug("step25 - get machine recipe for recipe body management");
            List<Infos.RecipeBodyManagement> machineRecipeListForRecipeBodyManagement = machineRecipeMethod.machineRecipeGetListForRecipeBodyManagement(objCommon, equipmentID, startCassettes);

            int targetRecipeLen = CimArrayUtils.getSize(machineRecipeListForRecipeBodyManagement);
            log.trace("targetRecipeLen is 【{}】",targetRecipeLen);
            if (0 != targetRecipeLen) {
                throw new ServiceException(retCodeConfig.getCannotLoadWithoutCj());
            }
        }
        //-----------------------------------------------------------------
        // Load Purpose Type is OTHER Case:
        //   Execute Cassette Category and Port Category Combination Check.
        //-----------------------------------------------------------------
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_OTHER, loadPurposeType)) {
            log.debug("step26 - Load Purpose Type is OTHER Case");
            lotMethod.lotCassetteCategoryCheckForContaminationControl(objCommon, null, cassetteID, equipmentID, portID);
        }
        /*---------------------------------------------------------------------------*/
        /*   Check Category for Copper/Non Copper                                    */
        /*                                                                           */
        /*   It is checked in the following method whether it is the condition       */
        /*   that Lot of the object is made of OpeStart.                             */
        /*                                                                           */
        /*   1. It is checked whether CassetteCategory of RequiredCassetteCategory   */
        /*      of PosLot and PosCassette is the same.                               */
        /*                                                                           */
        /*   2. It is checked whether CassetteCategoryCapability of CassetteCategory */
        /*      of PosCassette and PosPortResource is the same.                      */
        /*                                                                           */
        /*   3. It is proper condition if CassetteCategoryCapability is the same     */
        /*      as RequiredCassetteCategory and CassetteCategory.                    */
        /*---------------------------------------------------------------------------*/
        int nLotInCastLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
        for (int i = 0; i < nLotInCastLen; i++) {
            log.debug("step27 - Check Category for Copper/Non Copper");
            lotMethod.lotCassetteCategoryCheckForContaminationControl(objCommon, startCassette.getLotInCassetteList().get(i).getLotID(),
                    startCassette.getCassetteID(), equipmentID, startCassette.getLoadPortID());

        }
        /*--------------------------*/
        /*   Set Return Structure   */
        /*--------------------------*/
        List<Infos.LoadingVerifiedLot> loadingVerifiedLots = new ArrayList<>();
        int startLotCount = 0;
        int monitorLotCount = 0;
        for (int i = 0; i < lotIncassetteSiez; i++) {
            Infos.LoadingVerifiedLot loadingVerifiedLot = new Infos.LoadingVerifiedLot();
            loadingVerifiedLot.setMoveInFlag(startCassette.getLotInCassetteList().get(i).getMoveInFlag());
            loadingVerifiedLot.setMonitorLotFlag(startCassette.getLotInCassetteList().get(i).getMonitorLotFlag());
            loadingVerifiedLot.setLotID(startCassette.getLotInCassetteList().get(i).getLotID());
            log.trace("verifyNGReasons is 【{}】",verifyNGReasons);
            if (!CimObjectUtils.isEmpty(verifyNGReasons)) {
                loadingVerifiedLot.setVerifyNGReason(verifyNGReasons.get(i));
            }
            Boolean operationStartFlag = loadingVerifiedLot.getMoveInFlag();
            Boolean monitorLotFlag = loadingVerifiedLot.getMonitorLotFlag();
            log.trace("operationStartFlag is 【{}】",operationStartFlag);
            if (operationStartFlag) {
                startLotCount++;
                if (monitorLotFlag) {
                    monitorLotCount++;
                }
            }
            loadingVerifiedLots.add(loadingVerifiedLot);
        }
        /*-----------------------------------------------------------*/
        /*                                                           */
        /*   Final Check for Start Lot Count and Monitor Lot Count   */
        /*                                                           */
        /*-----------------------------------------------------------*/
        if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_PROCESSLOT, loadPurposeType)
                || CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT, loadPurposeType)) {
            log.trace("controlJobID is 【{}】",controlJobID);
            if (ObjectIdentifier.isEmpty(controlJobID)) {
                List<Infos.StartCassette> startCassettes = new ArrayList<>();
                startCassettes.add(startCassette);
                log.debug("step28 - check lot recipe combination for loading");
                lotMethod.lotRecipeCombinationCheckForLoading(objCommon, equipmentID, startCassettes, loadPurposeType);

            }
            /*-----------------------------------*/
            /*   Verify BufferResource           */
            /*-----------------------------------*/
            log.debug("step29 - Verify BufferResource");
            String equipmentMultiRecipeCapabilityGet = equipmentMethod.equipmentMultiRecipeCapabilityGet(objCommon, equipmentID);

            log.trace("equipmentMultiRecipeCapabilityGet is 【{}】",equipmentMultiRecipeCapabilityGet);
            if (CimStringUtils.equals(BizConstant.SP_EQP_MULTIRECIPECAPABILITY_BATCH, equipmentMultiRecipeCapabilityGet)) {
                if (startLotCount != lotLen) {
                    throw new ServiceException(retCodeConfig.getNeedToSpecifyAllLotInCassette());
                }
            }
            log.trace("startLotCount is 【{}】",startLotCount);
            if (0 == startLotCount) {
                throw new ServiceException(retCodeConfig.getNotCandidateLotForOperationStart(), loadingVerifiedLots);
            }
            log.trace("monitorLotCount is 【{}】",monitorLotCount);
            if (1 < monitorLotCount) {
                throw new ServiceException(retCodeConfig.getInvalidProductMonitorCount(), loadingVerifiedLots);
            }
            //-----------------------------------------------------------//
            //                                                           //
            //   Final Check for LoadPurposeType:ProcessMonitorLot       //
            //                                                           //
            //   The lot, which meets fhe following conditions must be   //
            //   exist, and its lot count must be 1.                     //
            //      - OpeStartFlag   : TRUE                              //
            //      - LotType        : ProcessMonitor                    //
            //      - MonitorLotFlag : TRUE                              //
            //                                                           //
            //-----------------------------------------------------------//
            log.trace("LoadPurposeType is 【{}】",startCassette.getLoadPurposeType());
            if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT, startCassette.getLoadPurposeType())) {
                if (1 != monitorLotCount) {
                    throw new ServiceException(retCodeConfig.getInvalidProductMonitorCount());
                }
                for (Infos.LotInCassette lotInCassette : startCassette.getLotInCassetteList()) {
                    if (lotInCassette.getMonitorLotFlag() && lotInCassette.getMoveInFlag()) {
                        if (!CimStringUtils.equals(BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT, lotInCassette.getLotType())) {
                            boolean lotMonitorRouteFlagGetOut = lotMethod.lotMonitorRouteFlagGet(objCommon, lotInCassette.getLotID());
                            if (!lotMonitorRouteFlagGetOut) {
                                throw new ServiceException(retCodeConfig.getInvalidLotType());
                            }
                        }
                        break;
                    }
                }

            }
        }
        /*----------------------*/
        /*   Return to Caller   */
        /*----------------------*/
        log.debug("step30 - Return to Caller");
        carrierLoadingVerifyReqResult.setLoadingVerifiedLots(loadingVerifiedLots);
        return carrierLoadingVerifyReqResult;
    }


    @Override
    public Results.EqpStatusChangeReqResult sxEqpStatusChangeReqV1(Infos.ObjCommon objCommonIn,
                                                                   ObjectIdentifier equipmentId,
                                                                   ObjectIdentifier equipmentStatusCode,
                                                                   String claimMemo) {
        if (log.isDebugEnabled())
            log.debug("sxEqpStatusChangeReq(): enter sxEqpStatusChangeReq");

        if (log.isDebugEnabled())
            log.debug("step1 - check input params");
        if (ObjectIdentifier.isEmpty(equipmentId) || ObjectIdentifier.isEmpty(equipmentStatusCode)) {
            throw new ServiceException(new ErrorCode("equipmentID and equipmentStatusCode can not be empty !"));
        }

        try {
            if (log.isDebugEnabled())
                log.debug("step2 - query stocker by equipment");
            stockerMethod.stockerTypeGetDR(objCommonIn, equipmentId);
            if (log.isDebugEnabled())
                log.debug("lock storage");
            objectLockMethod.objectLock(objCommonIn, CimStorageMachine.class, equipmentId);
        } catch (ServiceException e) {
            if (log.isDebugEnabled())
                log.debug("Step3 - object_lockMode_Get");
            Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
            objLockModeIn.setObjectID(equipmentId);
            objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            objLockModeIn.setFunctionCategory(TransactionIDEnum.EQP_STATUS_CHANGE_REQ.getValue());
            objLockModeIn.setUserDataUpdateFlag(false);
            Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommonIn, objLockModeIn);
            Long lockMode = objLockModeOut.getLockMode();
            if (log.isTraceEnabled())
                log.trace("lockMode is {}",lockMode);
            if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
                if (log.isDebugEnabled())
                    log.debug("Step4 - advanced_object_Lock");
                objectLockMethod.advancedObjectLock(objCommonIn, new Inputs.ObjAdvanceLockIn(equipmentId,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT,
                        objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));
                objectLockMethod.advancedObjectLock(objCommonIn, new Inputs.ObjAdvanceLockIn(equipmentId,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            } else {
                objectLockMethod.objectLock(objCommonIn, CimMachine.class, equipmentId);
            }
        }

        if (log.isDebugEnabled())
            log.debug("add season by ho");
        seasonMethod.createSeasonJobForPM(objCommonIn, equipmentId, equipmentStatusCode, claimMemo);

        if (log.isDebugEnabled())
            log.debug("Convert eqp Status DCR 9900001");
        boolean isStorageBool = false;

        if (log.isDebugEnabled())
            log.debug("step5 - query equipment state info");
        Infos.EqpStatusInfo eqpStatusInfo = new Infos.EqpStatusInfo();
        try {
            eqpStatusInfo = equipmentMethod.equipmentStatusInfoGet(objCommonIn, equipmentId);
        } catch (ServiceException e) {
            // RetCode as notFoundEqp indicates the equipment is a stocker not an error
            if (Validations.isEquals(retCodeConfig.getNotFoundEqp(), e.getCode())) {
                isStorageBool = true;
            } else {
                throw e;
            }
        }

        if (log.isDebugEnabled())
            log.debug("sxEqpStatusChangeReq():{} isStorageBool is {}",equipmentId.getValue(),isStorageBool);

        // get environment value with OM_EQP_STATUS_BACKUP,
        // this environment indicate whether need to backup eqp status before change.
        // if OM_EQP_STATUS_BACKUP = 1 ; then need to backup ; else don't neet to backup.
        String envEqpStatBackup = StandardProperties.OM_EQP_STATUS_BACKUP.getValue();
        ObjectIdentifier backupEquipmentStatus = ObjectIdentifier.emptyIdentifier();

        if (log.isTraceEnabled())
            log.trace("sxEqpStatusChangeReq(): current environment OM_EQP_STATUS_BACKUP value is {}", envEqpStatBackup);
        if (CimStringUtils.equals(envEqpStatBackup, "1")) {
            // If OpeStart, backup the previous eqp status:
            // strEquipment_statusInfo_GetDR_out.equipmentStatusInfo.E10Status
            if (CimStringUtils.equalsIn(objCommonIn.getTransactionID(),
                    TransactionIDEnum.OPERATION_START_REQ.getValue(),
                    TransactionIDEnum.OPERATION_START_FOR_INTERNAL_BUFFER_REQ.getValue())) {
                if (log.isDebugEnabled())
                    log.debug("transactionID is OpeStart = {}", objCommonIn.getTransactionID());
                // Get inProcessingControlJob to check if I am the first controlJob
                // Here using DR method to select existing controlJob only (not include myself)
                List<Infos.EqpInprocessingControlJob> inProcessingControlJobs =
                        equipmentMethod.equipmentInprocessingControlJobInfoGetDR(objCommonIn, equipmentId);
                if (CimArrayUtils.isEmpty(inProcessingControlJobs)) {
                    if (log.isDebugEnabled())
                        log.debug("step6 - Update equipment backup status");
                    equipmentMethod.equipmentBackupStateUpdate(objCommonIn, equipmentId,
                            eqpStatusInfo.getEquipmentStatusCode());
                }
            }

        }

        //If opeComp or opeStartCancel, switch in-para equipmentStatusCode to back eqp status
        if (CimStringUtils.equalsIn(objCommonIn.getTransactionID(),
                TransactionIDEnum.OPERATION_COMP_WITH_DATA_REQ.getValue(),
                TransactionIDEnum.OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(),
                TransactionIDEnum.FORCE_OPERATION_COMP_REQ.getValue(),
                TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue(),
                TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(),
                TransactionIDEnum.FORCE_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(),
                TransactionIDEnum.OPERATION_START_CANCEL_REQ.getValue(),
                TransactionIDEnum.OPERATION_START_CANCEL_FOR_INTERNAL_BUFFER_REQ.getValue())) {
            if (log.isDebugEnabled())
                log.debug("transactionID is OpeComp or OpeStartCancel = {}", objCommonIn.getTransactionID());

            if (log.isDebugEnabled())
                log.debug("step7 - Get inProcessingControlJob to check if I am the last controlJob; " +
                        "Here using DR method to select existing controlJob only (not include myself)");
            List<Infos.EqpInprocessingControlJob> inProcessingControlJobs =
                    equipmentMethod.equipmentInprocessingControlJobInfoGetDR(objCommonIn, equipmentId);
            if (log.isDebugEnabled())
                log.debug("inProcessingControlJobs.size() = {}", inProcessingControlJobs.size());
            if (inProcessingControlJobs.size() == 1) {
                Infos.EqpBackupState eqpBackupState = equipmentMethod.equipmentBackupStateGet(objCommonIn, equipmentId);
                backupEquipmentStatus = eqpBackupState.getBackupEquipmentStatus();
            }
        }

        if (log.isDebugEnabled())
            log.debug("step8 - Start to convert state");
        Outputs.ObjEquipmentStateConvertOut eqpStateConvertOut;
        if (CimStringUtils.equals(envEqpStatBackup, "1")
                && ObjectIdentifier.isNotEmptyWithValue(backupEquipmentStatus)) {
            if (log.isDebugEnabled())
                log.debug("Convert to backupState : {}", backupEquipmentStatus.getValue());
            eqpStateConvertOut = equipmentMethod.equipmentStateConvert(objCommonIn, equipmentId, backupEquipmentStatus);
        } else {
            if (log.isDebugEnabled())
                log.debug("Convert to equipmentStatusCode :{}", equipmentStatusCode.getValue());
            eqpStateConvertOut = equipmentMethod.equipmentStateConvert(objCommonIn, equipmentId, equipmentStatusCode);
        }

        if (log.isDebugEnabled())
            log.debug("step9 - Check input-eqp-status vs. allowed-new-status by Current mode");
        try {
            if (log.isDebugEnabled())
                log.debug("Convert to equipmentStatusCode : {}", equipmentStatusCode.getValue());
            equipmentMethod.equipmentCurrentStateCheckTransition(objCommonIn, equipmentId,
                    eqpStateConvertOut.getConvertedStatusCode(), false);
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())) {
                throw e;
            }
        }

        if (log.isDebugEnabled())
            log.debug("Step10 - equipment currentState Change");
        Outputs.ObjEquipmentCurrentStateChangeOut eqpCurrentStateChangeResult = equipmentMethod
                .equipmentCurrentStateChange(objCommonIn, equipmentId, eqpStateConvertOut.getConvertedStatusCode());
        /*------------------------------------------*/
        /*   Create eqp Status Change Event   */
        /*------------------------------------------*/
        ObjectIdentifier dummy = new ObjectIdentifier();
        if (ObjectIdentifier.isNotEmptyWithValue(backupEquipmentStatus)) {
            if (log.isDebugEnabled())
                log.debug("sxEqpStatusChangeReq(): E10 Status is changed from {} to {}",
                    eqpCurrentStateChangeResult.getPreviousE10Status(),
                    eqpCurrentStateChangeResult.getE10Status());

            if (log.isDebugEnabled())
                log.debug("Step11 - equipment backupState update");
            equipmentMethod.equipmentBackupStateUpdate(objCommonIn, equipmentId, dummy);
            if (log.isDebugEnabled())
                log.debug("sxEqpStatusChangeReq():backupState is reset");
        }
        Inputs.EquipmentStatusChangeEventMakeParams eventMakeParams = new Inputs.EquipmentStatusChangeEventMakeParams();
        eventMakeParams.setTransactionID(TransactionIDEnum.EQP_STATUS_CHANGE_REQ.getValue());
        eventMakeParams.setNewEquipmentStatus(eqpStateConvertOut.getConvertedStatusCode());
        eventMakeParams.setNewE10Status(eqpCurrentStateChangeResult.getE10Status());
        eventMakeParams.setNewActualStatus(eqpCurrentStateChangeResult.getActualStatus());
        eventMakeParams.setNewActualE10Status(eqpCurrentStateChangeResult.getActualE10Status());
        eventMakeParams.setNewOperationMode(eqpCurrentStateChangeResult.getOperationMode());
        eventMakeParams.setPreviousStatus(eqpCurrentStateChangeResult.getPreviousStatus());
        eventMakeParams.setPreviousE10Status(eqpCurrentStateChangeResult.getPreviousE10Status());
        eventMakeParams.setPreviousActualStatus(eqpCurrentStateChangeResult.getPreviousActualStatus());
        eventMakeParams.setPreviousActualE10Status(eqpCurrentStateChangeResult.getPreviousActualE10Status());
        eventMakeParams.setPreviousOpeMode(eqpCurrentStateChangeResult.getPreviousOpeMode());
        eventMakeParams.setPrevStateStartTime(eqpCurrentStateChangeResult.getPrevStateStartTime());
        eventMakeParams.setClaimMemo(claimMemo);
        if (log.isTraceEnabled())
            log.trace("isStorageBool is {}",isStorageBool);
        if (!isStorageBool) {
            eventMakeParams.setEquipmentID(equipmentId);
            eventMakeParams.setStockerID(dummy);
            eventMethod.equipmentStatusChangeEventMake(objCommonIn, eventMakeParams);
        } else {
            eventMakeParams.setEquipmentID(dummy);
            eventMakeParams.setStockerID(equipmentId);
            eventMethod.equipmentStatusChangeEventMake(objCommonIn, eventMakeParams);
        }

        Results.EqpStatusChangeReqResult out = new Results.EqpStatusChangeReqResult();
        out.setEquipmentID(eqpCurrentStateChangeResult.getEquipmentID());
        out.setEquipmentStatusCode(eqpCurrentStateChangeResult.getEquipmentStatusCode());
        return out;
    }

    @Override
    public Results.EqpStatusChangeReqResult sxEqpStatusChangeReq(Infos.ObjCommon objCommon,
                                                                 ObjectIdentifier equipmentID,
                                                                 ObjectIdentifier eqpToState,
                                                                 String claimMemo) {
        return sxEqpStatusChangeReq(objCommon, equipmentID, eqpToState, ObjectIdentifier.emptyIdentifier(), claimMemo);
    }

    @Override
    public Results.EqpStatusChangeReqResult sxEqpStatusChangeReq(Infos.ObjCommon objCommon,
                                                                 ObjectIdentifier equipmentID,
                                                                 ObjectIdentifier eqpToState,
                                                                 ObjectIdentifier reasonCodeID,
                                                                 String claimMemo) {
        if (ObjectIdentifier.isEmpty(equipmentID) || ObjectIdentifier.isEmpty(eqpToState))
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidInputParam()));

        if (CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.EQP_STATUS_CHANGE_REQ.getValue())) {
            Validations.check(ObjectIdentifier.isEmptyWithValue(reasonCodeID), retCodeConfig.getInvalidInputParam());

            // check reasonCode is correct
            codeMethod.codeCheckExistanceDR(objCommon, BizConstant.SP_REASONCAT_EQUIPMENTSTATE,
                    Collections.singletonList(reasonCodeID));
        }

        if (log.isDebugEnabled())
            log.debug("TransactionID is = {}", objCommon.getTransactionID());

        try {
            // 通过设备ID查询Stocker, 以判断是否操作的Storage设备
            stockerMethod.stockerTypeGetDR(objCommon, equipmentID);
            objectLockMethod.objectLock(objCommon, CimStorageMachine.class, equipmentID);
        } catch (Exception e) {
            Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
            objLockModeIn.setObjectID(equipmentID);
            objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            objLockModeIn.setFunctionCategory(TransactionIDEnum.EQP_STATUS_CHANGE_REQ.getValue());
            objLockModeIn.setUserDataUpdateFlag(false);
            Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
            if (!BizConstant.SP_EQP_LOCK_MODE_WRITE.equals(objLockModeOut.getLockMode())) {
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT,
                        objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            } else {
                objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
            }
        }

        Infos.EqpStatusInfo eqpStatusInfo;
        try {
            eqpStatusInfo = equipmentMethod.equipmentStatusInfoGet(objCommon, equipmentID);
        } catch (ServiceException e) {
            // RetCode as notFoundEqp indicates the equipment is a stocker not an error
            if (Validations.isEquals(retCodeConfig.getNotFoundEqp(), e.getCode())) {
                eqpStatusInfo = new Infos.EqpStatusInfo();
                eqpStatusInfo.setStorageBool(true);
                eqpStatusInfo.setEquipmentStatusCode(ObjectIdentifier.emptyIdentifier());
            } else {
                throw e;
            }
        }

        seasonMethod.createSeasonJobForPM(objCommon, equipmentID, eqpToState, eqpStatusInfo, claimMemo);

        // get environment value with OM_EQP_STATUS_BACKUP,
        // this environment indicate whether need to backup eqp status before change.
        // if OM_EQP_STATUS_BACKUP = 1 ; then need to backup ; else don't neet to backup.
        String envEqpStatBackup = StandardProperties.OM_EQP_STATUS_BACKUP.getValue();
        if (CimStringUtils.equals(envEqpStatBackup, "1")) {
            // If OpeStart, backup the previous eqp status:
            // strEquipment_statusInfo_GetDR_out.equipmentStatusInfo.E10Status
            if (CimStringUtils.equalsIn(objCommon.getTransactionID(),
                    TransactionIDEnum.OPERATION_START_REQ.getValue(),
                    TransactionIDEnum.OPERATION_START_FOR_INTERNAL_BUFFER_REQ.getValue())) {
                // Get inProcessingControlJob to check if I am the first controlJob
                // Here using DR method to select existing controlJob only (not include myself)
                List<Infos.EqpInprocessingControlJob> inprocessingControlJobs =
                        equipmentMethod.equipmentInprocessingControlJobInfoGetDR(objCommon, equipmentID);
                if (CimArrayUtils.isEmpty(inprocessingControlJobs)) {
                    equipmentMethod.equipmentBackupStateUpdate(objCommon, equipmentID,
                            eqpStatusInfo.getEquipmentStatusCode());
                }
            }
        }

        ObjectIdentifier backupEqpStatus = ObjectIdentifier.emptyIdentifier();
        // If opeComp or opeStartCancel, switch in-process equipmentStatusCode to back eqp status
        if (CimStringUtils.equalsIn(objCommon.getTransactionID(),
                TransactionIDEnum.OPERATION_COMP_WITH_DATA_REQ.getValue(),
                TransactionIDEnum.OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(),
                TransactionIDEnum.FORCE_OPERATION_COMP_REQ.getValue(),
                TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue(),
                TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(),
                TransactionIDEnum.FORCE_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(),
                TransactionIDEnum.OPERATION_START_CANCEL_REQ.getValue(),
                TransactionIDEnum.OPERATION_START_CANCEL_FOR_INTERNAL_BUFFER_REQ.getValue())) {
            // Get inProcessingControlJob to check if I am the last controlJob;
            // Here using DR method to select existing controlJob only (not include myself)
            List<Infos.EqpInprocessingControlJob> inprocessingControlJobs =
                    equipmentMethod.equipmentInprocessingControlJobInfoGetDR(objCommon, equipmentID);
            if (CimArrayUtils.getSize(inprocessingControlJobs) == 1) {
                Infos.EqpBackupState eqpBackupState = equipmentMethod.equipmentBackupStateGet(objCommon, equipmentID);
                backupEqpStatus = eqpBackupState.getBackupEquipmentStatus();
            }
        }

        // Start to convert state
        // 根据配置规则找到将要切换的目标E10子状态
        Outputs.ObjEquipmentStateConvertOut convertOut;
        if (CimStringUtils.equals(envEqpStatBackup, "1")
                && ObjectIdentifier.isNotEmptyWithValue(backupEqpStatus)) {
            // Convert to backupState
            convertOut = equipmentMethod.equipmentStateConvertV2(equipmentID, backupEqpStatus);
        } else {
            // Convert to eqpToState
            convertOut = equipmentMethod.equipmentStateConvertV2(equipmentID, eqpToState);
        }

        // Check input-eqp-status vs. allowed-new-status by Current mode
        try {
            equipmentMethod.equipmentCurrentStateCheckTransitionV2(objCommon, equipmentID,
                    convertOut.getConvertedStatusCode(), false);
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())) {
                throw e;
            }
        }

        // exec eqp status change
        Outputs.ObjEquipmentCurrentStateChangeOut result = equipmentMethod.equipmentCurrentStateChange(objCommon,
                equipmentID, convertOut.getConvertedStatusCode());

        ObjectIdentifier dummy = ObjectIdentifier.emptyIdentifier();
        if (ObjectIdentifier.isNotEmptyWithValue(backupEqpStatus)) {
            // exec eqp backupState update
            equipmentMethod.equipmentBackupStateUpdate(objCommon, equipmentID, dummy);
        }

        // Create eqp status change event
        Inputs.EquipmentStatusChangeEventMakeParams eventParam = new Inputs.EquipmentStatusChangeEventMakeParams();
        eventParam.setTransactionID(TransactionIDEnum.EQP_STATUS_CHANGE_REQ.getValue());
        eventParam.setNewEquipmentStatus(convertOut.getConvertedStatusCode());
        eventParam.setNewE10Status(result.getE10Status());
        eventParam.setNewActualStatus(result.getActualStatus());
        eventParam.setNewActualE10Status(result.getActualE10Status());
        eventParam.setNewOperationMode(result.getOperationMode());
        eventParam.setPreviousStatus(result.getPreviousStatus());
        eventParam.setPreviousE10Status(result.getPreviousE10Status());
        eventParam.setPreviousActualStatus(result.getPreviousActualStatus());
        eventParam.setPreviousActualE10Status(result.getPreviousActualE10Status());
        eventParam.setPreviousOpeMode(result.getPreviousOpeMode());
        eventParam.setPrevStateStartTime(result.getPrevStateStartTime());
        eventParam.setReasonCodeID(ObjectIdentifier.isEmptyWithValue(reasonCodeID) ? ObjectIdentifier.emptyIdentifier()
                : reasonCodeID);
        eventParam.setClaimMemo(claimMemo);
        if (eqpStatusInfo.isStorageBool()) {
            eventParam.setEquipmentID(dummy);
            eventParam.setStockerID(equipmentID);
            eventMethod.equipmentStatusChangeEventMake(objCommon, eventParam);
        } else {
            eventParam.setEquipmentID(equipmentID);
            eventParam.setStockerID(dummy);
            eventMethod.equipmentStatusChangeEventMake(objCommon, eventParam);
        }

        Results.EqpStatusChangeReqResult out = new Results.EqpStatusChangeReqResult();
        out.setEquipmentID(result.getEquipmentID());
        out.setEquipmentStatusCode(result.getEquipmentStatusCode());
        return out;
    }

    @Override
    public Results.EqpStatusChangeRptResult sxEqpStatusChangeRpt(Infos.ObjCommon objCommon,
                                                                 Params.EqpStatusChangeRptParams rptParams) {
        Results.EqpStatusChangeRptResult out = new Results.EqpStatusChangeRptResult();

        if (log.isDebugEnabled())
            log.debug("step1 - get lock mode for equipment 【{}】",rptParams.getEquipmentID());
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(rptParams.getEquipmentID());
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.EQP_STATUS_CHANGE_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        if (log.isTraceEnabled())
            log.trace("lockMode is 【{}】",lockMode);
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            if (log.isDebugEnabled())
                log.debug("step2 - Lock Equipment Main Object");
            List<String> dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(rptParams.getEquipmentID());
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);
            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            if (log.isDebugEnabled())
                log.debug("step3 - lock object equipment");
            objectLockMethod.objectLock(objCommon, CimMachine.class, rptParams.getEquipmentID());
        }

        if (log.isDebugEnabled())
            log.debug("step4 - Get PosMachine's eqp mode");
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, rptParams.getEquipmentID());
        if (CimArrayUtils.isEmpty(eqpPortInfo.getEqpPortStatuses())) {
            throw new ServiceException(retCodeConfig.getNotFoundPort());
        }
        if (log.isTraceEnabled())
            log.trace("OnlineMode is 【{}】",eqpPortInfo.getEqpPortStatuses().get(0).getOnlineMode());
        if (BizConstant.SP_EQP_ONLINEMODE_OFFLINE.equals(eqpPortInfo.getEqpPortStatuses().get(0).getOnlineMode())) {
            throw new ServiceException(retCodeConfig.getInvalidFromEqpMode());
        }
        if (log.isDebugEnabled())
            log.debug("step5 - Translate RawEqpState if defined  DCR 9900001");
        Outputs.ObjRawEquipmentStateTranslateOut translateOut = equipmentMethod
                .rawEquipmentStateTranslate(objCommon, rptParams.getEquipmentID(), rptParams.getEquipmentStatusCode());

        if (log.isDebugEnabled())
            log.debug("step6 - Convert eqp Status DCR 9900001");
        Outputs.ObjEquipmentStateConvertOut convertOut = equipmentMethod
                .equipmentStateConvertV2(rptParams.getEquipmentID(), translateOut.getEquipmentStatusCode());

        if (log.isDebugEnabled())
            log.debug("step7 - Check input-eqp-status vs. allowed-new-staus by Current mode");
        boolean updateCurrentStateFlag = false;
        try {
            equipmentMethod.equipmentCurrentStateCheckTransitionV2(objCommon, rptParams.getEquipmentID(),
                    convertOut.getConvertedStatusCode(), true);
            updateCurrentStateFlag = true;
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())
                    && Validations.isEquals(retCodeConfig.getInvalidStateTransition(), e.getCode())) {
                throw e;
            }
        }
        if (log.isDebugEnabled())
            log.debug("step8 - Change eqp status by Input data");
        Outputs.ObjEquipmentCurrentStateChangeByAutoOut result = equipmentMethod
                .equipmentCurrentStateChangeByAuto(objCommon, rptParams.getEquipmentID(),
                        translateOut.getEquipmentStatusCode(), convertOut.getConvertedStatusCode(),
                        updateCurrentStateFlag);

        if (log.isDebugEnabled())
            log.debug("setp9 - Create eqp Status Change Event");
        if (result.getGenHistory()) {
            Inputs.EquipmentStatusChangeEventMakeParams params = new Inputs.EquipmentStatusChangeEventMakeParams();
            params.setTransactionID(TransactionIDEnum.EQP_STATUS_CHANGE_RPT.getValue());
            params.setEquipmentID(rptParams.getEquipmentID());
            params.setStockerID(new ObjectIdentifier());
            params.setNewActualStatus(result.getActualStatus());
            params.setNewActualE10Status(result.getActualE10Status());
            params.setNewOperationMode(result.getOperationMode());
            params.setPreviousStatus(result.getPreviousStatus());
            params.setPreviousE10Status(result.getPreviousE10Status());
            params.setPreviousActualStatus(result.getPreviousActualStatus());
            params.setPreviousActualE10Status(result.getPreviousActualE10Status());
            params.setPreviousOpeMode(result.getPreviousOpeMode());
            params.setPrevStateStartTime(result.getPrevStateStartTime());
            params.setClaimMemo(rptParams.getOpeMemo());
            if (log.isTraceEnabled())
                log.trace("updateCurrentStateFlag is 【{}】",updateCurrentStateFlag);
            if (updateCurrentStateFlag) {
                params.setNewEquipmentStatus(convertOut.getConvertedStatusCode());
                params.setNewE10Status(result.getE10Status());
                eventMethod.equipmentStatusChangeEventMake(objCommon, params);
            } else {
                params.setNewEquipmentStatus(result.getPreviousStatus());
                params.setNewE10Status(result.getPreviousE10Status());
                eventMethod.equipmentStatusChangeEventMake(objCommon, params);
            }
        }
        out.setEquipmentID(rptParams.getEquipmentID());
        out.setTranslatedStatusCode(translateOut.getEquipmentStatusCode());
        out.setTranslatedStatusName(translateOut.getEquipmentStatusName());
        out.setTranslatedE10Status(translateOut.getE10Status());
        return out;
    }

    @Override
    public Results.EqpStatusResetReqResult sxEqpStatusResetReq(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID,
                                                               String changeType, String claimMemo) {
        Results.EqpStatusResetReqResult eqpStatusResetReqResult = new Results.EqpStatusResetReqResult();

        log.debug("setp1 - get equipment port info");
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID);
        List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo.getEqpPortStatuses();
        log.trace("eqpPortStatuses is 【{}】",eqpPortStatuses);
        if (CimArrayUtils.isEmpty(eqpPortStatuses)) {
            throw new ServiceException(retCodeConfig.getNotFoundPort());
        }
        log.trace("OnlineMode is 【{}】",eqpPortStatuses.get(0).getOnlineMode());
        if (!CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, eqpPortStatuses.get(0).getOnlineMode())) {
            Validations.check(retCodeConfig.getInvalidEquipmentMode(), ObjectIdentifier.fetchValue(equipmentID),
                    eqpPortStatuses.get(0).getOnlineMode());
        }

        log.debug("step2 - call recover function by required change type");
        ObjectIdentifier recoverStateResult;
        if (BizConstant.SP_EQPSTATUSRECOVERTYPE_MANUFACTURING.equals(changeType)) {
            recoverStateResult = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, equipmentID);
        } else {
            throw new ServiceException(retCodeConfig.getInvalidRecoverStateType());
        }

        log.debug("step3 - Convert eqp Status");
        Outputs.ObjEquipmentStateConvertOut convertOut = equipmentMethod.equipmentStateConvertV2(equipmentID,
                recoverStateResult);

        log.debug("step4 - Check input-eqp-status vs. allowed-new-staus by Current mode");
        equipmentMethod.equipmentCurrentStateCheckTransitionV2(objCommon, equipmentID,
                convertOut.getConvertedStatusCode(), false);

        log.debug("step5 - Change eqp status by Input data");
        Outputs.ObjEquipmentCurrentStateChangeOut stateChangeOutRetCode = equipmentMethod.equipmentCurrentStateChange(
                objCommon, equipmentID, convertOut.getConvertedStatusCode());

        log.debug("step6 - add equipment status change event");
        Inputs.EquipmentStatusChangeEventMakeParams params = new Inputs.EquipmentStatusChangeEventMakeParams();
        params.setTransactionID(TransactionIDEnum.EQP_STATUS_RECOVER_REQ.getValue());
        params.setEquipmentID(equipmentID);
        params.setStockerID(new ObjectIdentifier());
        params.setNewEquipmentStatus(convertOut.getConvertedStatusCode());
        params.setNewE10Status(stateChangeOutRetCode.getE10Status());
        params.setNewActualStatus(stateChangeOutRetCode.getActualStatus());
        params.setNewActualE10Status(stateChangeOutRetCode.getActualE10Status());
        params.setNewOperationMode(stateChangeOutRetCode.getOperationMode());
        params.setPreviousStatus(stateChangeOutRetCode.getPreviousStatus());
        params.setPreviousE10Status(stateChangeOutRetCode.getPreviousE10Status());
        params.setPreviousActualStatus(stateChangeOutRetCode.getPreviousActualStatus());
        params.setPreviousActualE10Status(stateChangeOutRetCode.getPreviousActualE10Status());
        params.setPreviousOpeMode(stateChangeOutRetCode.getPreviousOpeMode());
        params.setPrevStateStartTime(stateChangeOutRetCode.getPrevStateStartTime());
        params.setClaimMemo(claimMemo);
        eventMethod.equipmentStatusChangeEventMake(objCommon, params);

        eqpStatusResetReqResult.setEquipmentID(equipmentID);
        eqpStatusResetReqResult.setEquipmentE10Status(stateChangeOutRetCode.getE10Status());
        eqpStatusResetReqResult.setEquipmentStatusCode(stateChangeOutRetCode.getEquipmentStatusCode());

        return eqpStatusResetReqResult;
    }

    @Override
    public ObjectIdentifier sxEqpUsageCountResetReq(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, String claimMemo) {
        log.debug("step1 - get lock mode for equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.EQP_USAGE_COUNT_RESET_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step2 - Lock Equipment Main Object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);
            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            log.debug("step3 - lock object equipment");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        log.debug("step4 - Reset eqp usage information");
        equipmentMethod.equipmentUsageInfoReset(objCommon, equipmentID);

        // seasoning 相关代码
//        seasoningService.seasonJobCreateForPM(objCommon,equipmentID,claimMemo);

        return equipmentID;
    }

    @Override
    public List<Infos.LoadingVerifiedLot> sxCarrierLoadingRpt(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier cassetteID, ObjectIdentifier portID, String lotPurposeType) {
        log.debug("sxCarrierLoadingRpt(): enter sxCarrierLoadingRpt");

        // 适配sorter EAP
        if (CimStringUtils.isEmpty(lotPurposeType)){
            String objMachineTypeGetOut = equipmentMethod.equipmentCategoryGet(objCommon, equipmentID);
            if (CimStringUtils.equals(objMachineTypeGetOut,BizConstant.SP_MC_CATEGORY_WAFERSORTER)){
                try {
                    cassetteMethod.cassetteCheckEmpty(cassetteID);
                    lotPurposeType=BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE;
                }catch (ServiceException ex){
                    if (Validations.isEquals(ex.getCode(),retCodeConfig.getCastNotEmpty())){
                        lotPurposeType=BizConstant.SP_LOADPURPOSETYPE_OTHER;
                    }
                }
            }
        }

        Validations.check(CimStringUtils.isEmpty(equipmentID.getValue()), "equipmentID is empty");
        Validations.check(CimStringUtils.isEmpty(cassetteID.getValue()), "cassetteID is empty");
        Validations.check(CimStringUtils.isEmpty(portID.getValue()), "portID is empty");
        Validations.check(CimStringUtils.isEmpty(lotPurposeType), "lotPurposeType is empty");

        log.debug("step1 - get lock mode for equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.LOADING_LOT_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step2 - lock equipment main object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);
            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            log.debug("step3 - Lock objects to be updated");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        // add season by ho
//        Validations.check(seasonMethod.checkSeasonForLoading(objCommon, equipmentID,cassetteID),retCodeConfigEx.getSeasonRequired());

        List<Infos.LoadingVerifiedLot> loadingVerifiedLots = null;

        log.debug("step4 - Get All port Objects belong to a input port's PortGrp");
        Infos.EqpPortInfo allPortsInSameGroupListResult = portMethod.portResourceAllPortsInSameGroupGet(objCommon, equipmentID, portID);
        List<Infos.EqpPortStatus> allPortsInSameGroupList = allPortsInSameGroupListResult.getEqpPortStatuses();
        /*---------------------------------------------------------*/
        /* Lock All Ports being in the same Port Group as ToPort   */
        /*---------------------------------------------------------*/
        int lenToPort = CimArrayUtils.getSize(allPortsInSameGroupList);
        for (int i = 0; i < lenToPort; i++) {
            log.debug("step5 - lock equipment resource");
            objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, allPortsInSameGroupList.get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
        }
        log.debug("step6 - Lock objects to be updated ");
        objectLockMethod.objectLock(objCommon, CimCassette.class, cassetteID);
        log.trace("lotPurposeType is 【{}】",lotPurposeType);
        if (CimStringUtils.equals(lotPurposeType, BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING)) {
            /*-----------------------------------------------*/
            /*                                               */
            /*   Equipment Container Position Lock Process   */
            /*                                               */
            /*-----------------------------------------------*/

            log.debug("step7 - lock equipment container position");
            Inputs.ObjObjectLockForEquipmentContainerPositionIn objObjectLockForEquipmentContainerPositionIn = new Inputs.ObjObjectLockForEquipmentContainerPositionIn();
            objObjectLockForEquipmentContainerPositionIn.setDestCassetteID(cassetteID);
            objObjectLockForEquipmentContainerPositionIn.setEquipmentID(equipmentID);
            objectLockMethod.objectLockForEquipmentContainerPosition(objCommon, objObjectLockForEquipmentContainerPositionIn);
        }

        log.debug("step8 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        log.debug("step9 - Check Process for WaferSorter");
        ObjectIdentifier durableDurableControlJobIDGet = durableMethod.durableDurableControlJobIDGet(objCommon, cassetteID, BizConstant.SP_DURABLECAT_CASSETTE);
        if (!ObjectIdentifier.isEmpty(durableDurableControlJobIDGet) && !CimStringUtils.isEmpty(durableDurableControlJobIDGet.getValue())) {
            Validations.check(!CimStringUtils.equals(lotPurposeType, BizConstant.SP_LOADPURPOSETYPE_OTHER),
                    new OmCode(retCodeConfig.getInvalidPurposeTypeForProcessdurable(), lotPurposeType));
        }

        log.debug("step10 - get equipment brInfo");
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentID);
        String strEquipmentCategory = eqpBrInfo.getEquipmentCategory();
        //--------------------------
        // Equipmet is Not Sorter Or
        //--------------------------
        if (!CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERSORTER, strEquipmentCategory)
                && !CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_OTHER, lotPurposeType)) {
            log.debug("step11 - Check Scrap wafer Exsit In Carrier");
            List<Infos.LotWaferMap> lotWaferMaps = cassetteMethod.cassetteScrapWaferSelectDR(objCommon, Arrays.asList(cassetteID));
            int scrapCount = CimArrayUtils.getSize(lotWaferMaps);
            Validations.check(scrapCount > 0, retCodeConfig.getFoundScrap());
        }
        log.debug("step12 - verify loading carrier");
        boolean forceLoaded = false;
        Params.CarrierLoadingVerifyReqParams verifyForLoadingReqParams = new Params.CarrierLoadingVerifyReqParams();
        verifyForLoadingReqParams.setEquipmentId(equipmentID);
        verifyForLoadingReqParams.setCassetteId(cassetteID);
        verifyForLoadingReqParams.setLoadPurposeType(lotPurposeType);
        verifyForLoadingReqParams.setPortId(portID);
        Results.CarrierLoadingVerifyReqResult lotVerifyForLoadingResult = null;
        try {
            lotVerifyForLoadingResult = this.sxCarrierLoadingVerifyReq(objCommon, verifyForLoadingReqParams);
            loadingVerifiedLots = lotVerifyForLoadingResult.getLoadingVerifiedLots();
        } catch (ServiceException ex) {
            loadingVerifiedLots = ex.getData(List.class);
            int rcVerifyedRetCode = ex.getCode();

            log.debug("step13 - loadedLotVerifiedInfoCheckConditionForForceLoad");
            try {
                lotMethod.loadedLotVerifiedInfoCheckConditionForForceLoad(objCommon, rcVerifyedRetCode, loadingVerifiedLots, equipmentID, cassetteID, portID, lotPurposeType);
                throw ex;
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getCastForceLoaded(), e.getCode())) {
                    loadingVerifiedLots = e.getData(List.class);

                    log.debug("step14 - call loadedLotVerifiedInfoChangeForForceLoad");
                    lotMethod.loadedLotVerifiedInfoChangeForForceLoad(objCommon, equipmentID, cassetteID, portID, lotPurposeType, loadingVerifiedLots);
                    forceLoaded = true;
                } else {
                    throw e;
                }
            }
        }

        log.debug("step15 - check move in lot's carrier requirement");
        if (CimStringUtils.equals(lotPurposeType,BizConstant.SP_LOADPURPOSETYPE_OTHER)
        || CimStringUtils.equals(lotPurposeType,BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)){
            if (CimArrayUtils.isNotEmpty(loadingVerifiedLots)){
                for(Infos.LoadingVerifiedLot loadingVerifiedLot : loadingVerifiedLots){
                    if (loadingVerifiedLot.getMoveInFlag()){
                        contaminationMethod.carrierCategoryCheckAmongLotAndCarrier(cassetteID,loadingVerifiedLot.getLotID());
                    }
                }
            }
        }

        log.debug("step16 - Add to load lot in equipment");
        equipmentMethod.equipmentLoadLotAdd(objCommon, equipmentID, cassetteID, portID, lotPurposeType, loadingVerifiedLots);
        //----------------------------------------------------//
        //   Clear Cassette's DispatchState for NPW Loading   //
        //   - Usually, this cassette's dispatchState is      //
        //     changed to FALSE when OpeStart, but NPW        //
        //     cassettes are never started, so this timing    //
        //     is the best to clear it.                       //
        //----------------------------------------------------//
        List<String> lotPurposeTypeConditions = CimArrayUtils.generateList(
                BizConstant.SP_LOADPURPOSETYPE_OTHER,
                BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE,
                BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY,
                BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT,
                BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING,
                BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT);
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID);
        List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo == null ? null : eqpPortInfo.getEqpPortStatuses();
        int portLen = CimArrayUtils.getSize(eqpPortStatuses);
        if (ObjectIdentifier.isEmptyWithValue(durableDurableControlJobIDGet) && lotPurposeTypeConditions.contains(lotPurposeType)) {
            //Get port's LoadPurposeType
            for (int i = 0; i < portLen; i++) {
                Infos.EqpPortStatus eqpPortStatus = eqpPortStatuses.get(i);
                if (ObjectIdentifier.equalsWithValue(eqpPortStatus.getPortID(), portID)) {
                    List<String> conditions = CimArrayUtils.generateList(
                            BizConstant.SP_LOADPURPOSETYPE_OTHER,
                            BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY,
                            BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT,
                            BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT);
                    if (conditions.contains(eqpPortStatus.getLoadPurposeType()) || CimStringUtils.equals(lotPurposeType, BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING)) {
                        log.debug("step17 - Change cassette's dispatch State to FALSE");
                        cassetteMethod.cassetteDispatchStateChange(objCommon, cassetteID, false);

                        log.debug("step18 - change clear to Dispatched Load CassetteID");
                        equipmentMethod.equipmentDispatchStateChange(objCommon, equipmentID, portID,
                                BizConstant.SP_PORTRSC_DISPATCHSTATE_NOTDISPATCHED, null, null, null, null);

                        log.debug("step19 - Change cassette's NPWLoadPurposeType to NULL");
                        cassetteMethod.cassetteSetNPWLoadPurposeType(objCommon, cassetteID, null);
                    }
                    if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING, lotPurposeType)) {
                        log.debug("step20 - equipmentContainerPositionInfoUpdateForLoading");
                        equipmentMethod.equipmentContainerPositionInfoUpdateForLoading(objCommon, equipmentID, null, cassetteID, portID);
                    }
                    break;
                }
            }
        } else {
            for (int x = 0; x < portLen; x++) {
                Infos.EqpPortStatus eqpPortStatus = eqpPortStatuses.get(x);
                if (ObjectIdentifier.equalsWithValue(eqpPortStatus.getPortID(), portID)
                        && CimStringUtils.equals(eqpPortStatus.getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                    log.debug("step21 - change clear to Dispatched Load CassetteID");
                    equipmentMethod.equipmentDispatchStateChange(objCommon, equipmentID, portID, BizConstant.SP_PORTRSC_DISPATCHSTATE_NOTDISPATCHED,
                            null, null, null, null);
                    break;
                }
            }
        }
        log.debug("step22 - change status carrier transfer");
        Params.CarrierTransferStatusChangeRptParams carrierTransferStatusChangeRptParams = new Params.CarrierTransferStatusChangeRptParams();
        carrierTransferStatusChangeRptParams.setCarrierID(cassetteID);
        carrierTransferStatusChangeRptParams.setXferStatus(BizConstant.SP_TRANSSTATE_EQUIPMENTIN);
        carrierTransferStatusChangeRptParams.setManualInFlag(false);
        carrierTransferStatusChangeRptParams.setMachineID(equipmentID);
        carrierTransferStatusChangeRptParams.setPortID(portID);
        carrierTransferStatusChangeRptParams.setTransferStatusChangeTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        transferManagementSystemService.sxCarrierTransferStatusChangeRpt(objCommon, carrierTransferStatusChangeRptParams);
        log.trace("forceLoaded is 【{}】",forceLoaded);
        if (forceLoaded) {
            log.debug("sxCarrierLoadingRpt(): cassette force loaded");
            throw new ServiceException(retCodeConfig.getCastForceLoaded());
        }
        return loadingVerifiedLots;
    }

    @Override
    public Results.CarrierLoadingVerifyReqResult sxCarrierLoadingVerifyReq(Infos.ObjCommon objCommon, Params.CarrierLoadingVerifyReqParams carrierLoadingVerifyReqParams) {
        Results.CarrierLoadingVerifyReqResult carrierLoadingVerifyReqResult = new Results.CarrierLoadingVerifyReqResult();
        ObjectIdentifier portId = ObjectIdentifier.isEmpty(carrierLoadingVerifyReqParams.getPortId()) ? null : carrierLoadingVerifyReqParams.getPortId();
        ObjectIdentifier cassetteId = ObjectIdentifier.isEmpty(carrierLoadingVerifyReqParams.getCassetteId()) ? null : carrierLoadingVerifyReqParams.getCassetteId();
        ObjectIdentifier equipmentId = ObjectIdentifier.isEmpty(carrierLoadingVerifyReqParams.getEquipmentId()) ? null : carrierLoadingVerifyReqParams.getEquipmentId();
        String loadPurposeType = carrierLoadingVerifyReqParams.getLoadPurposeType();

        log.debug("step1 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentId);

        ObjectIdentifier objDurableControlJobIdGetOut = ObjectIdentifier.build(null, null);
        if (!SorterHandler.containsFOSB(cassetteId)) {
            objDurableControlJobIdGetOut = durableMethod.durableDurableControlJobIDGet(objCommon, cassetteId,
                    BizConstant.SP_DURABLECAT_CASSETTE);
        }
        if (!ObjectIdentifier.isEmptyWithValue(objDurableControlJobIdGetOut)) {
            Validations.check(!CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_OTHER),
                    new OmCode(retCodeConfig.getInvalidPurposeTypeForProcessdurable(), loadPurposeType));
        }

        log.debug("step3 - Check Scrap wafer Exist In Carrier (Except loadPurposeType=Other carrier)");
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (!CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_OTHER)) {
            List<ObjectIdentifier> cassetteIDList = new ArrayList<>();
            cassetteIDList.add(cassetteId);
            List<Infos.LotWaferMap> lotWaferMaps = cassetteMethod.cassetteScrapWaferSelectDR(objCommon, cassetteIDList);
            int scrapCount = CimArrayUtils.getSize(lotWaferMaps);
            Validations.check(scrapCount > 0, retCodeConfig.getFoundScrap());
        }
        //Check Process For Empty cassette
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
            log.debug("step4 - Check cassette is Empty or Not");
            cassetteMethod.cassetteCheckEmpty(cassetteId);

            log.debug("step5 - Check cassette Condition for Loading");
            /**
             * Check cassette Condition for Loading
             * The following conditions are checked for Loading.
             * - controlJobID
             * - multiLotType
             * - transferState
             * - cassetteState
             */
            cassetteMethod.cassetteCheckConditionForLoading(objCommon, equipmentId, portId, cassetteId);

            log.debug("step6 - Check eqp and port Condition for Loading");
            /**
             * Check cassette Condition for Loading
             * The following conditions are checked for Loading.
             * - controlJobID
             * - loadPort's reservedControlJob VS cassette's one
             * - loading sequence
             * - loadPort's portUsage (Input or InOut)
             * - loadPurposeType
             * - portState
             */
            equipmentMethod.equipmenCheckConditionForLoading(objCommon, equipmentId, portId, cassetteId, loadPurposeType);

            log.debug("step7 - Check Category for process contamination control");
            /**
             * Check Category for process contamination control (Copper/Non Copper)
             * It is checked in the following method whether it is the condition
             * that lot of the object is made of OpeStart.
             *
             * 1. It is checked whether the CassetteCategory of PosCassette and
             * the CassetteCategoryCapability of PosPortResource are the same.
             *
             * 2. It is proper condition if CassetteCategoryCapability is the same
             * as RequiredCassetteCategory and CassetteCategory.
             */
            lotMethod.lotCassetteCategoryCheckForContaminationControl(objCommon, null, cassetteId, equipmentId, portId);

            log.debug("step8 - check equipment avail");
            equipmentMethod.equipmentCheckAvail(objCommon, equipmentId);
            /*--------------------------------------------*/
            /*                                            */
            /*   Return to Caller (Empty Cassette case)   */
            /*                                            */
            /*--------------------------------------------*/
            return carrierLoadingVerifyReqResult;
        }
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_OTHER)) {
            log.debug("step9 - get equipment brInfo");
            Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentId);
            List<String> specialControls = eqpBrInfo.getSpecialControl();
            int spcCtlLen = CimArrayUtils.getSize(specialControls);
            for (int i = 0; i < spcCtlLen; i++) {
                String specialControl = specialControls.get(i);
                log.trace("specialControl is 【{}】",specialControl);
                if (CimStringUtils.equals(BizConstant.SP_MC_SPECIALEQUIPMENTCONTROL_DURABLECARRIER, specialControl)
                        || CimStringUtils.equals(BizConstant.SP_MC_SPECIALEQUIPMENTCONTROL_DURABLERETICLE, specialControl)
                        || CimStringUtils.equals(BizConstant.SP_MC_SPECIALEQUIPMENTCONTROL_DURABLERETICLEPOD, specialControl)) {
                    log.debug("step10 - Check condition for durable");
                    List<Infos.StartDurable> startDurables = new ArrayList<>();
                    Infos.StartDurable startDurable = new Infos.StartDurable();
                    startDurable.setDurableId(cassetteId);
                    startDurables.add(startDurable);
                    Inputs.ObjDurableCheckConditionForOperationIn in = new Inputs.ObjDurableCheckConditionForOperationIn();
                    in.setOperation(BizConstant.SP_OPERATION_LOADING);
                    in.setEquipmentId(equipmentId);
                    in.setDurableCategory(BizConstant.SP_DURABLECAT_CASSETTE);
                    in.setStartDurables(startDurables);
                    durableMethod.durableCheckConditionForOperation(objCommon, in);

                    log.debug("step11 - check durable status");
                    durableMethod.durableStatusCheckForOperation(objCommon, BizConstant.SP_OPERATION_LOADING, cassetteId, BizConstant.SP_DURABLECAT_CASSETTE);

                    log.debug("step12 - get equipment port group id");
                    Inputs.ObjEquipmentPortGroupIDGetIn objEquipmentPortGroupIDGetIn = new Inputs.ObjEquipmentPortGroupIDGetIn();
                    objEquipmentPortGroupIDGetIn.setEquipmentId(equipmentId);
                    objEquipmentPortGroupIDGetIn.setPortId(portId);
                    Outputs.ObjEquipmentPortGroupIDGetOut strEquipmentPortGroupIDGetOut = portMethod.equipmentPortGroupIDGet(objCommon, objEquipmentPortGroupIDGetIn);
                    Inputs.ObjEquipmentAndPortStateCheckForDurableOperationIn objEquipmentAndPortStateCheckForDurableOperationIn = new Inputs.ObjEquipmentAndPortStateCheckForDurableOperationIn();
                    objEquipmentAndPortStateCheckForDurableOperationIn.setOperation(BizConstant.SP_OPERATION_LOADING);
                    objEquipmentAndPortStateCheckForDurableOperationIn.setEquipmentId(equipmentId);
                    objEquipmentAndPortStateCheckForDurableOperationIn.setPortGroupId(strEquipmentPortGroupIDGetOut.getPortGroupId());
                    objEquipmentAndPortStateCheckForDurableOperationIn.setDurableCategory(BizConstant.SP_DURABLECAT_CASSETTE);
                    List<Infos.StartDurable> startDurableList = new ArrayList<>();
                    Infos.StartDurable tmpStartDurable = new Infos.StartDurable();
                    tmpStartDurable.setDurableId(cassetteId);
                    Infos.StartDurablePort startDurablePort = new Infos.StartDurablePort();
                    startDurablePort.setLoadPortID(portId);
                    startDurablePort.setLoadPurposeType(loadPurposeType);
                    tmpStartDurable.setStartDurablePort(startDurablePort);
                    startDurableList.add(tmpStartDurable);
                    objEquipmentAndPortStateCheckForDurableOperationIn.setStartDurables(startDurableList);

                    log.debug("step13 - equipmentAndPortStateCheckForDurableOperation");
                    equipmentMethod.equipmentAndPortStateCheckForDurableOperation(objCommon, objEquipmentAndPortStateCheckForDurableOperationIn);

                    log.debug("step14 - durableCassetteCategoryCheckForContaminationControl");
                    durableMethod.durableCassetteCategoryCheckForContaminationControl(objCommon, cassetteId, equipmentId, portId);

                    log.debug("step15 - equipmentCheckAvail");
                    equipmentMethod.equipmentCheckAvail(objCommon, equipmentId);
                    return carrierLoadingVerifyReqResult;
                }
            }
        }
        /*----------------------------------------------------------------------*/
        /*                          Check Process For lot                       */
        /*----------------------------------------------------------------------*/
        Infos.StartCassette startCassette = new Infos.StartCassette();
        startCassette.setCassetteID(cassetteId);
        startCassette.setLoadPurposeType(loadPurposeType);
        startCassette.setLoadPortID(portId);
        startCassette.setLoadSequenceNumber(0L);

        log.debug("step16 - Get cassette's ControlJobID");
        /*----------------------------------------------------------------------*/
        /* FOSB跳过验证
        /*----------------------------------------------------------------------*/
        ObjectIdentifier controlJobID = ObjectIdentifier.build(null, null);
        if (!SorterHandler.containsFOSB(cassetteId)) {
            controlJobID = cassetteMethod.cassetteControlJobIDGet(objCommon, cassetteId);

        }
        int lotLength = 0;
        if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            log.debug("step17 - Get Contained lot in cassette");
            Infos.LotListInCassetteInfo objCassetteGetLotListOut = null;
            try {
                objCassetteGetLotListOut = cassetteMethod.cassetteGetLotList(objCommon, cassetteId);
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getNotFoundLot(), e.getCode()) && CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING)) {
                    log.trace("rc == RC_NOT_FOUND_LOT && loadPurposeType = SLMRetrieving");
                } else {
                    e.setData(carrierLoadingVerifyReqResult.getLoadingVerifiedLots());
                    throw e;
                }
            }
            lotLength = 0;
            List<ObjectIdentifier> lotIds = new ArrayList<>();
            if (!CimObjectUtils.isEmpty(objCassetteGetLotListOut)) {
                lotIds = objCassetteGetLotListOut.getLotIDList();
                lotLength = CimArrayUtils.getSize(lotIds);
            }
            List<Infos.LotInCassette> lotInCassettes = new ArrayList<>();
            startCassette.setLotInCassetteList(lotInCassettes);
            for (int i = 0; i < lotLength; i++) {
                Infos.LotInCassette lotInCassette = new Infos.LotInCassette();
                lotInCassette.setMoveInFlag(!CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING));
                lotInCassette.setLotID(lotIds.get(i));
                log.trace("loadPurposeType is 【{}】",loadPurposeType);
                if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT)) {
                    log.debug("step18 - Get lot Type");
                    String lotType = lotMethod.lotTypeGet(objCommon, lotIds.get(i));
                    log.trace("lotType is 【{}】",lotType);
                    if (CimStringUtils.equals(lotType, BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)) {
                        lotInCassette.setMonitorLotFlag(true);
                    } else {
                        log.debug("step19 - get lot monitor route flag");
                        boolean monitorRouteFlag = lotMethod.lotMonitorRouteFlagGet(objCommon, lotInCassette.getLotID());
                        lotInCassette.setMonitorLotFlag(monitorRouteFlag);
                    }
                    lotInCassette.setLotType(lotType);
                } else {
                    lotInCassette.setMonitorLotFlag(false);
                }
                lotInCassettes.add(lotInCassette);
            }
        } else {
            log.debug("step20 - Get Contained lot in controljob");
            List<Infos.ControlJobCassette> controlJobCassettes = controlJobMethod.controlJobContainedLotGet(objCommon, controlJobID);
            int controlJobCassettesLength = CimArrayUtils.getSize(controlJobCassettes);
            List<Infos.LotInCassette> lotInCassettes = new ArrayList<>();
            for (int i = 0; i < controlJobCassettesLength; i++) {
                Infos.ControlJobCassette controlJobCassette = controlJobCassettes.get(i);
                if (ObjectIdentifier.equalsWithValue(controlJobCassette.getCassetteID(), cassetteId)) {
                    lotLength = CimArrayUtils.getSize(controlJobCassette.getControlJobLotList());
                    for (int j = 0; j < lotLength; j++) {
                        Infos.ControlJobLot controlJobLot = controlJobCassettes.get(i).getControlJobLotList().get(j);
                        Infos.LotInCassette lotInCassette = new Infos.LotInCassette();

                        lotInCassette.setMoveInFlag(controlJobLot.getOperationStartFlag());
                        lotInCassette.setMonitorLotFlag(controlJobLot.getMonitorLotFlag());
                        lotInCassette.setLotID(controlJobLot.getLotID());

                        log.debug("step21 - get lot type");
                        String lotType = lotMethod.lotTypeGet(objCommon, lotInCassette.getLotID());
                        lotInCassette.setLotType(lotType);
                        lotInCassettes.add(lotInCassette);
                        startCassette.setLotInCassetteList(lotInCassettes);
                    }
                    break;
                }
            }
        }
        /*-------------------------------------------------------*/
        /*                                                       */
        /*   Check lot Condition for Loading                     */
        /*                                                       */
        /*   The following conditions are checked for each lot.  */
        /*                                                       */
        /*   - lot's equipmentID                                 */
        /*   - lotHoldState                                      */
        /*   - lotProcessState                                   */
        /*   - lotInventoryState                                 */
        /*   - entityInhibition                                  */
        /*   - eqp's availability for specified lot        */
        /*                                                       */
        /*   (*)                                                 */
        /*   About for reticle/fixture, whether these are        */
        /*   Inhibited or not itself is checked at later.        */
        /*   (by processDurable_CheckConditionForOpeStart)       */
        /*-------------------------------------------------------*/
        log.trace("LoadPurposeType is 【{}】",startCassette.getLoadPurposeType());
        if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_OTHER)) {
            log.debug("step22 - check equipment avail");
            equipmentMethod.equipmentCheckAvail(objCommon, equipmentId);
        }
        List<String> verifyNGReasons = new ArrayList<>();
        for (int i = 0; i < lotLength; i++) {
            verifyNGReasons.add("");
            Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(i);
            log.trace("lotInCassette is 【{}】",lotInCassette);
            if (!lotInCassette.getMoveInFlag()) {
                continue;
            }
            log.debug("step23 - check load condition for lot");
            try {
                lotMethod.lotCheckConditionForLoading(objCommon, equipmentId, lotInCassette.getLotID());
                lotInCassette.setMoveInFlag(true);
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getNotCandidateLotForOperationStart(), e.getCode())) {
                    lotInCassette.setMoveInFlag(false);
                    verifyNGReasons.set(i, e.getReasonText());
                } else {
                    throw e;
                }
            }
        }
        /*--------------------------------------------------------*/
        /*                                                        */
        /*   Check cassette Condition for Loading                 */
        /*                                                        */
        /*   The following conditions are checked for Loading.    */
        /*                                                        */
        /*   - controlJobID                                       */
        /*   - multiLotType                                       */
        /*   - transferState                                      */
        /*   - cassetteState                                      */
        /*                                                        */
        /*--------------------------------------------------------*/
        log.debug("step24 - check load condition for cassette");
        try {
            cassetteMethod.cassetteCheckConditionForLoading(objCommon, equipmentId, portId, cassetteId);
        } catch (ServiceException e) {
            // strLoadingVerifiedLot information must be set for ForceLoad process.
            if (Validations.isEquals(retCodeConfig.getInvalidCassetteTransferState(), e.getCode())) {
                List<Infos.LoadingVerifiedLot> loadingVerifiedLots = new ArrayList<>();
                for (int j = 0; j < lotLength; j++) {
                    Infos.LoadingVerifiedLot loadingVerifiedLot = new Infos.LoadingVerifiedLot();
                    loadingVerifiedLot.setMoveInFlag(false);
                    loadingVerifiedLot.setMonitorLotFlag(false);
                    loadingVerifiedLot.setLotID(startCassette.getLotInCassetteList().get(j).getLotID());
                    loadingVerifiedLot.setVerifyNGReason(e.getMessage());
                    loadingVerifiedLots.add(loadingVerifiedLot);
                }
                e.setData(loadingVerifiedLots);
            }
            throw e;
        }
        /*--------------------------------------------------------*/
        /*                                                        */
        /*   Check eqp and port Condition for Loading       */
        /*                                                        */
        /*   The following conditions are checked for Loading.    */
        /*                                                        */
        /*   - controlJobID                                       */
        /*   - loadPort's reservedControlJob VS cassette's one    */
        /*   - loading sequence                                   */
        /*   - loadPort's portUsage (Input or InOut)              */
        /*   - loadPurposeType                                    */
        /*   - portState                                          */
        /*                                                        */
        /*--------------------------------------------------------*/
        log.debug("step25 - check load condition for equipment");
        try {
            equipmentMethod.equipmenCheckConditionForLoading(objCommon, equipmentId, portId, cassetteId, loadPurposeType);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getCastControlJobIdBlank(), e.getCode())) {
                List<Infos.LoadingVerifiedLot> loadingVerifiedLots = new ArrayList<>();
                for (int j = 0; j < lotLength; j++) {
                    Infos.LoadingVerifiedLot loadingVerifiedLot = new Infos.LoadingVerifiedLot();
                    loadingVerifiedLot.setMoveInFlag(false);
                    loadingVerifiedLot.setMonitorLotFlag(false);
                    loadingVerifiedLot.setLotID(startCassette.getLotInCassetteList().get(j).getLotID());
                    loadingVerifiedLot.setVerifyNGReason(e.getMessage());
                    loadingVerifiedLots.add(loadingVerifiedLot);
                }
                e.setData(loadingVerifiedLots);
            }
            throw e;
        }

        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING)) {
            log.debug("step26 - check operation condition for slm");
            slmMethod.slmCheckConditionForOperation(objCommon, equipmentId, null, null, Collections.singletonList(startCassette), null, BizConstant.SP_OPERATION_LOADINGLOT);
        }

        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check flowbatch Condition for Loading                               */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   1. whether in-parm's eqp has reserved flowBatchID or not      */
        /*      fill  -> in-parm's lot must have same flowBatchID                */
        /*      blank -> no check                                                */
        /*                                                                       */
        /*   2. whether lot is in flowBatch section or not                       */
        /*      in    -> lot must have flowBatchID, and flowBatch must have      */
        /*               reserved equipmentID.                                   */
        /*               if lot is on target operation, flowBatch's reserved     */
        /*               equipmentID and in-parm's equipmentID must be same.     */
        /*      out   -> no check                                                */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        log.debug("step27 - Check flowbatch Condition for Loading");
        equipmentMethod.equipmentLotCheckFlowBatchConditionForLoading(objCommon, equipmentId, startCassette);
        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process durable Condition for Loading                         */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   1. Whether eqp requires process durable or not                */
        /*      If no-need, return OK;                                           */
        /*                                                                       */
        /*   2. At least one of reticle / fixture for each reticleGroup /        */
        /*      fixtureGroup is in the eqp or not.                         */
        /*      Even if required reticle is in the eqp, its status must    */
        /*      be _Available or _InUse.                                         */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (!CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
            log.debug("step28 - check Process durable Required Flag");
            try {
                equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, equipmentId);
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())
                        || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                    log.trace("rc == RC_EQP_PROCDRBL_RTCL_REQD || rc == RC_EQP_PROCDRBL_FIXT_REQD");
                    int lotInCassetteListLength = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                    for (int j = 0; j < lotInCassetteListLength; j++) {
                        Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                        if (!lotInCassette.getMoveInFlag()) {
                            log.trace("strStartCassette.strLotInCassette[j].operationStartFlag == FALSE");
                            continue;
                        }
                        log.debug("step29 - check reserve reticle info");
                        if (!ObjectIdentifier.isEmptyWithValue(controlJobID)) {
                            Outputs.ObjControlJobStartReserveInformationOut objControlJobStartReserveInformationGetOut =
                                    controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                                            controlJobID,
                                            false);
                            List<Infos.StartCassette> startCassettes = objControlJobStartReserveInformationGetOut.getStartCassetteList();
                            int lenStartCassette = CimArrayUtils.getSize(startCassettes);
                            for (int k = 0; k < lenStartCassette; k++) {
                                if (ObjectIdentifier.equalsWithValue(startCassettes.get(k).getCassetteID(), cassetteId)) {
                                    List<Infos.LotInCassette> tmpLotInCassettes = startCassettes.get(k).getLotInCassetteList();
                                    int lenLotInCassette = CimArrayUtils.getSize(tmpLotInCassettes);
                                    for (int l = 0; l < lenLotInCassette; l++) {
                                        if (!tmpLotInCassettes.get(l).getMoveInFlag()) {
                                            continue;
                                        }
                                        List<Infos.StartReticleInfo> startReticles = tmpLotInCassettes.get(l).getStartRecipe().getStartReticleList();
                                        if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode()) && CimArrayUtils.getSize(startReticles) > 0) {
                                            log.debug("step30 - Get and Check Reticle State");
                                            reticleMethod.reticleStateCheck170(objCommon, equipmentId, startReticles, tmpLotInCassettes.get(l).getLotID());

                                            //Check Reticle Inhibition
                                            List<Infos.StartReticleInfo> startReticleList = tmpLotInCassettes.get(l).getStartRecipe().getStartReticleList();
                                            int lenStartReticle = CimArrayUtils.getSize(startReticleList);
                                            Infos.EntityInhibitAttributes entityInhibitAttributes = new Infos.EntityInhibitAttributes();
                                            List<Infos.EntityIdentifier> entits = new ArrayList<>();
                                            for (int m = 0; m < lenStartReticle; m++) {
                                                Infos.EntityIdentifier entityIdentifier = new Infos.EntityIdentifier();
                                                entityIdentifier.setClassName(BizConstant.SP_INHIBITCLASSID_RETICLE);
                                                entityIdentifier.setObjectID(startReticleList.get(m).getReticleID());
                                                entityIdentifier.setAttribution("");
                                                entits.add(entityIdentifier);
                                            }
                                            entityInhibitAttributes.setEntities(entits);

                                            log.debug("step31 - get sub lot type");
                                            String subLotType = lotMethod.lotSubLotTypeGetDR(objCommon, tmpLotInCassettes.get(l).getLotID());
                                            List<String> subLotTypes = new ArrayList<>();
                                            if (!CimStringUtils.isEmpty(subLotType)) {
                                                subLotTypes.add(subLotType);
                                            }
                                            entityInhibitAttributes.setSubLotTypes(subLotTypes);

                                            log.debug("step32 - check entity constraint");
                                            Infos.EntityInhibitCheckForEntitiesOut entityInhibitCheckForEntitiesOut = constraintMethod.constraintCheckForEntities(objCommon, entityInhibitAttributes);

                                            log.debug("step33 - get inhibiteffective for lot");
                                            List<Infos.EntityInhibitInfo> entityInhibitInfo = entityInhibitCheckForEntitiesOut.getEntityInhibitInfo();
                                            int lenInhibit = CimArrayUtils.getSize(entityInhibitInfo);
                                            List<Infos.EntityInhibitInfo> entityInhibitInfoList = null;
                                            log.trace("lenInhibit is 【{}】",lenInhibit);
                                            if (0 < lenInhibit) {
                                                Inputs.ObjEntityInhibiteffectiveForLotGetDRIn inhibiteffectiveForLotGetDRIn = new Inputs.ObjEntityInhibiteffectiveForLotGetDRIn();
                                                inhibiteffectiveForLotGetDRIn.setLotID(lotInCassette.getLotID());
                                                inhibiteffectiveForLotGetDRIn.setStrEntityInhibitInfos(entityInhibitInfo);
                                                entityInhibitInfoList = constraintMethod.constraintEffectiveForLotGetDR(objCommon, inhibiteffectiveForLotGetDRIn.getStrEntityInhibitInfos(), inhibiteffectiveForLotGetDRIn.getLotID());
                                                lenInhibit = CimArrayUtils.getSize(entityInhibitInfoList);
                                            }
                                            if (0 < lenInhibit) {
                                                throw new ServiceException(new OmCode(retCodeConfig.getInhibitEntity(),
                                                        CimArrayUtils.isEmpty(entityInhibitInfoList) ? "" : entityInhibitInfoList.get(0).getEntityInhibitAttributes().getEntities().get(0).getObjectID().getValue(), BizConstant.SP_INHIBITCLASSID_RETICLE));
                                            }
                                        } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                                            log.debug("step34 - Get and Check Fixture State");
                                            fixtureMethod.fixtureStateCheck(objCommon, equipmentId, tmpLotInCassettes.get(l).getStartRecipe().getStartFixtureList());
                                        }
                                    }

                                }
                            }
                        } else {
                            log.debug("step35 - Get lot's LogicalRecipeID / MachineRecipeID");
                            Outputs.ObjLotRecipeGetOut objLotRecipeGetOut = lotMethod.lotRecipeGet(objCommon, equipmentId, lotInCassette.getLotID());
                            if (null == lotInCassette.getStartRecipe()) {
                                lotInCassette.setStartRecipe(new Infos.StartRecipe());
                            }
                            lotInCassette.getStartRecipe().setLogicalRecipeID(objLotRecipeGetOut.getLogicalRecipeId());
                            lotInCassette.getStartRecipe().setMachineRecipeID(objLotRecipeGetOut.getMachineRecipeId());
                            /*--------------------------------------------------*/
                            /*  Check Process durable Condition for OpeStart    */
                            /*  - At least one of reticle / fixture for each    */
                            /*      reticleGroup / fixtureGroup is in the       */
                            /*      eqp or not. Even if required reticle  */
                            /*      is in the eqp, its status must be     */
                            /*      _Available or _InUse.                       */
                            /*      - Found reticles must not be inhibited.     */
                            /*--------------------------------------------------*/
                            log.debug("step36 - Check Process durable Condition for OpeStart");
                            Outputs.ObjProcessDurableCheckConditionForOperationStartOut objProcessDurableCheckConditionForOpeStartOut = null;
                            try {
                                objProcessDurableCheckConditionForOpeStartOut = processMethod.processDurableCheckConditionForOpeStart(objCommon, equipmentId,
                                        lotInCassette.getStartRecipe().getLogicalRecipeID(), lotInCassette.getStartRecipe().getMachineRecipeID(), lotInCassette.getLotID());
                            } catch (ServiceException ex) {
                                if (Validations.isEquals(retCodeConfig.getNotAvailableFixture(), ex.getCode())
                                        || Validations.isEquals(retCodeConfig.getNotAvailableReticle(), ex.getCode())) {
                                    log.trace("rc == RC_NOT_AVAILABLE_RETICLE || rc == RC_NOT_AVAILABLE_FIXTURE");
                                    lotInCassette.setMoveInFlag(false);
                                    verifyNGReasons.set(0, ex.getMessage());
                                    log.debug("Check Process durable Condition for Loading after strStartCassette.strLotInCassette[j].operationStartFlag");
                                } else {
                                    throw ex;
                                }
                            }
                            log.info("check OK");
                        }
                    }
                } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableNotRequired(), e.getCode())) {
                    log.info("rc == RC_EQP_PROCDRBL_NOT_REQD");
                } else {
                    throw e;
                }
            }
        }

        /*--------------------------------------------------*/
        /*  Check confirmation request setting for          */
        /*      -Uploaded Recipe Body and Eqp's Recipe Body */
        /*  Recipe Body Confirmation/DownLoad               */
        /*     -eqp or not. Even if required reticle  */
        /*--------------------------------------------------*/
        //Get Machine Recipe List for Recipe Body Management
        log.trace("controlJobID is 【{}】",controlJobID);
        if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            List<Infos.StartCassette> startCassettes = new ArrayList<>();
            startCassettes.add(startCassette);
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            int lotInCassetteLength = CimArrayUtils.getSize(lotInCassetteList);
            for (int lotInCstCnt = 0; lotInCstCnt < lotInCassetteLength; lotInCstCnt++) {
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(lotInCstCnt);
                log.trace("MoveInFlag is 【{}】",lotInCassette.getMoveInFlag());
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }
                log.debug("step37 - Get lot's LogicalRecipeID / MachineRecipeID from standard definition.");
                Outputs.ObjLotRecipeGetOut objLotRecipeGetOutData = lotMethod.lotRecipeGet(objCommon, equipmentId, lotInCassette.getLotID());
                Infos.StartRecipe startRecipe = new Infos.StartRecipe();
                startRecipe.setLogicalRecipeID(objLotRecipeGetOutData.getLogicalRecipeId());
                startRecipe.setMachineRecipeID(objLotRecipeGetOutData.getMachineRecipeId());
                lotInCassette.setStartRecipe(startRecipe);
            }
            log.debug("step38 - Get Machine Recipe List for Recipe Body Management.");
            List<Infos.RecipeBodyManagement> recipeBodyManagementList = machineRecipeMethod.machineRecipeGetListForRecipeBodyManagement(objCommon, equipmentId, startCassettes);
            int targetRecipeLength = CimArrayUtils.getSize(recipeBodyManagementList);
            if (targetRecipeLength == 0) {
                log.trace("Recipe for Recipe Body Management does not exist. And controljob does not exist. OK.");
            } else {
                log.trace("Cannot perform Recipe Confirmation/Download without lot Reservation. Please retry after lot Reservation.");
                throw new ServiceException(retCodeConfig.getCannotLoadWithoutCj());
            }
        }
        //-----------------------------------------------------------------
        // Load Purpose Type is Other Case:
        // Execute cassette Category and port Category Combination Check.
        //-----------------------------------------------------------------
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_OTHER)) {
            log.debug("step39 - Load Purpose Type is OTHER case, Checking Category");
            lotMethod.lotCassetteCategoryCheckForContaminationControl(objCommon, null, cassetteId, equipmentId, portId);
        }
        /*---------------------------------------------------------------------------*/
        /*   Check Category for Copper/Non Copper                                    */
        /*   It is checked in the following method whether it is the condition       */
        /*   that lot of the object is made of OpeStart.                             */
        /*   1. It is checked whether CassetteCategory of RequiredCassetteCategory   */
        /*      of PosLot and PosCassette is the same.                               */
        /*   2. It is checked whether CassetteCategoryCapability of CassetteCategory */
        /*      of PosCassette and PosPortResource is the same.                      */
        /*   3. It is proper condition if CassetteCategoryCapability is the same     */
        /*      as RequiredCassetteCategory and CassetteCategory.                    */
        /*---------------------------------------------------------------------------*/
        int nLotInCastLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
        for (int i = 0; i < nLotInCastLen; i++) {
            Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(i);
            if (!lotInCassette.getMoveInFlag()) {
                continue;
            }
            log.debug("step40 - lotCassetteCategoryCheckForContaminationControl");
            try {
                lotMethod.lotCassetteCategoryCheckForContaminationControl(objCommon, lotInCassette.getLotID(), startCassette.getCassetteID(), equipmentId, startCassette.getLoadPortID());
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getInvalidCategoryCheck(), e.getCode())) {
                    lotInCassette.setMoveInFlag(false);
                    verifyNGReasons.set(0, e.getMessage());
                } else {
                    throw e;
                }
            }
            log.debug("lot_CassetteCategory_CheckForContaminationControl is success");
        }
        //-----------------------------------------------------------//
        //  wafer Stacking Operation                                 //
        //  If eqp Category is SP_Mc_Category_WaferBonding,    //
        //  check Bonding Group Condition for Loading                //
        //-----------------------------------------------------------//
        if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_PROCESSLOT)
                || CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT)) {
            log.debug("step41 - Check Bonding Group Condition for Loading");
            List<Infos.StartCassette> strStartCassetteSeq = new ArrayList<>();
            strStartCassetteSeq.add(startCassette);
            lotMethod.lotBondingGroupUpdateByOperation(objCommon, equipmentId, controlJobID, strStartCassetteSeq, BizConstant.SP_OPERATION_LOADINGLOT);
        }
        /*--------------------------*/
        /*   Set Return Structure   */
        /*--------------------------*/
        int startLotCount = 0;
        int monitorLotCount = 0;
        List<Infos.LoadingVerifiedLot> loadingVerifiedLots = new ArrayList<>();
        for (int i = 0; i < lotLength; i++) {
            Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(i);
            Infos.LoadingVerifiedLot loadingVerifiedLot = new Infos.LoadingVerifiedLot();
            loadingVerifiedLot.setMoveInFlag(lotInCassette.getMoveInFlag());
            loadingVerifiedLot.setMonitorLotFlag(lotInCassette.getMonitorLotFlag());
            loadingVerifiedLot.setLotID(lotInCassette.getLotID());
            loadingVerifiedLot.setVerifyNGReason(verifyNGReasons.get(i));
            loadingVerifiedLots.add(loadingVerifiedLot);
            if (loadingVerifiedLot.getMoveInFlag()) {
                startLotCount++;
                if (loadingVerifiedLot.getMonitorLotFlag()) {
                    monitorLotCount++;
                }
            }
        }

        /*-----------------------------------------------------------*/
        /*   Final Check for Start lot Count and Monitor lot Count   */
        /*-----------------------------------------------------------*/
        log.trace("loadPurposeType is 【{}】",loadPurposeType);
        if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_PROCESSLOT)
                || CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT)) {
            if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
                List<Infos.StartCassette> startCassettes = new ArrayList<>(1);
                startCassettes.add(startCassette);
                log.debug("step42 - lotRecipeCombinationCheckForLoading");
                lotMethod.lotRecipeCombinationCheckForLoading(objCommon, equipmentId, startCassettes, loadPurposeType);
            }
            log.trace("startLotCount is 【{}】",startLotCount);
            if (startLotCount == 0) {
                throw new ServiceException(retCodeConfig.getNotCandidateLotForOperationStart(), loadingVerifiedLots);
            }
            if (monitorLotCount > 1) {
                throw new ServiceException(retCodeConfig.getInvalidProductMonitorCount(), loadingVerifiedLots);
            }
            //-----------------------------------------------------------//
            //   Final Check for LoadPurposeType:ProcessMonitorLot       //
            //   The lot, which meets fhe following conditions must be   //
            //   exist, and its lot count must be 1.                     //
            //      - OpeStartFlag   : TRUE                              //
            //      - lottype        : ProcessMonitor                    //
            //      - MonitorLotFlag : TRUE                              //
            //-----------------------------------------------------------//
            if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_PROCESSMONITORLOT)) {
                log.debug("loadPurposeType is ProcessMonitorLot");
                if (monitorLotCount != 1) {
                    throw new ServiceException(retCodeConfig.getInvalidProductMonitorCount());
                }
                int lotLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                for (int i = 0; i < lotLen; i++) {
                    Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(i);
                    log.trace("MoveInFlag is【{}】，MonitorLotFlag is 【{}】",lotInCassette.getMoveInFlag(),lotInCassette.getMonitorLotFlag());
                    if (lotInCassette.getMoveInFlag() && lotInCassette.getMonitorLotFlag()) {
                        if (CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_PRODUCTIONMONITORLOT)) {
                            log.debug("step43 - get monitor route flag");
                            boolean monitorRouteFlag = lotMethod.lotMonitorRouteFlagGet(objCommon, lotInCassette.getLotID());
                            Validations.check(!monitorRouteFlag, new OmCode(retCodeConfig.getInvalidLotType(), lotInCassette.getLotType(), lotInCassette.getLotID().getValue()));
                        }
                        break;
                    }
                }
            }
        }
        carrierLoadingVerifyReqResult.setLoadingVerifiedLots(loadingVerifiedLots);
        return carrierLoadingVerifyReqResult;
    }

    /**
     * @deprecated  该方法已重构，请参考
     * {@link EquipmentProcessOperationImpl#sxMoveOutReq(Infos.ObjCommon, Params.OpeComWithDataReqParams)}
     * @param objCommon objCommon
     * @param opeComWithDataReqParams opeComWithDataReqParams
     * @return move out result
     */
    @Override
    @Deprecated
    public Results.MoveOutReqResult sxMoveOutReq(Infos.ObjCommon objCommon,
                                                 Params.OpeComWithDataReqParams opeComWithDataReqParams) {

        Results.MoveOutReqResult out = new Results.MoveOutReqResult();
        ObjectIdentifier equipmentID = opeComWithDataReqParams.getEquipmentID();
        ObjectIdentifier controlJobID = opeComWithDataReqParams.getControlJobID();
        int postProcForLotFlag = StandardProperties.OM_PP_FOR_LOT_MOVEOUT_FLAG.getIntValue();

        log.debug("step1 - Check Process");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, opeComWithDataReqParams.getEquipmentID());

        log.debug("step2 - Get Started lot information which is specified with controljob ID");
        Outputs.ObjControlJobStartReserveInformationOut objControlJobStartReserveInformationGetOut =
                controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                        opeComWithDataReqParams.getControlJobID(),
                        false);

        log.debug("step3 - get lock mode by equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.OPERATION_COMP_WITH_DATA_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        log.trace("lockMode is 【{}】",lockMode);
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step4 - lock equipment main object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);
            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            /*--------------------------------*/
            /*   Lock objects to be updated   */
            /*--------------------------------*/
            log.debug("step5 - Lock objects to be updated ");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        int totalStartLotCount = 0;
        for (Infos.StartCassette startCassette : objControlJobStartReserveInformationGetOut.getStartCassetteList()) {
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                log.trace("moveInFlag is 【{}】",lotInCassette.getMoveInFlag());
                if (lotInCassette.getMoveInFlag()) {
                    totalStartLotCount++;
                }
            }
        }

        int scLen = CimArrayUtils.getSize(objControlJobStartReserveInformationGetOut.getStartCassetteList());

        List<Infos.StartCassette> startCassettes = new ArrayList<>(scLen);

        List<ObjectIdentifier> lotIDs;
        List<ObjectIdentifier> cassetteIDs;
        int extendLen = 25;
        int t_lotIDLen = extendLen;
        int lotIDCnt = 0;
        int cassetteIDCnt = 0;
        lotIDs = new ArrayList<>(t_lotIDLen);
        cassetteIDs = new ArrayList<>(scLen);

        for (int i = 0; i < scLen; i++) {
            startCassettes.add(objControlJobStartReserveInformationGetOut.getStartCassetteList().get(i));

            int nLen = 0;
            nLen = CimArrayUtils.getSize(startCassettes.get(i).getLotInCassetteList());

            /*--------------------------*/
            /*   Lock Cassette Object   */
            /*--------------------------*/
            log.trace("LoadPurposeTyp is 【{}】",startCassettes.get(i).getLoadPurposeType());
            if (CimStringUtils.equals(startCassettes.get(i).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {

                Boolean EmptyPortFlag = TRUE;
                log.debug("step6 - get equipment monitor creation flag");
                try {
                    equipmentMethod.equipmentMonitorCreationFlagGet(
                            objCommon,
                            opeComWithDataReqParams.getEquipmentID());
                } catch (ServiceException ex) {
                    //---------------------------------------------------------------------------------------------
                    //    if monitor creationflag was TRUE, at least one Lot should be existed in Empty Cassete.
                    //---------------------------------------------------------------------------------------------
                    if (Validations.isEquals(retCodeConfigEx.getMonitorCreatReqd(), ex.getCode())) {
                        if (nLen == 0) {
                            throw ex;
                        }
                    }
                }
                cassetteIDs.add(startCassettes.get(i).getCassetteID());
                cassetteIDCnt++;

                continue;
            }

            cassetteIDs.add(startCassettes.get(i).getCassetteID());
            cassetteIDCnt++;

            for (int j = 0; j < nLen; j++) {

                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                log.trace("moveInFlag is 【{}】",startCassettes.get(i).getLotInCassetteList().get(j).getMoveInFlag());
                if (CimBooleanUtils.isFalse(startCassettes.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }
                if (lotIDCnt >= t_lotIDLen) {
                    t_lotIDLen += extendLen;
                }
                lotIDs.add(startCassettes.get(i).getLotInCassetteList().get(j).getLotID());
                lotIDCnt++;
            }
        }


        log.debug("step7 - virtual operation check by start cassette");
        boolean virtualOperationFlag = virtualOperationMethod.virtualOperationCheckByStartCassette(objCommon, startCassettes);

        log.debug("step8 - get equipment brinfo");
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, opeComWithDataReqParams.getEquipmentID());

        log.trace("lockMode is 【{}】",lockMode);
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("get equipment online mode");
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
            log.trace("onlineMode is 【{}】",onlineMode);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                log.debug("step9 - lock advanced object");

                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            log.debug("step11 - Lock eqp ProcLot Element");
            List<String> procLotSeq = lotIDs.stream().map(ObjectIdentifier::fetchValue).collect(Collectors.toList());
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, procLotSeq));
            // For wafer stacking, lock load cassette
            String equipmentCategory = eqpBrInfo.getEquipmentCategory();
            log.trace("equipmentCategory is 【{}】,postProcForLotFlag is 【{}】",equipmentCategory,postProcForLotFlag);
            if (CimStringUtils.equals(equipmentCategory, BizConstant.SP_MC_CATEGORY_WAFERBONDING) && postProcForLotFlag != 1) {
                // Step12 - advanced_object_Lock
                log.debug("step12 - lock advanced object");
                List<String> loadCastSeq = cassetteIDs.stream().map(ObjectIdentifier::fetchValue).collect(Collectors.toList());
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, loadCastSeq));
            }
            //*------------------------------*//
            //*   Lock controljob Object     *//
            //*------------------------------*//
            log.debug("step13 - Lock controljob Object");
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
        }
        /*------------------------------*/
        /*   Lock cassette/lot Object   */
        /*------------------------------*/
        log.debug("step14 - Lock cassette/lot Object");
        cassetteIDs.removeIf(CimObjectUtils::isEmpty);
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);

        log.debug("step15 - lock sequence object");
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, lotIDs);

        log.debug("step16 - add season by ho");
        seasoningService.sxSeasonForMoveOut(objCommon, equipmentID);

        log.debug("step17 - update used achine recipe time");
        seasonMethod.updateMachineRecipeUsedTime(objCommon, startCassettes, equipmentID);

        /*-------------------------------------------------*/
        /*   call cassette_APCInformation_GetDR            */
        /*-------------------------------------------------*/
        log.debug("step18 - call cassetteAPCInformationGetDR");
        List<Infos.ApcBaseCassette> apcBaseCassettes = null;
        try {
            apcBaseCassettes = cassetteMethod.cassetteAPCInformationGetDR(objCommon, equipmentID, startCassettes);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getSystemError(), e.getCode())) {
                throw e;
            }
        }

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*   Check Process                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        boolean slmCapabilityFlag = false;

        log.trace("fmcCapabilityFlag is 【{}】",eqpBrInfo.isFmcCapabilityFlag());
        if (CimBooleanUtils.isTrue(eqpBrInfo.isFmcCapabilityFlag())) {
            slmCapabilityFlag = true;
        }

        log.trace("SLM Capability is " + slmCapabilityFlag + ".");

        List<ObjectIdentifier> destCassetteList = new ArrayList<>();
        int destCassetteLength = 0;
        int pstLen = 0;
        log.trace("slmCapabilityFlag is 【{}】",slmCapabilityFlag);
        if (slmCapabilityFlag) {
            log.debug("step19 - lock for equipment container position");
            Inputs.ObjObjectLockForEquipmentContainerPositionIn objObjectLockForEquipmentContainerPositionIn = new Inputs.ObjObjectLockForEquipmentContainerPositionIn();
            objObjectLockForEquipmentContainerPositionIn.setEquipmentID(equipmentID);
            objObjectLockForEquipmentContainerPositionIn.setControlJobID(controlJobID);
            objectLockMethod.objectLockForEquipmentContainerPosition(objCommon, objObjectLockForEquipmentContainerPositionIn);

            log.debug("step20 - get equipment container position info");
            Infos.EqpContainerPositionInfo eqpContainerPositionInfo = equipmentMethod.equipmentContainerPositionInfoGet(objCommon, equipmentID, controlJobID, BizConstant.SP_SLM_KEYCATEGORY_CONTROLJOB);
            List<Infos.EqpContainerPosition> eqpContainerPositionList = eqpContainerPositionInfo.getEqpContainerPositionList();
            pstLen = CimArrayUtils.getSize(eqpContainerPositionList);
            log.trace("TransactionID is 【{}】",objCommon.getTransactionID());
            if (CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                    || CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
                //----------------------------------------------------------
                //  Filtering for Partial OpeComp
                //----------------------------------------------------------
                List<Infos.EqpContainerPosition> strEqpContainerPositionSeq = new ArrayList<>();
                int nEqpContainerPositionCnt = 0;
                for (int nCnt1 = 0; nCnt1 < pstLen; nCnt1++) {
                    if (!CimObjectUtils.isEmptyWithValue(eqpContainerPositionList.get(nCnt1).getControlJobID())) {
                        strEqpContainerPositionSeq.add(eqpContainerPositionList.get(nCnt1));
                    }
                }
                eqpContainerPositionInfo.setEqpContainerPositionList(strEqpContainerPositionSeq);
                pstLen = CimArrayUtils.getSize(strEqpContainerPositionSeq);
            }
            log.trace("pstLen is 【{}】",pstLen);
            if (pstLen > 0) {
                List<Infos.EqpContainerPosition> eqpContainerPositionList2 = eqpContainerPositionInfo.getEqpContainerPositionList();
                Infos.EqpContainerPosition tmpStrEqpContainerPosition = null;
                for (int nCnt1 = 0; nCnt1 < pstLen; nCnt1++) {
                    tmpStrEqpContainerPosition = eqpContainerPositionList2.get(nCnt1);
                    /*-----------------------------------------------------------------------*/
                    /*   Check SLM condition for EqpContainerPosition                        */
                    /*   The following conditions are checked by this object                 */
                    /*   - All SLM Status of Equipment container position which has relation */
                    /*     with ControlJob has NOT to be 'Stored'.                           */
                    /*-----------------------------------------------------------------------*/
                    log.trace("FmcState is 【{}】",tmpStrEqpContainerPosition.getFmcState());
                    if (CimStringUtils.equals(tmpStrEqpContainerPosition.getFmcState(), BizConstant.SP_SLMSTATE_STORED)) {
                        throw new ServiceException(new OmCode(retCodeConfig.getInvalidSLMStatusOfContainerPosition(), tmpStrEqpContainerPosition.getContainerPositionID().getValue(), tmpStrEqpContainerPosition.getFmcState()));
                    }
                    // --------------------------------------------------------------
                    // Get Destination Cassette List.
                    // These cassettes should be locked before update
                    // --------------------------------------------------------------
                    log.trace("DestCassetteID is 【{}】",tmpStrEqpContainerPosition.getDestCassetteID());
                    if (!CimObjectUtils.isEmptyWithValue(tmpStrEqpContainerPosition.getDestCassetteID())) {
                        // destination cassette is assigned
                        int nCnt2 = 0;
                        for (nCnt2 = 0; nCnt2 < destCassetteLength; nCnt2++) {
                            if (CimObjectUtils.equalsWithValue(destCassetteList.get(nCnt2), tmpStrEqpContainerPosition.getDestCassetteID())) {
                                // found destnationCast
                                break;
                            }
                        }
                        if (nCnt2 == destCassetteLength) {
                            // new destcassette
                            destCassetteLength++;
                            destCassetteList.add(tmpStrEqpContainerPosition.getDestCassetteID());
                        }
                    }
                }
                log.debug("step21 - lock the cassette");
                for (ObjectIdentifier cassetteID : destCassetteList) {
                    // lock the cassette
                    objectLockMethod.objectLock(objCommon, CimCassette.class, cassetteID);
                }
            }
        }

        /*---------------------------------*/
        /*   Get eqp's Online Mode   */
        /*---------------------------------*/
        log.trace("startCassettes size is 【{}】",startCassettes.size());
        if (startCassettes.size() <= 0) {
            log.info("(There is no started cassette.)");
            throw new ServiceException(retCodeConfig.getNotFoundCassette());
        }

        Outputs.ObjPortResourceCurrentOperationModeGetOut objPortResourceCurrentOperationModeGetOut = null;
        log.trace("virtualOperationFlag is 【{}】",virtualOperationFlag);
        if (!virtualOperationFlag) {
            log.debug("step22 - get port resource current operation mode");
            objPortResourceCurrentOperationModeGetOut = portComp.portResourceCurrentOperationModeGet(objCommon, opeComWithDataReqParams.getEquipmentID(), startCassettes.get(0).getUnloadPortID());

            /*----------------------------------------------------------------------------*/
            /*   If AccessMode is Auto or OnlineMode is Offline, do the following check.  */
            /*----------------------------------------------------------------------------*/
            Infos.OperationMode operationMode = objPortResourceCurrentOperationModeGetOut.getOperationMode();
            log.trace("OnlineMode is 【{}】，AccessMode is 【{}】",operationMode.getOnlineMode(),operationMode.getAccessMode());
            if (CimStringUtils.equals(operationMode.getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)
                    || CimStringUtils.equals(operationMode.getAccessMode(), BizConstant.SP_EQP_ACCESSMODE_AUTO)) {
                /*-----------------------------------------------------------------------*/
                /*   Check Process for cassette                                          */
                /*   The following conditions are checked by this object                 */
                /*   - transferState                                                     */
                /*-----------------------------------------------------------------------*/

                log.debug("step23 - check cassette condition for operation Comp");
                cassetteMethod.cassetteCheckConditionForOpeComp(objCommon, startCassettes);

                /*-----------------------------------------------------------------------*/
                /*                                                                       */
                /*   Check eqp port for OpeComp                                    */
                /*                                                                       */
                /*   The following conditions are checked by this object                 */
                /*                                                                       */
                /*   - All of cassette, which is contained in controlJob, must be on     */
                /*     the eqp's unloadingPort.                                    */
                /*                                                                       */
                /*-----------------------------------------------------------------------*/
                log.debug("step24 - check equipment port state for operation comp");
                equipmentMethod.equipmentPortStateCheckForOpeComp(objCommon, opeComWithDataReqParams.getEquipmentID(), startCassettes);

            }
        }
        log.trace("objPortResourceCurrentOperationModeGetOut is 【{}】",objPortResourceCurrentOperationModeGetOut);
        if (objPortResourceCurrentOperationModeGetOut == null) {
            //init empty
            objPortResourceCurrentOperationModeGetOut = new Outputs.ObjPortResourceCurrentOperationModeGetOut();

            //【bug-2307】virtual operation ：move Out 未成功，出现报错提示
            Infos.OperationMode operationMode = new Infos.OperationMode();
            objPortResourceCurrentOperationModeGetOut.setOperationMode(operationMode);
        }
        /*-----------------------------------------------------------------------*/
        /*   Check Process for lot                                               */
        /*   The following conditions are checked by this object                 */
        /*   - lotProcessState                                                   */
        /*-----------------------------------------------------------------------*/

        log.debug("step25 - check lot condition for operation comp");
        lotMethod.lotCheckConditionForOpeComp(objCommon, startCassettes);


        /*-----------------------------------------------------------------------*/
        /*   Check Process for eqp                                         */
        /*   The following conditions are checked by this object                 */
        /*   - All of lot which is contained in controlJob must be existing      */
        /*     in the eqp's processing information.                        */
        /*-----------------------------------------------------------------------*/
        log.trace("virtualOperationFlag is 【{}】",virtualOperationFlag);
        if (!virtualOperationFlag) {
            log.debug("step26 - check equipment condition operation comp");
            equipmentMethod.equipmentCheckConditionForOpeComp(objCommon, opeComWithDataReqParams.getEquipmentID(), startCassettes);
        }

        /*---------------------------------------------------------------------*/
        /*   In case of post process migration mode, fix PostProcForLotFlag    */
        /*---------------------------------------------------------------------*/
        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag == -1) {
            log.trace("Post Process Migration Mode");
            /*----------------------------------------------------------------------*/
            /*   In case of post process migration mode, check value in OSPPRCCONFIG    */
            /*----------------------------------------------------------------------*/
            Infos.ConfigInfo objConfigurationInformationGetDROut;
            log.debug("step27 - get configuration information");
            try {
                objConfigurationInformationGetDROut = cimComp.configurationInformationGetDR(objCommon, opeComWithDataReqParams.getEquipmentID().getValue(), BizConstant.SP_CONFIGURATIONCATEGORY_EQUIPMENTPOSTPROCDECOUPLEMODE);
                if (objConfigurationInformationGetDROut.getValue().equals("1")) {
                    log.info("EquipmentPostProcActionDecoupleMode = 1");
                    postProcForLotFlag = 1;
                } else {
                    log.info("EquipmentPostProcActionDecoupleMode != 1");
                    postProcForLotFlag = 0;
                }
            } catch (ServiceException ex) {
                if (!Validations.isEquals(retCodeConfig.getNotFoundEntry(), ex.getCode())) {
                    throw ex;
                }
                postProcForLotFlag = 0;
            }
            // Store PostProcForLotFlag as thread specific data
            ThreadContextHolder.setThreadSpecificDataString(BizConstant.SP_THREADSPECIFICDATA_KEY_POSTPROCFORLOTFLAG, String.valueOf(postProcForLotFlag));
        }

        /*--------------------------------*/
        /*   CP Test Function Procedure   */
        /*--------------------------------*/
        int startCassettesLength = CimArrayUtils.getSize(objControlJobStartReserveInformationGetOut.getStartCassetteList());
        for (int i = 0; i < startCassettesLength; i++) {
            Infos.StartCassette tmpStartCassette = startCassettes.get(i);
            int lotInCassetteLength = CimArrayUtils.getSize(tmpStartCassette.getLotInCassetteList());
            for (int j = 0; j < lotInCassetteLength; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart lot   */
                /*---------------------------*/
                log.trace("MoveInFlag is 【{}】",tmpStartCassette.getLotInCassetteList().get(j).getMoveInFlag());
                if (CimBooleanUtils.isFalse(tmpStartCassette.getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }
                /*-----------------------------------------*/
                /*   Check Test Type of Current Process    */
                /*-----------------------------------------*/
                ObjectIdentifier objLotTestTypeIDGetOut = null;
                log.debug("step28 - get lot test type");
                try {
                    objLotTestTypeIDGetOut = lotMethod.lotTestTypeIDGet(objCommon, tmpStartCassette.getLotInCassetteList().get(j).getLotID());
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getNotFoundTestType(), e.getCode())) {
                        log.info("lot_testTypeID_Get() != RC_OK");
                        throw e;
                    }
                }

                log.trace("objLotTestTypeIDGetOut is 【{}】",objLotTestTypeIDGetOut);
                if (!CimObjectUtils.isEmptyWithValue(objLotTestTypeIDGetOut)) {
                    /*---------------------------------------------------------------*/
                    /*   Gather Bin Summary Information based on lotID & testTypeID  */
                    /*---------------------------------------------------------------*/
                    log.debug("step29 - get bin summary by test type");
                    List<Infos.WaferBinSummary> waferBinSummaryList = binSummaryMethod.binSummaryGetByTestTypeDR(objCommon, tmpStartCassette.getLotInCassetteList().get(j).getLotID(), objLotTestTypeIDGetOut);

                    /*----------------------------------------------------------*/
                    /*   Update wafer Die quantity based on the input parameter */
                    /*----------------------------------------------------------*/
                    int binSummaryLength = CimArrayUtils.getSize(waferBinSummaryList);
                    List<Infos.LotWaferAttributes> lotWaferAttributes = new ArrayList<>();
                    for (int k = 0; k < binSummaryLength; k++) {
                        Infos.WaferBinSummary waferBinSummary = waferBinSummaryList.get(k);
                        log.trace("BinReportCount is 【{}】",waferBinSummary.getBinReportCount());
                        if (waferBinSummary.getBinReportCount() > 0) {
                            Infos.LotWaferAttributes lotWaferAttribute = new Infos.LotWaferAttributes();
                            lotWaferAttribute.setWaferID(waferBinSummary.getWaferId());
                            lotWaferAttribute.setGoodUnitCount(waferBinSummary.getGoodUnitCount());
                            lotWaferAttribute.setRepairUnitCount(waferBinSummary.getRepairUnitCount());
                            lotWaferAttribute.setFailUnitCount(waferBinSummary.getFailUnitCount());

                            lotWaferAttributes.add(lotWaferAttribute);
                        }
                    }
                    log.debug("step30 - change lot wafer");
                    lotMethod.lotWaferChangeDie(objCommon, tmpStartCassette.getLotInCassetteList().get(j).getLotID(), lotWaferAttributes);
                }
            }
        }

        /*------------------------------------------------------*/
        /*                                                      */
        /*     flowbatch Related Information Update Procedure   */
        /*                                                      */
        /*------------------------------------------------------*/
        /*------------------------------------------------------*/
        /*   Update flowbatch Information of eqp          */
        /*------------------------------------------------------*/
        log.debug("step31 - update flow batch information by operation comp");
        flowBatchMethod.flowBatchInformationUpdateByOpeComp(objCommon, opeComWithDataReqParams.getEquipmentID(), startCassettes);


        /*----------------------------------------------*/
        /*   Process Operation Update Procedure         */
        /*----------------------------------------------*/
        /*----------------------------------------------*/
        /*  Update Process Operation (actual comp xxxx) */
        /*----------------------------------------------*/
        log.debug("step32 - set process actual comp information");
        processMethod.processActualCompInformationSet(objCommon, startCassettes);

        /*--------------------------------------------------*/
        /*  Bonding Map Condition Check for wafer Stacking  */
        /*--------------------------------------------------*/
        boolean bondingEqpFlag = false;
        log.trace("EquipmentCategory is 【{}】",eqpBrInfo.getEquipmentCategory());
        if (BizConstant.SP_MC_CATEGORY_WAFERBONDING.equals(eqpBrInfo.getEquipmentCategory())) {
            log.info("eqp Category is SP_Mc_Category_WaferBonding.");
            bondingEqpFlag = true;
        }

        Outputs.ObjBondingGroupInfoByEqpGetDROut objBondingGroupInfoByEqpGetDROut = new Outputs.ObjBondingGroupInfoByEqpGetDROut();
        log.trace("bondingEqpFlag is 【{}】",bondingEqpFlag);
        if (bondingEqpFlag) {
            log.debug("step 33 - get bonding group info ");
            objBondingGroupInfoByEqpGetDROut = bondingGroupMethod.bondingGroupInfoByEqpGetDR(objCommon, opeComWithDataReqParams.getEquipmentID(),
                    opeComWithDataReqParams.getControlJobID(), true);

            List<Infos.BondingGroupInfo> strBondingGroupInfoSeq = objBondingGroupInfoByEqpGetDROut.getBondingGroupInfoList();
            int grpLen = CimArrayUtils.getSize(strBondingGroupInfoSeq);

            for (int grpCnt = 0; grpCnt < grpLen; grpCnt++) {
                if (!CimStringUtils.equals(strBondingGroupInfoSeq.get(grpCnt).getBondingGroupState(), BizConstant.SP_BONDINGGROUPSTATE_PROCESSED)) {
                    Validations.check(true, new OmCode(retCodeConfigEx.getBondgrpStateInvalid(), "OpeComp"));
                }

                int mapLen = CimArrayUtils.getSize(strBondingGroupInfoSeq.get(grpCnt).getBondingMapInfoList());
                for (int mapCnt = 0; mapCnt < mapLen; mapCnt++) {
                    if (!CimStringUtils.equals(strBondingGroupInfoSeq.get(grpCnt).getBondingMapInfoList().get(mapCnt).getBondingProcessState(),
                            BizConstant.SP_BONDINGPROCESSSTATE_COMPLETED)) {
                        Validations.check(true, new OmCode(retCodeConfigEx.getBondmapStateInvalid(),
                                strBondingGroupInfoSeq.get(grpCnt).getBondingMapInfoList().get(mapCnt).getBondingProcessState(),
                                strBondingGroupInfoSeq.get(grpCnt).getBondingMapInfoList().get(mapCnt).getBaseWaferID().getValue()));
                    }
                }
            }
        }

        List<ObjectIdentifier> topLotIDSeq = objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq();
        int topLotLength = CimArrayUtils.getSize(topLotIDSeq);
        List<Infos.BondingGroupInfo> bondingGroupInfoList = objBondingGroupInfoByEqpGetDROut.getBondingGroupInfoList();
        int bondingGroupLength = CimArrayUtils.getSize(bondingGroupInfoList);

        List<Infos.StartCassette> baseStartCassettes = new ArrayList<>();
        if (postProcForLotFlag != 1 && bondingEqpFlag) {
            log.info("bondingEqpFlag == TRUE");

            for (Infos.StartCassette startCassette : startCassettes) {
                Infos.StartCassette baseStartCassette = new Infos.StartCassette();
                baseStartCassette.setLoadSequenceNumber(startCassette.getLoadSequenceNumber());
                baseStartCassette.setLoadPurposeType(startCassette.getLoadPurposeType());
                baseStartCassette.setLoadPortID(startCassette.getLoadPortID());
                baseStartCassette.setCassetteID(startCassette.getCassetteID());
                List<Infos.LotInCassette> baseLotsInCassette = new ArrayList<>();
                for (Infos.LotInCassette lotInCassette : startCassette.getLotInCassetteList()) {
                    Infos.LotInCassette baseLotInCassette = new Infos.LotInCassette();
                    baseLotsInCassette.add(baseLotInCassette);
                    baseLotInCassette.setMoveInFlag(lotInCassette.getMoveInFlag());
                    baseLotInCassette.setRecipeParameterChangeType(lotInCassette.getRecipeParameterChangeType());
                    baseLotInCassette.setStartOperationInfo(lotInCassette.getStartOperationInfo());
                    baseLotInCassette.setProductID(lotInCassette.getProductID());
                    baseLotInCassette.setSubLotType(lotInCassette.getSubLotType());
                    baseLotInCassette.setLotWaferList(lotInCassette.getLotWaferList());
                    baseLotInCassette.setLotType(lotInCassette.getLotType());
                    baseLotInCassette.setStartRecipe(lotInCassette.getStartRecipe());
                    baseLotInCassette.setMonitorLotFlag(lotInCassette.getMonitorLotFlag());
                    baseLotInCassette.setLotID(lotInCassette.getLotID());
                }
                baseStartCassette.setLotInCassetteList(baseLotsInCassette);
                baseStartCassette.setUnloadPortID(startCassette.getUnloadPortID());
                baseStartCassettes.add(baseStartCassette);
            }

            for (int i = 0; i < startCassettesLength; i++) {
                int lotInCassetteLength = CimArrayUtils.getSize(baseStartCassettes.get(i).getLotInCassetteList());

                for (int j = 0; j < lotInCassetteLength; j++) {
                    if (CimBooleanUtils.isFalse(baseStartCassettes.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                        continue;
                    }

                    boolean isTopLot = false;
                    for (int k = 0; k < topLotLength; k++) {
                        if (CimStringUtils.equals(objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq().get(k).getValue(),
                                baseStartCassettes.get(i).getLotInCassetteList().get(j).getLotID().getValue())) {
                            isTopLot = true;
                            break;
                        }
                    }
                    if (isTopLot) {
                        log.info("lot " + baseStartCassettes.get(i).getLotInCassetteList().get(j).getLotID() + " is Top lot.");
                        baseStartCassettes.get(i).getLotInCassetteList().get(j).setMoveInFlag(false);
                        continue;
                    }
                }
            }
        }

        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            /*-------------------------------------------------*/
            /*   Make Measurement & Process Data History       */
            /*-------------------------------------------------*/
            log.debug("step34 - Make Measurement & Process Data History");
            eventMethod.collectedDataEventMake(objCommon, "OEQPW006", startCassettes, opeComWithDataReqParams.getControlJobID(), opeComWithDataReqParams.getEquipmentID(), opeComWithDataReqParams.getOpeMemo());

        }

        List<Outputs.ObjLotFutureHoldRequestsEffectByConditionOut> objLotFutureHoldRequestsEffectByConditionOuts = new ArrayList<>();
        String releaseReasonCodeId = BizConstant.SP_REASON_GATEPASS;
        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            for (int i = 0; i < startCassettesLength; i++) {
                Infos.StartCassette startCassette = startCassettes.get(i);
                int lotInCassetteLength = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                for (int j = 0; j < lotInCassetteLength; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart lot   */
                    /*---------------------------*/
                    log.trace("MoveInFlag is 【{}】",startCassette.getLotInCassetteList().get(j).getMoveInFlag());
                    if (CimBooleanUtils.isFalse(startCassette.getLotInCassetteList().get(j).getMoveInFlag())) {
                        continue;
                    }

                    log.trace("bondingEqpFlag is 【{}】",bondingEqpFlag);
                    if (bondingEqpFlag) {
                        log.info("bondingEqpFlag == TRUE");

                        boolean isTopLot = false;
                        for (int k = 0; k < topLotLength; k++) {
                            if (CimStringUtils.equals(objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq().get(k).getValue(),
                                    startCassette.getLotInCassetteList().get(j).getLotID().getValue())) {
                                isTopLot = true;
                                break;
                            }
                        }
                        log.trace("isTopLot is 【{}】",isTopLot);
                        if (isTopLot) {
                            log.info("lot " + startCassette.getLotInCassetteList().get(j).getLotID() + " is Top lot.");
                            continue;
                        }
                    }
                    /*------------------------------------------------------------------*/
                    /*   Get Effected Future Hold PRE of Current after Operation Move   */
                    /*------------------------------------------------------------------*/
                    log.debug("Get Effected Future Hold PRE of Current after Operation Move");
                    Infos.EffectCondition effectCondition = new Infos.EffectCondition();
                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_POST);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);

                    log.debug("step35 - hold lot future requests effect by condition");
                    Outputs.ObjLotFutureHoldRequestsEffectByConditionOut objLotFutureHoldRequestsEffectByConditionOut
                            = lotMethod.lotFutureHoldRequestsEffectByCondition(objCommon, startCassette.getLotInCassetteList().get(j).getLotID(), effectCondition);
                    objLotFutureHoldRequestsEffectByConditionOuts.add(objLotFutureHoldRequestsEffectByConditionOut);

                    /*------------------------------------------------------------------------------------*/
                    /*   Get Effected Future Hold Cancel PRE and SINGLE of Current after Operation Move   */
                    /*------------------------------------------------------------------------------------*/
                    log.debug("Get Effected Future Hold Cancel PRE and SINGLE of Current after Operation Move");

                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_ALL);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);

                    log.debug("step36 - lotFutureHoldRequestsDeleteEffectedByCondition");
                    Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut objLotFutureHoldRequestsDeleteEffectedByConditionOut
                            = lotMethod.lotFutureHoldRequestsDeleteEffectedByCondition(objCommon, startCassette.getLotInCassetteList().get(j).getLotID(), effectCondition);


                    List<Infos.LotHoldReq> futureHoldReleaseReqList = objLotFutureHoldRequestsDeleteEffectedByConditionOut.getStrFutureHoldReleaseReqList();
                    if (CimArrayUtils.getSize(futureHoldReleaseReqList) > 0) {
                        log.trace("strLot_futureHoldRequests_DeleteEffectedByCondition_out.strFutureHoldReleaseReqList.length() > 0");

                        log.debug("step37 - cancel future hold");
                        processControlService.sxFutureHoldCancelReq(objCommon,
                                startCassette.getLotInCassetteList().get(j).getLotID(), new ObjectIdentifier(releaseReasonCodeId), BizConstant.SP_ENTRYTYPE_REMOVE, objLotFutureHoldRequestsDeleteEffectedByConditionOut.getStrFutureHoldReleaseReqList());
                    }
                }
            }

        }

        /*------------------------------------------------------------*/
        /*   Reticle / Fixture Related Information Update Procedure   */
        /*------------------------------------------------------------*/

        int usedReticleLength = 0;
        int usedFixtureLength = 0;

        /*--------------------------------------------------------*/
        /*   Check ProcessDurable was Used for Operation or Not   */
        /*--------------------------------------------------------*/
        log.debug("step38 - get equipment process durable required flag");
        try {
            equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, opeComWithDataReqParams.getEquipmentID());
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableNotRequired(), e.getCode())) {
                log.trace("equipment_processDurableRequiredFlag_Get() == RC_EQP_PROCDRBL_NOT_REQD");
            } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())
                    || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                log.trace("equipment_processDurableRequiredFlag_Get() == RC_EQP_PROCDRBL_RTCL_REQD || RC_EQP_PROCDRBL_FIXT_REQD");
                for (int i = 0; i < startCassettesLength; i++) {
                    Infos.StartCassette startCassette = startCassettes.get(i);
                    int lotInCassetteLength = startCassette.getLotInCassetteList().size();

                    for (int j = 0; j < lotInCassetteLength; j++) {
                        Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                        if (!lotInCassette.getMoveInFlag()) {
                            continue;
                        }
                        if (Validations.isEquals(e.getCode(), retCodeConfig.getEquipmentProcessDurableReticleRequired())) {
                            /*-------------------------------*/
                            /*   Get Used Reticles for lot   */
                            /*-------------------------------*/
                            log.debug("step39 - get process assigned reticle");
                            List<Infos.StartReticle> objProcessAssignedReticleGetOut = processMethod.processAssignedReticleGet(objCommon, lotInCassette.getLotID());
                            usedReticleLength = objProcessAssignedReticleGetOut.size();
                            for (int k = 0; k < usedReticleLength; k++) {
                                log.debug("step40 - check reticle usage limitation");
                                Outputs.ObjReticleUsageLimitationCheckOut objReticleUsageLimitationCheckOut = reticleMethod.reticleUsageLimitationCheck(objCommon, objProcessAssignedReticleGetOut.get(k).getReticleID());
                                log.trace("UsageLimitOverFlag is 【{}】",objReticleUsageLimitationCheckOut.isUsageLimitOverFlag());
                                if (objReticleUsageLimitationCheckOut.isUsageLimitOverFlag()) {
                                    log.info("strFixture_usageLimitation_Check_out.usageLimitOverFlag == TRUE");
                                    /*-------------------------*/
                                    /*   Call System Message   */
                                    /*-------------------------*/
                                    log.debug("step41- Call System Message");
                                    Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                                    alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                                    alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_RTCLUSAGELIMITOVER);
                                    alertMessageRptParams.setSystemMessageText(objReticleUsageLimitationCheckOut.getMessageText());
                                    alertMessageRptParams.setNotifyFlag(true);
                                    alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                                    systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
                                }

                                /*---------------------------------------------*/
                                /*  Set last used time stamp for used reticle  */
                                /*---------------------------------------------*/
                                log.debug("step42 - Set last used time stamp for used reticle");
                                reticleMethod.reticleLastUsedTimeSet(objProcessAssignedReticleGetOut.get(k).getReticleID(),
                                        objCommon.getTimeStamp().getReportTimeStamp());
                            }
                        } else {
                            /*------------------------------*/
                            /*   Get Used Fixture for lot   */
                            /*------------------------------*/
                            log.debug("step43 - Get Used Fixture for lot");
                            List<Infos.StartFixture> objProcessAssignedFixtureGetOut = processMethod.processAssignedFixtureGet(objCommon, lotInCassette.getLotID());
                            usedFixtureLength = CimArrayUtils.getSize(objProcessAssignedFixtureGetOut);
                            /*------------------------------------*/
                            /*   Fixture Usage Limitation Check   */
                            /*------------------------------------*/
                            for (int k = 0; k < usedFixtureLength; k++) {
                                log.debug("step44 - check fixture usage limitation");
                                Outputs.objFixtureUsageLimitationCheckOut objFixtureUsageLimitationCheckOut = fixtureMethod.fixtureUsageLimitationCheck(objCommon, objProcessAssignedFixtureGetOut.get(k).getFixtureID());
                                log.trace("UsageLimitOverFlag is 【{}】",objFixtureUsageLimitationCheckOut.isUsageLimitOverFlag());
                                if (objFixtureUsageLimitationCheckOut.isUsageLimitOverFlag()) {
                                    /*-------------------------*/
                                    /*   Call System Message   */
                                    /*-------------------------*/
                                    log.debug("step45 - Call System Message");
                                    Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                                    alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                                    alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_FIXTUSAGELIMITOVER);
                                    alertMessageRptParams.setSystemMessageText(objFixtureUsageLimitationCheckOut.getMessageText());
                                    alertMessageRptParams.setNotifyFlag(true);
                                    alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                                    systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
                                }
                            }
                        }
                    }
                }
            } else {
                log.trace("equipment_processDurableRequiredFlag_Get() != RC_OK");
                throw e;
            }
        }
        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            /*---------------------------------*/
            /*   Set/Clear Q-Time Management   */
            /*---------------------------------*/
            log.debug("step46 - Set/Clear Q-Time Management ");
            List<Infos.QTimeActionRegisterInfo> strQtimeSetClearByOpeCompOut =
                    qTimeMethod.qtimeSetClearByOpeComp(objCommon, bondingEqpFlag ? baseStartCassettes : startCassettes);
            ObjectIdentifier resetReasonCodeID = BaseStaticMethod.getObjectIdentifier(BizConstant.SP_REASON_QTIMECLEAR);

            List<Infos.QTimeActionRegisterInfo> strActionResetList = strQtimeSetClearByOpeCompOut;
            int resetLen = CimArrayUtils.getSize(strActionResetList);
            for (int resetCnt = 0; resetCnt < resetLen; resetCnt++) {
                Infos.QTimeActionRegisterInfo strResetAction = strActionResetList.get(resetCnt);
                List<Infos.LotHoldReq> strLotHoldList = strResetAction.getLotHoldList();

                //----- Lot Hold Actions -------//
                log.trace("strLotHoldList size is 【{}】", CimArrayUtils.getSize(strLotHoldList));
                if (CimArrayUtils.getSize(strLotHoldList) > 0) {


                    Params.HoldLotReleaseReqParams holdLotReleaseReqParams = new Params.HoldLotReleaseReqParams();
                    holdLotReleaseReqParams.setLotID(strResetAction.getLotID());
                    holdLotReleaseReqParams.setHoldReqList(strResetAction.getLotHoldList());

                    log.debug("step47 - hold lot release");
                    lotService.sxHoldLotReleaseReq(objCommon, holdLotReleaseReqParams);
                }

                //----- Future Hold Actions -------//
                List<Infos.LotHoldReq> strFutureHoldList = strResetAction.getFutureHoldList();
                log.trace("strFutureHoldList size 【{}】", CimArrayUtils.getSize(strFutureHoldList));
                if (CimArrayUtils.getSize(strFutureHoldList) > 0) {

                    Params.FutureHoldCancelReqParams futureHoldCancelReqParams = new Params.FutureHoldCancelReqParams();
                    futureHoldCancelReqParams.setLotID(strResetAction.getLotID());
                    futureHoldCancelReqParams.setReleaseReasonCodeID(resetReasonCodeID);
                    futureHoldCancelReqParams.setEntryType(BizConstant.SP_ENTRYTYPE_CANCEL);
                    futureHoldCancelReqParams.setLotHoldList(strFutureHoldList);
                    log.debug("step48 - cancel future hold");
                    processControlService.sxFutureHoldCancelReq(objCommon, futureHoldCancelReqParams);
                }

                //----- Future Rework Actions -------//
                List<Infos.FutureReworkInfo> strFutureReworkList = strResetAction.getFutureReworkList();
                int cancelLen = CimArrayUtils.getSize(strFutureReworkList);
                log.trace("cancelLen is 【{}】",cancelLen);
                if (cancelLen > 0) {
                    for (int cancelCnt = 0; cancelCnt < cancelLen; cancelCnt++) {
                        Infos.FutureReworkInfo strFutureRework = strFutureReworkList.get(cancelCnt);

                        log.debug("step49 - cancel future rework");
                        processControlService.sxFutureReworkCancelReq(objCommon, strFutureRework.getLotID(), strFutureRework.getRouteID(),
                                strFutureRework.getOperationNumber(), strFutureRework.getFutureReworkDetailInfoList(), "");
                    }
                }
            }

            // 检查并设置Min Q-Time最小时间限制
            minQTimeMethod.checkAndSetRestrictions(objCommon, bondingEqpFlag ? baseStartCassettes : startCassettes);
        }

        /*-----------------------------------------*/
        /*   Change lot Process State to Waiting   */
        /*-----------------------------------------*/
        log.debug("step50 - Change lot Process State to Waiting");
        lotMethod.lotProcessStateMakeWaiting(objCommon, startCassettes);

        /*-----------------------------------------------------------------------*/
        /*   Procedure for PO Moving                                             */
        /*-----------------------------------------------------------------------*/
        List<ObjectIdentifier> operationStartLotIds = new ArrayList<>();
        int operationStartLotCount = 0;

        for (int i = 0; i < startCassettesLength; i++) {
            List<Infos.LotInCassette> lotInCassetteList = startCassettes.get(i).getLotInCassetteList();

            for (int j = 0; j < lotInCassetteList.size(); j++) {
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                /*---------------------------*/
                /*   Omit Not-OpeStart lot   */
                /*---------------------------*/
                log.trace("MoveInFlag is 【{}】",lotInCassette.getMoveInFlag());
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                    continue;
                }

                log.debug("step51 - update contamination flag");
                contaminationMethod.lotContaminationLevelAndPrFlagSet(lotInCassette.getLotID());

                /*-----------------------------------*/
                /*   Move Process Operation of lot   */
                /*-----------------------------------*/
                log.debug("step52 - Move Process Operation of lot ");
                Outputs.ObjProcessMoveOut objProcessMoveOut = null;
                try {
                    objProcessMoveOut = processMethod.processMove(objCommon, lotInCassette.getLotID());
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getAddToQueueFail())) {
                        log.debug("step53 - get lot current operation info");
                        Outputs.ObjLotCurrentOperationInfoGetDROut objLotCurrentOperationInfoGetOut = lotMethod.lotCurrentOperationInfoGetDR(objCommon, lotInCassette.getLotID());

                        log.debug("step54 - hold lot");
                        Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                        lotHoldReq.setHoldType(BizConstant.SP_HOLDTYPE_ADDTOQUEUEERRHOLD);
                        lotHoldReq.setHoldReasonCodeID(new ObjectIdentifier(BizConstant.SP_REASON_ADDTOQUEUEERRHOLD));
                        lotHoldReq.setHoldUserID(objCommon.getUser().getUserID());
                        lotHoldReq.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                        lotHoldReq.setRouteID(objLotCurrentOperationInfoGetOut.getMainPDID());
                        lotHoldReq.setOperationNumber(objLotCurrentOperationInfoGetOut.getOpeNo());
                        lotHoldReq.setClaimMemo("");
                        List<Infos.LotHoldReq> holdReqList = new ArrayList<Infos.LotHoldReq>();
                        holdReqList.add(lotHoldReq);

                        lotService.sxHoldLotReq(objCommon, lotInCassette.getLotID(), holdReqList);
                    } else {
                        throw ex;
                    }
                }


                operationStartLotIds.add(lotInCassette.getLotID());
                operationStartLotCount++;

                log.debug("step55 - lotCassetteCategoryUpdateForContaminationControl");
                lotMethod.lotCassetteCategoryUpdateForContaminationControl(objCommon, lotInCassette.getLotID());
            }
        }

        log.trace("postProcForLotFlag is 【{}】,bondingEqpFlag is 【{}】",postProcForLotFlag,bondingEqpFlag);
        if (postProcForLotFlag != 1 && bondingEqpFlag) {
            /*-----------------------------*/
            /*   Make wafer Stacked        */
            /*-----------------------------*/
           log.debug("step56 - Make wafer Stacked");
            for (int grpCnt = 0; grpCnt < bondingGroupLength; grpCnt++) {
                Params.WaferStackingReqInParams waferStackingReqInParams = new Params.WaferStackingReqInParams();
                waferStackingReqInParams.setBondingGroupID(bondingGroupInfoList.get(grpCnt).getBondingGroupID());
                waferStackingReqInParams.setClaimMemo(opeComWithDataReqParams.getOpeMemo());
                bondService.sxWaferStackingReq(objCommon, waferStackingReqInParams);
            }
        }

        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            /*----------------------------------------------------------------------------*/
            /*   lot FutureHold Post By Previous Operation Effect after Operation Move    */
            /*----------------------------------------------------------------------------*/
            log.trace("lot FutureHold Post By Previous Operation Effect after Operation Move");

            for (int i = 0; i < CimArrayUtils.getSize(objLotFutureHoldRequestsEffectByConditionOuts); i++) {
                Outputs.ObjLotFutureHoldRequestsEffectByConditionOut objLotFutureHoldRequestsEffectByConditionOut = objLotFutureHoldRequestsEffectByConditionOuts.get(i);
                if (CimArrayUtils.getSize(objLotFutureHoldRequestsEffectByConditionOut.getStrLotHoldReqList()) > 0) {
                    log.trace("strLotHoldReqList.length() > 0");
                    /*-----------------------------------------------------*/
                    /*   Convert OpeNo, RouteID from previous to current   */
                    /*-----------------------------------------------------*/
                    log.trace("Convert OpeNo, RouteID from previous to current");
                    ObjectIdentifier lotId = objLotFutureHoldRequestsEffectByConditionOut.getLotID();
                    List<Infos.LotHoldReq> lotHoldReqList = objLotFutureHoldRequestsEffectByConditionOut.getStrLotHoldReqList();

                    log.debug("step57 - lotFutureHoldEffectedProcessConversion");
                    Outputs.ObjLotFutureHoldEffectedProcessConversionOut objLotFutureHoldEffectedProcessConversionOut
                            = lotMethod.lotFutureHoldEffectedProcessConversion(objCommon, lotId, lotHoldReqList);


                    log.debug("step58 - hold lot");
                    try {
                        lotService.sxHoldLotReq(objCommon, lotId, objLotFutureHoldEffectedProcessConversionOut.getLotHoldReqList());

                    } catch (ServiceException ex) {
                        if (!Validations.isEquals(retCodeConfig.getExistSameHold(), ex.getCode())) {
                            throw ex;

                        }
                    }

                }
            }
        }

        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            /*-------------------------------------------*/
            /*   Effect PO's Direction for TEL Furnace   */
            /*-------------------------------------------*/
            log.debug("step59 - Effect PO's Direction for TEL Furnace");
            List<Infos.LotHoldEffectList> effectRetCode = lotMethod.lotHoldRecordEffectMonitorIssue(objCommon, bondingEqpFlag ? baseStartCassettes : startCassettes);

            int nMonitorHoldEffectLen = CimArrayUtils.getSize(effectRetCode);
            if (nMonitorHoldEffectLen > 0) {
                List<Infos.LotHoldReq> lotHoldReqList = new ArrayList<>();
                Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                lotHoldReqList.add(lotHoldReq);
                for (int i = 0; i < nMonitorHoldEffectLen; i++) {
                    Infos.LotHoldEffectList lotHoldEffectList = effectRetCode.get(i);
                    lotHoldReq.setHoldType(lotHoldEffectList.getHoldType());
                    lotHoldReq.setHoldReasonCodeID(lotHoldEffectList.getReasonCodeID());
                    lotHoldReq.setHoldUserID(lotHoldEffectList.getUserID());
                    lotHoldReq.setResponsibleOperationMark(lotHoldEffectList.getResponsibleOperationMark());
                    lotHoldReq.setRouteID(lotHoldEffectList.getRouteID());
                    lotHoldReq.setOperationNumber(lotHoldEffectList.getOperationNumber());
                    lotHoldReq.setRelatedLotID(lotHoldEffectList.getRelatedLotID());
                    lotHoldReq.setClaimMemo(lotHoldEffectList.getClaimMemo());

                    log.debug("step60 - hold lot");
                    try {
                        lotService.sxHoldLotReq(objCommon, lotHoldEffectList.getLotID(),
                                lotHoldReqList);
                    } catch (ServiceException ex) {
                        if (!Validations.isEquals(retCodeConfig.getExistSameHold(), ex.getCode())) {
                            throw ex;
                        }
                    }

                }
            }
        }

        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            /*------------------------------------------*/
            /*   Effect Future Hold Direction if Exist  */
            /*------------------------------------------*/
            for (int i = 0; i < startCassettesLength; i++) {
                List<Infos.LotInCassette> lotInCassetteList = startCassettes.get(i).getLotInCassetteList();
                for (int j = 0; j < lotInCassetteList.size(); j++) {
                    Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                    /*---------------------------*/
                    /*   Omit Not-OpeStart lot   */
                    /*---------------------------*/
                    log.trace("MoveInFlag is 【{}】",lotInCassetteList.get(j).getMoveInFlag());
                    if (CimBooleanUtils.isFalse(lotInCassetteList.get(j).getMoveInFlag())) {
                        continue;
                    }

                    log.trace("bondingEqpFlag is 【{}】",bondingEqpFlag);
                    if (bondingEqpFlag) {
                        boolean isTopLot = false;
                        for (int k = 0; k < topLotLength; k++) {
                            if (objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq().get(k).equals(lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }
                        }

                        if (isTopLot) {
                            log.trace("lot " + lotInCassette.getLotID() + " is Top lot.");
                            continue;
                        }
                    }

                    /*------------------------------------------------------------------*/
                    /*   Get Effected Future Hold PRE of Current after Operation Move   */
                    /*------------------------------------------------------------------*/
                    log.info("Get Effected Future Hold PRE of Current after Operation Move");
                    Infos.EffectCondition effectCondition = new Infos.EffectCondition();
                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_PRE);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);

                    log.debug("step61 - lotFutureHoldRequestsEffectByCondition");
                    Outputs.ObjLotFutureHoldRequestsEffectByConditionOut objLotFutureHoldRequestsEffectByConditionOut
                            = lotMethod.lotFutureHoldRequestsEffectByCondition(objCommon, lotInCassette.getLotID(), effectCondition);


                    List<Infos.LotHoldReq> lotHoldReqList = objLotFutureHoldRequestsEffectByConditionOut.getStrLotHoldReqList();
                    if (lotHoldReqList != null && lotHoldReqList.size() > 0) {
                        log.trace("lotHoldReqList.strLotHoldReqList.length() > 0");

                        log.debug("step62 - hold lot");
                        try {
                            lotService.sxHoldLotReq(objCommon, lotInCassette.getLotID(), objLotFutureHoldRequestsEffectByConditionOut.getStrLotHoldReqList());

                        } catch (ServiceException ex) {
                            if (!Validations.isEquals(retCodeConfig.getExistSameHold(), ex.getCode())) {
                                log.info("txHoldLotReq() != RC_OK");
                                throw ex;
                            }
                        }

                    }
                    /*------------------------------------------------------------------------------------*/
                    /*   Get Effected Future Hold Cancel PRE and SINGLE of Current after Operation Move   */
                    /*------------------------------------------------------------------------------------*/
                    log.trace("Get Effected Future Hold Cancel PRE and SINGLE of Current after Operation Move");

                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_PRE);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_SINGLE);

                    log.debug("step63 - lotFutureHoldRequestsDeleteEffectedByCondition");
                    Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut objLotFutureHoldRequestsDeleteEffectedByConditionOut
                            = lotMethod.lotFutureHoldRequestsDeleteEffectedByCondition(objCommon, lotInCassette.getLotID(), effectCondition);


                    List<Infos.LotHoldReq> futureHoldReleaseReqList = objLotFutureHoldRequestsDeleteEffectedByConditionOut.getStrFutureHoldReleaseReqList();
                    if (futureHoldReleaseReqList != null && futureHoldReleaseReqList.size() > 0) {
                        log.trace("futureHoldReleaseReqList.strFutureHoldReleaseReqList.length() > 0");

                        log.debug("step64 - cancel future hold");
                        processControlService.sxFutureHoldCancelReq(objCommon, lotInCassette.getLotID(), new ObjectIdentifier(releaseReasonCodeId),
                                BizConstant.SP_ENTRYTYPE_REMOVE, objLotFutureHoldRequestsDeleteEffectedByConditionOut.getStrFutureHoldReleaseReqList());

                    }
                }
            }
        }

        /*----------------------------------------------------*/
        /*   eqp Related Information Update Procedure   */
        /*----------------------------------------------------*/
        log.trace("virtualOperationFlag is 【{}】",virtualOperationFlag);
        if (!virtualOperationFlag) {
            /*----------------------------------------------------------------*/
            /*   Remove ControlJobLot from EqpInfo's ProcessingLot Sequence   */
            /*----------------------------------------------------------------*/
            log.debug("step65 - delete equipment processing lot");
            equipmentMethod.equipmentProcessingLotDelete(objCommon, opeComWithDataReqParams.getEquipmentID(), startCassettes);
        }

        /*---------------------------------------------*/
        /*   Maintain Eqp's Status when OFF-LINE Mode  */
        /*---------------------------------------------*/
        log.trace("OnlineMode is 【{}】",objPortResourceCurrentOperationModeGetOut.getOperationMode().getOnlineMode());
        if (BizConstant.SP_EQP_ONLINEMODE_OFFLINE.equals(objPortResourceCurrentOperationModeGetOut.getOperationMode().getOnlineMode())) {
            /*--------------------------------------------------------*/
            /*   Change eqp's Status to 'STANDBY' if necessary  */
            /*--------------------------------------------------------*/
            log.debug("step66 - Change eqp's Status to 'STANDBY' if necessary");
            Boolean objEquipmentCurrentStateCheckToManufacturingOut = equipmentMethod.equipmentCurrentStateCheckToManufacturing(objCommon, opeComWithDataReqParams.getEquipmentID());

            log.trace("objEquipmentCurrentStateCheckToManufacturingOut is 【{}】",objEquipmentCurrentStateCheckToManufacturingOut);
            if (objEquipmentCurrentStateCheckToManufacturingOut) {
                /*===== get Default Status CimCode for Productive / Standby ===*/

                log.debug("step67 - get equipment recover state");
                ObjectIdentifier objEquipmentRecoverStateGetManufacturingOut = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, opeComWithDataReqParams.getEquipmentID());

                log.debug("step68 - change equipment status");
                Results.EqpStatusChangeReqResult eqpStateChangeResult = null;
                try {
                    eqpStateChangeResult = sxEqpStatusChangeReq(objCommon, opeComWithDataReqParams.getEquipmentID(), objEquipmentRecoverStateGetManufacturingOut, opeComWithDataReqParams.getOpeMemo());
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getInvalidStateTrans(), e.getCode())) {
                        throw e;
                    }
                }
            }
        }

        /*--------------------------------------*/
        /*   eqp Usage Limitation Check   */
        /*--------------------------------------*/
        log.debug("step69 - eqp Usage Limitation Check");
        Outputs.ObjEquipmentUsageLimitationCheckOut objEquipmentUsageLimitationCheckOut = equipmentMethod.equipmentUsageLimitationCheck(objCommon, opeComWithDataReqParams.getEquipmentID());

        log.trace("UsageLimitOverFlag is 【{}】",objEquipmentUsageLimitationCheckOut.isUsageLimitOverFlag());
        if (CimBooleanUtils.isTrue(objEquipmentUsageLimitationCheckOut.isUsageLimitOverFlag())) {
            /*-------------------------*/
            /*   Call System Message   */
            /*-------------------------*/
            log.debug("step70 - Call System Message ");
            Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
            alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
            alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_EQPUSAGELIMITOVER);
            alertMessageRptParams.setSystemMessageText(objEquipmentUsageLimitationCheckOut.getMessageText());
            alertMessageRptParams.setNotifyFlag(true);
            alertMessageRptParams.setEquipmentID(opeComWithDataReqParams.getEquipmentID());
            alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
            systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
        }

        /*-----------------------------------------------------------------------*/
        /*                          Clear container position                     */
        /*-----------------------------------------------------------------------*/
        log.trace("pstLen is 【{}】",pstLen);
        if (pstLen > 0) {
            Inputs.ObjEquipmentContainerPositionInfoClearIn objEquipmentContainerPositionInfoClearIn = new Inputs.ObjEquipmentContainerPositionInfoClearIn();
            objEquipmentContainerPositionInfoClearIn.setEquipmentID(opeComWithDataReqParams.getEquipmentID());
            objEquipmentContainerPositionInfoClearIn.setKey(opeComWithDataReqParams.getControlJobID());
            objEquipmentContainerPositionInfoClearIn.setKeyCategory(BizConstant.SP_SLM_KEYCATEGORY_CONTROLJOB);

            log.debug("step71 - equipmentContainerPositionInfoClear");
            List<ObjectIdentifier> objEquipmentContainerPositionInfoClearOut = equipmentContainerPositionMethod.equipmentContainerPositionInfoClear(objCommon, objEquipmentContainerPositionInfoClearIn);
        }

        /*-----------------------------------------------------------------------*/
        /*   Delete SLM reservation from container position                      */
        /*-----------------------------------------------------------------------*/
        log.trace("destCassetteLength is 【{}】",destCassetteLength);
        if (destCassetteLength > 0) {
            log.debug("step72 - cassetteSLMReserveEquipmentSet");
            for (int nCnt1 = 0; nCnt1 < destCassetteLength; nCnt1++) {
                cassetteMethod.cassetteSLMReserveEquipmentSet(objCommon, destCassetteList.get(nCnt1), null);
            }
        }

        /*-----------------------------------------------------------------------*/
        /*                          Delete Control Job                           */
        /*-----------------------------------------------------------------------*/
        if (!CimStringUtils.equals(objCommon.getTransactionID(), "OEQPW012")
                && !CimStringUtils.equals(objCommon.getTransactionID(), "OEQPW024")) {
            log.debug("step73 - change CJ status");
            Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
            cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE_FROM_EQP);
            cjStatusChangeReqParams.setControlJobID(opeComWithDataReqParams.getControlJobID());
            cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());

            Results.CJStatusChangeReqResult cjStatusChangeReqOut = controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);

        }

        /*---------------------------------------------------*/
        /*   cassette Related Information Update Procedure   */
        /*---------------------------------------------------*/
        for (int i = 0; i < startCassettesLength; i++) {
            /*-------------------------------------*/
            /*   cassette Usage Limitation Check   */
            /*-------------------------------------*/
            if (CimObjectUtils.isEmpty(startCassettes.get(i).getCassetteID())) {
                break;
            }
            log.debug("step74 - cassette Usage Limitation Check");
            Outputs.ObjCassetteUsageLimitationCheckOut objCassetteUsageLimitationCheckOut = cassetteMethod.cassetteUsageLimitationCheck(objCommon, startCassettes.get(i).getCassetteID());

            if (objCassetteUsageLimitationCheckOut.isUsageLimitOverFlag()) {
                log.debug("step75 - alert message");
                Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_CASTUSAGELIMITOVER);
                alertMessageRptParams.setSystemMessageText(objCassetteUsageLimitationCheckOut.getMessageText());
                alertMessageRptParams.setNotifyFlag(true);
                alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
            }

            /*---------------------------------------*/
            /*   Update cassette's MultiLotType      */
            /*---------------------------------------*/

            log.debug("step76 - Update cassette's MultiLotType");
            cassetteMethod.cassetteMultiLotTypeUpdate(objCommon, startCassettes.get(i).getCassetteID());
        }

        //-------------------------------------------------//
        //   ProcessLagTime Information Update Procedure   //
        //-------------------------------------------------//
        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            for (int i = 0; i < startCassettesLength; i++) {
                List<Infos.LotInCassette> lotInCassetteList = startCassettes.get(i).getLotInCassetteList();

                for (int j = 0; j < lotInCassetteList.size(); j++) {
                    Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    if (bondingEqpFlag) {
                        boolean isTopLot = false;
                        for (int lotCount = 0; lotCount < topLotLength; lotCount++) {
                            if (objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq().get(lotCount).equals(lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }
                        }

                        if (isTopLot) {
                            continue;
                        }
                    }

                    log.debug("step77 - update process lag time");
                    Params.LagTimeActionReqParams lagTimeActionReqParams = new Params.LagTimeActionReqParams();
                    lagTimeActionReqParams.setUser(objCommon.getUser());
                    lagTimeActionReqParams.setLotID(lotInCassette.getLotID());
                    lagTimeActionReqParams.setAction(BizConstant.SP_PROCESSLAGTIME_ACTION_SET);
                    processControlService.sxProcessLagTimeUpdate(objCommon, lagTimeActionReqParams);
                }
            }
        }

        //-----------------------//
        //     Process Hold      //
        //-----------------------//
        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            //-----------------------//
            //     Process Hold      //
            //-----------------------//
            log.debug("step78 - Process Hold");
            for (int i = 0; i < startCassettesLength; i++) {
                List<Infos.LotInCassette> lotInCassetteList = startCassettes.get(i).getLotInCassetteList();

                for (int j = 0; j < lotInCassetteList.size(); j++) {
                    Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    if (bondingEqpFlag) {
                        boolean isTopLot = false;

                        for (int lotCount = 0; lotCount < topLotLength; lotCount++) {
                            if (objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq().get(lotCount).equals(lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }

                            if (isTopLot) {
                                continue;
                            }
                        }
                    }
                    processControlService.sxProcessHoldDoActionReq(objCommon, lotInCassette.getLotID(), opeComWithDataReqParams.getOpeMemo());
                }
            }
        }

        String eventId;
        if (CimStringUtils.equals(objCommon.getTransactionID(), "OEQPW012")
                || CimStringUtils.equals(objCommon.getTransactionID(), "OEQPW024")) {
            eventId = objCommon.getTransactionID();
        } else {
            eventId = "OEQPW006";
        }

        /*--------------------------*/
        /*   Event Make Procedure   */
        /*--------------------------*/
        for (int i = 0; i < startCassettesLength; i++) {
            Infos.StartCassette startCassette = startCassettes.get(i);
            List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
            int nLen = CimArrayUtils.getSize(strLotInCassette);
            for (int j = 0; j < nLen; j++) {

                Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                if (!BaseStaticMethod.isTrue(lotInCassette.getMoveInFlag())) {
                    continue;
                }

                RetCode<Object> strLotOperationMoveEventMakeOpeCompOut;

                log.debug("step79 - Event Make Procedure");
                Inputs.LotOperationMoveEventMakeOpeComp lotOperationMoveEventMakeOpeComp = new Inputs.LotOperationMoveEventMakeOpeComp();
                lotOperationMoveEventMakeOpeComp.setTransactionID(eventId);
                lotOperationMoveEventMakeOpeComp.setEquipmentID(opeComWithDataReqParams.getEquipmentID());
                lotOperationMoveEventMakeOpeComp.setOperationMode(CimObjectUtils.getObjectValue(objPortResourceCurrentOperationModeGetOut.getOperationMode().getOperationMode()));
                lotOperationMoveEventMakeOpeComp.setControlJobID(opeComWithDataReqParams.getControlJobID());
                lotOperationMoveEventMakeOpeComp.setCassetteID(startCassette.getCassetteID());
                lotOperationMoveEventMakeOpeComp.setLotInCassette(lotInCassette);
                lotOperationMoveEventMakeOpeComp.setClaimMemo(opeComWithDataReqParams.getOpeMemo());
                eventMethod.lotOperationMoveEventMakeOpeComp(
                        objCommon,
                        lotOperationMoveEventMakeOpeComp
                );
            }
        }

        Results.EDCWithSpecCheckActionReqResult edcWithSpecCheckActionReqResultRetCode = null;
        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            /*------------------------------------------*/
            /*   Invoking Action for Collected Data.    */
            /*------------------------------------------*/
            log.debug("step80 - Invoking Action for Collected Data");
            Infos.EDCWithSpecCheckActionReqInParm specCheckActionReqInParm = new Infos.EDCWithSpecCheckActionReqInParm();
            specCheckActionReqInParm.setEquipmentID(opeComWithDataReqParams.getEquipmentID());
            specCheckActionReqInParm.setControlJobID(opeComWithDataReqParams.getControlJobID());
            specCheckActionReqInParm.setStrStartCassette(startCassettes);
            edcWithSpecCheckActionReqResultRetCode = engineerDataCollectionService.sxEDCWithSpecCheckActionReq(objCommon,
                    specCheckActionReqInParm,
                    opeComWithDataReqParams.getOpeMemo());

            opeComWithDataReqParams.setHoldReleasedLotIDs(edcWithSpecCheckActionReqResultRetCode.getHoldReleasedLotIDs());
        } else {
            //     DataValue CheckValidity for SpeckCheck      //
            Outputs.ObjDataValueCheckValidityForSpecCheckDrOut strDataValueCheckValidityForSpecCheckDROut =
                    new Outputs.ObjDataValueCheckValidityForSpecCheckDrOut();
            strDataValueCheckValidityForSpecCheckDROut.setEquipmentID(equipmentID);
            strDataValueCheckValidityForSpecCheckDROut.setControlJobID(controlJobID);
            strDataValueCheckValidityForSpecCheckDROut.setStartCassetteList(startCassettes);

            /*   Loop for startCassettes   */
            for (int i = 0; i < scLen; i++) {
                /*-------------------------------*/
                /*   Loop for strLotInCassette   */
                /*-------------------------------*/
                int lcLen = CimArrayUtils.getSize(strDataValueCheckValidityForSpecCheckDROut
                        .getStartCassetteList()
                        .get(i).getLotInCassetteList());
                for (int j = 0; j < lcLen; j++) {
                    final Infos.LotInCassette lotInCassette = strDataValueCheckValidityForSpecCheckDROut
                            .getStartCassetteList()
                            .get(i).getLotInCassetteList()
                            .get(j);
                    /*------------------------*/
                    /*   Omit Not-Start Lot   */
                    /*------------------------*/
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    /*---------------------------------*/
                    /*   Omit Non-DataClooection Lot   */
                    /*---------------------------------*/
                    if (CimBooleanUtils.isFalse(lotInCassette.getStartRecipe().getDataCollectionFlag())) {
                        continue;
                    }

                    /*-----------*/
                    /*   Clear   */
                    /*-----------*/
                    int dcLen = CimArrayUtils.getSize(lotInCassette.getStartRecipe().getDcDefList());
                    for (int n = 0; n < dcLen; n++) {
                        int itLen = CimArrayUtils.getSize(lotInCassette.getStartRecipe().getDcDefList()
                                .get(n).getDcItems());
                        for (int l = 0; l < itLen; l++) {
                            boolean bClearFlag = TRUE;

                            final Infos.DataCollectionItemInfo itemInfo = lotInCassette.getStartRecipe().getDcDefList()
                                    .get(n).getDcItems()
                                    .get(l);
                            final String measurementType = itemInfo.getMeasurementType();
                            final String specCheckResult = itemInfo.getSpecCheckResult();

                            if (CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJ, measurementType)
                                    || CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJWAFER, measurementType)
                                    || CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJWAFERSITE, measurementType)) {
                                if (0 < CimStringUtils.length(specCheckResult)) {
                                    if (CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_OK, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_UPPERCONTROLLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERCONTROLLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_UPPERSPECLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERSPECLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_UPPERSCREENLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERSCREENLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_APCERROR, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_ASTERISK, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_POUND, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_ERROR, specCheckResult)) {
                                        log.trace("Do Nothing");
                                    } else {
                                        bClearFlag = FALSE;
                                    }
                                }
                            }
                            log.trace("bClearFlag is 【{}】",bClearFlag);
                            if (bClearFlag) {
                                /*===== Clear specCheckResult / actionCode =====*/
                                if (log.isDebugEnabled()) {
                                    log.debug("Clear specCheckResult / actionCode...");
                                }
                                itemInfo.setSpecCheckResult("");
                                itemInfo.setActionCodes("");

                                /*===== Clear dataValue =====*/
                                if (log.isDebugEnabled()) {
                                    log.debug("Clear dataValue...");
                                }
                                if (CimStringUtils.equals(itemInfo.getItemType(), BizConstant.SP_DCDEF_ITEM_RAW)) {
                                    if (log.isDebugEnabled()) {
                                        log.debug("Raw Item. continue...");
                                    }
                                    continue;
                                }
                                itemInfo.setDataValue("");
                            }
                        }
                    }
                }
            }

            /*----------------------------------*/
            /*   Set Initialized Data into PO   */
            /*----------------------------------*/
            log.debug("step81 - set process operation tamp data");
            processMethod.processOperationTempDataSet(
                    objCommon,
                    controlJobID,
                    strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList());

            /*------------------------------------------------*/
            /*   Set DC Spec's detailed information into PO   */
            /*------------------------------------------------*/
            List<Infos.StartCassette> strProcessDataCollectionSpecificationSetOut;

            log.debug("step82 - set process data collection specification");
            strProcessDataCollectionSpecificationSetOut = processMethod.processDataCollectionSpecificationSet(
                    objCommon,
                    strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList());
            strDataValueCheckValidityForSpecCheckDROut.setStartCassetteList(strProcessDataCollectionSpecificationSetOut);

            /*--------------------*/
            /*   Validity Check   */
            /*--------------------*/
            log.debug("step83 - dataValueCheckValidityForSpecCheckDR");
            try {
                dataValueMethod.dataValueCheckValidityForSpecCheckDR(objCommon,
                        strDataValueCheckValidityForSpecCheckDROut.getEquipmentID(),
                        strDataValueCheckValidityForSpecCheckDROut.getControlJobID(),
                        strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList());
            } catch (ServiceException ex) {
                if (!Validations.isEquals(ex.getCode(), retCodeConfig.getAllDataValAsterisk())) {
                    throw ex;
                }
            }
            if (!TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.equals(objCommon.getTransactionID())
                    && !TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.equals(objCommon.getTransactionID())) {
                //---------------------------------------------//
                //   Delete Control Job From Lot and Cassette  //
                //---------------------------------------------//
                Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
                cjStatusChangeReqParams.setControlJobID(controlJobID);
                cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE_FROM_LOTANDCASSETTE);
                cjStatusChangeReqParams.setClaimMemo(opeComWithDataReqParams.getOpeMemo());

                log.debug("step84 - change CJ status");
                controlJobProcessJobService.sxCJStatusChangeReqService(
                        objCommon,
                        cjStatusChangeReqParams);
            }
        }

        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            /*-----------------------------*/
            /*   Future Action Procedure   */
            /*-----------------------------*/
            for (int i = 0; i < startCassettesLength; i++) {
                Infos.StartCassette startCassette = startCassettes.get(i);
                List<Infos.LotInCassette> lotInCassettes = startCassette.getLotInCassetteList();

                for (int j = 0; j < lotInCassettes.size(); j++) {
                    Infos.LotInCassette lotInCassette = lotInCassettes.get(j);
                    /*---------------------------*/
                    /*   Omit Not-OpeStart lot   */
                    /*---------------------------*/

                    log.trace("MoveInFlag is 【{}】",lotInCassette.getMoveInFlag());
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }

                    log.trace("bondingEqpFlag is 【{}】",bondingEqpFlag);
                    if (bondingEqpFlag) {
                        boolean isTopLot = false;
                        for (int k = 0; k < topLotLength; k++) {
                            if (objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq().get(k).equals(lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }
                        }

                        log.trace("isTopLot is 【{}】",isTopLot);
                        if (isTopLot) {
                            log.info("lot " + lotInCassette.getLotID() + " is Top lot.");
                            continue;
                        }
                    }

                    String tmpRouteID = startCassettes.get(i).getLotInCassetteList().get(j).getStartOperationInfo().getProcessFlowID().getValue();
                    Outputs.ObjSchdlChangeReservationCheckForActionDROut strSchdlChangeReservationCheckForActionOut;
                    Inputs.ObjSchdlChangeReservationCheckForActionDRIn strSchdlChangeReservationCheckForActionDRIn = new Inputs.ObjSchdlChangeReservationCheckForActionDRIn();
                    strSchdlChangeReservationCheckForActionDRIn.setLotID(startCassettes.get(i).getLotInCassetteList().get(j).getLotID());
                    strSchdlChangeReservationCheckForActionDRIn.setRouteID(tmpRouteID);
                    strSchdlChangeReservationCheckForActionDRIn.setOperationNumber(startCassettes.get(i).getLotInCassetteList().get(j).getStartOperationInfo().getOperationNumber());

                    log.debug("step85 - schdlChangeReservationCheckForActionDR");
                    strSchdlChangeReservationCheckForActionOut = scheduleChangeReservationMethod.schdlChangeReservationCheckForActionDR(
                            objCommon,
                            strSchdlChangeReservationCheckForActionDRIn);

                    log.trace("ExistFlag is 【{}】",strSchdlChangeReservationCheckForActionOut.isExistFlag());
                    if (strSchdlChangeReservationCheckForActionOut.isExistFlag()) {
                        // pptLotPlanChangeReserveDoActionReqResult strLotPlanChangeReserveDoActionReqResult;
                        List<Infos.ReScheduledLotAttributes> strRescheduledLotAttributes = new ArrayList<>(1);
                        strRescheduledLotAttributes.add(new Infos.ReScheduledLotAttributes());
                        strRescheduledLotAttributes.get(0).setLotID(startCassettes.get(i).getLotInCassetteList().get(j).getLotID());
                        strRescheduledLotAttributes.get(0).setProductID(strSchdlChangeReservationCheckForActionOut.getStrSchdlChangeReservation().getProductID());
                        strRescheduledLotAttributes.get(0).setRouteID(strSchdlChangeReservationCheckForActionOut.getStrSchdlChangeReservation().getRouteID());
                        strRescheduledLotAttributes.get(0).setCurrentOperationNumber(strSchdlChangeReservationCheckForActionOut.getStrSchdlChangeReservation().getOperationNumber());
                        strRescheduledLotAttributes.get(0).setSubLotType(strSchdlChangeReservationCheckForActionOut.getStrSchdlChangeReservation().getSubLotType());

                        ObjectIdentifier strLotCurrentRouteIDGetOut;
                        strLotCurrentRouteIDGetOut = lotMethod.lotCurrentRouteIDGet(
                                objCommon,
                                startCassettes.get(i).getLotInCassetteList().get(j).getLotID());
                        log.trace("Get current RouteID by lotID={}", strLotCurrentRouteIDGetOut.getValue());

                        strRescheduledLotAttributes.get(0).setOriginalRouteID(strLotCurrentRouteIDGetOut.getValue());
                        log.trace("OriginalRouteID={}", strRescheduledLotAttributes.get(0).getOriginalRouteID());

                        String strLotCurrentOpeNoGetOut = lotMethod.lotCurrentOpeNoGet(
                                objCommon,
                                startCassettes.get(i).getLotInCassetteList().get(j).getLotID());
                        log.trace("Get current operation No. by lotID:[opeNO.={}]", strLotCurrentOpeNoGetOut);

                        strRescheduledLotAttributes.get(0).setOriginalOperationNumber(strLotCurrentOpeNoGetOut);
                        log.trace("OroginalOperationNumber={}", strRescheduledLotAttributes.get(0).getOriginalOperationNumber());

                        log.debug("step86 - change lot plan reserve do action");
                        planService.sxLotPlanChangeReserveDoActionReq(objCommon, strRescheduledLotAttributes, strSchdlChangeReservationCheckForActionOut.getStrSchdlChangeReservation().getEventID());

                        log.debug("step87 - change schedule reservation apply count increase");
                        scheduleChangeReservationMethod.schdlChangeReservationApplyCountIncreaseDR(objCommon, strSchdlChangeReservationCheckForActionOut.getStrSchdlChangeReservation());
                    }
                }
            }
        }

        /*------------------------------------------------------------------------*/
        /*   BR Script Procedure                                                  */
        /*------------------------------------------------------------------------*/

        /*-----------------------*/
        /*   Execute BRScript    */
        /*-----------------------*/
        for (int i = 0; i < startCassettesLength; i++) {
            Infos.StartCassette startCassette = startCassettes.get(i);
            List<Infos.LotInCassette> lotInCassettes = startCassette.getLotInCassetteList();

            for (int j = 0; j < lotInCassettes.size(); j++) {
                Infos.LotInCassette lotInCassette = lotInCassettes.get(j);
                /*---------------------------*/
                /*   Omit Not-OpeStart lot   */
                /*---------------------------*/
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }

                log.trace("bondingEqpFlag is 【{}】",bondingEqpFlag);
                if (bondingEqpFlag) {
                    boolean isTopLot = false;
                    for (int k = 0; k < topLotLength; k++) {
                        if (objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq().get(k).equals(lotInCassette.getLotID())) {
                            isTopLot = true;
                            break;
                        }
                    }

                    log.trace("isTopLot is 【{}】",isTopLot);
                    if (isTopLot) {
                        log.info("lot " + lotInCassette.getLotID() + " is Top lot.");
                        continue;
                    }
                }
                /*-------------------------*/
                /*   Execute Post Script   */
                /*-------------------------*/
                Params.ProcessControlScriptRunReqParams scriptParams = new Params.ProcessControlScriptRunReqParams();
                scriptParams.setEquipmentId(equipmentID);
                scriptParams.setLotId(startCassettes.get(i).getLotInCassetteList().get(j).getLotID());
                scriptParams.setPhase(BizConstant.SP_BRSCRIPT_POST);
                scriptParams.setUser(objCommon.getUser());

                log.debug("step88 - control process script");
                processControlScriptService.sxProcessControlScriptRunReq(objCommon, scriptParams);
            }
        }

        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {

            for (int i = 0; i < operationStartLotCount; i++) {
                if (bondingEqpFlag) {
                    boolean isTopLot = false;
                    for (int j = 0; j < topLotLength; j++) {
                        if (objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq().get(j).equals(operationStartLotIds.get(i))) {
                            isTopLot = true;
                            break;
                        }
                    }
                    log.trace("isTopLot is 【{}】",isTopLot);
                    if (isTopLot) {
                        continue;
                    }
                }

                log.debug("step89 - check lot condition for auto bank in");
                boolean objLotCheckConditionForAutoBankInOut = lotMethod.lotCheckConditionForAutoBankIn(objCommon, operationStartLotIds.get(i));

                log.trace("objLotCheckConditionForAutoBankInOut is 【{}】",objLotCheckConditionForAutoBankInOut);
                if (!objLotCheckConditionForAutoBankInOut) {
                    continue;
                }

                log.debug("step90 - get lot hold state");
                String objLotHoldStateGetOut = lotMethod.lotHoldStateGet(objCommon, operationStartLotIds.get(i));

                log.trace("objLotHoldStateGetOut is 【{}】",objLotHoldStateGetOut);
                if (CimStringUtils.equals(objLotHoldStateGetOut, BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD)) {
                    //result.setReturnCode(objLotHoldStateGetOut.getReturnCode());
                    continue;
                }
                log.debug("step91 - bank in");
                bankService.sxBankInReq(objCommon, i, operationStartLotIds, opeComWithDataReqParams.getOpeMemo());
            }
        }

        /*------------------------------------------------------------------------*/
        /*   Send OpeComp Request to TCS Procedure                                */
        /*                                                                        */
        /*   - If specified portGroup's operationCompMode is Manual, OpeComp trx  */
        /*     must be sent to TCS. In TCS, if "ProcessEnd" report is not come    */
        /*     from eqp yet, OpeComp trx from MM is rejected by TCS.              */
        /*------------------------------------------------------------------------*/

        if (CimStringUtils.equals(BizConstant.SP_EQP_COMPMODE_MANUAL, objPortResourceCurrentOperationModeGetOut.getOperationMode().getMoveOutMode())) {
            if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                    && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {

                //Step91 - TCSMgr_SendMoveOutReq
//                Inputs.SendMoveOutReqIn sendMoveOutReqIn = new Inputs.SendMoveOutReqIn();
//                sendMoveOutReqIn.setControlJobID(opeComWithDataReqParams.getControlJobID());
//                sendMoveOutReqIn.setEquipmentID(opeComWithDataReqParams.getEquipmentID());
//                sendMoveOutReqIn.setSpcResultRequiredFlag(opeComWithDataReqParams.getSpcResultRequiredFlag());
//                sendMoveOutReqIn.setObjCommonIn(objCommon);
//                sendMoveOutReqIn.setRequestUserID(objCommon.getUser());
//                Outputs.SendMoveOutReqOut sendMoveOutReqOutRetCode = (Outputs.SendMoveOutReqOut) tcsMethod.sendTCSReq(TCSReqEnum.sendMoveOutReq, sendMoveOutReqIn);
                String tmpSleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue();
                String tmpRetryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue();
                Long sleepTimeValue = 0L;
                Long retryCountValue = 0L;

                log.trace("tmpSleepTimeValue length is 【{}】", CimStringUtils.length(tmpSleepTimeValue));
                if (0 == CimStringUtils.length(tmpSleepTimeValue)) {
                    sleepTimeValue = BizConstant.SP_DEFAULT_SLEEP_TIME_TCS;
                } else {
                    sleepTimeValue = BaseStaticMethod.parseToLong(tmpSleepTimeValue);
                }

                log.trace("tmpRetryCountValue length is 【{}】", CimStringUtils.length(tmpRetryCountValue));
                if (0 == CimStringUtils.length(tmpRetryCountValue)) {
                    retryCountValue = BizConstant.SP_DEFAULT_RETRY_COUNT_TCS;
                } else {
                    retryCountValue = BaseStaticMethod.parseToLong(tmpRetryCountValue);
                }

                for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                    /*--------------------------*/
                    /*    Send Request to EAP   */
                    /*--------------------------*/
                    log.debug("step92 - Send Request to EAP ");
                    IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,opeComWithDataReqParams.getUser(),opeComWithDataReqParams.getEquipmentID(),null,true);
                    if (null == eapRemoteManager) {
                        log.trace("MES not configure EAP host");
                        break;
                    }
                    try {
                        Object moveOutReqEapOut = eapRemoteManager.sendMoveOutReq(opeComWithDataReqParams);
                        log.trace("Now EAP subSystem is alive!! Go ahead");
                        break;
                    } catch (ServiceException ex) {
                        if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                            log.trace("{} {}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...", retryNum);
                            log.trace("{} {}", "now sleeping... ", sleepTimeValue);
                            if (retryNum != retryCountValue){
                                try {
                                    Thread.sleep(sleepTimeValue);
                                    continue;
                                } catch (InterruptedException e) {
                                    ex.addSuppressed(e);
                                    Thread.currentThread().interrupt();
                                    throw ex;
                                }
                            }else {
                                Validations.check(true,retCodeConfig.getTcsNoResponse());
                            }
                        } else {
                            Validations.check(true,new OmCode(ex.getCode(),ex.getMessage()));
                        }
                    }
                }
            }
        }

        if (CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                && CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
            /*------------------------------------------------------------------------*/
            /*   Send OpeComp Report to DCS Procedure                                 */
            /*------------------------------------------------------------------------*/
            //TODO: Step92 - DCSMgr_SendOperationCompletedRpt
        }

        boolean bActionTriggerFlag = false;
        List<Infos.APCRunTimeCapabilityResponse> apcRunTimeCapabilityResponseList = controlJobMethod.controlJobAPCRunTimeCapabilityGetDR(objCommon, controlJobID);
        int response_cnt = CimArrayUtils.getSize(apcRunTimeCapabilityResponseList);
        for (int loop_response_cnt = 0; loop_response_cnt < response_cnt; loop_response_cnt++) {
            List<Infos.APCRunTimeCapability> strAPCRunTimeCapability = apcRunTimeCapabilityResponseList.get(loop_response_cnt).getStrAPCRunTimeCapability();
            int capability_cnt = CimArrayUtils.getSize(strAPCRunTimeCapability);
            for (int loop_capability_cnt = 0; loop_capability_cnt < capability_cnt; loop_capability_cnt++) {
                Infos.APCRunTimeCapability apcRunTimeCapability = strAPCRunTimeCapability.get(loop_capability_cnt);
                List<Infos.APCBaseAPCSystemFunction1> strAPCBaseAPCSystemFunction1 = apcRunTimeCapability.getStrAPCBaseAPCSystemFunction1();
                int function_cnt = CimArrayUtils.getSize(strAPCBaseAPCSystemFunction1);
                for (int loop_function_cnt = 0; loop_function_cnt < function_cnt; loop_function_cnt++) {
                    if (CimStringUtils.equals(strAPCBaseAPCSystemFunction1.get(loop_function_cnt).getType(), BizConstant.SP_APCFUNCTIONTYPE_PRODUCTDISPOSITION)) {
                        bActionTriggerFlag = true;
                        break;
                    }
                }
            }
        }
        log.trace("bActionTriggerFlag is 【{}】",bActionTriggerFlag);
        if (!bActionTriggerFlag) {
            /*-----------------------------------------------------*/
            /*   Call APCRuntimeCapability_DeleteDR                */
            /*-----------------------------------------------------*/
            log.debug("step93 - call apcRuntimeCapabilityDeleteDR");
            apcMethod.apcRuntimeCapabilityDeleteDR(objCommon, controlJobID);
        }

        if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
            /*-------------------------------------------------*/
            /*   Call APCMgr_SendControlJobInformationDR       */
            /*-------------------------------------------------*/
            log.debug("step94 - call APCMgrSendControlJobInformationDR");
            int retCode2 = 0;
            try {
                apcMethod.APCMgrSendControlJobInformationDR(objCommon, equipmentID, controlJobID, BizConstant.SP_APC_CONTROLJOBSTATUS_COMPLETED, apcBaseCassettes);
            } catch (ServiceException e) {
                retCode2 = e.getCode();
                if (!Validations.isEquals(retCodeConfigEx.getOkNoIF(), e.getCode())) {
                    throw e;
                }
            }
            log.trace("retCode2 is 【{}】",retCode2);
            if (retCode2 == 0) {
                String tmpString = opeComWithDataReqParams.getApcifControlStatus();
                opeComWithDataReqParams.setApcifControlStatus(BizConstant.SP_APC_CONTROLJOBSTATUS_EXECUTING);
            }
        } else {
            opeComWithDataReqParams.setApcBaseCassetteListForOpeComp(apcBaseCassettes);
        }

        /*--------------------------------------*/
        /*  Update Reticle's LastUsedTimestamp  */
        /*--------------------------------------*/
        log.debug("step95 - Update Reticle's LastUsedTimestamp");
        reticleMethod.reticleLastUsedTimeStampUpdate(objCommon, objControlJobStartReserveInformationGetOut.getStartCassetteList());


        log.debug("step96 - change constraint exception lot for operation comp");
        Inputs.ObjEntityInhibitExceptionLotChangeForOpeCompIn inputs = new Inputs.ObjEntityInhibitExceptionLotChangeForOpeCompIn();
        inputs.setControlJobID(opeComWithDataReqParams.getControlJobID());
        List<ObjectIdentifier> lotIDList = new ArrayList<>(operationStartLotIds);
        inputs.setLotIDs(lotIDList);
        constraintMethod.constraintExceptionLotChangeForOpeComp(objCommon, inputs.getLotIDs(), inputs.getControlJobID());

        /*----------------------*/
        /*                      */
        /*   Return to Caller   */
        /*                      */
        /*----------------------*/
        log.trace("postProcForLotFlag is 【{}】",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            out = edcWithSpecCheckActionReqResultRetCode.getMoveOutReqResult();
        } else {
            Results.MoveOutReqResult moveOutReqResult = new Results.MoveOutReqResult();
            List<Infos.OpeCompLot> opeCompLotList = operationStartLotIds.stream().map(loID -> {
                Infos.OpeCompLot opeCompLot = new Infos.OpeCompLot();
                opeCompLot.setLotID(loID);
                return opeCompLot;
            }).collect(Collectors.toList());
            moveOutReqResult.setMoveOutLot(opeCompLotList);
            out = moveOutReqResult;
        }

        log.debug("step97 - check contamination level and pr flag after move out");
        List<ObjectIdentifier> lotIds = startCassettes.parallelStream()
                .flatMap(startCassette -> startCassette.getLotInCassetteList().parallelStream().map(Infos.LotInCassette::getLotID))
                .collect(Collectors.toList());
        contaminationMethod.lotCheckContaminationLevelAndPrFlagStepOut(objCommon, lotIds, equipmentID);

        log.debug("step98 - add pilot run");
        pilotRunMethod.checkPilotRunCompleted(objCommon, startCassettes);
        return out;
    }

    @Override
    public Results.MoveInCancelReqResult sxMoveInCancelForIBReq(Infos.ObjCommon objCommon,
                                                                ObjectIdentifier equipmentID,
                                                                ObjectIdentifier controlJobID,
                                                                List<Infos.ApcBaseCassette> apcBaseCassetteListForOpeStartCancel,
                                                                String pAPCIFControlStatus,
                                                                String pDCSIFControlStatus) {
        Results.MoveInCancelReqResult retVal = new Results.MoveInCancelReqResult();

        //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        //   Check Process
        //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        log.debug("step1 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Object Lock Process                                                 */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        log.debug("step2 - Object Lock Process");
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.OPERATION_START_CANCEL_FOR_INTERNAL_BUFFER_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        log.trace("lockMode is 【{}】",lockMode);
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step3 - lock equipment main object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            log.debug("step4 - lock object equipment");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        /*-------------------------*/
        /*   Get ControlJob Info   */
        /*-------------------------*/
        log.debug("step5 - Get Started lot information which is sepcified with controljob ID");
        Outputs.ObjControlJobStartReserveInformationOut reserveInformationResult =
                controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                        controlJobID,
                        false);

        /*---------------------------------------------------*/
        /*   Prepare strStartCassette for Working-Valiable   */
        /*---------------------------------------------------*/
        List<Infos.StartCassette> startCassetteList = reserveInformationResult.getStartCassetteList();
        int scLen = CimArrayUtils.getSize(startCassetteList);
        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();

        int lotIDCount = 0;
        int totalLotIDLength = BizConstant.SP_LOT_MAXIMUMWAFERSINALOT;

        for (int i = 0; i < startCassetteList.size(); i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            cassetteIDs.add(startCassette.getCassetteID());

            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            for (int j = 0; j < lotInCassetteList.size(); j++) {
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);

                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }

                if (lotIDCount > totalLotIDLength) {
                    totalLotIDLength = totalLotIDLength + Integer.valueOf(BizConstant.SP_LOT_MAXIMUMWAFERSINALOT);

                }

                lotIDs.add(lotInCassette.getLotID());
            }
        }
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step6 - get equipment online mode");
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                log.debug("step7 - add advanced object lock");
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            List<String> procLotSeq = lotIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            log.debug("step8 - add advanced object lock");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, procLotSeq));

            List<String> loadCassettes = new ArrayList<>();
            for (int i = 0; i < cassetteIDs.size(); i++) {
                log.debug("step9 - get ctte location info");
                Infos.LotLocationInfo lotLocationInfo = cassetteMethod.cassetteLocationInfoGetDR(cassetteIDs.get(i));
                if (CimStringUtils.equals(lotLocationInfo.getTransferStatus(), BizConstant.SP_TRANSSTATE_EQUIPMENTIN)
                        && ObjectIdentifier.equalsWithValue(lotLocationInfo.getEquipmentID(), equipmentID)) {
                    // this cassette is load on equipment
                    loadCassettes.add(cassetteIDs.get(i).getValue());
                }
            }
            log.debug("step10 - Lock Equipment LoadCassette Element (Read)");
            if (!CimArrayUtils.isEmpty(loadCassettes)) {
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ, loadCassettes));
            }
            /*------------------------------*/
            /*   Lock Material Location     */
            /*------------------------------*/
            log.debug("step11 - Lock Material Location ");
            for (int i = 0; i < scLen; i++) {
                Inputs.ObjAdvancedObjectLockForEquipmentResourceIn objAdvancedObjectLockForEquipmentResourceIn = new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
                objAdvancedObjectLockForEquipmentResourceIn.setEquipmentID(equipmentID);
                objAdvancedObjectLockForEquipmentResourceIn.setClassName(BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCJ);
                objAdvancedObjectLockForEquipmentResourceIn.setObjectID(controlJobID);
                objAdvancedObjectLockForEquipmentResourceIn.setObjectLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
                objAdvancedObjectLockForEquipmentResourceIn.setBufferResourceName(startCassetteList.get(i).getLoadPurposeType());
                objAdvancedObjectLockForEquipmentResourceIn.setBufferResourceLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);
                objectLockMethod.advancedObjectLockForEquipmentResource(objCommon, objAdvancedObjectLockForEquipmentResourceIn);
            }
            log.debug("step12 - add object lock");
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
        } else {
            log.debug("step13 - Lock All port Object for internal Buffer eqp.");
            Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon, equipmentID);
            List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo.getEqpPortStatuses();
            int lenPortInfo = CimArrayUtils.getSize(eqpPortStatuses);
            for (int j = 0; j < lenPortInfo; j++) {
                log.debug("step14 - lock equipment resource");
                objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, eqpPortStatuses.get(j).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            }
        }
        /*------------------------------*/
        /*   Lock cassette/lot Object   */
        /*------------------------------*/
        log.debug("step15 - Lock cassette Object");
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);

        log.debug("step16 - Lock lot Object");
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, lotIDs);
        int eqpMonitorSwitch = StandardProperties.OM_AUTOMON_FLAG.getIntValue();
        if (1 == eqpMonitorSwitch) {
            List<ObjectIdentifier> eqpMonitorList = new ArrayList<>();
            List<Infos.EqpMonitorJobInfo> strEqpMonitorJobInfoSeq = new ArrayList<>();
            int eqpMonitorCnt = 0;
            int eqpMonJobCnt = 0;
            int castLen = CimArrayUtils.getSize(startCassetteList);
            for (int i = 0; i < castLen; i++) {
                List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(i).getLotInCassetteList();
                int lotLen = CimArrayUtils.getSize(lotInCassetteList);
                for (int j = 0; j < lotLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(lotInCassetteList.get(j).getMoveInFlag())) {
                        continue;
                    }
                    if (!CimStringUtils.equals(lotInCassetteList.get(j).getLotType(), BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                            && !CimStringUtils.equals(lotInCassetteList.get(j).getLotType(), BizConstant.SP_LOT_TYPE_DUMMYLOT)) {
                        continue;
                    }
                    log.debug("step17 - get eqp monitor section information");
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut objEquipmentMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassetteList.get(j).getLotID());
                    if (!ObjectIdentifier.isEmptyWithValue(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                        if (CimStringUtils.equals(objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)) {
                            boolean bNewEqpMonitor = true;
                            for (int iCnt1 = 0; iCnt1 < eqpMonitorCnt; iCnt1++) {
                                if (ObjectIdentifier.equalsWithValue(eqpMonitorList.get(iCnt1), objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID())) {
                                    bNewEqpMonitor = false;
                                    break;
                                }
                            }
                            if (bNewEqpMonitor) {
                                eqpMonitorList.add(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                eqpMonitorCnt++;
                            }
                        }
                        if (CimStringUtils.equals(objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)
                                || CimBooleanUtils.isTrue(objEquipmentMonitorSectionInfoGetForJobOut.isExitFlag())) {
                            boolean bNewEqpMonJob = true;
                            for (int iCnt2 = 0; iCnt2 < eqpMonJobCnt; iCnt2++) {
                                if (ObjectIdentifier.equalsWithValue(strEqpMonitorJobInfoSeq.get(iCnt2).getEqpMonitorJobID(), objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                                    bNewEqpMonJob = false;
                                    break;
                                }
                            }
                            if (bNewEqpMonJob) {
                                Infos.EqpMonitorJobInfo eqpMonitorJobInfo = new Infos.EqpMonitorJobInfo();
                                eqpMonitorJobInfo.setEqpMonitorID(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                eqpMonitorJobInfo.setEqpMonitorJobID(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());
                                strEqpMonitorJobInfoSeq.add(eqpMonitorJobInfo);
                                eqpMonJobCnt++;
                            }
                        }
                    }
                }
            }
            log.debug("step18 - lock equipment monitor");
            for (int iCnt3 = 0; iCnt3 < eqpMonitorCnt; iCnt3++) {
                objectLockMethod.objectLock(objCommon, CimEqpMonitor.class, eqpMonitorList.get(iCnt3));
            }
            log.debug("step19 - lock equipment monitor job");
            for (int iCnt4 = 0; iCnt4 < eqpMonJobCnt; iCnt4++) {
                objectLockMethod.objectLockForEqpMonitorJob(objCommon, strEqpMonitorJobInfoSeq.get(iCnt4).getEqpMonitorID(), strEqpMonitorJobInfoSeq.get(iCnt4).getEqpMonitorJobID());
            }
        }

        log.debug("step20 - add season by ho");
        seasoningService.sxSeasonForMoveInCancel(objCommon, equipmentID, controlJobID);

        log.debug("step21 - call cassetteAPCInformationGetDR");
        List<Infos.ApcBaseCassette> apcBaseCassettes = null;
        try {
            apcBaseCassettes = cassetteMethod.cassetteAPCInformationGetDR(objCommon, equipmentID, startCassetteList);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getSystemError(), e.getCode())) {
                throw e;
            }
        }

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*   Check Process                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

        /*------------------------------------*/
        /*   Get and Check Cassette on Port   */
        /*------------------------------------*/
        log.debug("step22 - Get and Check cassette on port");
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID);
        /*---------------------------------*/
        /*   Get Equipment's Online Mode   */
        /*---------------------------------*/
        List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo.getEqpPortStatuses();
        log.trace("eqpPortStatuses is 【{}】",eqpPortStatuses);
        if (CimArrayUtils.isEmpty(eqpPortStatuses)) {
            throw new ServiceException(retCodeConfig.getNotFoundPort());
        }

        log.debug("step23 -  Get eqp's Online Mode");
        Outputs.ObjPortResourceCurrentOperationModeGetOut currentOperationModeOut = portMethod.portResourceCurrentOperationModeGet(objCommon, equipmentID, eqpPortStatuses.get(0).getPortID());

        Infos.OperationMode currentOperationMode = currentOperationModeOut.getOperationMode();

        /*-----------------------------------------------------------------------*/
        /*   Check Process for cassette                                          */
        /*   The following conditions are checked by this object                 */
        /*   - transferState                                                     */
        /*-----------------------------------------------------------------------*/
        log.debug("step24 - Check Port's OperationMode");
        if (BizConstant.equalsIgnoreCase(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, currentOperationMode.getAccessMode())
                || BizConstant.equalsIgnoreCase(BizConstant.SP_EQP_ACCESSMODE_AUTO, currentOperationMode.getOnlineMode())) {
            cassetteMethod.cassetteCheckConditionForOpeStartCancel(objCommon, startCassetteList);
        }

        /*-----------------------------------------------------------------------*/
        /*   Check Process for lot                                               */
        /*   The following conditions are checked by this object                 */
        /*   - lotProcessState                                                   */
        /*-----------------------------------------------------------------------*/
        log.debug("step25 - Check Process for lot ");
        lotMethod.lotCheckConditionForOpeStartCancel(objCommon, startCassetteList);


        /*-----------------------------------------------------------------------*/
        /*   Check Process for eqp                                               */
        /*   The following conditions are checked by this object                 */
        /*   - All lof lot, which is contained in controlJob, must be existing   */
        /*     in the eqp's processing information.                              */
        /*-----------------------------------------------------------------------*/

        if (BizConstant.equalsIgnoreCase(BizConstant.SP_EQP_ACCESSMODE_AUTO, currentOperationMode.getAccessMode())
                || BizConstant.equalsIgnoreCase(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, currentOperationMode.getOnlineMode())) {
            log.debug("step2 - Check Port's OperationMode");
            equipmentMethod.equipmentPortStateCheckForOpeStartCancel(objCommon, equipmentID, startCassetteList);
        }

        /*-----------------------------------------------------------------------*/
        /*   Check eqp port for OpeStartCancel                                   */
        /*   The following conditions are checked by this object                 */
        /*   - All of cassette, which is contained in controlJob, must be on     */
        /*     the eqp's unloadingPort.                                          */
        /*-----------------------------------------------------------------------*/

        if (BizConstant.equalsIgnoreCase(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, currentOperationMode.getAccessMode())
                || BizConstant.equalsIgnoreCase(BizConstant.SP_EQP_ACCESSMODE_AUTO, currentOperationMode.getOnlineMode())) {
            log.debug("step27 - Check Port's OperationMode");
            equipmentMethod.equipmentPortStateCheckForOpeStartCancelForInternalBuffer(objCommon, equipmentID, startCassetteList);
        }

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*   Main Process (Reverse Order of OpeStart Procedure)                  */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

        /*--------------------------------*/
        /*                                */
        /*   CP Test Function Procedure   */
        /*                                */
        /*--------------------------------*/
        for (int i = 0; i < startCassetteList.size(); i++) {
            List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(i).getLotInCassetteList();

            for (int j = 0; j < lotInCassetteList.size(); j++) {
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }
                ObjectIdentifier testTypeID = null;
                log.debug("step28 - get lot test type id");
                try {
                    testTypeID = lotMethod.lotTestTypeIDGet(objCommon, lotInCassette.getLotID());
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getNotFoundTestType(), e.getCode())) {
                        throw e;
                    }
                }
                if (!ObjectIdentifier.isEmptyWithValue(testTypeID)) {
                    log.debug("step29 - Update binReportCount of Bin Summary");
                    try {
                        binSummaryMethod.binSummaryBinRptCountSetDR(objCommon, lotInCassetteList.get(j).getLotID(), ObjectIdentifier.fetchValue(testTypeID), "0");
                    } catch (ServiceException e) {
                        if (!Validations.isEquals(retCodeConfigEx.getNotFoundBbinsum(), e.getCode())) {
                            throw e;
                        }
                    }
                }
            }
        }

        /*------------------------------------------------------------*/
        /*                                                            */
        /*   Reticle / Fixture Related Information Update Procedure   */
        /*                                                            */
        /*------------------------------------------------------------*/
        log.debug("step30 - Check ProcessDurable was Used for Operation or Not ");
        try {
            equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, equipmentID);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())
                    || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                for (int i = 0; i < startCassetteList.size(); i++) {
                    List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(i).getLotInCassetteList();

                    for (int j = 0; j < lotInCassetteList.size(); j++) {
                        Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                        if (!lotInCassette.getMoveInFlag()) {
                            continue;
                        }
                        /*-------------------------------*/
                        /*   Get Used Reticles for Lot   */
                        /*-------------------------------*/
                        if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())) {
                            log.debug("step31 - Get Used Reticles for lot");
                            List<Infos.StartReticle> assignedReticleResult = processMethod.processAssignedReticleGet(objCommon, lotInCassette.getLotID());

                            log.debug("step32 - Update Reticle Usage Information");
                            List<Infos.StartReticle> assignedReticleList = assignedReticleResult;
                            if (CimArrayUtils.isNotEmpty(assignedReticleList)) {
                                for (Infos.StartReticle startReticle : assignedReticleList) {
                                    reticleMethod.reticleUsageCountDecrement(objCommon, startReticle.getReticleID());
                                }
                            }
                        } else {
                            /*------------------------------*/
                            /*   Get Used Fixture for Lot   */
                            /*------------------------------*/
                            List<Infos.StartFixture> processAssignedFixtureResult = processMethod.processAssignedFixtureGet(objCommon, lotInCassette.getLotID());

                            log.debug("step33 - fixtureUsageCountDecrement");
                            List<Infos.StartFixture> assignedFixtureList = processAssignedFixtureResult;
                            if (CimArrayUtils.isNotEmpty(assignedFixtureList)) {
                                for (Infos.StartFixture startFixture : assignedFixtureList) {
                                    fixtureMethod.fixtureUsageCountDecrement(objCommon, lotInCassette.getLotID(), startFixture.getFixtureID());

                                }
                            }
                        }
                    }

                }
            } else if (!Validations.isEquals(retCodeConfig.getEquipmentProcessDurableNotRequired(), e.getCode())) {
                throw e;
            }
        }

        log.debug("step34 - Change lot Process State to Waiting");
        lotMethod.lotProcessStateMakeWaiting(objCommon, startCassetteList);

        if (1 == eqpMonitorSwitch) {
            for (int i = 0; i < scLen; i++) {
                List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(i).getLotInCassetteList();
                int lcLen = CimArrayUtils.getSize(lotInCassetteList);
                for (int j = 0; j < lcLen; j++) {
                    if (CimBooleanUtils.isFalse(lotInCassetteList.get(j).getMoveInFlag())) {
                        continue;
                    }
                    if (!CimStringUtils.equals(lotInCassetteList.get(j).getLotType(), BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                            && !CimStringUtils.equals(lotInCassetteList.get(j).getLotType(), BizConstant.SP_LOT_TYPE_DUMMYLOT)) {
                        continue;
                    }
                    log.debug("step35 - get lot equipment monitor section info for job");
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut objEquipmentMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassetteList.get(j).getLotID());
                    if (objEquipmentMonitorSectionInfoGetForJobOut != null && !ObjectIdentifier.isEmptyWithValue(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                        equipmentMethod.eqpMonitorJobLotUpdate(objCommon, lotInCassetteList.get(j).getLotID(), BizConstant.SP_EQPMONITORJOB_OPECATEGORY_OPESTARTCANCEL);

                        log.debug("step36 - Get EqpMonitorJob Information");
                        List<Infos.EqpMonitorJobInfo> eqpMonitorJobInfos = equipmentMethod.eqpMonitorJobInfoGet(objCommon, objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID(), objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());
                        log.trace("OperationLabel is 【{}】",objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel());
                        if (CimStringUtils.equals(objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)) {
                            boolean eqpMonitorJobStatusChg = true;
                            int eqpMonitorLotInfoLen = 0;
                            if (!CimArrayUtils.isEmpty(eqpMonitorJobInfos)) {
                                eqpMonitorLotInfoLen = CimArrayUtils.getSize(eqpMonitorJobInfos.get(0).getStrEqpMonitorLotInfoSeq());
                            }
                            for (int k = 0; k < eqpMonitorLotInfoLen; k++) {
                                Infos.EqpMonitorLotInfo eqpMonitorLotInfo = eqpMonitorJobInfos.get(0).getStrEqpMonitorLotInfoSeq().get(k);
                                if (CimStringUtils.equals(eqpMonitorLotInfo.getMonitorLotStatus(), BizConstant.SP_EQPMONITOR_LOTSTATUS_EXECUTING)) {
                                    eqpMonitorJobStatusChg = false;
                                    break;
                                }
                            }
                            log.trace("eqpMonitorJobStatusChg is 【{}】",eqpMonitorJobStatusChg);
                            if (eqpMonitorJobStatusChg) {
                                log.debug("step37 - Status of EqpMonitor job is updated to Ready");
                                Params.AMJobStatusChangeRptInParm amJobStatusChangeRptInParm = new Params.AMJobStatusChangeRptInParm();
                                amJobStatusChangeRptInParm.setEquipmentID(eqpMonitorJobInfos.get(0).getEquipmentID());
                                amJobStatusChangeRptInParm.setEqpMonitorID(eqpMonitorJobInfos.get(0).getEqpMonitorID());
                                amJobStatusChangeRptInParm.setEqpMonitorJobID(eqpMonitorJobInfos.get(0).getEqpMonitorJobID());
                                amJobStatusChangeRptInParm.setMonitorJobStatus(BizConstant.SP_EQPMONITORJOB_STATUS_READY);
                                autoMonitorService.sxAMJobStatusChangeRpt(objCommon, amJobStatusChangeRptInParm);
                            }
                        }
                    }
                }
            }
        }

        log.debug("step38 - Stop Q-Time Management");
        List<Infos.QTimeActionRegisterInfo> resetByOpeStartCancelResult = qTimeMethod.qtimeReSetByOpeStartCancel(objCommon, startCassetteList);
        /*-------------------------------------------------------------------------*/
        /*  Cancel FutureHold/futurerework registered by wafer Level qtime Action  */
        /*-------------------------------------------------------------------------*/
        ObjectIdentifier resetReasonCodeID = new ObjectIdentifier(BizConstant.SP_REASON_QTIMECLEAR);
        List<Infos.QTimeActionRegisterInfo> qTimeActionRegisterInfos = resetByOpeStartCancelResult;
        for (int i = 0; i < qTimeActionRegisterInfos.size(); i++) {
            Infos.QTimeActionRegisterInfo qTimeActionRegisterInfo = qTimeActionRegisterInfos.get(i);

            ObjectIdentifier lotID = qTimeActionRegisterInfo.getLotID();
            int futureHoldCount = CimArrayUtils.getSize(qTimeActionRegisterInfo.getFutureHoldList());
            log.trace("futureHoldCount is 【{}】",futureHoldCount);
            if (futureHoldCount > 0) {
                log.debug("step39 - cancel future hold");
                processControlService.sxFutureHoldCancelReq(objCommon, lotID, resetReasonCodeID, BizConstant.SP_ENTRYTYPE_CANCEL, qTimeActionRegisterInfo.getFutureHoldList());
            }

            for (int j = 0; j < CimArrayUtils.getSize(qTimeActionRegisterInfo.getFutureReworkList()); j++) {
                Infos.FutureReworkInfo futureReworkInfo = qTimeActionRegisterInfo.getFutureReworkList().get(j);
                log.debug("step40 - cancel future rework");
                processControlService.sxFutureReworkCancelReq(objCommon, futureReworkInfo.getLotID(), futureReworkInfo.getRouteID(), futureReworkInfo.getOperationNumber(), futureReworkInfo.getFutureReworkDetailInfoList(), "");
            }
        }
        /*------------------------------------------------------------*/
        /*   Get Monitor Lot ID in strStartCassette[].strStartLot[]   */
        /*------------------------------------------------------------*/
        /*------------------------------------------------------------*/
        /*   Get Monitor lot ID in strStartCassette[].strStartLot[]   */
        /*------------------------------------------------------------*/
        ObjectIdentifier monitorLotID = null;
        for (int i = 0; i < startCassetteList.size(); i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();

            for (int j = 0; j < lotInCassetteList.size(); j++) {
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                if (lotInCassette.getMoveInFlag() && lotInCassette.getMonitorLotFlag()) {
                    monitorLotID = lotInCassette.getLotID();
                    break;
                }
            }
        }

        log.trace("monitorLotID is 【{}】",monitorLotID);
        if (!ObjectIdentifier.isEmpty(monitorLotID)) {
            log.debug("step41 - call sxMonitorBatchDeleteReq");
            Results.MonitorBatchDeleteReqResult monitorBatchDeleteReqResultRetCode
                    = processMonitorService.sxMonitorBatchDeleteReq(objCommon, monitorLotID);

        }

        for (int i = 0; i < startCassetteList.size(); i++) {
            List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(i).getLotInCassetteList();

            for (int j = 0; j < lotInCassetteList.size(); j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                log.trace("MoveInFlag is 【{}】",lotInCassette.getMoveInFlag());
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }

                //---------------------------------------------------------------------------------------//
                //  Check if schedule change by lot information change is reserved for this operation    //
                //  If schedule change is reserved, delete the reservation and send e-mail to lot owner  //
                //---------------------------------------------------------------------------------------//
                log.debug("step42 - get lot current operation info");
                Outputs.ObjLotCurrentOperationInfoGetOut lotCurrentOperationInfoOut = lotMethod.lotCurrentOperationInfoGet(objCommon, lotInCassette.getLotID());

                String targetRouteID = lotCurrentOperationInfoOut.getRouteID().getValue();
                String targetOperationNumber = lotCurrentOperationInfoOut.getOperationNumber();

                log.debug("step43 - get change reservattion list");
                Inputs.ObjScheduleChangeReservationGetListIn scheduleChangeReservationParams = new Inputs.ObjScheduleChangeReservationGetListIn();
                scheduleChangeReservationParams.setObjectID(lotInCassette.getLotID().getValue());
                scheduleChangeReservationParams.setObjectID(BizConstant.SP_SCHDL_CHG_OBJTYPE_LOT);
                scheduleChangeReservationParams.setTargetRouteID(targetRouteID);
                scheduleChangeReservationParams.setTargetOperationNumber(targetOperationNumber);
                //2: LOTINFO_CHANGE_FLAG is 1. this flag value to be optimized as a constant
                scheduleChangeReservationParams.setLotInfoChangeFlag(2L);
                List<Infos.SchdlChangeReservation> scheduleChangeReservationResult = scheduleChangeReservationMethod.schdlChangeReservationGetListDR(objCommon, scheduleChangeReservationParams);

                List<Infos.SchdlChangeReservation> scheduleChangeReservationList = scheduleChangeReservationResult;
                if (!CimArrayUtils.isEmpty(scheduleChangeReservationList)) {
                    for (Infos.SchdlChangeReservation scheduleChangeReservation : scheduleChangeReservationList) {
                        //Step45 - schdlChangeReservation_DeleteDR__110
                        log.debug("step44 - schdlChangeReservationDeleteDR");
                        scheduleChangeReservationMethod.schdlChangeReservationDeleteDR(objCommon, scheduleChangeReservation);

                        log.debug("step45 - Send e-mail ");
                        StringBuffer ostrMessageSb = new StringBuffer();
                        ostrMessageSb.append("This message was sent because reservation for \"Lot Information Change\" is canceled.\n")
                                .append("Schedule Change Reservation Info.\n")
                                .append("LotID      : ").append(ObjectIdentifier.fetchValue(lotInCassette.getLotID())).append("\n")
                                .append("Product ID : ").append(ObjectIdentifier.fetchValue(scheduleChangeReservation.getProductID())).append("\n")
                                .append("Route ID   : ").append(ObjectIdentifier.fetchValue(scheduleChangeReservation.getRouteID())).append("\n")
                                .append("Ope.No     : ").append(scheduleChangeReservation.getOperationNumber()).append("\n")
                                .append("SubLotType : ").append(scheduleChangeReservation.getSubLotType()).append("\n");
                        messageMethod.messageDistributionMgrPutMessage(objCommon, new ObjectIdentifier(BizConstant.SP_SYSTEMMSGCODE_SCRNOTICE),
                                lotInCassette.getLotID(), "", equipmentID, lotCurrentOperationInfoOut.getRouteID(), lotCurrentOperationInfoOut.getOperationNumber(),
                                "", ostrMessageSb.toString());
                    }
                }
            }
        }

        /*---------------------------------------------------*/
        /*   cassette Related Information Update Procedure   */
        /*---------------------------------------------------*/
        for (int i = 0; i < startCassetteList.size(); i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);

            log.debug("step46 - Update Casssette's Usage Information");
            cassetteMethod.cassetteUsageCountDecrement(objCommon, startCassette.getCassetteID());
        }


        /*------------------------------------------------------*/
        /*     flowbatch Related Information Update Procedure   */
        /*------------------------------------------------------*/

        /*----------------------------------------------------------*/
        /*   Update FlowBatch Information of Equipment              */
        /*                                                          */
        /*   If lots to be canceled are on the target operation     */
        /*   of FlowBatch section, equipment's reservedFlowBatchID  */
        /*   is set-back again. In this case, Flow-Batch's          */
        /*   reservedEquipmentID is re-set, too.                    */
        /*----------------------------------------------------------*/
        log.debug("step47 - Update FlowBatch Information of Equipment");
        flowBatchMethod.flowBatchInformationUpdateByOpeStartCancel(objCommon, equipmentID, startCassetteList);


        /*----------------------------------------------------*/
        /*                                                    */
        /*   Equipment Related Information Update Procedure   */
        /*                                                    */
        /*----------------------------------------------------*/

        log.debug("step48 - Remove ControlJobLot from EqpInfo's ProcessingLot Sequence ");
        equipmentMethod.equipmentProcessingLotDelete(objCommon, equipmentID, startCassetteList);

        /*---------------------------------------------*/
        /*   Maintain Eqp's Status for OFF-LINE Mode   */
        /*---------------------------------------------*/
        if (BizConstant.SP_EQP_ONLINEMODE_OFFLINE.equals(currentOperationMode.getOnlineMode())) {
            log.debug("step49 - equipment Current State Check To Manufacturing ");
            Boolean checkEquipmentCurrentState2ManufacturingResult = equipmentMethod.equipmentCurrentStateCheckToManufacturing(objCommon, equipmentID);
            log.trace("checkEquipmentCurrentState2ManufacturingResult is 【{}】",checkEquipmentCurrentState2ManufacturingResult);
            if (checkEquipmentCurrentState2ManufacturingResult) {
                log.debug("step50 - equipment Recover State Get Manufacturing");
                ObjectIdentifier getRecoverStateResult = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, equipmentID);
                ObjectIdentifier equipmentStatusCode = getRecoverStateResult;

                log.debug("step51 - change equipment state");
                String claimMemo = "";
                Results.EqpStatusChangeReqResult statusChangeResult = sxEqpStatusChangeReq(objCommon, equipmentID, equipmentStatusCode, claimMemo);
            }
        }
        log.debug("step52 - Update eqp's Usage Information");
        equipmentMethod.equipmentUsageCountDecrement(objCommon, equipmentID, startCassetteList);

        /*--------------------------------------------------------*/
        /*   Clear ActualStart Info in Each Lots' PO              */
        /*                                                        */
        /*   - Clear controlJobID of each cassette.               */
        /*   - Clear controlJobID of each lot.                    */
        /*   - Clear control job info of each lot's cunrrent PO.  */
        /*--------------------------------------------------------*/
        log.debug("step53 - process Start Reserve Information Clear");
        processMethod.processStartReserveInformationClear(objCommon, controlJobID, startCassetteList);

        //Step55 - process_waferChamberInformation_Clear
        log.debug("step54 - process Wafer Chamber Information Clear");
        processMethod.processWaferChamberInformationClear(objCommon, startCassetteList);

        log.debug("step55 - Clear Process resource wafer position information in PO");
        processMethod.processWaferPositionInProcessResourceInformationClear(objCommon, startCassetteList);

        log.debug("step56 - Delete Control Job");
        Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
        cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE);
        cjStatusChangeReqParams.setControlJobID(ObjectIdentifier.build(controlJobID.getValue(), null));
        cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());

        if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())    //TxPartialMoveOutReq
                && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) { //TxPartialMoveOutForIBReq
            log.debug("step57 - sxCJStatusChangeReqService");
            controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);
        }

        /*----------------------------------------------------*/
        /*   Clear UsedFlag in MfgRestrict Exception Lot    */
        /*----------------------------------------------------*/
        for (int i = 0; i < startCassetteList.size(); i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();

            for (int j = 0; j < lotInCassetteList.size(); j++) {
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }

                log.debug("step58 - constraint Filter Exception Lot");
                List<Infos.EntityInhibitInfo> objEntityInhibitFilterExceptionLotOut = constraintMethod.constraintFilterExceptionLot(objCommon, lotInCassette.getLotID(), null);

            }
        }

        /*---------------------------------------------------------------------------------*/
        /*   Get of the FutureHold information by ImmediateHold for OperationStartCancel   */
        /*---------------------------------------------------------------------------------*/
        for (int i = 0; i < startCassetteList.size(); i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();

            for (int j = 0; j < lotInCassetteList.size(); j++) {
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }
                log.debug("step59 -  Get of the FutureHold information");
                Outputs.ObjLotFutureHoldRequestsEffectForOpeStartCancelOut effect4OpeStartCancelResult = lotMethod.lotFutureHoldRequestsEffectForOpeStartCancel(objCommon, lotInCassette.getLotID());
                Outputs.ObjLotFutureHoldRequestsEffectForOpeStartCancelOut effect4OpeStartCancelOut = effect4OpeStartCancelResult;

                log.debug("step60 - FutureHold(POST) registered by ImmediateHold action is released ");
                List<Infos.LotHoldReq> futureHoldReleaseReqList = effect4OpeStartCancelOut.getFutureHoldReleaseReqList();
                if (!CimArrayUtils.isEmpty(futureHoldReleaseReqList)) {
                    Params.FutureHoldCancelReqParams futureHoldCancelReqParams = new Params.FutureHoldCancelReqParams();
                    futureHoldCancelReqParams.setLotID(effect4OpeStartCancelOut.getLotID());
                    futureHoldCancelReqParams.setReleaseReasonCodeID(new ObjectIdentifier(BizConstant.EMPTY));
                    futureHoldCancelReqParams.setEntryType(BizConstant.SP_ENTRYTYPE_REMOVE);
                    futureHoldCancelReqParams.setLotHoldList(futureHoldReleaseReqList);
                    processControlService.sxFutureHoldCancelReq(objCommon, futureHoldCancelReqParams);
                }

                /*--------------------------------------------------*/
                /*   FutureHold is performed immediately            */
                /*--------------------------------------------------*/
                List<Infos.LotHoldReq> lotHoldReqList = effect4OpeStartCancelOut.getLotHoldReqList();
                log.debug("step61 - hold lot");
                if (!CimArrayUtils.isEmpty(lotHoldReqList)) {
                    lotService.sxHoldLotReq(objCommon, effect4OpeStartCancelOut.getLotID(), lotHoldReqList);
                }
            }
        }

        /*--------------------------*/
        /*                          */
        /*   Event Make Procedure   */
        /*                          */
        /*--------------------------*/
        log.debug("step62 - Event Make Procedure");
        scLen = CimArrayUtils.getSize(startCassetteList);
        for (int i = 0; i < scLen; i++) {
            int j = 0;
            int lcLen = CimArrayUtils.getSize(startCassetteList.get(i).getLotInCassetteList());
            for (j = 0; j < lcLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (Objects.equals(startCassetteList.get(i).getLotInCassetteList().get(j).getMoveInFlag(), FALSE)) {
                    continue;
                }

                /*--------------------------------------------------------------------*/
                /*   Make OperationMoveEvent for Operation History - OpeStartCancel   */
                /*--------------------------------------------------------------------*/
                RetCode<Object> strLotOperationMoveEvent_MakeOpeStartCancel_out;
                eventMethod.lotOperationMoveEventMakeOpeStartCancel(objCommon,
                        objCommon.getTransactionID(),
                        equipmentID,
                        currentOperationModeOut.getOperationMode().getOperationMode().getValue(),
                        controlJobID,
                        startCassetteList.get(i).getCassetteID(),
                        startCassetteList.get(i).getLotInCassetteList().get(j),
                        null);

            }
        }

        /*------------------------------------------------------------------------*/
        /*                                                                        */
        /*   Send OpeStartCancel Request to EAP Procedure                         */
        /*                                                                        */
        /*------------------------------------------------------------------------*/
        log.debug("step63 - Send OpeStartCancel Request to EAP Procedure");
        if (!CimStringUtils.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue(), objCommon.getTransactionID())
                && !CimStringUtils.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(), objCommon.getTransactionID())) {
//            Inputs.SendMoveInCancelForIBReqIn sendMoveInCancelForIBReqIn = new Inputs.SendMoveInCancelForIBReqIn();
//            sendMoveInCancelForIBReqIn.setObjCommonIn(objCommon);
//            sendMoveInCancelForIBReqIn.setRequestUserID(objCommon.getUser());
//            sendMoveInCancelForIBReqIn.setEquipmentID(equipmentID);
//            sendMoveInCancelForIBReqIn.setControlJobID(controlJobID);
//            Outputs.SendMoveInCancelForIBReqOut sendMoveInCancelForIBReqOut = (Outputs.SendMoveInCancelForIBReqOut) tcsMethod.sendTCSReq(TCSReqEnum.sendMoveInCancelForIBReq, sendMoveInCancelForIBReqIn);
            Params.MoveInCancelForIBReqParams params = new Params.MoveInCancelForIBReqParams();
            params.setControlJobID(controlJobID);
            params.setEquipmentID(equipmentID);
            params.setUser(objCommon.getUser());
            params.setOpeMemo(params.getOpeMemo());
            String tmpSleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue();
            String tmpRetryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue();
            Long sleepTimeValue = 0L;
            Long retryCountValue = 0L;

            if (0 == CimStringUtils.length(tmpSleepTimeValue)) {
                sleepTimeValue = BizConstant.SP_DEFAULT_SLEEP_TIME_TCS;
            } else {
                sleepTimeValue = CimNumberUtils.longValue(tmpSleepTimeValue);
            }

            if (0 == CimStringUtils.length(tmpRetryCountValue)) {
                retryCountValue = BizConstant.SP_DEFAULT_RETRY_COUNT_TCS;
            } else {
                retryCountValue = CimNumberUtils.longValue(tmpRetryCountValue);
            }

            for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                log.trace("{} {}", "loop to retryCountValue + 1", retryNum);
                log.debug("step64 - Send Request to EAP ");
                IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,params.getUser(),params.getEquipmentID(),null,true);
                if (null == eapRemoteManager) {
                    log.trace("MES not configure EAP host");
                    break;
                }
                try {
                    Object moveInCancelReqEapOut = eapRemoteManager.sendMoveInCancelForIBReq(params);
                    log.trace("Now EAP subSystem is alive!! Go ahead");
                    break;
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                        log.trace("{} {}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...", retryNum);
                        log.trace("{} {}", "now sleeping... ", sleepTimeValue);
                        if (retryNum != retryCountValue){
                            try {
                                Thread.sleep(sleepTimeValue);
                                continue;
                            } catch (InterruptedException e) {
                                ex.addSuppressed(e);
                                Thread.currentThread().interrupt();
                                throw ex;
                            }
                        }else {
                            Validations.check(true,retCodeConfig.getTcsNoResponse());
                        }
                    } else {
                        Validations.check(true,new OmCode(ex.getCode(),ex.getMessage()));
                    }
                }
            }
        }

        //TODO: Step64 - DCSMgr_SendOperationStartCancelRpt
        // Step65 - APCRuntimeCapability_DeleteDR
        log.debug("step65 - apcRuntimeCapabilityDeleteDR");
        apcMethod.apcRuntimeCapabilityDeleteDR(objCommon, controlJobID);
        if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
            //      Wafer information in APCBaseCassette is not necessary for reserve cancel,
            //      but it is required by wrapper for process xml which satisfy dtd.
            //      So, now we add dummy wafer data into strCassette_APCInformation_GetDR_out.strAPCBaseCassetteList.
            int bcLen = CimArrayUtils.getSize(apcBaseCassettes);
            for (int bcIdx = 0; bcIdx < bcLen; bcIdx++) {
                Infos.ApcBaseCassette apcBaseCassette = apcBaseCassettes.get(bcIdx);
                List<Infos.ApcBaseLot> apcBaseLotList = apcBaseCassette.getApcBaseLotList();
                int blLen = CimArrayUtils.getSize(apcBaseLotList);
                for (int blIdx = 0; blIdx < blLen; blIdx++) {
                    Infos.ApcBaseLot apcBaseLot = apcBaseLotList.get(blIdx);
                    Infos.ApcBaseWafer apcBaseWafer = new Infos.ApcBaseWafer();
                    apcBaseWafer.setWaferID("");
                    apcBaseWafer.setSlotNumber(0L);
                    apcBaseWafer.setControlWaferFlag(false);
                    apcBaseWafer.setSendAheadWaferFlag(false);
                    apcBaseWafer.setProcessFlag(false);
                    apcBaseWafer.setExperimentSplitWafer(false);
                    apcBaseLot.setApcBaseWaferList(Collections.singletonList(apcBaseWafer));
                }
            }
            int retCode = 0;
            try {
                log.debug("step66 - apcRuntimeCapabilityDeleteDR");
                apcMethod.APCMgrSendControlJobInformationDR(objCommon, equipmentID, controlJobID, BizConstant.SP_APC_CONTROLJOBSTATUS_CANCELED, apcBaseCassettes);
            } catch (ServiceException e) {
                retCode = e.getCode();
                if (!Validations.isEquals(retCodeConfigEx.getOkNoIF(), e.getCode())) {
                    throw e;
                }
            }
            log.trace("retCode is 【{}】",retCode);
            if (retCode == 0) {
                String tmpString = pAPCIFControlStatus;
                pAPCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_EXECUTING;
            }
        } else {
            apcBaseCassetteListForOpeStartCancel = apcBaseCassettes;
        }
        retVal.setStartCassetteList(startCassetteList);
        return retVal;
    }

    @Override
    public Results.MoveInCancelReqResult sxMoveInCancelReq(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier controlJobID,
                                                       String claimMemo, List<Infos.ApcBaseCassette> strAPCBaseCassetteListForOpeStartCancel, String APCIFControlStatus, String DCSIFControlStatus) {
        log.debug("sxMoveInCancelReq(): enter MoveInCancelReq");

        Results.MoveInCancelReqResult retVal = new Results.MoveInCancelReqResult();

        log.debug("step1 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        log.debug("step2 - get lock mode for equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.OPERATION_START_CANCEL_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step3 - Lock Equipment Main Object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            log.debug("step4 - Lock Machine Object");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        log.debug("step5 - Get SLM Switch for the eqp");
        boolean slmCapabilityFlag = false;
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentID);
        Infos.EqpPortInfo eqpPortInfo = null;
        if ((CimBooleanUtils.isTrue(eqpBrInfo.isFmcCapabilityFlag()))) {
            slmCapabilityFlag = true;

            log.debug("step6 - lock equipment container position");
            Inputs.ObjObjectLockForEquipmentContainerPositionIn objObjectLockForEquipmentContainerPositionIn = new Inputs.ObjObjectLockForEquipmentContainerPositionIn();
            objObjectLockForEquipmentContainerPositionIn.setEquipmentID(equipmentID);
            objObjectLockForEquipmentContainerPositionIn.setControlJobID(controlJobID);
            objectLockMethod.objectLockForEquipmentContainerPosition(objCommon, objObjectLockForEquipmentContainerPositionIn);

            log.debug("step7 - Get equipmentContainer position objects by controlJobID");
            Infos.EqpContainerPositionInfo containerPositionInfo = equipmentMethod.equipmentContainerPositionInfoGet(objCommon, equipmentID,
                    controlJobID, BizConstant.SP_SLM_KEYCATEGORY_CONTROLJOB);
            List<Infos.EqpContainerPosition> eqpContainerPositionList = containerPositionInfo.getEqpContainerPositionList();
            int pstLen = CimArrayUtils.getSize(eqpContainerPositionList);
            if (CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                    || CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
                //----------------------------------------------------------
                //  Filtering for Partial OpeComp
                //----------------------------------------------------------
                List<Infos.EqpContainerPosition> strEqpContainerPositionSeq = new ArrayList<>();
                int nEqpContainerPositionCnt = 0;
                for (int nCnt1 = 0; nCnt1 < pstLen; nCnt1++) {
                    if (!ObjectIdentifier.isEmptyWithValue(eqpContainerPositionList.get(nCnt1).getControlJobID())) {
                        strEqpContainerPositionSeq.add(eqpContainerPositionList.get(nCnt1));
                    }
                }
                containerPositionInfo.setEqpContainerPositionList(strEqpContainerPositionSeq);
                pstLen = CimArrayUtils.getSize(strEqpContainerPositionSeq);
            }
            if (pstLen > 0) {
                /*
                 If all wafers in a lot are "Stored" and eqp is online,
                 destination cassette is required
                 */
                log.debug("step8 - get equipment port info");
                eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID);
                List<Infos.EqpPortStatus> eqpPortStatusList = eqpPortInfo.getEqpPortStatuses();
                Validations.check(CimArrayUtils.isEmpty(eqpPortStatusList), "eqp port info is empty");

                if (!BizConstant.SP_EQP_ONLINEMODE_OFFLINE.equals(eqpPortStatusList.get(0).getOnlineMode())) {
                    log.debug("sxMoveInCancelReq(): eqp is NOT offline");
                    Predicate<Infos.EqpContainerPosition> containerPositionFilter = eqpContainerPosition -> !ObjectIdentifier.isEmpty(eqpContainerPosition.getLotID());
                    eqpContainerPositionList.stream()
                            .filter(containerPositionFilter)
                            .forEach(eqpContainerPosition -> {
                                ObjectIdentifier lotID = eqpContainerPosition.getLotID();
                                //check if all wafers in this lot is stored
                                boolean isAllStored = false;
                                for (int i = 0; i < eqpContainerPositionList.size(); i++) {
                                    Infos.EqpContainerPosition item = eqpContainerPositionList.get(i);
                                    if (!lotID.equals(item.getLotID())) {
                                        continue;
                                    }
                                    if (!BizConstant.SP_SLMSTATE_STORED.equals(item.getFmcState())) {
                                        break;
                                    }
                                    if (i == eqpContainerPositionList.size() - 1) {
                                        isAllStored = true;
                                        break;
                                    }
                                }
                                if (isAllStored) {
                                    log.debug("sxMoveInCancelReq(): All wafers in this lot are stored for lot : {}", lotID);
                                    Validations.check(ObjectIdentifier.isEmpty(eqpContainerPosition.getDestCassetteID()), retCodeConfig.getSlmDestinationCassetteUndefine(),
                                            objCommon.getTransactionID());
                                }
                            });
                }
                /*
                 Get Destination cassette List.
                 These cassettes should be locked before update
                 */
                List<ObjectIdentifier> destCassetteList = new ArrayList<>();
                Predicate<Infos.EqpContainerPosition> containerPositionFilter = eqpContainerPosition -> !ObjectIdentifier.isEmpty(eqpContainerPosition.getDestCassetteID());
                eqpContainerPositionList.stream()
                        .filter(containerPositionFilter)
                        .forEach(eqpContainerPosition -> {
                            ObjectIdentifier destCassetteID = eqpContainerPosition.getDestCassetteID();
                            String slmState = eqpContainerPosition.getFmcState();
                            if (BizConstant.SP_SLMSTATE_RESERVED.equals(slmState)
                                    || BizConstant.SP_SLMSTATE_RETRIEVED.equals(slmState)) {
                                destCassetteList.add(destCassetteID);
                            }
                        });
                log.debug("step9 - lock object");
                int destCassetteListLen = CimArrayUtils.getSize(destCassetteList);
                for (int nCnt1 = 0; nCnt1 < destCassetteListLen; nCnt1++) {
                    objectLockMethod.objectLock(objCommon, CimCassette.class, destCassetteList.get(nCnt1));
                }
                log.debug("step10 - Update equipment container position for operationCancel");
                equipmentMethod.equipmentContainerPositionUpdateForOpeStartCancel(objCommon, equipmentID, controlJobID);
            }
        }
        log.debug("step11 - Get controljob Info");
        Outputs.ObjControlJobStartReserveInformationOut reserveInformationResult =
                controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                        controlJobID,
                        false);
        //Prepare strStartCassette for Working-Valiable
        List<Infos.StartCassette> startCassetteList = reserveInformationResult.getStartCassetteList();
        int scLen = CimArrayUtils.getSize(startCassetteList);

        log.debug("step12 - check virtual operation");
        Boolean virtualOperationFlag = virtualOperationMethod.virtualOperationCheckByStartCassette(objCommon, startCassetteList);
        /*--------------------------------*/
        /*   Lock Cassette / Lot Object   */
        /*--------------------------------*/
        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
        for (int i = 0; i < scLen; i++) {
            if (!ObjectIdentifier.isEmptyWithValue(startCassetteList.get(i).getCassetteID()) || !slmCapabilityFlag) {
                cassetteIDs.add(startCassetteList.get(i).getCassetteID());
            }
            List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(i).getLotInCassetteList();
            int lcLen = CimArrayUtils.getSize(lotInCassetteList);
            for (int j = 0; j < lcLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(lotInCassetteList.get(j).getMoveInFlag())) {
                    continue;
                }
                lotIDs.add(lotInCassetteList.get(j).getLotID());
            }
        }
        log.trace("lockMode is 【{}】",lockMode);
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step13 - get equipment online mode");
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                log.debug("step14 - lock advanced object");
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            List<String> procLotSeq = lotIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());

            log.debug("step15 - lock advanced object");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, procLotSeq));
            int cassetteLen = CimArrayUtils.getSize(cassetteIDs);
            List<String> loadCastSeq = new ArrayList<>();
            for (int i = 0; i < cassetteLen; i++) {
                log.debug("step16 - get cassette location info");
                Infos.LotLocationInfo lotLocationInfo = cassetteMethod.cassetteLocationInfoGetDR(cassetteIDs.get(i));
                if (CimStringUtils.equals(lotLocationInfo.getTransferStatus(), BizConstant.SP_TRANSSTATE_EQUIPMENTIN)
                        || ObjectIdentifier.equalsWithValue(lotLocationInfo.getEquipmentID(), equipmentID)) {
                    // this cassette is load on equipment
                    loadCastSeq.add(cassetteIDs.get(i).getValue());
                }
            }
            log.trace("loadCastSeq is 【{}】",loadCastSeq);
            if (!CimArrayUtils.isEmpty(loadCastSeq)) {
                log.debug("step17 - lock advanced object");
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ, loadCastSeq));
            }
            log.debug("step18 - Lock ControlJob Object");
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
        }

        log.debug("step19 -  Lock Cassette Object");
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);

        log.debug("step20 -  Lock Cassette Object");
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, lotIDs);
        int eqpMonitorSwitch = StandardProperties.OM_AUTOMON_FLAG.getIntValue();
        log.trace("eqpMonitorSwitch is 【{}】",eqpMonitorSwitch);
        if (1 == eqpMonitorSwitch) {
            List<ObjectIdentifier> eqpMonitorList = new ArrayList<>();
            List<Infos.EqpMonitorJobInfo> strEqpMonitorJobInfoSeq = new ArrayList<>();
            int eqpMonitorCnt = 0;
            int eqpMonJobCnt = 0;
            int castLen = CimArrayUtils.getSize(startCassetteList);
            for (int i = 0; i < castLen; i++) {
                List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(i).getLotInCassetteList();
                int lotLen = CimArrayUtils.getSize(lotInCassetteList);
                for (int j = 0; j < lotLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(lotInCassetteList.get(j).getMoveInFlag())) {
                        continue;
                    }
                    if (!CimStringUtils.equals(lotInCassetteList.get(j).getLotType(), BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                            && !CimStringUtils.equals(lotInCassetteList.get(j).getLotType(), BizConstant.SP_LOT_TYPE_DUMMYLOT)) {
                        continue;
                    }
                    log.debug("step21 - get lot equipment monitor section info for job");
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut objEquipmentMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassetteList.get(j).getLotID());
                    if (!ObjectIdentifier.isEmptyWithValue(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                        if (CimStringUtils.equals(objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)) {
                            boolean bNewEqpMonitor = true;
                            for (int iCnt1 = 0; iCnt1 < eqpMonitorCnt; iCnt1++) {
                                if (ObjectIdentifier.equalsWithValue(eqpMonitorList.get(iCnt1), objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID())) {
                                    bNewEqpMonitor = false;
                                    break;
                                }
                            }
                            if (bNewEqpMonitor) {
                                eqpMonitorList.add(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                eqpMonitorCnt++;
                            }
                        }
                        if (CimStringUtils.equals(objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)
                                || CimBooleanUtils.isTrue(objEquipmentMonitorSectionInfoGetForJobOut.isExitFlag())) {
                            boolean bNewEqpMonJob = true;
                            for (int iCnt2 = 0; iCnt2 < eqpMonJobCnt; iCnt2++) {
                                if (ObjectIdentifier.equalsWithValue(strEqpMonitorJobInfoSeq.get(iCnt2).getEqpMonitorJobID(), objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                                    bNewEqpMonJob = false;
                                    break;
                                }
                            }
                            if (bNewEqpMonJob) {
                                Infos.EqpMonitorJobInfo eqpMonitorJobInfo = new Infos.EqpMonitorJobInfo();
                                eqpMonitorJobInfo.setEqpMonitorID(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                eqpMonitorJobInfo.setEqpMonitorJobID(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());
                                strEqpMonitorJobInfoSeq.add(eqpMonitorJobInfo);
                                eqpMonJobCnt++;
                            }
                        }
                    }
                }
            }
            for (int iCnt3 = 0; iCnt3 < eqpMonitorCnt; iCnt3++) {
                log.debug("step22 - lock object");
                objectLockMethod.objectLock(objCommon, CimEqpMonitor.class, eqpMonitorList.get(iCnt3));
            }
            for (int iCnt4 = 0; iCnt4 < eqpMonJobCnt; iCnt4++) {
                log.debug("step23 - lock object for equipment monitor job");
                objectLockMethod.objectLockForEqpMonitorJob(objCommon, strEqpMonitorJobInfoSeq.get(iCnt4).getEqpMonitorID(), strEqpMonitorJobInfoSeq.get(iCnt4).getEqpMonitorJobID());
            }
        }

        log.debug("step24 - add season by ho");
        seasoningService.sxSeasonForMoveInCancel(objCommon, equipmentID, controlJobID);

        log.debug("step25 - get cassette APC info");
        List<Infos.ApcBaseCassette> apcBaseCassettes = null;
        try {
            apcBaseCassettes = cassetteMethod.cassetteAPCInformationGetDR(objCommon, equipmentID, startCassetteList);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getSystemError(), e.getCode())) {
                throw e;
            }
        }
        String accessMode = BizConstant.EMPTY;
        String onlineMode = BizConstant.EMPTY;
        String operationModeID = BizConstant.EMPTY;
        if (!CimArrayUtils.isEmpty(startCassetteList) && !ObjectIdentifier.isEmpty(startCassetteList.get(0).getCassetteID())) {
            if (CimBooleanUtils.isFalse(virtualOperationFlag)) {
                Outputs.ObjPortResourceCurrentOperationModeGetOut currentOperationModeOut = portMethod.portResourceCurrentOperationModeGet(objCommon, equipmentID, startCassetteList.get(0).getUnloadPortID());
                Infos.OperationMode operationMode = currentOperationModeOut.getOperationMode();
                onlineMode = operationMode.getOnlineMode();
                accessMode = operationMode.getAccessMode();
                operationModeID = operationMode.getOperationMode().getValue();
            }
        } else {
            log.debug("step26 - get equipment port info");
            eqpPortInfo = eqpPortInfo == null ? equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID) : eqpPortInfo;
            onlineMode = eqpPortInfo.getEqpPortStatuses().get(0).getOnlineMode();
        }
        log.debug("step27 - check port's OperationMode");
        log.trace("accessMode is 【{}】，slmCapabilityFlag is 【{}】",accessMode,slmCapabilityFlag);
        if (BizConstant.SP_EQP_ACCESSMODE_AUTO.equalsIgnoreCase(accessMode) || slmCapabilityFlag) {
            cassetteMethod.cassetteCheckConditionForOpeStartCancel(objCommon, startCassetteList);
        }
        log.debug("step28 - Check Process for lot");
        lotMethod.lotCheckConditionForOpeStartCancel(objCommon, startCassetteList);

        log.debug("step29 - check equipment condition for operation start cacel");
        if (BizConstant.SP_EQP_ACCESSMODE_AUTO.equalsIgnoreCase(accessMode) || slmCapabilityFlag) {
            equipmentMethod.equipmentCheckConditionForOpeStartCancel(objCommon, equipmentID, startCassetteList);
            //Step30 - equipment_portState_CheckForOpeStartCancel
            equipmentMethod.equipmentPortStateCheckForOpeStartCancel(objCommon, equipmentID, startCassetteList);
        }


       log.debug("step30 - Main Process (Reverse Order of OpeStart Procedure)");
        Predicate<Infos.LotInCassette> lotInCassetteFilter = Infos.LotInCassette::getMoveInFlag;
        startCassetteList.forEach(startCassette -> startCassette.getLotInCassetteList().stream()
                .filter(lotInCassetteFilter)
                .forEach(lotInCassette -> {
                    //Check Test Type of Current Process
                    ObjectIdentifier lotTestTypeIDResult = null;
                    try {
                        lotTestTypeIDResult = lotMethod.lotTestTypeIDGet(objCommon, lotInCassette.getLotID());
                    } catch (ServiceException e) {
                        if (!Validations.isEquals(retCodeConfig.getNotFoundTestType(), e.getCode())) {
                            throw e;
                        }
                    }


                    ObjectIdentifier lotTestTypeID = lotTestTypeIDResult;
                    log.trace("lotTestTypeID is 【{}】",lotTestTypeID);
                    if (!ObjectIdentifier.isEmptyWithValue(lotTestTypeID)) {
                        log.debug("step31 - binSummaryBinRptCountSetDR");
                        try {
                            binSummaryMethod.binSummaryBinRptCountSetDR(objCommon, lotInCassette.getLotID(), lotTestTypeID.getValue(), "0");
                        } catch (ServiceException e) {
                            if (!Validations.isEquals(retCodeConfigEx.getNotFoundBbinsum(), e.getCode())) {
                                throw e;
                            }
                        }
                    }
                }));

        if (StandardProperties.OM_RTMS_CHECK_ACTIVE.isTrue()){
            //report RTMS
            for (Infos.StartCassette startCassette : startCassetteList){
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList){
                    if (lotInCassette.getMoveInFlag()){
                        List<String> reticleList = new ArrayList<>();
                        Infos.StartRecipe startRecipe = lotInCassette.getStartRecipe();
                        List<Infos.StartReticleInfo> startReticleList = startRecipe.getStartReticleList();
                        if (CimArrayUtils.isNotEmpty(startReticleList)) {
                            for (Infos.StartReticleInfo startReticleInfo : startReticleList){
                                reticleList.add(startReticleInfo.getReticleID().getValue());
                            }
                        }
                        if (CimArrayUtils.isNotEmpty(reticleList)) {
                            reticleMethod.reticleUsageCheckByRTMS(objCommon,BizConstant.RTMS_RETICLE_CHECK_ACTION_MOVE_IN_CANCEL,
                                    reticleList,lotInCassette.getLotID(),equipmentID);
                        }
                    }
                }
            }
        }

        log.debug("step32 - get equipment process durable required flag");
        try {
            equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, equipmentID);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())
                    || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                startCassetteList.forEach(startCassette -> startCassette.getLotInCassetteList().stream()
                        .filter(lotInCassetteFilter)
                        .forEach(lotInCassette -> {
                            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())) {
                                log.debug("step33 - Get Used Reticles for lot");
                                List<Infos.StartReticle> assignedReticleResult = processMethod.processAssignedReticleGet(objCommon, lotInCassette.getLotID());
                                //Update Reticle Usage Information
                                List<Infos.StartReticle> assignedReticleList = assignedReticleResult;

                                log.debug("step34 - decrement reticle usage count");
                                assignedReticleList.forEach(startReticle -> {
                                    reticleMethod.reticleUsageCountDecrement(objCommon, startReticle.getReticleID());
                                });
                            } else {
                                log.debug("step35 - Get Used Fixture for lot");
                                List<Infos.StartFixture> processAssignedFixtureResult = processMethod.processAssignedFixtureGet(objCommon, lotInCassette.getLotID());
                                List<Infos.StartFixture> assignedFixtureList = processAssignedFixtureResult;

                                log.debug("step36 - Update Fixture Usage Information");
                                assignedFixtureList.forEach(startFixture -> {
                                    fixtureMethod.fixtureUsageCountDecrement(objCommon, lotInCassette.getLotID(), startFixture.getFixtureID());
                                });
                            }
                        }));
            } else if (!Validations.isEquals(retCodeConfig.getEquipmentProcessDurableNotRequired(), e.getCode())) {
                throw e;
            }
        }
        log.debug("step37 - Change lot Process State to Waiting");
        lotMethod.lotProcessStateMakeWaiting(objCommon, startCassetteList);

        log.trace("eqpMonitorSwitch is 【{}】",eqpMonitorSwitch);
        if (1 == eqpMonitorSwitch) {
            for (Infos.StartCassette startCassette : startCassetteList) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    log.trace("MoveInFlag is 【{}】",lotInCassette.getMoveInFlag());
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    log.trace("LotType is 【{}】",lotInCassette.getLotType());
                    if (!CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                            && !CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_DUMMYLOT)) {
                        continue;
                    }

                    log.debug("step38 - get lot equipment monitor section info");
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut objEquipmentMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassette.getLotID());

                    log.trace("EquipmentMonitorJobID is 【{}】",objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());
                    if (!ObjectIdentifier.isEmpty(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                        log.debug("step39 - Update information of EqpMonitor job lot");
                        equipmentMethod.eqpMonitorJobLotUpdate(objCommon, lotInCassette.getLotID(), BizConstant.SP_EQPMONITORJOB_OPECATEGORY_OPESTARTCANCEL);

                        log.debug("step40 - Get EqpMonitorJob Information");
                        List<Infos.EqpMonitorJobInfo> eqpMonitorJobInfos = equipmentMethod.eqpMonitorJobInfoGet(objCommon, objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID(), objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());

                        log.trace("OperationLabel is 【{}】",objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel());
                        if (CimStringUtils.equals(objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)) {
                            boolean eqpMonitorJobStatusChg = true;
                            List<Infos.EqpMonitorLotInfo> strEqpMonitorLotInfoSeq = eqpMonitorJobInfos.get(0).getStrEqpMonitorLotInfoSeq();
                            for (Infos.EqpMonitorLotInfo eqpMonitorLotInfo : strEqpMonitorLotInfoSeq) {
                                if (CimStringUtils.equals(eqpMonitorLotInfo.getMonitorLotStatus(), BizConstant.SP_EQPMONITOR_LOTSTATUS_EXECUTING)) {
                                    eqpMonitorJobStatusChg = false;
                                    break;
                                }
                            }

                            log.trace("eqpMonitorJobStatusChg is 【{}】",eqpMonitorJobStatusChg);
                            if (eqpMonitorJobStatusChg) {
                                Params.AMJobStatusChangeRptInParm rptInParm = new Params.AMJobStatusChangeRptInParm();
                                rptInParm.setEquipmentID(eqpMonitorJobInfos.get(0).getEquipmentID());
                                rptInParm.setEqpMonitorID(eqpMonitorJobInfos.get(0).getEqpMonitorID());
                                rptInParm.setEqpMonitorJobID(eqpMonitorJobInfos.get(0).getEqpMonitorJobID());
                                rptInParm.setMonitorJobStatus(BizConstant.SP_EQPMONITORJOB_STATUS_READY);
                                autoMonitorService.sxAMJobStatusChangeRpt(objCommon, rptInParm);
                            }
                        }
                    }
                }
            }
        }
        log.debug("step41 - cancel qtime reset by opetation start");
        List<Infos.QTimeActionRegisterInfo> resetByOpeStartCancelResult = qTimeMethod.qtimeReSetByOpeStartCancel(objCommon, startCassetteList);
        List<Infos.QTimeActionRegisterInfo> actionResetList = resetByOpeStartCancelResult;
        //----- Future Hold Actions -------
        log.trace("actionResetList is 【{}】",actionResetList);
        if (!CimArrayUtils.isEmpty(actionResetList)) {
            log.debug("step42 - cacel future hold");
            actionResetList.forEach(qTimeActionRegisterInfo -> {
                ObjectIdentifier lotID = qTimeActionRegisterInfo.getLotID();
                List<Infos.LotHoldReq> futureHoldList = qTimeActionRegisterInfo.getFutureHoldList();
                log.trace("actionResetList is 【{}】",actionResetList);
                if (!CimArrayUtils.isEmpty(futureHoldList)) {
                    Params.FutureHoldCancelReqParams futureHoldCancelReqParams = new Params.FutureHoldCancelReqParams();
                    futureHoldCancelReqParams.setLotID(lotID);
                    futureHoldCancelReqParams.setReleaseReasonCodeID(new ObjectIdentifier(BizConstant.SP_REASON_QTIMECLEAR));
                    futureHoldCancelReqParams.setEntryType(BizConstant.SP_ENTRYTYPE_CANCEL);
                    futureHoldCancelReqParams.setLotHoldList(futureHoldList);
                    processControlService.sxFutureHoldCancelReq(objCommon, futureHoldCancelReqParams);
                }

                //----- Future Rework Actions -------//
                List<Infos.FutureReworkInfo> futureReworkList = qTimeActionRegisterInfo.getFutureReworkList();
                log.debug("step43 - cancel future rework");
                if (CimArrayUtils.isNotEmpty(futureReworkList)) {
                    for (Infos.FutureReworkInfo futureReworkInfo : futureReworkList) {
                        processControlService.sxFutureReworkCancelReq(objCommon, futureReworkInfo.getLotID(), futureReworkInfo.getRouteID(), futureReworkInfo.getOperationNumber(),
                                futureReworkInfo.getFutureReworkDetailInfoList(), "");
                    }
                }
            });
        }

        ObjectIdentifier monitorLotID = null;

        for (int i = 0; i < scLen; i++) {
            List<Infos.LotInCassette> strLotInCassette = startCassetteList.get(i).getLotInCassetteList();
            int lcLen = CimArrayUtils.getSize(strLotInCassette);
            for (int j = 0; j < lcLen; j++) {
                Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                if (CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag()) &&
                        CimBooleanUtils.isTrue(lotInCassette.getMonitorLotFlag())) {
                    monitorLotID = lotInCassette.getLotID();
                    break;
                }
            }
        }

        if (monitorLotID != null && !CimStringUtils.isEmpty(monitorLotID.getValue())) {
            log.debug("step44 - delete monitor batch");
            processMonitorService.sxMonitorBatchDeleteReq(objCommon, monitorLotID);

        }

        startCassetteList.forEach(startCassette -> startCassette.getLotInCassetteList().stream()
                .filter(lotInCassetteFilter)
                .forEach(lotInCassette -> {
                    log.debug("step45 - get lot current operation info");
                    Outputs.ObjLotCurrentOperationInfoGetOut lotCurrentOperationInfoOut = lotMethod.lotCurrentOperationInfoGet(objCommon, lotInCassette.getLotID());

                    String targetRouteID = lotCurrentOperationInfoOut.getRouteID().getValue();
                    String targetOperationNumber = lotCurrentOperationInfoOut.getOperationNumber();
                    Inputs.ObjScheduleChangeReservationGetListIn scheduleChangeReservationParams = new Inputs.ObjScheduleChangeReservationGetListIn();
                    scheduleChangeReservationParams.setObjectID(lotInCassette.getLotID().getValue());
                    scheduleChangeReservationParams.setObjectID(BizConstant.SP_SCHDL_CHG_OBJTYPE_LOT);
                    scheduleChangeReservationParams.setTargetRouteID(targetRouteID);
                    scheduleChangeReservationParams.setTargetOperationNumber(targetOperationNumber);
                    //2: LOTINFO_CHANGE_FLAG is 1. this flag value to be optimized as a constant
                    scheduleChangeReservationParams.setLotInfoChangeFlag(2L);
                    log.debug("step46 - get schedule change reservation");
                    List<Infos.SchdlChangeReservation> scheduleChangeReservationList = scheduleChangeReservationMethod.schdlChangeReservationGetListDR(objCommon, scheduleChangeReservationParams);
                    if (!CimArrayUtils.isEmpty(scheduleChangeReservationList)) {
                        scheduleChangeReservationList.forEach(scheduleChangeReservation -> {
                            log.debug("step47 - delete schedule change reservation");
                            scheduleChangeReservationMethod.schdlChangeReservationDeleteDR(objCommon, scheduleChangeReservation);

                            log.debug("step48 - Send e-mail");
                            StringBuffer ostrMessage = new StringBuffer();
                            ostrMessage.append("This message was sent because reservation for \"Lot Information Change\" is canceled.\n");
                            ostrMessage.append("Schedule Change Reservation Info.\n");
                            ostrMessage.append(String.format("LotID      : %s", lotInCassette.getLotID() + "\n"));
                            ostrMessage.append(String.format("Product ID : %s", scheduleChangeReservation.getProductID() + "\n"));
                            ostrMessage.append(String.format("Route ID   : %s", scheduleChangeReservation.getRouteID() + "\n"));
                            ostrMessage.append(String.format("Ope.No     : %s", scheduleChangeReservation.getOperationNumber() + "\n"));
                            ostrMessage.append(String.format("SubLotType : %s", scheduleChangeReservation.getSubLotType() + "\n"));
                            messageMethod.messageDistributionMgrPutMessage(objCommon, new ObjectIdentifier(BizConstant.SP_SYSTEMMSGCODE_SCRNOTICE), lotInCassette.getLotID(), "", equipmentID,
                                    lotCurrentOperationInfoOut.getRouteID(), lotCurrentOperationInfoOut.getOperationNumber(), "", ostrMessage.toString());
                        });
                    }
                }));
        /*
         cassette Related Information Update Procedure
         */

        final boolean finalSlmCapabilityFlag = slmCapabilityFlag;
        Predicate<Infos.StartCassette> startCassetteFilter = startCassette -> !ObjectIdentifier.isEmpty(startCassette.getCassetteID()) || !finalSlmCapabilityFlag;
        startCassetteList.stream()
                .filter(startCassetteFilter)
                .forEach(startCassette -> {
                    log.debug("step49 - Update Casssette's Usage Information");
                    cassetteMethod.cassetteUsageCountDecrement(objCommon, startCassette.getCassetteID());
                });

        log.debug("setp50 - flow Batch Information Update By Operation Start Cancel");
        flowBatchMethod.flowBatchInformationUpdateByOpeStartCancel(objCommon, equipmentID, startCassetteList);

        /*
         eqp Related Information Update Procedur
         */
        if (!virtualOperationFlag) {
            log.debug("setp51 - delete equipment process lot");
            equipmentMethod.equipmentProcessingLotDelete(objCommon, equipmentID, startCassetteList);
        }
        /*
         Maintain Eqp's Status for OFF-LINE Mode
         */
        log.trace("onlineMode is 【{}】",onlineMode);
        if (BizConstant.SP_EQP_ONLINEMODE_OFFLINE.equalsIgnoreCase(onlineMode)) {
            //Change eqp's Status to 'STANDBY'
            log.debug("setp52 - check equipment current state to manufacturing");
            Boolean checkEquipmentCurrentState2ManufacturingResult = equipmentMethod.equipmentCurrentStateCheckToManufacturing(objCommon, equipmentID);
            Boolean manufacturingStateChangeableFlag = checkEquipmentCurrentState2ManufacturingResult;
            if (manufacturingStateChangeableFlag != null && manufacturingStateChangeableFlag) {
                log.debug("setp53 - get equipment current state to manufacturing");
                ObjectIdentifier getRecoverStateResult = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, equipmentID);
                ObjectIdentifier equipmentStatusCode = getRecoverStateResult;

                log.debug("step54 - change equipment status");
                try {
                    sxEqpStatusChangeReq(objCommon, equipmentID, equipmentStatusCode, "");
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())) {
                        throw e;
                    }
                }
            }
        }
        /*
         Update eqp's Usage Information
         */
        log.debug("step55 - decrement equipment usage count");
        equipmentMethod.equipmentUsageCountDecrement(objCommon, equipmentID, startCassetteList);
        //-----------------------------------------------------------//
        //  Wafer Stacking Operation                                 //
        //    If Equipment Category is SP_Mc_Category_WaferBonding,  //
        //    update Bonding Group Information                       //
        //-----------------------------------------------------------//
        //------------------------------//
        //   Check Equipment Category   //
        //------------------------------//
        log.trace("EquipmentCategory is 【{}】",eqpBrInfo.getEquipmentCategory());
        if (CimStringUtils.equals(eqpBrInfo.getEquipmentCategory(), BizConstant.SP_MC_CATEGORY_WAFERBONDING)) {
            log.debug("step56 - lot bonding greoup update by operation");
            lotMethod.lotBondingGroupUpdateByOperation(objCommon, equipmentID, controlJobID, startCassetteList, BizConstant.SP_OPERATION_OPESTARTCANCEL);
        }
        log.debug("step57 - clear process start reserve information");
        processMethod.processStartReserveInformationClear(objCommon, controlJobID, startCassetteList);

        log.debug("step58 - Clear wafer Chamber Information in process");
        processMethod.processWaferChamberInformationClear(objCommon, startCassetteList);

        log.debug("step59 - Clear Process resource wafer position information in process");
        processMethod.processWaferPositionInProcessResourceInformationClear(objCommon, startCassetteList);

//        RetCode<Object> controlJobDeleteOut = controlJobMethod.controlJobDelete(objCommon, controlJobID, CIMStateEnum.SP_CONTROLJOB_ACTION_TYPE_DELETE.getValue());
        Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
        cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE);
        cjStatusChangeReqParams.setControlJobID(controlJobID);
        cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());

        if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())    //TxPartialMoveOutReq
                && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) { //TxPartialMoveOutForIBReq
            log.debug("step60 - change CJ status");
            controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);
        }

        for (int i = 0; i < scLen; i++) {
            List<Infos.LotInCassette> strLotInCassette = startCassetteList.get(i).getLotInCassetteList();
            int lcLen = CimArrayUtils.getSize(strLotInCassette);
            for (int j = 0; j < lcLen; j++) {
                Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                if (!CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag())) {
                    continue;
                }

                log.debug("step61 - filter constraint exception lot");
                constraintMethod.constraintFilterExceptionLot(objCommon, lotInCassette.getLotID(), null);

            }
        }

        /*
         Get of the FutureHold information by ImmediateHold for OperationStartCancel
         */
        startCassetteList.forEach(startCassette -> startCassette.getLotInCassetteList().stream()
                .filter(lotInCassetteFilter)
                .forEach(lotInCassette -> {
                    log.debug("step62 - Get of the FutureHold information");
                    Outputs.ObjLotFutureHoldRequestsEffectForOpeStartCancelOut effect4OpeStartCancelOut = lotMethod.lotFutureHoldRequestsEffectForOpeStartCancel(objCommon, lotInCassette.getLotID());
                    /*
                     FutureHold(POST) registered by ImmediateHold action is released
                     */
                    log.debug("step63 - cancel future hold");
                    List<Infos.LotHoldReq> futureHoldReleaseReqList = effect4OpeStartCancelOut.getFutureHoldReleaseReqList();
                    if (!CimArrayUtils.isEmpty(futureHoldReleaseReqList)) {
                        Params.FutureHoldCancelReqParams futureHoldCancelReqParams = new Params.FutureHoldCancelReqParams();
                        futureHoldCancelReqParams.setLotID(effect4OpeStartCancelOut.getLotID());
                        futureHoldCancelReqParams.setReleaseReasonCodeID(new ObjectIdentifier(BizConstant.EMPTY));
                        futureHoldCancelReqParams.setEntryType(BizConstant.SP_ENTRYTYPE_REMOVE);
                        futureHoldCancelReqParams.setLotHoldList(futureHoldReleaseReqList);
                        processControlService.sxFutureHoldCancelReq(objCommon, futureHoldCancelReqParams);
                    }
                    /*
                     FutureHold is performed immediately
                     */
                    List<Infos.LotHoldReq> lotHoldReqList = effect4OpeStartCancelOut.getLotHoldReqList();
                    log.debug("step64 - hold lot");
                    if (!CimArrayUtils.isEmpty(lotHoldReqList)) {
                        lotService.sxHoldLotReq(objCommon, effect4OpeStartCancelOut.getLotID(), lotHoldReqList);
                    }

                }));

        /*--------------------------*/
        /*                          */
        /*   Event Make Procedure   */
        /*                          */
        /*--------------------------*/
        for (int i = 0; i < scLen; i++) {
            int j = 0;
            int lcLen = CimArrayUtils.getSize(startCassetteList.get(i).getLotInCassetteList());
            for (j = 0; j < lcLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (Objects.equals(startCassetteList.get(i).getLotInCassetteList().get(j).getMoveInFlag(), FALSE)) {
                    continue;
                }

                /*--------------------------------------------------------------------*/
                /*   Make OperationMoveEvent for Operation History - OpeStartCancel   */
                /*--------------------------------------------------------------------*/
                log.debug("step65 - Make OperationMoveEvent for Operation History - OpeStartCancel ");
                eventMethod.lotOperationMoveEventMakeOpeStartCancel(objCommon,
                        objCommon.getTransactionID(),
                        equipmentID,
                        operationModeID,
                        controlJobID,
                        startCassetteList.get(i).getCassetteID(),
                        startCassetteList.get(i).getLotInCassetteList().get(j),
                        null);

            }
        }

        //Step68 - TCSMgr_SendMoveInCancelReq
        /*------------------------------------------------------------------------*/
        /*   Send OpeStartCancel Request to EAP Procedure                         */
        /*------------------------------------------------------------------------*/
        log.debug("step66 - Send OpeStartCancel Request to EAP Procedure");
        if (!CimStringUtils.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue(), objCommon.getTransactionID())
                && !CimStringUtils.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(), objCommon.getTransactionID())) {
//            Inputs.SendMoveInCancelReqIn sendMoveInCancelReqIn = new Inputs.SendMoveInCancelReqIn();
//            sendMoveInCancelReqIn.setObjCommonIn(objCommon);
//            sendMoveInCancelReqIn.setRequestUserID(objCommon.getUser());
//            sendMoveInCancelReqIn.setEquipmentID(equipmentID);
//            sendMoveInCancelReqIn.setControlJobID(controlJobID);
//            Outputs.SendMoveInCancelReqOut sendMoveInCancelReqOut = (Outputs.SendMoveInCancelReqOut) tcsMethod.sendTCSReq(TCSReqEnum.sendMoveInCancelReq, sendMoveInCancelReqIn);
            Params.MoveInCancelReqParams params = new Params.MoveInCancelReqParams();
            params.setControlJobID(controlJobID);
            params.setEquipmentID(equipmentID);
            params.setUser(objCommon.getUser());
            params.setOpeMemo(claimMemo);
            String tmpSleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue();
            String tmpRetryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue();
            Long sleepTimeValue = 0L;
            Long retryCountValue = 0L;

            if (0 == CimStringUtils.length(tmpSleepTimeValue)) {
                sleepTimeValue = BizConstant.SP_DEFAULT_SLEEP_TIME_TCS;
            } else {
                sleepTimeValue = CimNumberUtils.longValue(tmpSleepTimeValue);
            }

            if (0 == CimStringUtils.length(tmpRetryCountValue)) {
                retryCountValue = BizConstant.SP_DEFAULT_RETRY_COUNT_TCS;
            } else {
                retryCountValue = CimNumberUtils.longValue(tmpRetryCountValue);
            }

            for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                log.trace("{} {}", "loop to retryCountValue + 1", retryNum);
                /*--------------------------*/
                /*    Send Request to EAP   */
                /*--------------------------*/
                IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,params.getUser(),params.getEquipmentID(),null,true);
                log.trace("eapRemoteManager is 【{}】",eapRemoteManager);
                if (null == eapRemoteManager) {
                    break;
                }
                try {
                    Object moveInCancelReqEapOut = eapRemoteManager.sendMoveInCancelReq(params);
                    log.trace("Now EAP subSystem is alive!! Go ahead");
                    break;
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                        log.trace("{} {}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...", retryNum);
                        log.trace("{} {}", "now sleeping... ", sleepTimeValue);
                        if (retryNum != retryCountValue){
                            try {
                                Thread.sleep(sleepTimeValue);
                                continue;
                            } catch (InterruptedException e) {
                                ex.addSuppressed(e);
                                Thread.currentThread().interrupt();
                                throw ex;
                            }
                        }else {
                            Validations.check(true,retCodeConfig.getTcsNoResponse());
                        }
                    } else {
                        Validations.check(true,new OmCode(ex.getCode(),ex.getMessage()));
                    }
                }
            }
        }
        //TODO-NOTIMPL: Step69 - DCSMgr_SendOperationStartCancelRpt
        // Step70 - APCRuntimeCapability_DeleteDR
        log.debug("step67 - delete runtime capability");
        apcMethod.apcRuntimeCapabilityDeleteDR(objCommon, controlJobID);

        log.debug("step68 - send control job information");
        if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
            //      Wafer information in APCBaseCassette is not necessary for reserve cancel,
            //      but it is required by wrapper for process xml which satisfy dtd.
            //      So, now we add dummy wafer data into strCassette_APCInformation_GetDR_out.strAPCBaseCassetteList.
            int bcLen = CimArrayUtils.getSize(apcBaseCassettes);
            for (int bcIdx = 0; bcIdx < bcLen; bcIdx++) {
                Infos.ApcBaseCassette apcBaseCassette = apcBaseCassettes.get(bcIdx);
                List<Infos.ApcBaseLot> apcBaseLotList = apcBaseCassette.getApcBaseLotList();
                int blLen = CimArrayUtils.getSize(apcBaseLotList);
                for (int blIdx = 0; blIdx < blLen; blIdx++) {
                    Infos.ApcBaseLot apcBaseLot = apcBaseLotList.get(blIdx);
                    Infos.ApcBaseWafer apcBaseWafer = new Infos.ApcBaseWafer();
                    apcBaseWafer.setWaferID("");
                    apcBaseWafer.setSlotNumber(0L);
                    apcBaseWafer.setControlWaferFlag(false);
                    apcBaseWafer.setSendAheadWaferFlag(false);
                    apcBaseWafer.setProcessFlag(false);
                    apcBaseWafer.setExperimentSplitWafer(false);
                    apcBaseLot.setApcBaseWaferList(Collections.singletonList(apcBaseWafer));
                }
            }
            int retCode = 0;
            try {
                apcMethod.APCMgrSendControlJobInformationDR(objCommon, equipmentID, controlJobID, BizConstant.SP_APC_CONTROLJOBSTATUS_CANCELED, apcBaseCassettes);
            } catch (ServiceException e) {
                retCode = e.getCode();
                if (!Validations.isEquals(retCodeConfigEx.getOkNoIF(), e.getCode())) {
                    throw e;
                }
            }

            if (retCode == 0) {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CREATED;
            }
        } else {
            strAPCBaseCassetteListForOpeStartCancel = apcBaseCassettes;
        }
        retVal.setStartCassetteList(startCassetteList);
        return retVal;
    }

    @Override
    public Results.MoveInReqResult sxMoveInForIBReq(Infos.ObjCommon objCommon, Params.MoveInForIBReqParams moveInForIBReqParams, String APCIFControlStatus, String DCSIFControlStatus) {
        String claimMemo = "";
        Results.MoveInReqResult strMoveInForIBReqResult = new Results.MoveInReqResult();
        List<Infos.StartCassette> strStartCassette = moveInForIBReqParams.getStartCassetteList();

        boolean processJobPauseFlag = moveInForIBReqParams.isProcessJobPauseFlag();
        // step1 - lot_processJobExecFlag_ValidCheckForOpeStart
        lotMethod.lotProcessJobExecFlagValidCheckForOpeStart(objCommon, strStartCassette, processJobPauseFlag);

        boolean sendTxFlag = false;
        ObjectIdentifier controlJobID = moveInForIBReqParams.getControlJobID();
        List<Infos.APCRunTimeCapabilityResponse> apcRunTimeCapabilityResponseList = null;
        if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            sendTxFlag = true;
            /*-----------------------------------------*/
            /*   call txAPCRunTimeCapabilityInq        */
            /*-----------------------------------------*/
            // step2  txAPCRTSystemInfoInq
            apcRunTimeCapabilityResponseList = apcInqService.sxAPCRunTimeCapabilityInq(objCommon, moveInForIBReqParams.getEquipmentID(), moveInForIBReqParams.getControlJobID(), strStartCassette, true);
            int runCapaRespCount = CimArrayUtils.getSize(apcRunTimeCapabilityResponseList);
            if (runCapaRespCount > 0) {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CANCELED;
            }
            // step3 txAPCRcpParmChgInq
            int retCode = 0;
            try {
                strStartCassette = apcInqService.sxAPCRecipeParameterAdjustInq(objCommon, moveInForIBReqParams.getEquipmentID(), strStartCassette, apcRunTimeCapabilityResponseList, true);
            } catch (ServiceException e) {
                retCode = e.getCode();
                if (!Validations.isEquals(retCodeConfigEx.getOkNoIF(), e.getCode())) {
                    throw e;
                }
            }
            if (retCode == 0) {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CANCELED;
            }

        }
        strMoveInForIBReqResult.setStartCassetteList(strStartCassette);
        /*=-=-=-=-=-=-=-=-==-=*/
        /*   Check Process    */
        /*=-=-=-=-=-=-=-=-==-=*/
        // step4 - lot_processJobExecFlag_ValidCheckForOpeStart
        lotMethod.lotProcessJobExecFlagValidCheckForOpeStart(objCommon, strStartCassette, processJobPauseFlag);

        ObjectIdentifier equipmentID = moveInForIBReqParams.getEquipmentID();
        // step5 - equipment_categoryVsTxID_CheckCombination
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*   Object Lock Process   */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=*/
        // step6 - object_lockMode_Get
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        if (!ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            objLockModeIn.setFunctionCategory(TransactionIDEnum.OPERATION_START_FOR_INTERNAL_BUFFER_REQ.getValue());
        } else {
            objLockModeIn.setFunctionCategory(BizConstant.SP_FUNCTIONCATEGORY_OPESTARTFORIBWITHCJIDGENTXID);
        }
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // step7 - advanced_object_Lock
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            // step8 - object_Lock
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        int nILen = CimArrayUtils.getSize(strStartCassette);

        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();

        for (int i = 0; i < nILen; i++) {
            Infos.StartCassette startCassette = strStartCassette.get(i);
            ObjectIdentifier cassetteID = startCassette.getCassetteID();
            cassetteIDs.add(cassetteID);

            List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
            int nJLen = CimArrayUtils.getSize(strLotInCassette);
            for (int j = 0; j < nJLen; j++) {
                lotIDs.add(strLotInCassette.get(j).getLotID());
            }
        }

        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // step9 - equipment_onlineMode_Get
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                // step10 - advanced_object_Lock
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
        }
        List<String> loadCastSeq = cassetteIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
        // step11 - advanced_object_Lock
        objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                BizConstant.SP_CLASSNAME_POSMACHINE,
                BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ, loadCastSeq));
        if (!ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            // step12 - object_Lock
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
        } else {
            /*------------------------------*/
            /*   Lock Dispatcher Object     */
            /*------------------------------*/
            // step13 - object_Lock
            objectLockMethod.objectLock(objCommon, CimDispatcher.class, equipmentID);
        }
        /*------------------------------*/
        /*   Lock Cassette/Lot Object   */
        /*-------------------------------*/
        // step14 - objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);
        // step15 - objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, lotIDs);

        String eqpMonitorSwitch = StandardProperties.OM_AUTOMON_FLAG.getValue();
        if (CimStringUtils.equals(eqpMonitorSwitch, BizConstant.VALUE_ONE)) {
            List<ObjectIdentifier> eqpMonitorList = new ArrayList<>();
            Integer eqpMonitorCnt = 0;
            Integer eqpMonitorLen = 5;
            List<Infos.EqpMonitorJobInfo> strEqpMonitorJobInfoSeq = new ArrayList<>();
            Integer eqpMonJobCnt = 0;
            Integer eqpMonJobLen = 5;
            int castLen = CimArrayUtils.getSize(strStartCassette);
            for (int i = 0; i < castLen; i++) {
                Infos.StartCassette startCassette = strStartCassette.get(i);
                List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
                int lotLen = CimArrayUtils.getSize(strLotInCassette);
                for (int j = 0; j < lotLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }
                    if (!CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                            && !CimStringUtils.equals(lotInCassette.getSubLotType(), BizConstant.SP_LOT_TYPE_DUMMYLOT)) {
                        continue;
                    }

                    // step16 - lot_eqpMonitorSectionInfo_GetForJob
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut strLotEqpMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassette.getLotID());

                    if (!ObjectIdentifier.isEmpty(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                        if (CimStringUtils.equals(strLotEqpMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)) {
                            boolean bNewEqpMonitor = true;
                            for (int iCnt1 = 0; iCnt1 < eqpMonitorCnt; iCnt1++) {
                                ObjectIdentifier eqpMonitor = eqpMonitorList.get(iCnt1);
                                if (ObjectIdentifier.equalsWithValue(eqpMonitor, strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID())) {
                                    bNewEqpMonitor = false;
                                    break;
                                }
                            }

                            if (bNewEqpMonitor) {
                                if (eqpMonitorCnt > eqpMonitorLen) {
                                    eqpMonitorLen = eqpMonitorLen + 5;
                                }
                                eqpMonitorList.add(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                eqpMonitorCnt++;
                            }
                        }

                        if (CimStringUtils.equals(strLotEqpMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)
                                || strLotEqpMonitorSectionInfoGetForJobOut.isExitFlag()) {
                            boolean bNewEqpMonJob = true;
                            for (int iCnt2 = 0; iCnt2 < eqpMonJobCnt; iCnt2++) {
                                Infos.EqpMonitorJobInfo strEqpMonitorJobInfo = strEqpMonitorJobInfoSeq.get(iCnt2);
                                if (ObjectIdentifier.equalsWithValue(strEqpMonitorJobInfo.getEqpMonitorJobID(), strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                                    bNewEqpMonJob = false;
                                    break;
                                }
                            }

                            if (bNewEqpMonJob) {
                                if (eqpMonJobCnt > eqpMonJobLen) {
                                    eqpMonJobLen = eqpMonJobLen + 5;
                                }

                                Infos.EqpMonitorJobInfo strEqpMonitorJobInfo = new Infos.EqpMonitorJobInfo();
                                strEqpMonitorJobInfoSeq.add(strEqpMonitorJobInfo);
                                strEqpMonitorJobInfo.setEqpMonitorJobID(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());
                                strEqpMonitorJobInfo.setEqpMonitorID(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                eqpMonJobCnt++;
                            }
                        }
                    }
                }
            }

            for (int iCnt3 = 0; iCnt3 < eqpMonitorCnt; iCnt3++) {
                // step17 -  object_Lock
                objectLockMethod.objectLock(objCommon, CimEqpMonitor.class, eqpMonitorList.get(iCnt3));
            }

            for (int iCnt4 = 0; iCnt4 < eqpMonJobCnt; iCnt4++) {
                // step18 - object_LockForEqpMonitorJob
                objectLockMethod.objectLockForEqpMonitorJob(objCommon, strEqpMonitorJobInfoSeq.get(iCnt4).getEqpMonitorID(), strEqpMonitorJobInfoSeq.get(iCnt4).getEqpMonitorJobID());
            }
        }

        // seasoning 相关代码, by ho
        seasonMethod.checkSeasonForMoveIn(objCommon, moveInForIBReqParams.getEquipmentID(), moveInForIBReqParams.getStartCassetteList());
        seasoningService.sxSeasonJobForMoveInUpdate(objCommon, moveInForIBReqParams.getEquipmentID());

        //check Ocap Info without moveInReserve case
        strStartCassette = ocapMethod.ocapCheckEquipmentAndSamplingAndRecipeExchange(equipmentID,
                strStartCassette);

        log.debug("check PM PilotRun");
        pilotRunMethod.checkPMRun(moveInForIBReqParams.getEquipmentID(), strStartCassette);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*   BRScript Execution Process                                          */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        nILen = CimArrayUtils.getSize(strStartCassette);
        for (int i = 0; i < nILen; i++) {
            Infos.StartCassette startCassette = strStartCassette.get(i);
            if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                continue;
            }

            int nJLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nJLen; j++) {
                Infos.LotInCassette lotInCassette = strStartCassette.get(i).getLotInCassetteList().get(j);
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }
                /*-------------------------*/
                /*   Execute Pre2 BRScript */
                /*-------------------------*/
                log.info("Execute Pre2 Script");
                Params.ProcessControlScriptRunReqParams scriptParams = new Params.ProcessControlScriptRunReqParams();
                scriptParams.setEquipmentId(equipmentID);
                scriptParams.setLotId(lotInCassette.getLotID());
                scriptParams.setPhase(BizConstant.SP_BRSCRIPT_PRE2);
                scriptParams.setUser(objCommon.getUser());
                processControlScriptService.sxProcessControlScriptRunReq(objCommon, scriptParams);
            }
        }


        /*-----------------------------------------------------------*/
        /*   machine recipe convert to layout recipe                 */
        /*-----------------------------------------------------------*/
        LayoutRecipeParams.ConvertEquipmentFurnaceRecipeParams convertEquipmentFurnaceRecipeParams = new LayoutRecipeParams.ConvertEquipmentFurnaceRecipeParams();
        convertEquipmentFurnaceRecipeParams.setEquipmentId(moveInForIBReqParams.getEquipmentID());
        convertEquipmentFurnaceRecipeParams.setStartCassettes(strStartCassette);
        strStartCassette = layoutRecipeMethod.equipmentFurnaceRecipeConvert(objCommon, convertEquipmentFurnaceRecipeParams);
        moveInForIBReqParams.setStartCassetteList(strStartCassette);


        /*------------------------------------------------------------------*/
        /*   machine recipe convert to chamber level recipe                 */
        /*------------------------------------------------------------------*/
        ChamberLevelRecipeReserveParam chamberLevelRecipeReserveParam = new ChamberLevelRecipeReserveParam();
        chamberLevelRecipeReserveParam.setEquipmentId(moveInForIBReqParams.getEquipmentID());
        chamberLevelRecipeReserveParam.setStartCassettes(moveInForIBReqParams.getStartCassetteList());
        strStartCassette = chamberLevelRecipeMethod.chamberLevelRecipeMoveQueryRpt(objCommon, chamberLevelRecipeReserveParam);
        moveInForIBReqParams.setStartCassetteList(strStartCassette);

        //---------------------------------------------------------------------------------
        // ControlJob Checking
        // If Start Cassette had a Control Job whether InParameter of Control Job is blank,
        // Makes request fail.
        //---------------------------------------------------------------------------------
        if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            // step20 - cassette_controlJobID_Get
            //-----------------------------------------------------------
            // ControlJob Check for first record of strStartCassette.
            // Because checking ControlJob whether All ControlJoj is same
            // at cassette_CheckConditionForOperation().
            //-----------------------------------------------------------
            ObjectIdentifier strCassetteControlJobIDGetOut = cassetteMethod.cassetteControlJobIDGet(objCommon, new ObjectIdentifier(strStartCassette.get(0).getCassetteID().getValue()));
            //---------------------------------
            // Inpara ControlJob is not blank
            // but StartCassette has ControlJo.
            //---------------------------------
            Validations.check(!ObjectIdentifier.isEmptyWithValue(strCassetteControlJobIDGetOut), retCodeConfig.getCassetteControlJobFilled());

        }

        // 【step 5-1】 check contamination
        List<ObjectIdentifier> moveInLotIds = strStartCassette.parallelStream()
                .flatMap(startCassette -> startCassette.getLotInCassetteList().parallelStream()
                        .filter(Infos.LotInCassette::getMoveInFlag).map(Infos.LotInCassette::getLotID))
                .collect(Collectors.toList());
        contaminationMethod.lotCheckContaminationLevelAndPrFlagStepIn(moveInLotIds, moveInForIBReqParams.getEquipmentID(),"");
        List<Params.ContaminationAllLotCheckParams> allLots = new ArrayList<>();
        for (Infos.StartCassette tempStartCassettes : strStartCassette){
            List<Infos.LotInCassette> lotInCassetteList = tempStartCassettes.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassetteList){
                Params.ContaminationAllLotCheckParams checkParams = new Params.ContaminationAllLotCheckParams();
                allLots.add(checkParams);
                checkParams.setLotID(lotInCassette.getLotID());
                checkParams.setMoveInFlag(lotInCassette.getMoveInFlag());
            }
        }
        contaminationMethod.contaminationLvlCheckAmongLots(allLots);

        for (Infos.StartCassette startCassette : strStartCassette){
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassetteList){
                if (lotInCassette.getMoveInFlag()){
                    contaminationMethod.recipeContaminationCheck(lotInCassette.getStartRecipe().getLogicalRecipeID(),
                            lotInCassette.getStartRecipe().getMachineRecipeID(),lotInCassette.getLotID(),equipmentID);
                }
            }
        }

        //check capability
        equipmentMethod.capabilityCheck(objCommon,moveInLotIds,moveInForIBReqParams.getEquipmentID());

        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process for Cassette                                          */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   - controlJobID                                                      */
        /*   - multiLotType                                                      */
        /*   - transferState                                                     */
        /*   - transferReserved                                                  */
        /*   - dispatchState                                                     */
        /*   - maxBatchSize                                                      */
        /*   - minBatchSize                                                      */
        /*   - emptyCassetteCount                                                */
        /*   - cassette's loadingSequenceNumber                                  */
        /*   - eqp's multiRecipeCapability and recipeParameter                   */
        /*   - Upper/Lower Limit for RecipeParameterChange                       */
        /*   - MonitorLotCount or OperationStartLotCount                         */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        // step21 - cassette_CheckConditionForOperationForInternalBuffer
        cassetteMethod.cassetteCheckConditionForOperationForInternalBuffer(objCommon, equipmentID, strStartCassette, BizConstant.SP_OPERATION_OPESTART);
        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process for Lot                                               */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   - controlJobID                                                      */
        /*   - lot's equipmentID                                                 */
        /*   - lotHoldState                                                      */
        /*   - lotProcessState                                                   */
        /*   - lotInventoryState                                                 */
        /*   - entityInhibition                                                  */
        /*   - minWaferCount                                                     */
        /*   - equipment's availability for specified lot                        */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        // step22 - lot_CheckConditionForOperationForInternalBuffer
        lotMethod.lotCheckConditionForOperationForInternalBuffer(objCommon, equipmentID, strStartCassette, BizConstant.SP_OPERATION_OPESTART);

        /*-----------------------------------------------------------------------------*/
        /*                                                                             */
        /*   Check Equipment Port for OpeStart                                         */
        /*                                                                             */
        /*   The following conditions are checked by this object                       */
        /*                                                                             */
        /*   1. All of ports' loadMode must be CIMFW_PortRsc_Input or _InputOutput.    */
        /*   2. All of port, which is registered as in-parm's portGroup, must be       */
        /*      _LoadComp when equipment is online.                                    */
        /*   3. All of port, which is registered as in-parm's portGroup, must have     */
        /*      loadedCassetteID. And each combination of cassetteID/portID must be    */
        /*      same as in-parm's startCassette perfectlly.                            */
        /*   4. strStartCassette[].loadPortID's portGroupID must be same as in-parm's  */
        /*      portGroupID.                                                           */
        /*   5. strStartCassette[].loadPurposeType must be match as specified port's   */
        /*      loadPutposeType.                                                       */
        /*   6. strStartCassette[].loadSequenceNumber must be same as specified port's */
        /*      loadSequenceNumber.                                                    */
        /*                                                                             */
        // step23 - equipment_portState_CheckForOpeStartForInternalBuffer
        equipmentMethod.equipmentPortStateCheckForOpeStartForInternalBuffer(objCommon, equipmentID, strStartCassette);
        /*------------------------------------*/
        /*   Get and Check Cassette on Port   */
        /*------------------------------------*/
        // step24 - equipment_portInfo_Get
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID);

        /*---------------------------------*/
        /*   Get Equipment's Online Mode   */
        /*---------------------------------*/
        if (0 >= CimArrayUtils.getSize(eqpPortInfo.getEqpPortStatuses())) {
            throw new ServiceException(retCodeConfig.getNotFoundPort());
        }

        // step25 - portResource_currentOperationMode_Get
        Outputs.ObjPortResourceCurrentOperationModeGetOut strPortResourceCurrentOperationModeGetOut = portMethod.portResourceCurrentOperationModeGet(objCommon, equipmentID,
                eqpPortInfo.getEqpPortStatuses().get(0).getPortID());
        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process for FlowBatch                                         */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   1. whether in-parm's equipment has reserved flowBatchID or not      */
        /*      fill  -> all of flowBatch member and in-parm's lot must be       */
        /*               same perfectly.                                         */
        /*      blank -> no check                                                */
        /*                                                                       */
        /*   2. whether lot is in flowBatch section or not                       */
        /*      in    -> lot must have flowBatchID, and flowBatch must have      */
        /*               reserved equipmentID.                                   */
        /*               if lot is on target operation, flowBatch's reserved     */
        /*               equipmentID and in-parm's equipmentID must be same.     */
        /*      out   -> no check                                                */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        Inputs.ObjEquipmentLotCheckFlowBatchConditionForOperationStartIn operationStartIn = new Inputs.ObjEquipmentLotCheckFlowBatchConditionForOperationStartIn();
        operationStartIn.setEquipmentID(equipmentID);
        operationStartIn.setPortGroupID("");
        operationStartIn.setStartCassetteList(strStartCassette);
        // step26 - equipment_lot_CheckFlowBatchConditionForOpeStart__090
        ObjectIdentifier strEquipmentLotCheckFlowBatchConditionForOpeStartOut = equipmentMethod.equipmentLotCheckFlowBatchConditionForOpeStart(objCommon, operationStartIn);
        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process for Process Durable                                   */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   1. Whether equipment requires process durable or not                */
        /*      If no-need, return OK;                                           */
        /*                                                                       */
        /*   2. All of specified reticles / fixtures must be in the equipment.   */
        /*      And, their state must be _Available or _InUse.                   */
        /*                                                                       */
        /*   3. Entity inhibition for all of specified reticles must not be      */
        /*      registered.                                                      */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/

        /*-----------------------------------------*/
        /*   Check Process Durable Required Flag   */
        /*-----------------------------------------*/
        // step27 - equipment_processDurableRequiredFlag_Get
        Integer saveCode = null;
        try {
            equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, equipmentID);
            saveCode = retCodeConfig.getSucc().getCode();
        } catch (ServiceException e) {
            saveCode = e.getCode();
            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())
                    || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                nILen = CimArrayUtils.getSize(strStartCassette);
                for (int i = 0; i < nILen; i++) {
                    Infos.StartCassette startCassette = strStartCassette.get(i);
                    if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                        continue;
                    }
                    List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
                    int nJLen = CimArrayUtils.getSize(strLotInCassette);
                    for (int j = 0; j < nJLen; j++) {
                        Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                        if (!lotInCassette.getMoveInFlag()) {
                            continue;
                        }

                        List<Infos.StartReticleInfo> strStartReticle = lotInCassette.getStartRecipe().getStartReticleList();
                        if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode()) && CimArrayUtils.getSize(strStartReticle) > 0) {
                            /*---------------------------------*/
                            /*   Get and Check Reticle State   */
                            /*     - state                     */
                            /*     - transferState             */
                            /*---------------------------------*/
                            // step28 - reticle_state_Check__170 注意
                            reticleMethod.reticleStateCheck170(objCommon, equipmentID, strStartReticle, lotInCassette.getLotID());


                            /*------------------------------*/
                            /*   Check Reticle Inhibition   */
                            /*------------------------------*/
                            int rtclLen = CimArrayUtils.getSize(strStartReticle);
                            Infos.EntityInhibitAttributes entityInhibitAttributes = new Infos.EntityInhibitAttributes();
                            List<Infos.EntityIdentifier> entities = new ArrayList<>();
                            for (int k = 0; k < rtclLen; k++) {
                                Infos.EntityIdentifier entity = new Infos.EntityIdentifier();
                                entity.setClassName(BizConstant.SP_INHIBITCLASSID_RETICLE);
                                entity.setObjectID(strStartReticle.get(k).getReticleID());
                                entity.setAttribution("");
                                entities.add(entity);
                            }
                            entityInhibitAttributes.setEntities(entities);

                            // step29 - entityInhibit_CheckForEntities
                            Infos.EntityInhibitCheckForEntitiesOut strEntityInhibitCheckForEntitiesOut = constraintMethod.constraintCheckForEntities(objCommon, entityInhibitAttributes);

                            int lenInhibit = CimArrayUtils.getSize(strEntityInhibitCheckForEntitiesOut.getEntityInhibitInfo());
                            List<Infos.EntityInhibitInfo> strEntityInhibitFilterExceptionLotOut = null;
                            if (lenInhibit > 0) {
                                // step30 - entityInhibit_FilterExceptionLot
                                strEntityInhibitFilterExceptionLotOut = constraintMethod.constraintFilterExceptionLot(objCommon, lotInCassette.getLotID(), strEntityInhibitCheckForEntitiesOut.getEntityInhibitInfo());
                                lenInhibit = CimArrayUtils.getSize(strEntityInhibitFilterExceptionLotOut);
                            }
                            if (lenInhibit > 0) {
                                if (0 >= CimArrayUtils.getSize(strEntityInhibitFilterExceptionLotOut.get(0).getEntityInhibitAttributes().getEntities())) {
                                    throw new ServiceException(retCodeConfig.getNotFoundEntityInhibit());
                                }
                                throw new ServiceException(new OmCode(retCodeConfig.getInhibitEntity()
                                        , ObjectIdentifier.fetchValue(strEntityInhibitFilterExceptionLotOut.get(0).getEntityInhibitAttributes().getEntities().get(0).getObjectID())
                                        , BizConstant.SP_INHIBITCLASSID_RETICLE));
                            }

                            rtclLen = CimArrayUtils.getSize(strStartReticle);
                            for (int k = 0; k < rtclLen; k++) {
                                // step31 - reticle_dispatchJob_CheckExistenceDR
                                reticleMethod.reticleDispatchJobCheckExistenceDR(objCommon, strStartReticle.get(k).getReticleID(), null, null);

                                // step32 - reticle_detailInfo_GetDR__170
                                Results.ReticleDetailInfoInqResult strReticleDetailInfoGetDROut = reticleMethod.reticleDetailInfoGetDR(objCommon, strStartReticle.get(k).getReticleID(), false, false);
                                if (!CimStringUtils.isEmpty(strReticleDetailInfoGetDROut.getReticleStatusInfo().getReticlePodID().getValue())) {
                                    throw new ServiceException(retCodeConfig.getNotAvailableReticle());
                                }
                            }
                        } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                            /*---------------------------------*/
                            /*   Get and Check Fixture State   */
                            /*     - state                     */
                            /*     - transferState             */
                            /*---------------------------------*/
                            // step33 - fixture_state_Check
                            fixtureMethod.fixtureStateCheck(objCommon, equipmentID, lotInCassette.getStartRecipe().getStartFixtureList());
                        }
                    }
                }
            } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableNotRequired(), e.getCode())) {
                //result.setReturnCode(retCodeConfig.getSucc());
            } else {
                throw e;
            }
        }

        /*---------------------------------------------------------------------------*/
        /*                                                                           */
        /*   Check Carrier Type for next operation of Empty carrier.             */
        /*                                                                           */
        /*---------------------------------------------------------------------------*/
        // step34 - emptyCassette_CheckCategoryForOperation
        cassetteMethod.emptyCassetteCheckCategoryForOperation(objCommon, strStartCassette);

        int castLen = CimArrayUtils.getSize(strStartCassette);
        for (int cnt = 0; cnt < castLen; cnt++) {
            cassetteIDs.add(strStartCassette.get(cnt).getCassetteID());
        }
        //-------------------------------------------------
        //  Check Scrap Wafer Exsit In Carrier
        //-------------------------------------------------
        // step35 - cassette_scrapWafer_SelectDR
        List<Infos.LotWaferMap> lotWaferMaps = cassetteMethod.cassetteScrapWaferSelectDR(objCommon, cassetteIDs);
        int scrapCount = CimArrayUtils.getSize(lotWaferMaps);
        if (scrapCount > 0) {
            throw new ServiceException(retCodeConfig.getFoundScrap());
        }

        //-------------------------------------------------
        //  Check pilotrun in eqp
        //-------------------------------------------------
        pilotRunMethod.checkPilotRunForEquipment(objCommon, equipmentID, strStartCassette);

        // Check Min Q-Time restrictions
        minQTimeMethod.checkIsRejectByRestriction(objCommon, strStartCassette);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Main Process                                                        */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

        /*--------------------------------------------------------*/
        /*     Control Job Related Information Update Procedure   */
        /*--------------------------------------------------------*/

        ObjectIdentifier saveControlJobID = null;
        if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            Params.CJStatusChangeReqParams strControlJobCreateRequest = new Params.CJStatusChangeReqParams();
            strControlJobCreateRequest.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_CREATE);
            strControlJobCreateRequest.setClaimMemo(moveInForIBReqParams.getOpeMemo());
            Infos.ControlJobCreateRequest controlJobCreateRequest = new Infos.ControlJobCreateRequest();
            controlJobCreateRequest.setEquipmentID(equipmentID);
            controlJobCreateRequest.setPortGroup("");
            controlJobCreateRequest.setStartCassetteList(strStartCassette);
            strControlJobCreateRequest.setControlJobCreateRequest(controlJobCreateRequest);
            // step36 - txCJStatusChangeReq
            Results.CJStatusChangeReqResult strCJStatusChangeReqResult = controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, strControlJobCreateRequest);
            saveControlJobID = strCJStatusChangeReqResult.getControlJobID();

            /*----------------------------------------------------*/
            /*   Set Start Reservation Info to Each Lots' PO      */
            /*                                                    */
            /*   - Set created controlJobID into each cassette.   */
            /*   - Set created controlJobID into each lot.        */
            /*   - Set control job info (StartRecipe, DCDefs,     */
            /*     DCSpecs, Parameters, ...) into each lot's      */
            /*     cunrrent PO.                                   */
            /*----------------------------------------------------*/
            // step37 - process_startReserveInformation_Set__090
            processMethod.processStartReserveInformationSet(objCommon, equipmentID, "", saveControlJobID, strStartCassette, processJobPauseFlag);

            String environmentVariableBO = StandardProperties.OM_DOC_ENABLE_FLAG.getValue();
            String tmpFPCAdoptFlag = null == environmentVariableBO ? "0" : environmentVariableBO;
            if (CimStringUtils.equals(BizConstant.VALUE_ONE, tmpFPCAdoptFlag)) {
                int casLen = CimArrayUtils.getSize(strStartCassette);
                for (int casCnt = 0; casCnt < casLen; casCnt++) {
                    List<Infos.LotInCassette> strLotInCassette = strStartCassette.get(casCnt).getLotInCassetteList();
                    int lotLen = CimArrayUtils.getSize(strLotInCassette);
                    for (int lotCnt = 0; lotCnt < lotLen; lotCnt++) {
                        Infos.LotInCassette lotInCassette = strLotInCassette.get(lotCnt);
                        if (!lotInCassette.getMoveInFlag()) {
                            continue;
                        }
                        // step38 -done: lot_currentFPCInfo_Get
                        List<Infos.FPCInfo> lotCurrentFPCInfoGet = lotMethod.lotCurrentFPCInfoGet(objCommon, lotInCassette.getLotID(), equipmentID, false, false, false, false);
                        Validations.check(!CimObjectUtils.isEmpty(lotCurrentFPCInfoGet), retCodeConfig.getFpcRequireStartReserve(), objCommon.getTransactionID());
                    }
                }
            }
        } else {
            /*----------------------------------------------------*/
            /*   Clear Start Reserved Control Job in Equipment    */
            /*----------------------------------------------------*/
            saveControlJobID = controlJobID;
            // step39 - equipment_reservedControlJobID_Clear
            equipmentMethod.equipmentReservedControlJobIDClear(objCommon, equipmentID, controlJobID);
            /*----------------------------------------------------*/
            /*   Update Start Reservation Info                    */
            /*                                                    */
            /*   - To update recipe parameters, this process is   */
            /*     required.                                      */
            /*----------------------------------------------------*/
            // step40 - process_startReserveInformation_Set__090
            processMethod.processStartReserveInformationSet(objCommon, equipmentID, "", controlJobID, strStartCassette, processJobPauseFlag);
        }

        // step41 -done: FPC_startCassette_processCondition_Check
        List<Infos.FPCProcessCondition> fpcStartCassetteProcessConditionCheck = fpcMethod.fpcStartCassetteProcessConditionCheck(objCommon, equipmentID, strStartCassette, false, true);


        /*------------------------------------------------------*/
        /*                                                      */
        /*     Equipment Related Information Update Procedure   */
        /*                                                      */
        /*------------------------------------------------------*/

        /*------------------------------------------------------*/
        /*   Add StartLot to EqpInfo's ProcessingLot Sequence   */
        /*------------------------------------------------------*/
        // step42 - equipment_processingLot_AddForInternalBuffer
        equipmentMethod.equipmentProcessingLotAddForInternalBuffer(objCommon, equipmentID, saveControlJobID, strStartCassette);
        if (CimStringUtils.equals(BizConstant.VALUE_ONE, eqpMonitorSwitch)) {
            boolean getEqpStateAtStart = true;
            ObjectIdentifier eqpStateAtStart = null;
            ObjectIdentifier chamberID = null;
            boolean eqpStatusChg = true;
            castLen = CimArrayUtils.getSize(strStartCassette);
            for (int i = 0; i < castLen; i++) {
                List<Infos.LotInCassette> strLotInCassette = strStartCassette.get(i).getLotInCassetteList();
                int lotLen = CimArrayUtils.getSize(strLotInCassette);
                for (int j = 0; j < lotLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }

                    if (!CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                            && !CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_DUMMYLOT)) {
                        continue;
                    }

                    // step43 - lot_eqpMonitorSectionInfo_GetForJob
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut strLotEqpMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassette.getLotID());
                    if (!ObjectIdentifier.isEmptyWithValue(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                        if (CimStringUtils.equals(strLotEqpMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)) {
                            // step44 - eqpMonitorJob_info_Get
                            List<Infos.EqpMonitorJobInfo> strEqpMonitorJobInfoGetOut = equipmentMethod.eqpMonitorJobInfoGet(objCommon, strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID(),
                                    strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());
                            boolean eqpMonitorJobStatusChg = true;
                            if (!CimStringUtils.equals(strEqpMonitorJobInfoGetOut.get(0).getMonitorJobStatus(), BizConstant.SP_EQPMONITORJOB_STATUS_READY)) {
                                eqpStatusChg = false;
                                eqpMonitorJobStatusChg = false;
                            }

                            if (eqpStatusChg) {
                                if (ObjectIdentifier.isNotEmptyWithValue(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID()) && getEqpStateAtStart) {
                                    List<Infos.EqpMonitorDetailInfo> strEqpMonitorInfoGetOut = equipmentMethod.eqpMonitorInfoGet(objCommon, null, strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                    if (!ObjectIdentifier.isEmpty(strEqpMonitorInfoGetOut.get(0).getEqpStateAtStart().getEquipmentStatusCode())) {
                                        eqpStateAtStart = strEqpMonitorInfoGetOut.get(0).getEqpStateAtStart().getEquipmentStatusCode();
                                        chamberID = strEqpMonitorInfoGetOut.get(0).getChamberID();
                                        getEqpStateAtStart = false;
                                    }
                                }
                            }

                            if (eqpMonitorJobStatusChg) {
                                Params.AMJobStatusChangeRptInParm params = new Params.AMJobStatusChangeRptInParm();
                                params.setEquipmentID(strEqpMonitorJobInfoGetOut.get(0).getEquipmentID());
                                params.setEqpMonitorID(strEqpMonitorJobInfoGetOut.get(0).getEqpMonitorID());
                                params.setEqpMonitorJobID(strEqpMonitorJobInfoGetOut.get(0).getEqpMonitorJobID());
                                params.setMonitorJobStatus(BizConstant.SP_EQPMONITORJOB_STATUS_EXECUTING);
                                autoMonitorService.sxAMJobStatusChangeRpt(objCommon, params);
                            }
                        }

                        // step47 - eqpMonitorJob_lot_Update
                        equipmentMethod.eqpMonitorJobLotUpdate(objCommon, lotInCassette.getLotID(), BizConstant.SP_EQPMONITORJOB_OPECATEGORY_OPESTART);
                    }
                }
            }

            if (!ObjectIdentifier.isEmptyWithValue(eqpStateAtStart)) {
                if (!ObjectIdentifier.isEmptyWithValue(chamberID)) {
                    List<Infos.EqpChamberStatus> strEqpChamberStatus = new ArrayList<>();
                    Infos.EqpChamberStatus eqpChamberStatus = new Infos.EqpChamberStatus();
                    strEqpChamberStatus.add(eqpChamberStatus);
                    eqpChamberStatus.setChamberID(chamberID);
                    eqpChamberStatus.setChamberStatusCode(eqpStateAtStart);
                    //-------------------------------------------------------
                    //   Call txChamberStatusChangeReq
                    //-------------------------------------------------------
                    // step48 - txChamberStatusChangeReq
                    this.sxChamberStatusChangeReq(objCommon, equipmentID, strEqpChamberStatus, moveInForIBReqParams.getOpeMemo());

                } else {

                    //-------------------------------------------------------
                    //   Call txEqpStatusChangeReq
                    //-------------------------------------------------------
                    // step49 - txEqpStatusChangeReq
                    Results.EqpStatusChangeReqResult strEqpStatusChangeReqResult = sxEqpStatusChangeReq(objCommon, equipmentID, eqpStateAtStart, claimMemo);

                }
            }
        }

        /*---------------------------------------------*/
        /*   Maintain Eqp's Status for OFF-LINE Mode   */
        /*---------------------------------------------*/
        if (CimStringUtils.equals(strPortResourceCurrentOperationModeGetOut.getOperationMode().getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
            /*-----------------------------------------------*/
            /*   Change Equipment's Status to 'PRODUCTIVE'   */
            /*-----------------------------------------------*/
            // step50 - equipment_currentState_CheckToManufacturing
            Boolean strEquipmentCurrentStateCheckToManufacturingOut = equipmentMethod.equipmentCurrentStateCheckToManufacturing(objCommon, equipmentID);
            if (CimBooleanUtils.isTrue(strEquipmentCurrentStateCheckToManufacturingOut)) {
                /*===== get Defaclt Status Code for Productive / Standby ===*/
                // step51 - equipment_recoverState_GetManufacturing
                ObjectIdentifier strEquipmentRecoverStateGetManufacturingOut = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, equipmentID);
                /*---------------------------------*/
                /*   Call txEqpStatusChangeReq()   */
                /*---------------------------------*/
                // step52 - txEqpStatusChangeReq
                try {
                    sxEqpStatusChangeReq(objCommon, equipmentID, strEquipmentRecoverStateGetManufacturingOut, claimMemo);
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())) {
                        throw e;
                    }
                }
            }
        }
        /*------------------------------------------*/
        /*   Update Equipment's Usage Information   */
        /*------------------------------------------*/
        // step53 - equipment_usageCount_Increment
        equipmentMethod.equipmentUsageCountIncrement(objCommon, equipmentID, strStartCassette);

        /*------------------------------------------------------*/
        /*     FlowBatch Related Information Update Procedure   */
        /*------------------------------------------------------*/

        //-----------------------------------------------------------
        //  Update Flow Batch Information
        //
        //  envValue OM_FLOWB_RSRV_REMOVE_BY_MOVEIN is "1"
        //     Equipment's researvedFlowBatchID is cleared.
        //     FlowBatch's reservedEquipmentID is also cleared.
        //  envValue OM_FLOWB_RSRV_REMOVE_BY_MOVEIN is "0".
        //     Nothing is cleared.
        //-----------------------------------------------------------
        if (!ObjectIdentifier.isEmptyWithValue(strEquipmentLotCheckFlowBatchConditionForOpeStartOut)) {
            // step54 - flowBatch_Information_UpdateByOpeStart__090
            flowBatchMethod.flowBatchInformationUpdateByOpeStart(objCommon, equipmentID, strEquipmentLotCheckFlowBatchConditionForOpeStartOut);
        }
        /*-----------------------------------------------------*/
        /*     Cassette Related Information Update Procedure   */
        /*-----------------------------------------------------*/
        nILen = CimArrayUtils.getSize(strStartCassette);
        for (int i = 0; i < nILen; i++) {
            /*-----------------------------------------------*/
            /*   Change Cassette's Dispatch State to FALSE   */
            /*-----------------------------------------------*/
            // step55 - cassette_dispatchState_Change
            cassetteMethod.cassetteDispatchStateChange(objCommon, strStartCassette.get(i).getCassetteID(), false);

            /*------------------------------------------*/
            /*   Update Casssette's Usage Information   */
            /*------------------------------------------*/
            // step56 - cassette_usageCount_Increment
            cassetteMethod.cassetteUsageCountIncrement(objCommon, strStartCassette.get(i).getCassetteID());
        }

        /*------------------------------------------------*/
        /*                                                */
        /*     Lot Related Information Update Procedure   */
        /*                                                */
        /*------------------------------------------------*/

        /*----------------------------------------------------------------*/
        /*   Make Monitor Relation for ProcessMonitorLot and ProcessLot   */
        /*----------------------------------------------------------------*/

        /*-----------------------------------*/
        /*   Get LotID's for Each Purpose    */
        /*-----------------------------------*/
        // step57 - operationStartLot_lotCount_GetByLoadPurposeType
        Outputs.ObjOperationStartLotCountByLoadPurposeTypeOut strOperationStartLotLotCountGetByLoadPurposeTypeOut = operationMethod.operationStartLotLotCountGetByLoadPurposeType(objCommon,
                strStartCassette);
        if (!ObjectIdentifier.isEmpty(strOperationStartLotLotCountGetByLoadPurposeTypeOut.getProcessMonitorLotID())) {
            /*------------------------*/
            /*    Prepare Structure   */
            /*------------------------*/
            List<ObjectIdentifier> processLotIDs = strOperationStartLotLotCountGetByLoadPurposeTypeOut.getProcessLotIDs();
            int plCnt = CimArrayUtils.getSize(processLotIDs);
            List<Infos.MonRelatedProdLots> strMonRelatedProdLots = new ArrayList<>();
            for (int i = 0; i < plCnt; i++) {
                Infos.MonRelatedProdLots strMonRelatedProdLot = new Infos.MonRelatedProdLots();
                strMonRelatedProdLot.setProductLotID(processLotIDs.get(i));
                strMonRelatedProdLots.add(strMonRelatedProdLot);
            }
            /*----------------------------------------------*/
            /*    Call txMonitorBatchCreateReq()   */
            /*----------------------------------------------*/
            // step58 - txMonitorBatchCreateReq
            Params.MonitorBatchCreateReqParams monitorBatchCreateReqParams = new Params.MonitorBatchCreateReqParams();
            monitorBatchCreateReqParams.setMonitorLotID(strOperationStartLotLotCountGetByLoadPurposeTypeOut.getProcessMonitorLotID());
            monitorBatchCreateReqParams.setStrMonRelatedProdLots(strMonRelatedProdLots);
            processMonitorService.sxMonitorBatchCreateReq(objCommon, monitorBatchCreateReqParams);

        }

        /*--------------------------------------------*/
        /*   Change Lot Process State to Processing   */
        /*--------------------------------------------*/
        // step59 - lot_processState_MakeProcessing
        lotMethod.lotProcessStateMakeProcessing(objCommon, strStartCassette);


        /*----------------------------*/
        /*   Stop Q-Time Management   */
        /*----------------------------*/
        // step60 - qtime_StopByOpeStart
        qTimeMethod.qtimeStopByOpeStart(objCommon, strStartCassette);
        /*------------------------------------------------------------*/
        /*                                                            */
        /*   Reticle / Fixture Related Information Update Procedure   */
        /*                                                            */
        /*------------------------------------------------------------*/
        if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), saveCode)
                || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), saveCode)) {
            nILen = CimArrayUtils.getSize(strStartCassette);
            for (int i = 0; i < nILen; i++) {
                Infos.StartCassette startCassette = strStartCassette.get(i);
                if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                    continue;
                }

                List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
                int nJLen = CimArrayUtils.getSize(strLotInCassette);
                for (int j = 0; j < nJLen; j++) {
                    Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }

                    if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), saveCode)) {
                        /*--------------------------------------*/
                        /*   Update Reticle Usage Information   */
                        /*--------------------------------------*/
                        List<Infos.StartReticleInfo> strStartReticle = lotInCassette.getStartRecipe().getStartReticleList();
                        int nKLen = CimArrayUtils.getSize(strStartReticle);
                        for (int k = 0; k < nKLen; k++) {
                            // step61 - reticle_UsageCount_Increment
                            reticleMethod.reticleUsageCountIncrement(objCommon, strStartReticle.get(k).getReticleID());
                        }
                    } else {
                        /*--------------------------------------*/
                        /*   Update Fixture Usage Information   */
                        /*--------------------------------------*/
                        List<Infos.StartFixtureInfo> strStartFixture = lotInCassette.getStartRecipe().getStartFixtureList();
                        int nKLen = CimArrayUtils.getSize(strStartFixture);
                        for (int k = 0; k < nKLen; k++) {
                            // step62 - fixture_UsageCount_Increment
                            fixtureMethod.fixtureUsageCountIncrement(objCommon, lotInCassette.getLotID(), strStartFixture.get(k).getFixtureID());

                        }
                    }
                }
            }
        }
        /*---------------------------------*/
        /*                                 */
        /*    CP Test Function Procedure   */
        /*                                 */
        /*---------------------------------*/
        nILen = CimArrayUtils.getSize(strStartCassette);
        for (int i = 0; i < nILen; i++) {
            /*-------------------------*/
            /*   Omit Empty Cassette   */
            /*-------------------------*/
            Infos.StartCassette startCassette = strStartCassette.get(i);
            if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                continue;
            }
            List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
            int nJLen = CimArrayUtils.getSize(strLotInCassette);
            for (int j = 0; j < nJLen; j++) {

                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }
                /*-----------------------------------------*/
                /*   Check Test Type of Current Process    */
                /*-----------------------------------------*/
                // step63 - lot_testTypeID_Get
                ObjectIdentifier strLotTestTypeIDGetOut = null;
                try {
                    strLotTestTypeIDGetOut = lotMethod.lotTestTypeIDGet(objCommon, lotInCassette.getLotID());
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getNotFoundTestType(), e.getCode())) {
                        throw e;
                    }
                }


                if (!ObjectIdentifier.isEmptyWithValue(strLotTestTypeIDGetOut)) {
                    /*------------------------------------------*/
                    /*   Update binReportCount of Bin Summary   */
                    /*------------------------------------------*/
                    // step64 - binSummary_binRptCount_SetDR
                    try {
                        binSummaryMethod.binSummaryBinRptCountSetDR(objCommon, lotInCassette.getLotID(), ObjectIdentifier.fetchValue(strLotTestTypeIDGetOut), "1");
                    } catch (ServiceException e) {
                        if (!Validations.isEquals(retCodeConfigEx.getNotFoundBbinsum(), e.getCode())) {
                            throw e;
                        }
                    }
                }
            }
        }

        /*--------------------------*/
        /*   Event Make Procedure   */
        /*--------------------------*/
        nILen = CimArrayUtils.getSize(strStartCassette);
        for (int i = 0; i < nILen; i++) {
            /*-------------------------*/
            /*   Omit Empty Cassette   */
            /*-------------------------*/
            Infos.StartCassette startCassette = strStartCassette.get(i);
            if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                continue;
            }

            List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
            int nJLen = CimArrayUtils.getSize(strLotInCassette);
            for (int j = 0; j < nJLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }
                /*--------------------------------------------------------------*/
                /*   Make OperationMoveEvent for Operation History - OpeStart   */
                /*--------------------------------------------------------------*/
                // step65 - lotOperationMoveEvent_MakeOpeStart
                eventMethod.lotOperationMoveEventMakeOpeStart(objCommon, TransactionIDEnum.OPERATION_START_FOR_INTERNAL_BUFFER_REQ.getValue(), equipmentID, strPortResourceCurrentOperationModeGetOut.getOperationMode().getOperationMode().getValue(), saveControlJobID, startCassette.getCassetteID(), startCassette.getLotInCassetteList().get(j), claimMemo);

            }
        }
        /*------------------------------------------------------------------------*/
        /*                                                                        */
        /*   Send OpeStart Request to TCS Procedure                               */
        /*                                                                        */
        /*   - If specified portGroup's startMode is Auto, MoveInReq itself is  */
        /*     come from TCS, so MoveInReq sending procedure is required for    */
        /*     startMode=Manu case only.                                          */
        /*                                                                        */
        /*------------------------------------------------------------------------*/
        if (CimStringUtils.equals(strPortResourceCurrentOperationModeGetOut.getOperationMode().getMoveInMode(), BizConstant.SP_EQP_STARTMODE_MANUAL)) {
            /*--------------------------*/
            /*    Send Request to TCS   */
            /*--------------------------*/
            // step67 - TCSMgr_SendMoveInForIBReq
//            Inputs.SendMoveInForIBReqIn sendMoveInForIBReqIn = new Inputs.SendMoveInForIBReqIn();
//            sendMoveInForIBReqIn.setObjCommonIn(objCommon);
//            sendMoveInForIBReqIn.setRequestUserID(objCommon.getUser());
//            sendMoveInForIBReqIn.setEquipmentID(equipmentID);
//            sendMoveInForIBReqIn.setControlJobID(saveControlJobID);
//            sendMoveInForIBReqIn.setStrStartCassette(strStartCassette);
//            sendMoveInForIBReqIn.setProcessJobPauseFlag(processJobPauseFlag);
//            sendMoveInForIBReqIn.setClaimMemo(claimMemo);
//            Outputs.SendMoveInForIBReqOut sendMoveInForIBReqOut = (Outputs.SendMoveInForIBReqOut) tcsMethod.sendTCSReq(TCSReqEnum.sendMoveInForIBReq, sendMoveInForIBReqIn);
            String tmpSleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue();
            String tmpRetryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue();
            Long sleepTimeValue = 0L;
            Long retryCountValue = 0L;

            if (0 == CimStringUtils.length(tmpSleepTimeValue)) {
                sleepTimeValue = BizConstant.SP_DEFAULT_SLEEP_TIME_TCS;
            } else {
                sleepTimeValue = CimNumberUtils.longValue(tmpSleepTimeValue);
            }

            if (0 == CimStringUtils.length(tmpRetryCountValue)) {
                retryCountValue = BizConstant.SP_DEFAULT_RETRY_COUNT_TCS;
            } else {
                retryCountValue = CimNumberUtils.longValue(tmpRetryCountValue);
            }

            for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                log.info("{} {}", "loop to retryCountValue + 1", retryNum);
                /*--------------------------*/
                /*    Send Request to EAP   */
                /*--------------------------*/
                IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,objCommon.getUser(),equipmentID,null,true);
                if (null == eapRemoteManager) {
                    log.info("MES not configure EAP host");
                    break;
                }
                Params.MoveInForIBReqParams sendMoveInForIBReqParams = new Params.MoveInForIBReqParams();
                sendMoveInForIBReqParams.setEquipmentID(equipmentID);
                sendMoveInForIBReqParams.setControlJobID(saveControlJobID);
                // chamber level recipe 转换。 [ESEC Service]
                strStartCassette.parallelStream().forEach(startCassette -> {
                    startCassette.getLotInCassetteList().forEach(lotInCassette -> {
                        Infos.StartRecipe startRecipe = lotInCassette.getStartRecipe();
                        if (Objects.nonNull(startRecipe) &&
                                ObjectIdentifier.isNotEmpty(startRecipe.getChamberLevelRecipeID())) {
                            startRecipe.setPhysicalRecipeID(
                                    ObjectIdentifier.fetchValue(startRecipe.getChamberLevelRecipeID()));
                        }
                    });
                });
                sendMoveInForIBReqParams.setStartCassetteList(strStartCassette);
                sendMoveInForIBReqParams.setOpeMemo(claimMemo);
                try {
                    Object moveInForIBReqEapOut = eapRemoteManager.sendMoveInForIBReq(sendMoveInForIBReqParams);
                    log.info("Now EAP subSystem is alive!! Go ahead");
                    break;
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                        log.info("{} {}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...", retryNum);
                        log.info("{} {}", "now sleeping... ", sleepTimeValue);
                        if (retryNum != retryCountValue){
                            try {
                                Thread.sleep(sleepTimeValue);
                                continue;
                            } catch (InterruptedException e) {
                                ex.addSuppressed(e);
                                Thread.currentThread().interrupt();
                                throw ex;
                            }
                        }else {
                            Validations.check(true,retCodeConfig.getTcsNoResponse());
                        }
                    } else {
                        Validations.check(true,new OmCode(ex.getCode(),ex.getMessage()));
                    }
                }
            }
        }

        Infos.ControlJobCreateRequest dummyControlJobCreateRequest = null;
        Params.CJStatusChangeReqParams strControlJobCreateRequest = new Params.CJStatusChangeReqParams();
        strControlJobCreateRequest.setControlJobID(ObjectIdentifier.build(saveControlJobID.getValue(), null));
        strControlJobCreateRequest.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_QUEUE);
        strControlJobCreateRequest.setControlJobCreateRequest(dummyControlJobCreateRequest);
        strControlJobCreateRequest.setClaimMemo(moveInForIBReqParams.getOpeMemo());
        /*----------------------------------------*/
        /*   call controlJob_status_Change        */
        /*----------------------------------------*/
        // step68 - txCJStatusChangeReq
        Results.CJStatusChangeReqResult strCJStatusChangeReqResult = controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, strControlJobCreateRequest);


        if (sendTxFlag) {
            /*---------------------------------------------------*/
            /*   call APCRuntimeCapability_RegistDR              */
            /*---------------------------------------------------*/
            // step69 - APCRuntimeCapability_RegistDR
            apcMethod.apcRuntimeCapabilityRegistDR(objCommon, saveControlJobID, apcRunTimeCapabilityResponseList);

        }
        /*-------------------------------------------------*/
        /*   call cassette_APCInformation_GetDR            */
        /*-------------------------------------------------*/
        // step70 - cassette_APCInformation_GetDR
        List<Infos.ApcBaseCassette> apcBaseCassettes = null;
        try {
            apcBaseCassettes = cassetteMethod.cassetteAPCInformationGetDR(objCommon, equipmentID, strStartCassette);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getSystemError(), e.getCode())) {
                throw e;
            }
        }

        /*--------------------------------------------------*/
        /*   call APCMgr_SendControlJobInformationDR        */
        /*--------------------------------------------------*/
        // step71 - APCMgr_SendControlJobInformationDR
        int retCode = 0;
        try {
            apcMethod.APCMgrSendControlJobInformationDR(objCommon, equipmentID, saveControlJobID, BizConstant.SP_APC_CONTROLJOBSTATUS_EXECUTING, apcBaseCassettes);
        } catch (ServiceException e) {
            retCode = e.getCode();
            if (!Validations.isEquals(retCodeConfigEx.getOkNoIF(), e.getCode())) {
                throw e;
            }
        }
        if (retCode == 0) {
            if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CANCELED;
            } else {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CREATED;
            }
        }

        /*------------------------------------------*/
        /*   Set ControlJobID to Return Structure   */
        /*------------------------------------------*/
        strMoveInForIBReqResult.setControlJobID(saveControlJobID);

        /*----------------------*/
        /*   Return to Caller   */
        /*----------------------*/

        return strMoveInForIBReqResult;
    }


    @Override
    public Results.MoveInReqResult sxMoveInReq(Infos.ObjCommon objCommon,
                                               ObjectIdentifier equipmentID,
                                               String portGroupID,
                                               ObjectIdentifier controlJobID,
                                               List<Infos.StartCassette> startCassetteList,
                                               boolean processJobPauseFlag,
                                               String APCIFControlStatus,
                                               String DCSIFControlStatus, String claimMemo) {

        log.debug("sxMoveInReq(): enter MoveInReq");
        Validations.check(CimArrayUtils.isEmpty(startCassetteList), retCodeConfig.getInvalidParameter(), objCommon.getTransactionID());
        Results.MoveInReqResult moveInReqResult = new Results.MoveInReqResult();
        //Change processJobExecFlag to True
        log.debug("sxMoveInReq(): Check every lot has at least one wafer with processJobExecFlag == TRUE.");

        //Step1 - lot_processJobExecFlag_ValidCheckForOpeStart
        lotMethod.lotProcessJobExecFlagValidCheckForOpeStart(objCommon, startCassetteList, processJobPauseFlag);

        //Check Process
        //Step2 - equipment_categoryVsTxID_CheckCombination
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        //Step3 - virtualOperation_CheckByStartCassette
        boolean virtualOperationFlag = false;
        if (CimObjectUtils.isEmpty(portGroupID)) {
            virtualOperationFlag = virtualOperationMethod.virtualOperationCheckByStartCassette(objCommon, startCassetteList);
        }

        List<ObjectIdentifier> moveInLotIds = startCassetteList.parallelStream()
                .flatMap(startCassette -> startCassette.getLotInCassetteList().parallelStream()
                        .filter(Infos.LotInCassette::getMoveInFlag).map(Infos.LotInCassette::getLotID))
                .collect(Collectors.toList());

        //Check Process for WaferSorter
        //Step4 - equipment_brInfo_GetDR__120
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentID);
        String equipmentCategory = eqpBrInfo.getEquipmentCategory();
        if (CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERSORTER, equipmentCategory)) {
            //Read a Slot Map
            Infos.WaferSorterSlotMap waferSorterSlotMap = new Infos.WaferSorterSlotMap(true);
            String requiredData = BizConstant.SP_SORTER_SLOTMAP_ALLDATA;
            waferSorterSlotMap.setPortGroup(portGroupID);
            waferSorterSlotMap.setEquipmentID(equipmentID);
            waferSorterSlotMap.setSorterStatus(BizConstant.SP_SORTER_REQUESTED);
            List<Infos.WaferSorterSlotMap> waferSorterSlotMaps = null;
            try {
                waferSorterSlotMaps = waferMethod.waferSorterSlotMapSelectDR(objCommon, requiredData, "", BizConstant.SP_SORTER_IGNORE_SIVIEWFLAG, BizConstant.SP_SORTER_IGNORE_SIVIEWFLAG, waferSorterSlotMap);
            } catch (ServiceException ex) {
                if (Validations.isEquals(retCodeConfigEx.getNotFoundSlotMapRecord(), ex.getCode())) {
                } else {
                    throw ex;
                }
            }
            Validations.check(!CimObjectUtils.isEmpty(waferSorterSlotMaps), retCodeConfigEx.getFoundSlotmap());

        } else {
            //Check Scrap wafer Exsit In Carrier
            //Step6 - cassette_scrapWafer_SelectDR
            List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
            startCassetteList.forEach(startCassette -> cassetteIDs.add(startCassette.getCassetteID()));

            List<Infos.LotWaferMap> lotWaferMaps = cassetteMethod.cassetteScrapWaferSelectDR(objCommon, cassetteIDs);
            int scrapCount = lotWaferMaps.size();
            Validations.check(scrapCount > 0, retCodeConfig.getFoundScrap(), objCommon.getTransactionID());

            // Check if Lot has Terminate
            lotMethod.checkIsTerminated(moveInLotIds);
        }

        // Step7 - object_lockMode_Get
        // step6 - object_lockMode_Get
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        if (!ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            objLockModeIn.setFunctionCategory(TransactionIDEnum.OPERATION_START_REQ.getValue());
        } else {
            objLockModeIn.setFunctionCategory(BizConstant.SP_FUNCTIONCATEGORY_OPESTARTWITHCJIDGENTXID);
        }
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // Step8 - advanced_object_Lock
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT,
                    objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));
        } else {
            /*--------------------------------*/
            /*   Lock objects to be updated   */
            /*--------------------------------*/
            // Step9 - object_Lock
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        int nILen = CimArrayUtils.getSize(startCassetteList);
        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
        for (int i = 0; i < nILen; i++) {
            cassetteIDs.add(startCassetteList.get(i).getCassetteID());
            List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(i).getLotInCassetteList();
            int nJLen = CimArrayUtils.getSize(lotInCassetteList);
            for (int j = 0; j < nJLen; j++) {
                lotIDs.add(lotInCassetteList.get(j).getLotID());
            }
        }
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            //Step10 - equipment_onlineMode_Get
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                // Step12 - advanced_object_Lock
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            List<String> loadCastSeq = cassetteIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ, loadCastSeq));
            // Step13 - object_Lock
            if (!ObjectIdentifier.isEmptyWithValue(controlJobID)) {
                objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
            } else {
                objectLockMethod.objectLock(objCommon, CimDispatcher.class, equipmentID);
            }
        }
        /*------------------------------*/
        /*   Lock Cassette/Lot Object   */
        /*-------------------------------*/
        // step14 - objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);
        // step15 - objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, lotIDs);

        String eqpMonitorSwitch = StandardProperties.OM_AUTOMON_FLAG.getValue();
        if (CimStringUtils.equals(eqpMonitorSwitch, BizConstant.VALUE_ONE)) {
            List<ObjectIdentifier> eqpMonitorList = new ArrayList<>();
            Integer eqpMonitorCnt = 0;
            Integer eqpMonitorLen = 5;
            List<Infos.EqpMonitorJobInfo> strEqpMonitorJobInfoSeq = new ArrayList<>();
            Integer eqpMonJobCnt = 0;
            Integer eqpMonJobLen = 5;
            int castLen = CimArrayUtils.getSize(startCassetteList);
            for (int i = 0; i < castLen; i++) {
                Infos.StartCassette startCassette = startCassetteList.get(i);
                List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
                int lotLen = CimArrayUtils.getSize(strLotInCassette);
                for (int j = 0; j < lotLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }
                    if (!CimStringUtils.equals(lotInCassette.getLotType(), BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT)
                            && !CimStringUtils.equals(lotInCassette.getSubLotType(), BizConstant.SP_LOT_TYPE_DUMMYLOT)) {
                        continue;
                    }

                    // step16 - lot_eqpMonitorSectionInfo_GetForJob
                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut strLotEqpMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassette.getLotID());

                    if (!ObjectIdentifier.isEmpty(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                        if (CimStringUtils.equals(strLotEqpMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)) {
                            boolean bNewEqpMonitor = true;
                            for (int iCnt1 = 0; iCnt1 < eqpMonitorCnt; iCnt1++) {
                                ObjectIdentifier eqpMonitor = eqpMonitorList.get(iCnt1);
                                if (ObjectIdentifier.equalsWithValue(eqpMonitor, strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID())) {
                                    bNewEqpMonitor = false;
                                    break;
                                }
                            }

                            if (bNewEqpMonitor) {
                                if (eqpMonitorCnt > eqpMonitorLen) {
                                    eqpMonitorLen = eqpMonitorLen + 5;
                                }
                                eqpMonitorList.add(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                eqpMonitorCnt++;
                            }
                        }

                        if (CimStringUtils.equals(strLotEqpMonitorSectionInfoGetForJobOut.getOperationLabel(), BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR)
                                || strLotEqpMonitorSectionInfoGetForJobOut.isExitFlag()) {
                            boolean bNewEqpMonJob = true;
                            for (int iCnt2 = 0; iCnt2 < eqpMonJobCnt; iCnt2++) {
                                Infos.EqpMonitorJobInfo strEqpMonitorJobInfo = strEqpMonitorJobInfoSeq.get(iCnt2);
                                if (ObjectIdentifier.equalsWithValue(strEqpMonitorJobInfo.getEqpMonitorJobID(), strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                                    bNewEqpMonJob = false;
                                    break;
                                }
                            }

                            if (bNewEqpMonJob) {
                                if (eqpMonJobCnt > eqpMonJobLen) {
                                    eqpMonJobLen = eqpMonJobLen + 5;
                                }

                                Infos.EqpMonitorJobInfo strEqpMonitorJobInfo = new Infos.EqpMonitorJobInfo();
                                strEqpMonitorJobInfoSeq.add(strEqpMonitorJobInfo);
                                strEqpMonitorJobInfo.setEqpMonitorJobID(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());
                                strEqpMonitorJobInfo.setEqpMonitorID(strLotEqpMonitorSectionInfoGetForJobOut.getEquipmentMonitorID());
                                eqpMonJobCnt++;
                            }
                        }
                    }
                }
            }

            for (int iCnt3 = 0; iCnt3 < eqpMonitorCnt; iCnt3++) {
                // step17 -  object_Lock
                objectLockMethod.objectLock(objCommon, CimEqpMonitor.class, eqpMonitorList.get(iCnt3));
            }

            for (int iCnt4 = 0; iCnt4 < eqpMonJobCnt; iCnt4++) {
                // step18 - object_LockForEqpMonitorJob
                objectLockMethod.objectLockForEqpMonitorJob(objCommon, strEqpMonitorJobInfoSeq.get(iCnt4).getEqpMonitorID(), strEqpMonitorJobInfoSeq.get(iCnt4).getEqpMonitorJobID());
            }
        }

        // seasoning 相关代码, by ho
        seasonMethod.checkSeasonForMoveIn(objCommon, equipmentID, startCassetteList);
        seasoningService.sxSeasonJobForMoveInUpdate(objCommon, equipmentID);

        //check Ocap Info without moveInReserve case
        startCassetteList = ocapMethod.ocapCheckEquipmentAndSamplingAndRecipeExchange(equipmentID,startCassetteList);

        log.debug("check PM PilotRun");
        pilotRunMethod.checkPMRun(equipmentID, startCassetteList);


        /*------------------------------------------------------------------*/
        /*   machine recipe convert to chamber level recipe                 */
        /*------------------------------------------------------------------*/
        ChamberLevelRecipeReserveParam chamberLevelRecipeReserveParam = new ChamberLevelRecipeReserveParam();
        chamberLevelRecipeReserveParam.setEquipmentId(equipmentID);
        chamberLevelRecipeReserveParam.setStartCassettes(startCassetteList);
        startCassetteList = chamberLevelRecipeMethod.chamberLevelRecipeMoveQueryRpt(objCommon,
                chamberLevelRecipeReserveParam);


        // Step19 - txPCSExecReq
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*     Script Execution Process                                          */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        for (Infos.StartCassette startCassette : startCassetteList) {
            /*-------------------------*/
            /*   Omit Empty Cassette   */
            /*-------------------------*/
            if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                continue;
            }
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            for (Infos.LotInCassette lot : lotInCassetteList) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (!lot.getMoveInFlag()) {
                    continue;
                }

                /*-------------------------*/
                /*   Execute Pre2 Script   */
                /*-------------------------*/
                Params.ProcessControlScriptRunReqParams scriptParams = new Params.ProcessControlScriptRunReqParams();
                scriptParams.setEquipmentId(equipmentID);
                scriptParams.setLotId(lot.getLotID());
                scriptParams.setPhase(BizConstant.SP_BRSCRIPT_PRE2);
                scriptParams.setUser(objCommon.getUser());
                log.info(">>>>>> Execute Pre2 Script");
                processControlScriptService.sxProcessControlScriptRunReq(objCommon, scriptParams);
            }
        }

        // Step20 - txAPCRTSystemInfoInq
        boolean sendTxFlag = false;
        List<Infos.APCRunTimeCapabilityResponse> apcRunTimeCapabilityResponseList = null;
        if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
            sendTxFlag = true;
            /*-----------------------------------------*/
            /*   call txAPCRunTimeCapabilityInq        */
            /*-----------------------------------------*/
            apcRunTimeCapabilityResponseList = apcInqService.sxAPCRunTimeCapabilityInq(objCommon, equipmentID, controlJobID, startCassetteList, sendTxFlag);
            int runCapaRespCount = CimArrayUtils.getSize(apcRunTimeCapabilityResponseList);
            if (runCapaRespCount > 0) {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CANCELED;
            }
            // Step21 - txAPCRcpParmChgInq
            /*---------------------------------------------*/
            /*   call txAPCRecipeParameterAdjustInq        */
            /*---------------------------------------------*/
            int retCode = 0;
            try {
                startCassetteList = apcInqService.sxAPCRecipeParameterAdjustInq(objCommon, equipmentID, startCassetteList, apcRunTimeCapabilityResponseList, true);
            } catch (ServiceException e) {
                retCode = e.getCode();
                if (!Validations.isEquals(retCodeConfigEx.getOkNoIF(), e.getCode())) {
                    throw e;
                }
            }
            if (retCode == 0) {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CANCELED;
            }

        }
        //Step22 - lot_processJobExecFlag_ValidCheckForOpeStart
        lotMethod.lotProcessJobExecFlagValidCheckForOpeStart(objCommon, startCassetteList, processJobPauseFlag);

        /*
         controljob Checking
         If Start cassette had a Control Job whether InParameter of Control Job is blank,
         Makes request fail.
          */
        if (ObjectIdentifier.isEmpty(controlJobID)) {
            //Step23 - cassette_controlJobID_Get
            /*
            controljob Check for first record of strStartCassette.
            Because checking controljob whether All ControlJoj is same at cassette_CheckConditionForOperation().
             */
            ObjectIdentifier cassetteControlJob = cassetteMethod.cassetteControlJobIDGet(objCommon, startCassetteList.get(0).getCassetteID());
            //Inpara controljob is not blank,but StartCassette has ControlJo.
            Validations.check(!ObjectIdentifier.isEmpty(cassetteControlJob), retCodeConfig.getCassetteControlJobFilled());
        }
        //Step24 - cassette_CheckConditionForOperation, Check Process for cassette
        //QianDao add MES-EAP Integration cassetteChangeFlag change cassetteCheckConditionForOperation to cassetteCheckConditionForOperationForBackSideClean
        cassetteMethod.cassetteCheckConditionForOperationForBackSideClean(objCommon, equipmentID, portGroupID, startCassetteList, BizConstant.SP_OPERATION_OPESTART);

        //Step25 - lot_CheckConditionForOperation ,Check Process for lot
        lotMethod.lotCheckConditionForOperation(objCommon, equipmentID, portGroupID, startCassetteList, BizConstant.SP_OPERATION_OPESTART);

        // check contamination
        contaminationMethod.lotCheckContaminationLevelAndPrFlagStepIn(moveInLotIds, equipmentID,"");
        List<Params.ContaminationAllLotCheckParams> allLots = new ArrayList<>();
        for (Infos.StartCassette tempStartCassettes : startCassetteList){
            List<Infos.LotInCassette> lotInCassetteList = tempStartCassettes.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassetteList){
                Params.ContaminationAllLotCheckParams checkParams = new Params.ContaminationAllLotCheckParams();
                allLots.add(checkParams);
                checkParams.setLotID(lotInCassette.getLotID());
                checkParams.setMoveInFlag(lotInCassette.getMoveInFlag());
            }
        }
        contaminationMethod.contaminationLvlCheckAmongLots(allLots);

        for (Infos.StartCassette startCassette : startCassetteList){
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassetteList){
                if (lotInCassette.getMoveInFlag()){
                    contaminationMethod.recipeContaminationCheck(lotInCassette.getStartRecipe().getLogicalRecipeID(),
                            lotInCassette.getStartRecipe().getMachineRecipeID(), lotInCassette.getLotID(),equipmentID);
                }
            }
        }

        //check capability
        equipmentMethod.capabilityCheck(objCommon,moveInLotIds,equipmentID);


        Outputs.ObjPortResourceCurrentOperationModeGetOut portCurrentOperationModeResult = null;
        if (!virtualOperationFlag) {
            //Step26 - equipment_portState_CheckForOpeStart, Check eqp port for OpeStart
            equipmentMethod.equipmentPortStateCheckForOpeStart(objCommon, equipmentID, portGroupID, startCassetteList);

            //Step27 - portResource_currentOperationMode_Get, Get eqp's Online Mode
            portCurrentOperationModeResult = portComp.portResourceCurrentOperationModeGet(objCommon, equipmentID, startCassetteList.get(0).getLoadPortID());
        }

        Inputs.ObjEquipmentLotCheckFlowBatchConditionForOperationStartIn operationStartIn = new Inputs.ObjEquipmentLotCheckFlowBatchConditionForOperationStartIn();
        operationStartIn.setEquipmentID(equipmentID);
        operationStartIn.setPortGroupID(portGroupID);
        operationStartIn.setStartCassetteList(startCassetteList);
        // Step28 - equipment_lot_CheckFlowBatchConditionForOpeStart__090
        ObjectIdentifier strEquipmentLotCheckFlowBatchConditionForOpeStartOut = equipmentMethod.equipmentLotCheckFlowBatchConditionForOpeStart(objCommon, operationStartIn);
        //Step29 - equipment_processDurableRequiredFlag_Get, Check Process for Process durable
        Integer saveCode;
        //set startCassetteList filter
        Predicate<Infos.StartCassette> startCassetteListFlagFilter = startCassette -> !BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE.equals(startCassette.getLoadPurposeType());
        //set lotInCassetteList filter
        Predicate<Infos.LotInCassette> lotInCassetteListFlagFilter = lotInCassette -> lotInCassette.getMoveInFlag() != null && lotInCassette.getMoveInFlag();
        boolean returnFlag = true;
        try {
            equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, equipmentID);
            saveCode = retCodeConfig.getSucc().getCode();
        } catch (ServiceException e) {
            saveCode = e.getCode();
            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), saveCode)
                    || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), saveCode)) {
                returnFlag = false;
                log.debug("sxMoveInReq(): retCode equals RC_EQP_PROCDRBL_RTCL_REQD or retCode equals RC_EQP_PROCDRBL_FIXT_REQD");
                final Integer finalSaveCode = saveCode;
                startCassetteList.stream()
                        .filter(startCassetteListFlagFilter)
                        .forEach(startCassette -> startCassette.getLotInCassetteList().stream()
                                .filter(lotInCassetteListFlagFilter)
                                .forEach(lotInCassette -> {
                                    if (retCodeConfig.getEquipmentProcessDurableReticleRequired().getCode() == finalSaveCode
                                            && !CimArrayUtils.isEmpty(lotInCassette.getStartRecipe().getStartReticleList())) {
                                        log.debug("sxMoveInReq(): retCode == RC_EQP_PROCDRBL_RTCL_REQD");
                                        List<Infos.StartReticleInfo> startReticleList = lotInCassette.getStartRecipe().getStartReticleList();
                                        reticleMethod.reticleStateCheck170(objCommon, equipmentID, startReticleList, lotInCassette.getLotID());

                                        List<Infos.StartCassette> strStartCassetteSeq = new ArrayList<>();
                                        Infos.StartCassette strStartCassette = new Infos.StartCassette();
                                        strStartCassetteSeq.add(strStartCassette);
                                        List<Infos.LotInCassette> strLotInCassette = new ArrayList<>();
                                        strStartCassette.setLotInCassetteList(strLotInCassette);

                                        List<ObjectIdentifier> checkLotIDs = new ArrayList<>();
                                        checkLotIDs.add(lotInCassette.getLotID());

                                        Infos.LotInCassette slotInCassette = new Infos.LotInCassette();
                                        strLotInCassette.add(slotInCassette);
                                        slotInCassette.setLotID(lotInCassette.getLotID());
                                        slotInCassette.setStartRecipe(lotInCassette.getStartRecipe());

                                        // Step31 - equipment_CheckInhibitForLotWithMachineRecipe
                                        equipmentMethod.equipmentCheckInhibitForLotWithMachineRecipe(
                                                objCommon,
                                                equipmentID,
                                                checkLotIDs,
                                                strStartCassetteSeq);
                                        List<String> reticleList = new ArrayList<>();
                                        startReticleList.forEach(startReticle -> {
                                            /*--------------------------------------*/
                                            /*  Check ReticleDispatchJob existence  */
                                            /*--------------------------------------*/
                                            reticleMethod.reticleDispatchJobCheckExistenceDR(objCommon, startReticle.getReticleID(), null, null);
                                            reticleList.add(startReticle.getReticleID().getValue());

                                            /*--------------------------------*/
                                            /*  Check Reticle Pod relation.   */
                                            /*--------------------------------*/
                                            Results.ReticleDetailInfoInqResult reticleDetailInfoInqResult = reticleMethod.reticleDetailInfoGetDR(objCommon, startReticle.getReticleID(), false, false);
                                            ObjectIdentifier reticlePodID = reticleDetailInfoInqResult.getReticleStatusInfo().getReticlePodID();
                                            Validations.check(!ObjectIdentifier.isEmpty(reticlePodID), retCodeConfig.getNotAvailableReticle());
                                        });
                                        if (StandardProperties.OM_RTMS_CHECK_ACTIVE.isTrue()) {
                                            //check reticle usage by RTMS
                                            if((CimArrayUtils.isNotEmpty(reticleList))){
                                                reticleMethod.reticleUsageCheckByRTMS(objCommon, BizConstant.RTMS_RETICLE_CHECK_ACTION_MOVE_IN,
                                                        reticleList, lotInCassette.getLotID(), equipmentID);
                                            }
                                        }
                                    }
                                    if (retCodeConfig.getEquipmentProcessDurableFixtRequired().getCode() == finalSaveCode) {
                                        fixtureMethod.fixtureStateCheck(objCommon, equipmentID, lotInCassette.getStartRecipe().getStartFixtureList());

                                        List<Infos.StartCassette> strStartCassetteSeq = new ArrayList<>();
                                        Infos.StartCassette strStartCassette = new Infos.StartCassette();
                                        strStartCassetteSeq.add(strStartCassette);

                                        List<ObjectIdentifier> checkLotIDs = new ArrayList<>();
                                        ObjectIdentifier checkLotID = lotInCassette.getLotID();
                                        checkLotIDs.add(checkLotID);

                                        List<Infos.LotInCassette> strLotInCassette = new ArrayList<>();
                                        strStartCassette.setLotInCassetteList(strLotInCassette);

                                        Infos.LotInCassette sLotInCassette = new Infos.LotInCassette();
                                        strLotInCassette.add(sLotInCassette);
                                        sLotInCassette.setLotID(lotInCassette.getLotID());
                                        sLotInCassette.setStartRecipe(lotInCassette.getStartRecipe());

                                        // Step35 - equipment_CheckInhibitForLotWithMachineRecipe
                                        equipmentMethod.equipmentCheckInhibitForLotWithMachineRecipe(
                                                objCommon,
                                                equipmentID,
                                                checkLotIDs,
                                                strStartCassetteSeq);

                                    }
                                }));
            }
            if (retCodeConfig.getEquipmentProcessDurableNotRequired().getCode() == saveCode) {
                returnFlag = false;
            }
            Validations.check(returnFlag, new OmCode(e.getCode(), e.getMessage()));
        }
        Predicate<Infos.LotInCassette> lotInCassetteFlagFilter = Infos.LotInCassette::getMoveInFlag;

        int size = CimArrayUtils.getSize(startCassetteList);
        for (int i = 0; i < size; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            int lotInCassetteSize = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
            for (int j = 0; j < lotInCassetteSize; j++) {
                Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                    continue;
                }
                if (!virtualOperationFlag) {
                    //Step36 - lot_CassetteCategory_CheckForContaminationControl
                    lotMethod.lotCassetteCategoryCheckForContaminationControl(objCommon, lotInCassette.getLotID(),
                            startCassette.getCassetteID(), equipmentID, startCassette.getLoadPortID());

                }
            }
        }
        //Step37 - emptyCassette_CheckCategoryForOperation,Check Carrier Type for next operation of Empty carrier.
        cassetteMethod.emptyCassetteCheckCategoryForOperation(objCommon, startCassetteList);

        //Step38 - recipeParameter_CheckConditionForOpeStart,Check for RecipeParameter
        recipeMethod.recipeParameterCheckConditionForOpeStart(objCommon, equipmentID, portGroupID,
                controlJobID, startCassetteList, processJobPauseFlag);
        /*
        Control Job Related Information Update Procedure
         */
        ObjectIdentifier saveControlJobID = null;
        if (ObjectIdentifier.isEmpty(controlJobID)) {
            //Create Control Job and Assign to Each Cassettes / Lots
            //Step39 - txCJStatusChangeReq
            Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
            cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_CREATE);
            Infos.ControlJobCreateRequest controlJobCreateRequest = new Infos.ControlJobCreateRequest();
            cjStatusChangeReqParams.setControlJobCreateRequest(controlJobCreateRequest);
            controlJobCreateRequest.setEquipmentID(equipmentID);
            controlJobCreateRequest.setPortGroup(portGroupID);
            controlJobCreateRequest.setStartCassetteList(startCassetteList);
            Results.CJStatusChangeReqResult cjStatusChangeReqOut = controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);

            saveControlJobID = cjStatusChangeReqOut.getControlJobID();

            //Set Start Reservation Info to Each Lots' PO
            //Step40 - process_startReserveInformation_Set__090
            processMethod.processStartReserveInformationSet(objCommon, equipmentID, portGroupID, saveControlJobID, startCassetteList, processJobPauseFlag);
            String tmpFPCAdoptFlag = StandardProperties.OM_DOC_ENABLE_FLAG.getValue();
            if (BizConstant.ENV_ENABLE.equals(tmpFPCAdoptFlag)) {
                startCassetteList.forEach(startCassette -> startCassette.getLotInCassetteList().stream()
                        .filter(lotInCassetteFlagFilter)
                        .forEach(lotInCassette -> {
                            List<Infos.FPCInfo> lotCurrentFPCInfoGet = lotMethod.lotCurrentFPCInfoGet(objCommon,
                                    lotInCassette.getLotID(),
                                    equipmentID,
                                    false,
                                    false,
                                    false,
                                    false);
                            Validations.check(CimArrayUtils.isNotEmpty(lotCurrentFPCInfoGet),
                                    retCodeConfig.getFpcRequireStartReserve(), objCommon.getTransactionID());
                        }));
            }
        } else {
            saveControlJobID = controlJobID;
            //Step42 - equipment_reservedControlJobID_Clear,Clear Start Reserved Control Job in eqp
            equipmentMethod.equipmentReservedControlJobIDClear(objCommon, equipmentID, controlJobID);

            //Update Start Reservation Info
            //Step43 - process_startReserveInformation_Set__090
            processMethod.processStartReserveInformationSet(objCommon, equipmentID, portGroupID, controlJobID, startCassetteList, processJobPauseFlag);
        }
        fpcMethod.fpcStartCassetteProcessConditionCheck(objCommon, equipmentID, startCassetteList, false, true);

        // Step45 - SLM_CheckConditionForOperation
        slmMethod.slmCheckConditionForOperation(objCommon, equipmentID, portGroupID, controlJobID, startCassetteList, null, BizConstant.SP_OPERATION_OPESTART);


        //-------------------------------------------------
        //  Check pilotrun in eqp
        //-------------------------------------------------
        pilotRunMethod.checkPilotRunForEquipment(objCommon, equipmentID, startCassetteList);

        // Check Min Q-Time restriction
        minQTimeMethod.checkIsRejectByRestriction(objCommon, startCassetteList);

        //-----------------------------------------------------------//
        //  Wafer Stacking Operation                                 //
        //    If Equipment Category is SP_Mc_Category_WaferBonding,  //
        //    update Bonding Group Information                       //
        //-----------------------------------------------------------//
        if (CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERBONDING, equipmentCategory)) {
            lotMethod.lotBondingGroupUpdateByOperation(objCommon, equipmentID, controlJobID, startCassetteList, processJobPauseFlag ? BizConstant.SP_OPERATION_OPESTARTBYWAFER : BizConstant.SP_OPERATION_OPESTART);
        }

        // eqp Related Information Update Procedure
        //Step47 - equipment_processingLot_Add
        equipmentMethod.equipmentProcessingLotAdd(objCommon, equipmentID, saveControlJobID, startCassetteList);
        if (BizConstant.ENV_ENABLE.equals(eqpMonitorSwitch)) {
            ObjectIdentifier eqpStateAtStart = new ObjectIdentifier();
            ObjectIdentifier chamberID = new ObjectIdentifier();
            boolean getEqpStateAtStart = true;
            boolean eqpStatusChg = true;
            for (Infos.StartCassette startCassette : startCassetteList) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    if (!CimStringUtils.equals(BizConstant.SP_LOT_TYPE_EQUIPMENTMONITORLOT, lotInCassette.getLotType())
                            && !CimStringUtils.equals(BizConstant.SP_LOT_TYPE_DUMMYLOT, lotInCassette.getLotType())) {
                        continue;
                    }

                    Outputs.ObjEquipmentMonitorSectionInfoGetForJobOut objEquipmentMonitorSectionInfoGetForJobOut = lotMethod.lotEqpMonitorSectionInfoGetForJob(objCommon, lotInCassette.getLotID());
                    if (!ObjectIdentifier.isEmpty(objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID())) {
                        if (CimStringUtils.equals(BizConstant.SP_EQPMONITOR_OPELABEL_MONITOR, objEquipmentMonitorSectionInfoGetForJobOut.getOperationLabel())) {
                            log.info("strLot_eqpMonitorSectionInfo_GetForJob_out.operationLabel is Monitor");
                            //Get EqpMonitorJob Information
                            ObjectIdentifier equipmentMonitorID = objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorID();
                            List<Infos.EqpMonitorJobInfo> eqpMonitorJobInfos = equipmentMethod.eqpMonitorJobInfoGet(objCommon, equipmentMonitorID, objEquipmentMonitorSectionInfoGetForJobOut.getEquipmentMonitorJobID());
                            boolean eqpMonitorJobStatusChg = true;
                            if (!CimStringUtils.equals(BizConstant.SP_EQPMONITORJOB_STATUS_READY, eqpMonitorJobInfos.get(0).getMonitorJobStatus())) {
                                log.info("strEqpMonitorJob_info_Get_out.strEqpMonitorJobInfoSeq[0].monitorJobStatus is not Ready");
                                eqpStatusChg = false;
                                eqpMonitorJobStatusChg = false;
                            }

                            if (eqpStatusChg) {
                                log.info("TRUE == eqpStatusChg");
                                if (!ObjectIdentifier.isEmpty(equipmentMonitorID) && getEqpStateAtStart) {
                                    log.info("0 < CIMFWStrLen(strLot_eqpMonitorSectionInfo_GetForJob_out.eqpMonitorID.identifier) && TRUE==getEqpStateAtStart");
                                    //Get EqpMonitor information
                                    List<Infos.EqpMonitorDetailInfo> eqpMonitorDetailInfos = equipmentMethod.eqpMonitorInfoGet(objCommon, null, equipmentMonitorID);
                                    ObjectIdentifier equipmentStatusCode = eqpMonitorDetailInfos.get(0).getEqpStateAtStart().getEquipmentStatusCode();
                                    if (!ObjectIdentifier.isEmpty(equipmentStatusCode)) {
                                        log.info("0 < CIMFWStrLen(strEqpMonitor_info_Get_out.strEqpMonitorDetailInfos[0].eqpStateAtStart.equipmentStatusCode.identifier)");
                                        eqpStateAtStart = equipmentStatusCode;
                                        chamberID = eqpMonitorDetailInfos.get(0).getChamberID();
                                        getEqpStateAtStart = false;
                                    }
                                }
                            }

                            if (eqpMonitorJobStatusChg) {
                                log.info("TRUE == eqpMonitorJobStatusChg");
                                //Status of EqpMonitor job is updated to "Executing"
                                Params.AMJobStatusChangeRptInParm amJobStatusChangeRptInParm = new Params.AMJobStatusChangeRptInParm();
                                amJobStatusChangeRptInParm.setEqpMonitorID(eqpMonitorJobInfos.get(0).getEqpMonitorID());
                                amJobStatusChangeRptInParm.setEquipmentID(eqpMonitorJobInfos.get(0).getEquipmentID());
                                amJobStatusChangeRptInParm.setEqpMonitorJobID(eqpMonitorJobInfos.get(0).getEqpMonitorJobID());
                                amJobStatusChangeRptInParm.setMonitorJobStatus(BizConstant.SP_EQPMONITORJOB_STATUS_EXECUTING);
                                autoMonitorService.sxAMJobStatusChangeRpt(objCommon, amJobStatusChangeRptInParm);
                            }
                        }

                        //Update information of EqpMonitor job lot
                        equipmentMethod.eqpMonitorJobLotUpdate(objCommon, lotInCassette.getLotID(), BizConstant.SP_EQPMONITORJOB_OPECATEGORY_OPESTART);
                    }
                }
            }

            if (!ObjectIdentifier.isEmpty(eqpStateAtStart)) {
                if (!ObjectIdentifier.isEmpty(chamberID)) {
                    List<Infos.EqpChamberStatus> chamberStatusList = new ArrayList<>();
                    Infos.EqpChamberStatus eqpChamberStatus = new Infos.EqpChamberStatus();
                    chamberStatusList.add(eqpChamberStatus);
                    eqpChamberStatus.setChamberID(chamberID);
                    eqpChamberStatus.setChamberStatusCode(eqpStateAtStart);
                    // Step53 - txChamberStatusChangeReq
                    this.sxChamberStatusChangeReq(objCommon, equipmentID, chamberStatusList, claimMemo);
                } else {
                    //Step54 - txEqpStatusChangeReq
                    sxEqpStatusChangeReq(objCommon, equipmentID, eqpStateAtStart, claimMemo);
                }
            }
        }

        /*
         Maintain Eqp 's Status for OFF-LINE Mode
         */
        if (portCurrentOperationModeResult != null
                && CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, portCurrentOperationModeResult.getOperationMode().getOnlineMode())) {
            /*-----------------------------------------------*/
            /*   Change Equipment's Status to 'PRODUCTIVE'   */
            /*-----------------------------------------------*/
            //get StateChageableFlag
            //Step55 - equipment_currentState_CheckToManufacturing
            Boolean manufacturingStateChangeableFlag = equipmentMethod.equipmentCurrentStateCheckToManufacturing(objCommon, equipmentID);
            if (manufacturingStateChangeableFlag) {
                //get Defaclt Status CimCode for Productive / Standby
                //Step56 - equipment_recoverState_GetManufacturing
                ObjectIdentifier equipmentRecoverStateCode = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, equipmentID);
                //Step57 - txEqpStatusChangeReq
                try {
                    sxEqpStatusChangeReq(objCommon, equipmentID, equipmentRecoverStateCode, claimMemo);
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())) throw e;
                }
            }
        }

        //Update eqp's Usage Information
        //Step58 - equipment_usageCount_Increment
        equipmentMethod.equipmentUsageCountIncrement(objCommon, equipmentID, startCassetteList);
        /*
         flowbatch Related Information Update Procedure
         */
        if (!ObjectIdentifier.isEmptyWithValue(strEquipmentLotCheckFlowBatchConditionForOpeStartOut)) {
            // Step59 - flowBatch_Information_UpdateByOpeStart__090
            flowBatchMethod.flowBatchInformationUpdateByOpeStart(objCommon, equipmentID, strEquipmentLotCheckFlowBatchConditionForOpeStartOut);

        }

        //Change cassette's dispatch State to FALSE
        startCassetteList.forEach(startCassette -> {
            //Step60 - cassette_dispatchState_Change
            cassetteMethod.cassetteDispatchStateChange(objCommon, startCassette.getCassetteID(), false);
            //Step61 - cassette_usageCount_Increment ,Update Casssette's Usage Information
            cassetteMethod.cassetteUsageCountIncrement(objCommon, startCassette.getCassetteID());
        });

        /*
         lot Related Information Update Procedure
         */
        //Step62 - operationStartLot_lotCount_GetByLoadPurposeType
        Outputs.ObjOperationStartLotCountByLoadPurposeTypeOut lotCountByLoadPurposeTypeOut = operationMethod.operationStartLotLotCountGetByLoadPurposeType(objCommon, startCassetteList);
        ObjectIdentifier processMonitorLotID = lotCountByLoadPurposeTypeOut.getProcessMonitorLotID();
        if (!ObjectIdentifier.isEmpty(processMonitorLotID)) {
            List<Infos.MonRelatedProdLots> strMonRelatedProdLots = new ArrayList<>();
            //----------------------------------//
            //   Get Bonding Group Information  //
            //----------------------------------//
            List<Infos.BondingGroupInfo> strBondingGroupInfoSeq = new ArrayList<>();
            if (CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERBONDING, equipmentCategory)) {
                Outputs.ObjBondingGroupInfoByEqpGetDROut objBondingGroupInfoByEqpGetDROut = bondingGroupMethod.bondingGroupInfoByEqpGetDR(objCommon, equipmentID, saveControlJobID, true);
                strBondingGroupInfoSeq = objBondingGroupInfoByEqpGetDROut.getBondingGroupInfoList();
            }
            List<ObjectIdentifier> processLotIDs = lotCountByLoadPurposeTypeOut.getProcessLotIDs();
            for (int i = 0; i < processLotIDs.size(); i++) {
                /*------------------------------------------------*/
                /*    Check Top Lot existence for Monitor Group   */
                /*------------------------------------------------*/
                boolean bTopLot = false;
                for (Infos.BondingGroupInfo bondingGroupInfo : strBondingGroupInfoSeq) {
                    List<Infos.BondingMapInfo> bondingMapInfoList = bondingGroupInfo.getBondingMapInfoList();
                    for (Infos.BondingMapInfo bondingMapInfo : bondingMapInfoList) {
                        if (ObjectIdentifier.equalsWithValue(lotCountByLoadPurposeTypeOut.getProcessLotIDs().get(i),
                                bondingMapInfo.getPlanTopLotID())) {
                            // Top Lot should NOT be included in Monitor Group
                            log.info("Top Lot Found! Omit this lot from Monitor Group candidates.");
                            bTopLot = true;
                            break;
                        }
                    }
                    if (bTopLot) {
                        break;
                    }
                }
                if (bTopLot) {
                    continue;
                }
                Infos.MonRelatedProdLots monRelatedProdLots = new Infos.MonRelatedProdLots();
                monRelatedProdLots.setProductLotID(lotCountByLoadPurposeTypeOut.getProcessLotIDs().get(i));
                strMonRelatedProdLots.add(monRelatedProdLots);
            }

            /*----------------------------------------------*/
            /*    Call txMonitorBatchCreateReq()   */
            /*----------------------------------------------*/
            Params.MonitorBatchCreateReqParams monitorBatchCreateReqParams = new Params.MonitorBatchCreateReqParams();
            monitorBatchCreateReqParams.setMonitorLotID(lotCountByLoadPurposeTypeOut.getProcessMonitorLotID());
            monitorBatchCreateReqParams.setStrMonRelatedProdLots(strMonRelatedProdLots);
            processMonitorService.sxMonitorBatchCreateReq(objCommon, monitorBatchCreateReqParams);
        }

        //Change lot Process State to Processing
        //Step65 - lot_processState_MakeProcessing
        lotMethod.lotProcessStateMakeProcessing(objCommon, startCassetteList);


        // Step66 - qtime_StopByOpeStart
        qTimeMethod.qtimeStopByOpeStart(objCommon, startCassetteList);

        /*
         Reticle / Fixture Related Information Update Procedure
         */
        if (retCodeConfig.getEquipmentProcessDurableFixtRequired().getCode() == saveCode
                || retCodeConfig.getEquipmentProcessDurableReticleRequired().getCode() == saveCode) {
            final Integer finalSaveCode = saveCode;
            startCassetteList.stream()
                    .filter(startCassetteListFlagFilter)
                    .forEach(startCassette -> startCassette.getLotInCassetteList().stream()
                            .filter(lotInCassetteListFlagFilter)
                            .forEach(lotInCassette -> {
                                //Update Reticle Usage Information
                                if (retCodeConfig.getEquipmentProcessDurableReticleRequired().getCode() == finalSaveCode) {
                                    List<Infos.StartReticleInfo> startReticleList = lotInCassette.getStartRecipe().getStartReticleList();
                                    if (startReticleList != null) {
                                        for (Infos.StartReticleInfo startReticle : startReticleList) {
                                            //Step67 - reticle_UsageCount_Increment
                                            reticleMethod.reticleUsageCountIncrement(objCommon, startReticle.getReticleID());
                                        }
                                    }
                                } else {
                                    List<Infos.StartFixtureInfo> startFixtureList = lotInCassette.getStartRecipe().getStartFixtureList();
                                    for (Infos.StartFixtureInfo startFixture : startFixtureList) {
                                        //Step68 - fixture_UsageCount_Increment
                                        fixtureMethod.fixtureUsageCountIncrement(objCommon, lotInCassette.getLotID(), startFixture.getFixtureID());
                                    }
                                }
                            }));
        }

        /*---------------------------------*/
        /*    CP Test Function Procedure   */
        /*---------------------------------*/
        for (Infos.StartCassette startCassette : startCassetteList) {
            /*-------------------------*/
            /*   Omit Empty Cassette   */
            /*-------------------------*/
            if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE, startCassette.getLoadPurposeType())) {
                continue;
            }
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassetteList) {

                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }

                /*-----------------------------------------*/
                /*   Check Test Type of Current Process    */
                /*-----------------------------------------*/
                ObjectIdentifier testTypeID = null;
                try {
                    testTypeID = lotMethod.lotTestTypeIDGet(objCommon, lotInCassette.getLotID());
                } catch (ServiceException ex) {
                    if (!Validations.isEquals(retCodeConfig.getNotFoundTestType(), ex.getCode())) throw ex;
                }

                if (!ObjectIdentifier.isEmpty(testTypeID)) {
                    /*------------------------------------------*/
                    /*   Update binReportCount of Bin Summary   */
                    /*------------------------------------------*/
                    // binSummary_binRptCount_SetDR
                    try {
                        binSummaryMethod.binSummaryBinRptCountSetDR(objCommon, lotInCassette.getLotID(), ObjectIdentifier.fetchValue(testTypeID), "1");
                    } catch (ServiceException e) {
                        if (!Validations.isEquals(retCodeConfigEx.getNotFoundBbinsum(), e.getCode())) {
                            throw e;
                        }
                    }
                }
            }
        }
        for (int i = 0; i < nILen; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            if (CimStringUtils.equals(startCassette.getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                continue;
            }

            int j = 0;
            List<Infos.LotInCassette> strLotInCassette = startCassette.getLotInCassetteList();
            int nJLen = CimArrayUtils.getSize(strLotInCassette);
            for (j = 0; j < nJLen; j++) {
                Infos.LotInCassette lotInCassette = strLotInCassette.get(j);
                if (!CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag())) {
                    continue;
                }

                // Step71 - lotOperationMoveEvent_MakeOpeStart Add by HO
                //----------------------------------------------------------------
                //BUG-1073
                String operationModeID = null;
                if (portCurrentOperationModeResult != null) {
                    operationModeID = portCurrentOperationModeResult.getOperationMode().getOperationMode().getValue();
                }
                //------------------------------------------------------------------
                eventMethod.lotOperationMoveEventMakeOpeStart(objCommon,
                        TransactionIDEnum.OPERATION_START_REQ.getValue(),
                        equipmentID,
                        operationModeID,
                        saveControlJobID,
                        startCassette.getCassetteID(),
                        lotInCassette,
                        null);
            }
        }

        //TODO-NOTIMPL: Step72 - DCSMgr_SendOperationStartRpt
        //TODO-NOTIMOL: Step73 - TCSMgr_SendMoveInReq
        /*------------------------------------------------------------------------*/
        /*                                                                        */
        /*   Send OpeStart Request to TCS Procedure                               */
        /*                                                                        */
        /*   - If specified portGroup's startMode is Auto, MoveInReq itself is  */
        /*     come from TCS, so MoveInReq sending procedure is required for    */
        /*     startMode=Manu case only.                                          */
        /*                                                                        */
        /*------------------------------------------------------------------------*/
        if (null != portCurrentOperationModeResult && CimStringUtils.equals(portCurrentOperationModeResult.getOperationMode().getMoveInMode(), BizConstant.SP_EQP_STARTMODE_MANUAL)) {
            /*--------------------------*/
            /*    Send Request to TCS   */
            /*--------------------------*/
            // step67 - TCSMgr_SendMoveInForIBReq
//            Inputs.SendMoveInReqIn sendMoveInReqIn = new Inputs.SendMoveInReqIn();
//            sendMoveInReqIn.setObjCommonIn(objCommon);
//            sendMoveInReqIn.setRequestUserID(objCommon.getUser());
//            sendMoveInReqIn.setEquipmentID(equipmentID);
//            sendMoveInReqIn.setControlJobID(saveControlJobID);
//            sendMoveInReqIn.setStrStartCassette(startCassetteList);
//            sendMoveInReqIn.setProcessJobPauseFlag(processJobPauseFlag);
//            sendMoveInReqIn.setClaimMemo(claimMemo);
//            Outputs.SendMoveInReqOut sendMoveInReqOut = null;
//            sendMoveInReqOut = (Outputs.SendMoveInReqOut) tcsMethod.sendTCSReq(TCSReqEnum.sendMoveInReq, sendMoveInReqIn);
            String tmpSleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue();
            String tmpRetryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue();
            Long sleepTimeValue = 0L;
            Long retryCountValue = 0L;

            if (0 == CimStringUtils.length(tmpSleepTimeValue)) {
                sleepTimeValue = BizConstant.SP_DEFAULT_SLEEP_TIME_TCS;
            } else {
                sleepTimeValue = CimNumberUtils.longValue(tmpSleepTimeValue);
            }

            if (0 == CimStringUtils.length(tmpRetryCountValue)) {
                retryCountValue = BizConstant.SP_DEFAULT_RETRY_COUNT_TCS;
            } else {
                retryCountValue = CimNumberUtils.longValue(tmpRetryCountValue);
            }

            for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                log.info("{} {}", "loop to retryCountValue + 1", retryNum);
                /*--------------------------*/
                /*    Send Request to EAP   */
                /*--------------------------*/
                IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,objCommon.getUser(),equipmentID,null,true);
                if (null == eapRemoteManager) {
                    log.info("MES not configure EAP host");
                    break;
                }
                Params.MoveInReqParams moveInReqParams = new Params.MoveInReqParams();
                moveInReqParams.setEquipmentID(equipmentID);
                moveInReqParams.setPortGroupID(portGroupID);
                moveInReqParams.setControlJobID(saveControlJobID);
                // chamber level recipe 转换，发送给eap [ESEC Service]
                startCassetteList.parallelStream().forEach(startCassette -> {
                    startCassette.getLotInCassetteList().forEach(lotInCassette -> {
                        Infos.StartRecipe startRecipe = lotInCassette.getStartRecipe();
                        if (Objects.nonNull(startRecipe) &&
                                ObjectIdentifier.isNotEmpty(startRecipe.getChamberLevelRecipeID())) {
                            startRecipe.setPhysicalRecipeID(
                                    ObjectIdentifier.fetchValue(startRecipe.getChamberLevelRecipeID()));
                        }
                    });
                });
                moveInReqParams.setStartCassetteList(startCassetteList);
                moveInReqParams.setProcessJobPauseFlag(processJobPauseFlag);
                moveInReqParams.setOpeMemo(claimMemo);
                try {
                    Object moveInReqEapOut = eapRemoteManager.sendMoveInReq(moveInReqParams);
                    log.info("Now EAP subSystem is alive!! Go ahead");
                    break;
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                        log.info("{} {}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...", retryNum);
                        log.info("{} {}", "now sleeping... ", sleepTimeValue);
                        if (retryNum != retryCountValue){
                            try {
                                Thread.sleep(sleepTimeValue);
                                continue;
                            } catch (InterruptedException e) {
                                ex.addSuppressed(e);
                                Thread.currentThread().interrupt();
                                throw ex;
                            }
                        }else {
                            Validations.check(true,retCodeConfig.getTcsNoResponse());
                        }
                    } else {
                        Validations.check(true,new OmCode(ex.getCode(),ex.getMessage()));
                    }
                }
            }

        }

        Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
        cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_QUEUE);
        cjStatusChangeReqParams.setControlJobID(saveControlJobID);
        cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());
        // Step74 - txCJStatusChangeReq
        controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);

        // Step75 - APCRuntimeCapability_RegistDR
        if (sendTxFlag) {
            log.info("sendTxFlag == TRUE");
            /*---------------------------------------------------*/
            /*   call APCRuntimeCapability_RegistDR              */
            /*---------------------------------------------------*/
            apcMethod.apcRuntimeCapabilityRegistDR(objCommon, saveControlJobID, apcRunTimeCapabilityResponseList);
        }
        // Step76 - cassette_APCInformation_GetDR
        List<Infos.ApcBaseCassette> apcBaseCassettes = null;
        try {
            apcBaseCassettes = cassetteMethod.cassetteAPCInformationGetDR(objCommon, equipmentID, startCassetteList);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getSystemError(), e.getCode())) {
                throw e;
            }
        }
        // Step77 - APCMgr_SendControlJobInformationDR
        int retCode = 0;
        try {
            apcMethod.APCMgrSendControlJobInformationDR(objCommon, equipmentID, saveControlJobID, BizConstant.SP_APC_CONTROLJOBSTATUS_EXECUTING, apcBaseCassettes);
        } catch (ServiceException e) {
            retCode = e.getCode();
            if (!Validations.isEquals(retCodeConfigEx.getOkNoIF(), e.getCode())) {
                throw e;
            }
        }
        if (retCode == 0) {
            if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CANCELED;
            } else {
                String tmpString = APCIFControlStatus;
                APCIFControlStatus = BizConstant.SP_APC_CONTROLJOBSTATUS_CREATED;
            }
        }
        moveInReqResult.setControlJobID(saveControlJobID);
        moveInReqResult.setStartCassetteList(startCassetteList);
        return moveInReqResult;
    }


    @Override
    public void sxCarrierUnloadingRpt(Infos.ObjCommon objCommonIn, ObjectIdentifier equipmentID, ObjectIdentifier cassetteID, ObjectIdentifier portID) {
        log.debug("sxCarrierUnloadingRpt(): enter sxCarrierUnloadingRpt");

        //Object Lock Process

        // add season by ho
//        seasoningService.sxSeasonForUnloading(objCommonIn,equipmentID,cassetteID);

        log.debug("step1 - get lock mode for equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.UN_LOADING_LOT_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommonIn, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("setp2 - lock equipment main object");
            objectLockMethod.advancedObjectLock(objCommonIn, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT,
                    objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));
            log.debug("step3 - lock casset main object");
            objectLockMethod.advancedObjectLock(objCommonIn, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, Arrays.asList(cassetteID.getValue())));
        } else {
            /*--------------------------------*/
            /*   Lock objects to be updated   */
            /*--------------------------------*/
            log.debug("step4 - Lock objects to be updated");
            objectLockMethod.objectLock(objCommonIn, CimMachine.class, equipmentID);
        }
        log.debug("step5 - Get All port Objects belong to a input port's PortGrp");
        Infos.EqpPortInfo portsInSameGroupResult = portComp.portResourceAllPortsInSameGroupGet(objCommonIn, equipmentID, portID);
        List<Infos.EqpPortStatus> portsInSameGroup = portsInSameGroupResult.getEqpPortStatuses();
        int lenToPort = CimArrayUtils.getSize(portsInSameGroup);
        for (int i = 0; i < lenToPort; i++) {
            log.debug("step6 - Lock All Ports being in the same port Group as ToPort");
            objectLockMethod.objectLockForEquipmentResource(objCommonIn, equipmentID, portsInSameGroup.get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
        }

        log.debug("step7 - Get eqp's Online Mode");
        Outputs.ObjPortResourceCurrentOperationModeGetOut currentOperationModeOut = portComp.portResourceCurrentOperationModeGet(objCommonIn, equipmentID, portID);
        Infos.OperationMode currentOperationMode = currentOperationModeOut.getOperationMode();
        if (CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, currentOperationMode.getOnlineMode())
                || CimStringUtils.equals(BizConstant.SP_EQP_ACCESSMODE_AUTO, currentOperationMode.getAccessMode())) {
            log.debug("step8 - get durable control job");
            ObjectIdentifier strDurableControlJobIDGetOut = durableMethod.durableDurableControlJobIDGet(objCommonIn, cassetteID, BizConstant.SP_DURABLECAT_CASSETTE);
            if (!ObjectIdentifier.isEmpty(strDurableControlJobIDGetOut)) {
                log.debug("step9 - lock object");
                objectLockMethod.objectLock(objCommonIn, CimDurableControlJob.class, strDurableControlJobIDGetOut);
                //TODO: Step10 - durableControlJob_status_Get
                log.debug("step10 - get durable control job status");
                Infos.DurableControlJobStatusGet strDurableControlJobStatusGetOut = durableMethod.durableControlJobStatusGet(objCommonIn, strDurableControlJobIDGetOut);
                if (!CimStringUtils.equals(strDurableControlJobStatusGetOut.getDurableControlJobStatus(), BizConstant.SP_DURABLECONTROLJOBSTATUS_CREATED)
                        && !CimStringUtils.equals(strDurableControlJobStatusGetOut.getDurableControlJobStatus(), BizConstant.SP_DURABLECONTROLJOBSTATUS_DELETE)) {
                    Validations.check(new OmCode(retCodeConfig.getInvalidDcjstatus(), strDurableControlJobStatusGetOut.getDurableControlJobStatus()));
                }
            }
        }
        log.debug("step11 - lock object");
        objectLockMethod.objectLock(objCommonIn, CimCassette.class, cassetteID);

        log.debug("step12 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommonIn, equipmentID);

        log.debug("step13 - Check Process for cassette,The following conditions are checked by this object:transferState");
        cassetteMethod.cassetteCheckConditionForUnloading(objCommonIn, cassetteID);

        //Check port's OperationMode
        log.trace("OnlineMode is 【{}】，AccessMode is 【{}】",currentOperationMode.getOnlineMode(),currentOperationMode.getAccessMode());
        if (CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, currentOperationMode.getOnlineMode())
                || CimStringUtils.equals(BizConstant.SP_EQP_ACCESSMODE_AUTO, currentOperationMode.getAccessMode())) {
            log.debug("step14 - Get cassette's ControlJobID");
            ObjectIdentifier controlJobID = cassetteMethod.cassetteControlJobIDGet(objCommonIn, cassetteID);
            log.trace("controlJobID is 【{}】",controlJobID);
            if (!ObjectIdentifier.isEmpty(controlJobID)) {
                log.debug("step15 - Get controljob Info");
                List<Infos.ControlJobCassette> controlJobCassettes = controlJobMethod.controlJobContainedLotGet(objCommonIn, controlJobID);
                //Check ControlJobLot's ProcessState
                int lenCtrlJobCassette = CimArrayUtils.getSize(controlJobCassettes);
                for (int i = 0; i < lenCtrlJobCassette; i++) {
                    Infos.ControlJobCassette controlJobCassette = controlJobCassettes.get(i);
                    if (CimArrayUtils.isEmpty(controlJobCassette.getControlJobLotList())) {
                        continue;
                    }
                    log.debug("sxCarrierUnloadingRpt(): controlJobCassette's cassetteID is {}", controlJobCassette.getCassetteID());

                    log.debug("step16 - get lot list from cassette");
                    Infos.LotListInCassetteInfo cassetteLotListGetResult = cassetteMethod.cassetteGetLotList(objCommonIn, controlJobCassette.getCassetteID());

                    log.debug("step17 - check condition lot for uploading");
                    lotMethod.lotCheckConditionForUnloading(objCommonIn, cassetteLotListGetResult);
                }
            }
        }

        log.debug("step18 - Check eqp port for Unloading");
        equipmentMethod.equipmentPortStateCheckForUnloading(objCommonIn, equipmentID, portID, cassetteID);

        log.debug("step19 - get equipment BR info");
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommonIn, equipmentID);
        log.trace("FmcCapabilityFlag is 【{}】",eqpBrInfo.isFmcCapabilityFlag());
        if (CimBooleanUtils.isTrue(eqpBrInfo.isFmcCapabilityFlag())) {
            log.debug("sxCarrierUnloadingRpt(): SLM Capability is ON.");
            //Check Condition for SLM.
            //TODO: Step20 - SLM_CheckConditionForUnloading
        }

        log.debug("step21 - Clear Loaded cassette Information on eqp");
        equipmentMethod.equipmentLoadLotDelete(objCommonIn, equipmentID, portID, cassetteID);

        //Call txCarrierTransferStatusChangeRpt() with 'EquipmentOut'
        log.debug("step22 - Change cassette's TransferState to EquipmentOut");
        Params.CarrierTransferStatusChangeRptParams params = new Params.CarrierTransferStatusChangeRptParams();
        params.setCarrierID(cassetteID);
        params.setXferStatus(BizConstant.SP_TRANSSTATE_EQUIPMENTOUT);
        params.setManualInFlag(false);
        params.setMachineID(equipmentID);
        params.setPortID(portID);
        params.setTransferStatusChangeTimeStamp(objCommonIn.getTimeStamp().getReportTimeStamp());
        transferManagementSystemService.sxCarrierTransferStatusChangeRpt(objCommonIn, params);

        String equipmentCategory = eqpBrInfo.getEquipmentCategory();
        log.trace("equipmentCategory is 【{}】",equipmentCategory);
        if (CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERSORTER, equipmentCategory)) {
            log.debug("step23 - get equipment port info");
            Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommonIn, equipmentID);
            //Delete OSSLOTMAP Information
            List<Infos.EqpPortStatus> tmpEqpPortStatus = eqpPortInfo.getEqpPortStatuses();
            int nEqpPortLen = CimArrayUtils.getSize(tmpEqpPortStatus);
            for (int i = 0; i < nEqpPortLen; i++) {
                if (ObjectIdentifier.equalsWithValue(tmpEqpPortStatus.get(i).getPortID(), portID)) {
                    log.debug("step24 - delete wafer sorter slot map");
                    waferMethod.waferSorterSlotMapDeleteDR(objCommonIn, tmpEqpPortStatus.get(i).getPortGroup(), equipmentID,
                            Arrays.asList(cassetteID), "", BizConstant.SP_SORTER_ALLDELETE, "");
                }
            }
        }
    }

    @Override
    public Results.EAPRecoveryReqResult sxEAPRecoveryReq(Infos.ObjCommon objCommon, Params.EAPRecoveryReqParam params) {
        String actionCode = params.getActionCode();
        ObjectIdentifier equipmentID = params.getEquipmentID();
        List<Infos.RecoverWafer> strRecoverWafer = params.getRecoverWaferList();
        String claimMemo = params.getOpeMemo();

        /*---------------------------------------------*/
        /*   Request to EAP to Turn-Off Signal Tower   */
        /*---------------------------------------------*/
        if (log.isDebugEnabled()){
            log.debug("step1 - Request to EAP");
        }
        Inputs.SendEAPRecoveryReqInput eapParam = new Inputs.SendEAPRecoveryReqInput();
        eapParam.setActionCode(actionCode);
        eapParam.setEquipmentID(equipmentID);
        eapParam.setOpeMemo(claimMemo);

        long sleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getLongValue() == 0L ?
                BizConstant.SP_DEFAULT_SLEEP_TIME_TCS : StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getLongValue();

        long retryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getLongValue() == 0L ?
                BizConstant.SP_DEFAULT_RETRY_COUNT_TCS : StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getLongValue();

        for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
            if (log.isDebugEnabled()) {
                log.debug("{} loop to retryCountValue + 1", retryNum);
            }
            /*--------------------------*/
            /*    Send Request to EAP   */
            /*--------------------------*/
            IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon, objCommon.getUser(),
                    equipmentID, null, false);
            if (null == eapRemoteManager) {
                log.error("MES not configure EAP host");
                Validations.check(retCodeConfigEx.getNotFoundEap());
            }
            try {
                eapRemoteManager.sendEAPRecoveryReq(eapParam);
                log.debug("Now EAP subSystem is alive!! Go ahead");
                break;
            } catch (ServiceException ex) {
                if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                    if (log.isDebugEnabled()) {
                        log.debug("EAP subsystem has return NO_RESPONSE!just retry now!! now count...{}", retryNum);
                        log.debug("now sleeping... {}", sleepTimeValue);
                    }
                    if (retryNum != retryCountValue) {
                        try {
                            Thread.sleep(sleepTimeValue);
                            continue;
                        } catch (InterruptedException e) {
                            ex.addSuppressed(e);
                            Thread.currentThread().interrupt();
                            throw ex;
                        }
                    } else {
                        Validations.check(true, retCodeConfig.getTcsNoResponse());
                    }
                } else {
                    Validations.check(true, new OmCode(ex.getCode(), ex.getMessage()));
                }
            }
        }
        //because of the result is no use, integration retrun null body.
        return null;
    }

    @Override
    public List<Infos.LoadingVerifiedLot> sxCarrierLoadingForIBRpt(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier cassetteID,
                                                                   ObjectIdentifier portID, String loadPurposeType, String claimMemo) {
        List<Infos.LoadingVerifiedLot> loadingVerifiedLots = new ArrayList<>();

        log.debug("step1 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        log.debug("step2 - object lock get");
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.LOADING_LOT_FOR_INTERNAL_BUFFER_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        log.trace("lockMode is {}",lockMode);
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step3 - Lock Equipment Main Object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);

            log.debug("step4 - Lock the target portID only");
            objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, portID, BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
        } else {
            log.debug("step5 - Lock objects to be updated ");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        // add season by ho
//        Validations.check(seasonMethod.checkSeasonForLoading(objCommon, equipmentID,cassetteID),retCodeConfigEx.getSeasonRequired());


        if (log.isInfoEnabled()) {
            log.info(
                    "equipmentAllocatedMaterialAdd()->info : controlJobIsCarrierLotFurnaceSpecificControl check specific control");
        }
        layoutRecipeMethod.controlJobIsCarrierLotFurnaceSpecificControl(objCommon, cassetteID, equipmentID);

        log.debug("step6 - get equipment port info");
        Infos.EqpPortInfo strEquipmentPortInfoForInternalBufferGetDROut = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon, equipmentID);

        List<Infos.EqpPortStatus> strEqpPortStatus = strEquipmentPortInfoForInternalBufferGetDROut.getEqpPortStatuses();
        int lenPortInfo = CimArrayUtils.getSize(strEqpPortStatus);
        for (int i = 0; i < lenPortInfo; i++) {
            if (lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
                log.debug("step7 - objectLockForEquipmentResource");
                objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, strEqpPortStatus.get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            }
        }

        log.debug("step8 - cassette dispatchState Get");
        Boolean strCassetteDispatchStateGetOut = cassetteMethod.cassetteDispatchStateGet(objCommon, cassetteID);
        log.trace("strCassetteDispatchStateGetOut is {}",strCassetteDispatchStateGetOut);
        if (!CimBooleanUtils.isTrue(strCassetteDispatchStateGetOut)) {
            log.debug("Material Location Object (and Buffer resource object )Lock Process");
            if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
                log.debug("step9 - advancedObjectLockForEquipmentResource");
                Inputs.ObjAdvancedObjectLockForEquipmentResourceIn objAdvancedObjectLockForEquipmentResourceIn = new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
                objAdvancedObjectLockForEquipmentResourceIn.setEquipmentID(equipmentID);
                objAdvancedObjectLockForEquipmentResourceIn.setClassName(BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_EMPTYML);
                objAdvancedObjectLockForEquipmentResourceIn.setObjectID(cassetteID);
                objAdvancedObjectLockForEquipmentResourceIn.setObjectLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
                objAdvancedObjectLockForEquipmentResourceIn.setBufferResourceName(loadPurposeType);
                objAdvancedObjectLockForEquipmentResourceIn.setBufferResourceLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);
                objectLockMethod.advancedObjectLockForEquipmentResource(objCommon, objAdvancedObjectLockForEquipmentResourceIn);
            } else {
                log.debug("step10 - objectLockForEquipmentResource");
                objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, new ObjectIdentifier(loadPurposeType), BizConstant.SP_CLASSNAME_POSMATERIALLOCATION);
            }
        }
        log.debug("step11 - lock cassette {}",cassetteID);
        objectLockMethod.objectLock(objCommon, CimCassette.class, cassetteID);

        boolean bForceLoaded = false;
        log.debug("step12 - call txCarrierLoadingVerifyForIBReq");
        Results.CarrierLoadingVerifyReqResult carrierLoadingVerifyReqResultRetCode = null;
        try {
            carrierLoadingVerifyReqResultRetCode = this.sxCarrierLoadingVerifyForIBReq(objCommon, equipmentID, portID, cassetteID, loadPurposeType);
            loadingVerifiedLots = carrierLoadingVerifyReqResultRetCode.getLoadingVerifiedLots();
        } catch (ServiceException ex) {
            loadingVerifiedLots = ex.getData(List.class);
            int rcVerifyedRetCode = ex.getCode();
            try {
                lotMethod.loadedLotVerifiedInfoCheckConditionForForceLoad(objCommon, rcVerifyedRetCode, loadingVerifiedLots, equipmentID, cassetteID, portID, loadPurposeType);
                throw ex;
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getCastForceLoaded(), e.getCode())) {
                    loadingVerifiedLots = e.getData(List.class);
                    lotMethod.loadedLotVerifiedInfoChangeForForceLoad(objCommon, equipmentID, cassetteID, portID, loadPurposeType, loadingVerifiedLots);
                    bForceLoaded = true;
                } else {
                    throw e;
                }
            }
        }

        log.debug("step13 - Add to load Lot in Equipment");
        log.trace("loadPurposeType is {}",loadPurposeType);
        if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_OTHER, loadPurposeType)) {
            equipmentMethod.equipmentLoadLotAdd(objCommon, equipmentID, cassetteID, portID, BizConstant.SP_LOADPURPOSETYPE_OTHER, loadingVerifiedLots);
        } else {
            equipmentMethod.equipmentLoadLotAdd(objCommon, equipmentID, cassetteID, portID, BizConstant.SP_LOADPURPOSETYPE_INTERNALBUFFER, loadingVerifiedLots);
        }

        log.debug("step4 - Clear DispatchReserve for NPW");
        if (CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT)
                || CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY)
                || CimStringUtils.equals(loadPurposeType, BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT)) {
            log.debug("step15 - cassetteDispatchStateChange");
            cassetteMethod.cassetteDispatchStateChange(objCommon, cassetteID, false);

            log.debug("step16 - cassetteSetNPWLoadPurposeType");
            cassetteMethod.cassetteSetNPWLoadPurposeType(objCommon, cassetteID, null);

            log.debug("step17 - equipmentDispatchStateChange");
            equipmentMethod.equipmentDispatchStateChange(objCommon, equipmentID, portID, BizConstant.SP_PORTRSC_DISPATCHSTATE_NOTDISPATCHED,
                    null, null, null, null);
        }

        ObjectIdentifier controlJobID = null;

        log.debug("step18 - equipmentAllocatedMaterialAdd");
        equipmentMethod.equipmentAllocatedMaterialAdd(objCommon, equipmentID, cassetteID, portID, loadPurposeType, controlJobID);

        Params.CarrierTransferStatusChangeRptParams params = new Params.CarrierTransferStatusChangeRptParams();
        params.setCarrierID(cassetteID);
        params.setXferStatus(BizConstant.SP_TRANSSTATE_EQUIPMENTIN);
        params.setManualInFlag(false);
        params.setMachineID(equipmentID);
        params.setPortID(portID);
        params.setTransferStatusChangeTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
        params.setClaimMemo(claimMemo);

        log.debug("step19 - sxCarrierTransferStatusChangeRpt");
        transferManagementSystemService.sxCarrierTransferStatusChangeRpt(objCommon, params);
        Validations.check(bForceLoaded, retCodeConfig.getCastForceLoaded());
        return loadingVerifiedLots;
    }

    @Override
    public void sxCarrierMoveToIBRpt(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier loadedPortID, ObjectIdentifier carrierID, String claimMemo) {
        log.debug("step1 - Transaction ID and eqp Category Consistency Chec");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        log.debug("step2 - get mode lock for equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.MOVE_CASSETTE_TO_INTERNAL_BUFFER_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        log.trace("lockMode is 【{}】",lockMode);
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step3 - lock equipmetn mian object");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT,
                    objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));

            log.debug("step4 - lock carrier advanced object");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ, Arrays.asList(carrierID.getValue())));

            log.debug("step5 - Lock the target portID only");
            objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, loadedPortID, BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
        } else {
            log.debug("step6 - lock object");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        log.debug("step7 - get equipment port info for internal buffer");
        Infos.EqpPortInfo strEquipment_portInfoForInternalBuffer_GetDR_out = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon, equipmentID);

        List<Infos.EqpPortStatus> strEqpPortStatus = strEquipment_portInfoForInternalBuffer_GetDR_out.getEqpPortStatuses();
        int lenPortInfo = CimArrayUtils.getSize(strEqpPortStatus);
        for (int i = 0; i < lenPortInfo; i++) {
            if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
                log.trace("strEqpPortStatus port is 【{}】，loadedPortID is 【{}】",strEqpPortStatus.get(i).getPortID(),loadedPortID);
                if (ObjectIdentifier.equalsWithValue(strEqpPortStatus.get(i).getPortID(), loadedPortID)) {
                    log.debug("step8 - Lock Material Location");
                    Inputs.ObjAdvancedObjectLockForEquipmentResourceIn objAdvancedObjectLockForEquipmentResourceIn = new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
                    objAdvancedObjectLockForEquipmentResourceIn.setEquipmentID(equipmentID);
                    objAdvancedObjectLockForEquipmentResourceIn.setClassName(BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCASTID);
                    objAdvancedObjectLockForEquipmentResourceIn.setObjectID(carrierID);
                    objAdvancedObjectLockForEquipmentResourceIn.setObjectLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
                    objAdvancedObjectLockForEquipmentResourceIn.setBufferResourceLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);
                    objectLockMethod.advancedObjectLockForEquipmentResource(objCommon, objAdvancedObjectLockForEquipmentResourceIn);
                    break;
                }
            } else {
                log.debug("step9 - lock equipment resource");
                objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, strEqpPortStatus.get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            }
        }
        log.debug("step10 - lock object carrier 【{}】",carrierID);
        objectLockMethod.objectLock(objCommon, CimCassette.class, carrierID);
        boolean portFind = false;
        for (int p = 0; p < CimArrayUtils.getSize(strEqpPortStatus); p++) {
            Infos.EqpPortStatus eqpPortStatus = strEqpPortStatus.get(p);
            if (ObjectIdentifier.equalsWithValue(carrierID, eqpPortStatus.getLoadedCassetteID())
                    && ObjectIdentifier.equalsWithValue(loadedPortID, eqpPortStatus.getPortID())) {
                portFind = true;
                break;
            }
        }
        Validations.check(CimBooleanUtils.isFalse(portFind), retCodeConfig.getNoCassetteOnPort());

        log.debug("step11 - add equipment contained materia");
        equipmentMethod.equipmentContainedMaterialAdd(objCommon, equipmentID, loadedPortID, carrierID);
    }

    @Override
    public void sxCarrierUnloadingForIBRpt(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, ObjectIdentifier cassetteID, ObjectIdentifier portID, String claimMemo) {

        // add season by ho
//        seasoningService.sxSeasonForUnloading(objCommon,equipmentID,cassetteID);

        log.debug("step1 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Object Lock Process                                                 */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        log.debug("step2 - get mode lock for equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.UN_LOADING_LOT_FOR_INTERNAL_BUFFER_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step3 - lock equipment main object");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT,
                    objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));

            log.debug("step4 - lock advanced object");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, Arrays.asList(cassetteID.getValue())));
        } else {
            log.debug("step5 - Lock objects to be updated");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        log.debug("step6 - get equipment port info for internal buffer");
        Infos.EqpPortInfo strEquipmentPortInfoForInternalBufferGetDROut = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon, equipmentID);

        List<Infos.EqpPortStatus> strEqpPortStatus = strEquipmentPortInfoForInternalBufferGetDROut.getEqpPortStatuses();
        int lenPortInfo = CimArrayUtils.getSize(strEqpPortStatus);
        for (int i = 0; i < lenPortInfo; i++) {
            if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE) && !ObjectIdentifier.equalsWithValue(strEqpPortStatus.get(i).getPortID(), portID)) {
                continue;
            }
            log.debug("step7 - lock equipment resource");
            objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, strEqpPortStatus.get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
        }
        log.debug("step8 - lock object");
        objectLockMethod.objectLock(objCommon, CimCassette.class, cassetteID);

        log.debug("step9 - get equipment all cassette on port for internal buffer");
        List<Infos.PortID> strEquipmentAllCassetteOnPortForInternalBufferGetDROut = equipmentMethod.equipmentAllCassetteOnPortForInternalBufferGetDR(objCommon, equipmentID);

        boolean portFind = false;
        List<Infos.PortID> strPortInfo = equipmentMethod.equipmentAllCassetteOnPortForInternalBufferGetDR(objCommon, equipmentID);

        for (int p = 0; p < CimArrayUtils.getSize(strPortInfo); p++) {
            Infos.PortID portInfo = strPortInfo.get(p);
            log.trace("cassetteID is 【{}】，portInfo cassetteID is 【{}】",cassetteID,portInfo.getCassetteID());
            if (ObjectIdentifier.equalsWithValue(cassetteID, portInfo.getCassetteID())
                    && ObjectIdentifier.equalsWithValue(portID, portInfo.getPortID())) {
                portFind = true;
                break;
            }
        }

        Validations.check(!portFind, retCodeConfig.getNotCassetteOnPort());

        log.debug("step10 - get port resource current operation mode");
        Outputs.ObjPortResourceCurrentOperationModeGetOut strPortResourceCurrentOperationModeGetOut = portMethod.portResourceCurrentOperationModeGet(objCommon, equipmentID, portID);

        log.debug("step11 - check condition cassette for uploading");
        cassetteMethod.cassetteCheckConditionForUnloading(objCommon, cassetteID);

        if (CimStringUtils.equals(strPortResourceCurrentOperationModeGetOut.getOperationMode().getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)
                || CimStringUtils.equals(strPortResourceCurrentOperationModeGetOut.getOperationMode().getAccessMode(), BizConstant.SP_EQP_ACCESSMODE_AUTO)) {
            log.debug("step12 - get cassette control job");
            ObjectIdentifier controlJobID = cassetteMethod.cassetteControlJobIDGet(objCommon, cassetteID);

            if (!ObjectIdentifier.isEmptyWithValue(controlJobID)) {
                log.debug("step13 - get control job contained lot");
                List<Infos.ControlJobCassette> strControlJobCassette = controlJobMethod.controlJobContainedLotGet(objCommon, controlJobID);
                int lenCtrlJobCassette = CimArrayUtils.getSize(strControlJobCassette);
                int lenCtrlJobLot;

                for (int i = 0; i < lenCtrlJobCassette; i++) {
                    List<Infos.ControlJobLot> strControlJobLot = strControlJobCassette.get(i).getControlJobLotList();
                    lenCtrlJobLot = CimArrayUtils.getSize(strControlJobLot);

                    log.trace("lenCtrlJobLot is 【{}】",lenCtrlJobLot);
                    if (0 == lenCtrlJobLot) {
                        continue;
                    }

                    log.debug("step14 - get lot list for cassette");
                    Infos.LotListInCassetteInfo strCassetteGetLotListOut = cassetteMethod.cassetteGetLotList(objCommon, strControlJobCassette.get(i).getCassetteID());

                    log.debug("step15 - check condition lot for unloading");
                    lotMethod.lotCheckConditionForUnloading(objCommon, strCassetteGetLotListOut);

                }
            }
        }

        log.debug("step16 - check equipment port state for uploading");
        try {
            equipmentMethod.equipmentPortStateCheckForUnloading(objCommon, equipmentID, portID, cassetteID);
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getInvalidCassettePortCombination(), e.getCode())) {
                throw e;
            }
        }
        log.debug("step17 - delete equipment load lot for internal buffer");
        equipmentMethod.equipmentLoadLotDeleteForInternalBuffer(objCommon, equipmentID, portID, cassetteID);

        Params.CarrierTransferStatusChangeRptParams params = new Params.CarrierTransferStatusChangeRptParams();
        params.setCarrierID(cassetteID);
        params.setXferStatus(BizConstant.SP_TRANSSTATE_EQUIPMENTOUT);
        params.setManualInFlag(false);
        params.setMachineID(equipmentID);
        params.setPortID(portID);
        params.setTransferStatusChangeTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());

        log.debug("step18 - change carrier transfer status");
        Results.CarrierTransferStatusChangeRptResult strCarrierTransferStatusChangeRptResult = transferManagementSystemService.sxCarrierTransferStatusChangeRpt(objCommon, params);
    }

    @Deprecated
    @Override
    public Results.MoveOutReqResult sxMoveOutForIBReq(Infos.ObjCommon objCommon, Params.MoveOutForIBReqParams params) {
        log.debug("【Method Entry】sxMoveOutForIBReq()");
        Results.MoveOutReqResult out = new Results.MoveOutReqResult();

        log.debug("step1 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, params.getEquipmentID());

        log.debug("step2 - Get Started lot information which is sepcified with controljob ID");
        Outputs.ObjControlJobStartReserveInformationOut controlJobStartReserveInformationOutRetCode =
                controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                        params.getControlJobID(),
                        false);

        log.debug("step3 - Get required equipment lock mode");
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(params.getEquipmentID());
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        log.trace("lockMode is {}",lockMode);
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step4 - add required equipment lock");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(params.getEquipmentID(),
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT,
                    objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));
        } else {
            log.debug("step5 - add object lock of equipment");
            objectLockMethod.objectLock(objCommon, CimMachine.class, params.getEquipmentID());
        }

        int startCassetteLen = CimArrayUtils.getSize(controlJobStartReserveInformationOutRetCode.getStartCassetteList());
        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
        List<Infos.StartCassette> startCassetteList = new ArrayList<>();
        log.trace("startCassetteLen is {}",startCassetteLen);
        if (startCassetteLen > 0) {
            for (int i = 0; i < startCassetteLen; i++) {
                Infos.StartCassette item = controlJobStartReserveInformationOutRetCode.getStartCassetteList().get(i);
                Infos.StartCassette startCassette = new Infos.StartCassette();
                startCassette.setCassetteID(item.getCassetteID());
                startCassette.setLoadPortID(item.getLoadPortID());
                startCassette.setLoadPurposeType(item.getLoadPurposeType());
                startCassette.setLoadSequenceNumber(item.getLoadSequenceNumber());
                startCassette.setLotInCassetteList(item.getLotInCassetteList());
                startCassette.setUnloadPortID(item.getUnloadPortID());
                startCassetteList.add(startCassette);

                int nLen = 0;
                nLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                log.trace("LoadPurposeType is {}",startCassette.getLoadPurposeType());
                if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE, startCassette.getLoadPurposeType())) {
                    //equipment_monitorCreationFlag_Get();
                    try {
                        log.debug("step6 - check equipment monitor creation flag");
                        equipmentMethod.equipmentMonitorCreationFlagGet(objCommon, params.getEquipmentID());
                    } catch (ServiceException e) {
                        if (Validations.isEquals(retCodeConfigEx.getMonitorCreatReqd(), e.getCode())) {
                            if (nLen == 0) {
                                log.error("object_Lock() == RC_MONITOR_CREAT_REQD");
                                Validations.check(true, retCodeConfigEx.getMonitorCreatReqd());
                            }
                        }
                    }
                    //if monitor creationflag was TRUE, at least one lot should be existed in Empty Cassete;
                    cassetteIDs.add(startCassette.getCassetteID());
                    continue;
                }
                cassetteIDs.add(startCassette.getCassetteID());
                for (int j = 0; j < nLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(startCassette.getLotInCassetteList().get(j).getMoveInFlag())) {
                        continue;
                    }
                    lotIDs.add(startCassette.getLotInCassetteList().get(j).getLotID());
                }
            }
        }


        log.trace("lockMode is {}",lockMode);
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step7 - get equipment online mode from equipment {}",params.getEquipmentID());
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, params.getEquipmentID());
            log.trace("onlineMode is {}",onlineMode);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                log.debug("step8 - Lock eqp ProcLot Element (Count)");
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(params.getEquipmentID(),
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            log.debug("step9 - Lock eqp ProcLot Element (Write)");
            List<String> procLotSeq = lotIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(params.getEquipmentID(),
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, procLotSeq));
        } else {
            log.trace("lockMode == SP_EQP_LOCK_MODE_WRITE");
            log.debug("step10 - Lock All port Object for internal Buffer eqp;");
            Infos.EqpPortInfo portInfoRetCode = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon, params.getEquipmentID());

            log.debug("step11 - lock equipment resource");
            int lenPortInfo = CimArrayUtils.getSize(portInfoRetCode.getEqpPortStatuses());
            for (int i = 0; i < lenPortInfo; i++) {
                Infos.EqpPortStatus eqpPortStatus = portInfoRetCode.getEqpPortStatuses().get(i);
                objectLockMethod.objectLockForEquipmentResource(objCommon, params.getEquipmentID(), eqpPortStatus.getPortID(),
                        BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            }
        }
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step12 - Lock Material Location");
            for (int i = 0; i < startCassetteLen; i++) {
                Infos.StartCassette startCassette = controlJobStartReserveInformationOutRetCode.getStartCassetteList().get(i);

                Inputs.ObjAdvancedObjectLockForEquipmentResourceIn inputs = new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
                inputs.setEquipmentID(params.getEquipmentID());
                inputs.setClassName(BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCJ);
                inputs.setObjectID(params.getControlJobID());
                inputs.setObjectLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
                inputs.setBufferResourceName(startCassette.getLoadPurposeType());
                inputs.setBufferResourceLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);
                objectLockMethod.advancedObjectLockForEquipmentResource(objCommon, inputs);
            }

            log.debug("step13 - Lock controljob Object");
            objectLockMethod.objectLock(objCommon, CimControlJob.class, params.getControlJobID());
        }

        log.debug("step14 - lock cassette object");
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);

        log.debug("step15 - lock lot object");
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, lotIDs);

        log.debug("step16 - update season of the move out");
        seasoningService.sxSeasonForMoveOut(objCommon, params.getEquipmentID());

        log.debug("step17 - update machine recipe used time");
        seasonMethod.updateMachineRecipeUsedTime(objCommon, startCassetteList, params.getEquipmentID());

        startCassetteList = controlJobStartReserveInformationOutRetCode.getStartCassetteList();
        startCassetteLen = CimArrayUtils.getSize(startCassetteList);

        log.debug("step18 - call cassetteAPCInformationGetDR");
        List<Infos.ApcBaseCassette> apcBaseCassettes = null;
        try {
            apcBaseCassettes = cassetteMethod.cassetteAPCInformationGetDR(objCommon, params.getEquipmentID(), startCassetteList);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getSystemError(), e.getCode())) {
                throw e;
            }
        }

        log.debug("step19 - Get and Check cassette on port");
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, params.getEquipmentID());

        // Check length of eqp port
        Validations.check(CimArrayUtils.isEmpty(eqpPortInfo.getEqpPortStatuses()), retCodeConfig.getNotFoundPort());
        ObjectIdentifier portID = eqpPortInfo.getEqpPortStatuses().get(0).getPortID();

        log.debug("step20 - get equipment's online mode");
        Outputs.ObjPortResourceCurrentOperationModeGetOut operationModeRetCode = portMethod.portResourceCurrentOperationModeGet(objCommon, params.getEquipmentID(), portID);

        // If AccessMode is Auto or OnlineMode is Offline, do the following check;
        if (CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, operationModeRetCode.getOperationMode().getOnlineMode())
                || CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, operationModeRetCode.getOperationMode().getAccessMode())) {
            log.debug("step21 - Check Process for cassette");
            cassetteMethod.cassetteCheckConditionForOpeComp(objCommon, startCassetteList);

            log.debug("step22 - Check eqp port for OpeComp");
            equipmentMethod.equipmentPortStateCheckForOpeCompForInternalBuffer(objCommon, params.getEquipmentID(), startCassetteList);
        }

        log.debug("step23 - Check Process for lot: The following conditions are checked by this object");
        lotMethod.lotCheckConditionForOpeComp(objCommon, startCassetteList);

        log.debug("step24 - Check Process for eqp: The following conditions are checked by this object");
        // - All lof lot, which is contained in controlJob, must be existing in the eqp's processing information.
        equipmentMethod.equipmentCheckConditionForOpeComp(objCommon, params.getEquipmentID(), startCassetteList);

        log.debug("step25 - In case of post process migration mode, fix PostProcForLotFlag");
        int postProcForLotFlag = StandardProperties.OM_PP_FOR_LOT_MOVEOUT_FLAG.getIntValue();
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag == -1) {
            try {
                log.debug("step26 - In case of post process migration mode, check value in OSPPRCCONFIG");
                Infos.ConfigInfo configurationInformationGetDROut = cimComp.configurationInformationGetDR(objCommon, params.getEquipmentID().getValue(), BizConstant.SP_CONFIGURATIONCATEGORY_EQUIPMENTPOSTPROCDECOUPLEMODE);
                log.trace("configurationInformationGetDROut is {}",configurationInformationGetDROut.getValue());
                if (CimStringUtils.equals(configurationInformationGetDROut.getValue(), "1")) {
                    postProcForLotFlag = 1;
                } else {
                    postProcForLotFlag = 0;
                }
            } catch (ServiceException ex) {
                if (Validations.isEquals(retCodeConfig.getNotFoundEntry(), ex.getCode())) {
                    log.debug("Entry isn't found in OSPPRCCONFIG");
                    postProcForLotFlag = 0;
                } else {
                    throw ex;
                }
            }
            log.debug("step27 - Store PostProcForLotFlag as thread specific data");
            ThreadContextHolder.setThreadSpecificDataString(BizConstant.SP_THREADSPECIFICDATA_KEY_POSTPROCFORLOTFLAG, String.valueOf(postProcForLotFlag));
        }

        log.debug("step28 - CP Test Function Procedure");
        int nLen = 0;
        for (int i = 0; i < startCassetteLen; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            for (int j = 0; j < CimArrayUtils.getSize(startCassette.getLotInCassetteList()); j++) {
                Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                log.trace("MoveInFlag is {}",lotInCassette.getMoveInFlag());
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                    continue;
                }
                log.debug("step29 - Check Test Type of Current Process");
                ObjectIdentifier lotTestTypeRetCode = null;
                try {
                    lotTestTypeRetCode = lotMethod.lotTestTypeIDGet(objCommon, lotInCassette.getLotID());
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getNotFoundTestType(), e.getCode())) {
                        throw e;
                    }
                }

                if (!CimObjectUtils.isEmptyWithValue(lotTestTypeRetCode)) {
                    log.debug("step30 - Gather Bin Summary Information based on lotID & testTypeID");
                    List<Infos.WaferBinSummary> waferBinSummaryList = binSummaryMethod.binSummaryGetByTestTypeDR(objCommon, lotInCassette.getLotID(), lotTestTypeRetCode);

                    log.debug("step31- Update wafer Die quantity based on the input parameter");
                    int bsLen = CimArrayUtils.getSize(waferBinSummaryList);
                    List<Infos.LotWaferAttributes> strLotWaferAttributes = new ArrayList<>();
                    for (int k = 0; k < bsLen; k++) {
                        if (waferBinSummaryList.get(k).getBinReportCount() > 0) {
                            Infos.LotWaferAttributes lotWaferAttributes = new Infos.LotWaferAttributes();
                            strLotWaferAttributes.add(lotWaferAttributes);
                            lotWaferAttributes.setWaferID(waferBinSummaryList.get(k).getWaferId());
                            lotWaferAttributes.setGoodUnitCount(waferBinSummaryList.get(k).getGoodUnitCount());
                            lotWaferAttributes.setRepairUnitCount(waferBinSummaryList.get(k).getRepairUnitCount());
                            lotWaferAttributes.setFailUnitCount(waferBinSummaryList.get(k).getFailUnitCount());
                        }
                    }
                    lotMethod.lotWaferChangeDie(objCommon, lotInCassette.getLotID(), strLotWaferAttributes);
                }
            }
        }
        log.debug("step32 - Update flowbatch Information of eqp");
        flowBatchMethod.flowBatchInformationUpdateByOpeComp(objCommon, params.getEquipmentID(), startCassetteList);

        log.debug("step33 - Process Operation Update Procedure");
        processMethod.processActualCompInformationSet(objCommon, startCassetteList);

        log.debug("step34 - Make Measurement & Process Data History");
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != -1) {
            String transactionID = TransactionIDEnum.OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue();
            eventMethod.collectedDataEventMake(objCommon, transactionID, startCassetteList, params.getControlJobID()
                    , params.getEquipmentID(), params.getOpeMemo());
        }

        ObjectIdentifier releaseReasonCodeID = new ObjectIdentifier(BizConstant.SP_REASON_GATEPASS);
        List<Outputs.ObjLotFutureHoldRequestsEffectByConditionOut> fuHoldReuests = new ArrayList<>();
        if (postProcForLotFlag != 1) {
            log.debug("step35 - Delete Effected Future Hold Direction");
            for (int i = 0; i < startCassetteLen; i++) {
                Infos.StartCassette startCassette = controlJobStartReserveInformationOutRetCode.getStartCassetteList().get(i);
                for (int j = 0; j < CimArrayUtils.getSize(startCassette.getLotInCassetteList()); j++) {
                    Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                    //Omit Not-OpeStart lot ;
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }
                    //Get Effected Future Hold ;
                    Infos.EffectCondition effectCondition = new Infos.EffectCondition(BizConstant.SP_FUTUREHOLD_POST, BizConstant.SP_FUTUREHOLD_ALL);
                    Outputs.ObjLotFutureHoldRequestsEffectByConditionOut fuHoldRequestsRetCode = lotMethod.lotFutureHoldRequestsEffectByCondition(
                            objCommon, lotInCassette.getLotID(), effectCondition);
                    fuHoldReuests.add(fuHoldRequestsRetCode);

                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_ALL);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);

                    log.debug("step36 - Delete Effected Future Hold Direction");
                    Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut fuHoldRequestsDeleteEffectCondRetCode = lotMethod.lotFutureHoldRequestsDeleteEffectedByCondition(
                            objCommon, lotInCassette.getLotID(), effectCondition);

                    log.trace("fuHoldRequestsDeleteEffectCondRetCode is {}",fuHoldRequestsDeleteEffectCondRetCode.getStrFutureHoldReleaseReqList());
                    if (!CimArrayUtils.isEmpty(fuHoldRequestsDeleteEffectCondRetCode.getStrFutureHoldReleaseReqList())) {
                        Params.FutureHoldCancelReqParams futureHoldCancelReqParams = new Params.FutureHoldCancelReqParams();
                        futureHoldCancelReqParams.setLotID(lotInCassette.getLotID());
                        futureHoldCancelReqParams.setReleaseReasonCodeID(releaseReasonCodeID);
                        futureHoldCancelReqParams.setEntryType(BizConstant.SP_ENTRYTYPE_REMOVE);
                        futureHoldCancelReqParams.setLotHoldList(fuHoldRequestsDeleteEffectCondRetCode.getStrFutureHoldReleaseReqList());
                        log.debug("step37 - Pass hold cancel record list");
                        processControlService.sxFutureHoldCancelReq(objCommon, futureHoldCancelReqParams);
                    }
                }
            }
        }

        /**
         * Reticle / Fixture Related Information Update Procedure;
         */
        int usedReticleSeqLen = 0;
        int usedFixtureSeqLen = 0;
        try {
            log.debug("step38 - Check ProcessDurable was Used for Operation or Not");
            equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, params.getEquipmentID());
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableNotRequired(), e.getCode())) {
                //throw e;
                //RC = ok;
            } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())
                    || Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                for (int i = 0; i < startCassetteLen; i++) {
                    Infos.StartCassette startCassette = startCassetteList.get(i);
                    nLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                    for (int j = 0; j < nLen; j++) {
                        Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                        if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                            continue;
                        }
                        if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())) {
                            log.debug("step39 - Get Used Reticles for lot");
                            List<Infos.StartReticle> startReticleRetCode = processMethod.processAssignedReticleGet(objCommon, lotInCassette.getLotID());

                            log.debug("step40 - check reticle usage limitation for reticle");
                            for (int k = 0; k < CimArrayUtils.getSize(startReticleRetCode); k++) {
                                Infos.StartReticle startReticle = startReticleRetCode.get(k);
                                Outputs.ObjReticleUsageLimitationCheckOut reticleUsedLimitRetCode = reticleMethod.reticleUsageLimitationCheck(objCommon, startReticle.getReticleID());
                                log.trace("UsageLimitOverFlag is {}",reticleUsedLimitRetCode.isUsageLimitOverFlag());
                                if (reticleUsedLimitRetCode.isUsageLimitOverFlag()) {
                                    log.debug("step41 - Call System Message");
                                    Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                                    alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                                    alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_RTCLUSAGELIMITOVER);
                                    alertMessageRptParams.setSystemMessageText(reticleUsedLimitRetCode.getMessageText());
                                    alertMessageRptParams.setNotifyFlag(true);
                                    alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                                    systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
                                }

                                log.debug("step42 - Set last used time stamp for used reticle");
                                reticleMethod.reticleLastUsedTimeSet(startReticle.getReticleID(), objCommon.getTimeStamp().getReportTimeStamp());
                            }
                        } else {
                            log.debug("step43 - Get Used Fixture for lot");
                            List<Infos.StartFixture> startFixturesRetCode = processMethod.processAssignedFixtureGet(objCommon, lotInCassette.getLotID());
                            usedFixtureSeqLen = CimArrayUtils.getSize(startFixturesRetCode);
                            for (int k = 0; k < usedFixtureSeqLen; k++) {
                                log.debug("step44 - Fixture Usage Limitation Check");
                                Outputs.objFixtureUsageLimitationCheckOut objFixtureUsageLimitationCheckOut = fixtureMethod.fixtureUsageLimitationCheck(objCommon, startFixturesRetCode.get(k).getFixtureID());
                                log.debug("step45 - Call System Message");
                                Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                                alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                                alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_FIXTUSAGELIMITOVER);
                                alertMessageRptParams.setSystemMessageText(objFixtureUsageLimitationCheckOut.getMessageText());
                                alertMessageRptParams.setNotifyFlag(true);
                                alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                                systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
                            }
                        }
                    }
                }
            } else {
                throw e;
            }
        }

        log.debug("step46 - lot Related Information Update Procedure");
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            log.debug("step47 - Set/Clear Q-Time Management");
            List<Infos.QTimeActionRegisterInfo> qtimeSetClearRetCode = qTimeMethod.qtimeSetClearByOpeComp(objCommon, startCassetteList);

            //Reset Q-Time actions;
            ObjectIdentifier resetReasonCodeID = new ObjectIdentifier(BizConstant.SP_REASON_QTIMECLEAR);
            int resetLen = CimArrayUtils.getSize(qtimeSetClearRetCode);
            for (int resetCnt = 0; resetCnt < resetLen; resetCnt++) {
                Infos.QTimeActionRegisterInfo strResetAction = qtimeSetClearRetCode.get(resetCnt);

                int lotHoldsLen = CimArrayUtils.getSize(strResetAction.getLotHoldList());
                log.trace("lotHoldsLen is {}",lotHoldsLen);
                if (lotHoldsLen > 0) {
                    Params.HoldLotReleaseReqParams holdLotReleaseReqParams = new Params.HoldLotReleaseReqParams();
                    holdLotReleaseReqParams.setReleaseReasonCodeID(resetReasonCodeID);
                    holdLotReleaseReqParams.setLotID(strResetAction.getLotID());
                    holdLotReleaseReqParams.setHoldReqList(strResetAction.getLotHoldList());
                    holdLotReleaseReqParams.setUser(objCommon.getUser());
                    log.debug("step48 - lot Hold Actions");
                    lotService.sxHoldLotReleaseReq(objCommon, holdLotReleaseReqParams);
                }

               log.trace("FutureHoldList's size is {}", CimArrayUtils.getSize(strResetAction.getFutureHoldList()));
                if (CimArrayUtils.getSize(strResetAction.getFutureHoldList()) > 0) {
                    Params.FutureHoldCancelReqParams inParams = new Params.FutureHoldCancelReqParams();
                    inParams.setLotID(strResetAction.getLotID());
                    inParams.setReleaseReasonCodeID(releaseReasonCodeID);
                    inParams.setEntryType(BizConstant.SP_ENTRYTYPE_CANCEL);
                    inParams.setLotHoldList(strResetAction.getFutureHoldList());
                    log.debug("step49 - Future Hold Actions");
                    processControlService.sxFutureHoldCancelReq(objCommon, inParams);
                }

                if (CimArrayUtils.getSize(strResetAction.getFutureReworkList()) > 0) {
                    for (Infos.FutureReworkInfo futureReworkInfo : strResetAction.getFutureReworkList()) {
                        processControlService.sxFutureReworkCancelReq(objCommon, futureReworkInfo.getLotID(), futureReworkInfo.getRouteID()
                                , futureReworkInfo.getOperationNumber(), futureReworkInfo.getFutureReworkDetailInfoList(), "");
                    }
                }
            }

            // 检查并设置Min Q-Time最小时间限制
            minQTimeMethod.checkAndSetRestrictions(objCommon, startCassetteList);
        }
        log.debug("step50 - Change lot Process State to Waiting");
        lotMethod.lotProcessStateMakeWaiting(objCommon, startCassetteList);

        log.debug("step51 - Procedure for PO Moving");
        List<ObjectIdentifier> opeStartLotIDs = new ArrayList<>();
        for (int i = 0; i < startCassetteLen; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            for (int j = 0; j < CimArrayUtils.getSize(startCassette.getLotInCassetteList()); j++) {
                Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                //Omit Not-OpeStart lot ;
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                    continue;
                }

                log.debug("step52 - update contamination flag");
                contaminationMethod.lotContaminationLevelAndPrFlagSet(lotInCassette.getLotID());

                try {
                    log.debug("step53 - Move Process Operation of lot");
                    processMethod.processMove(objCommon, lotInCassette.getLotID());
                } catch (ServiceException ex) {
                    if (Validations.isEquals(retCodeConfig.getAddToQueueFail(), ex.getCode())) {
                        log.debug("step54 - get current operation info of lot {}",lotInCassette.getLotID());
                        Outputs.ObjLotCurrentOperationInfoGetOut lotCurrentOpeInfoRetCode = lotMethod.lotCurrentOperationInfoGet(objCommon, lotInCassette.getLotID());

                        List<Infos.LotHoldReq> lotHoldReqList = new ArrayList<>();
                        Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                        lotHoldReqList.add(lotHoldReq);
                        lotHoldReq.setHoldType(BizConstant.SP_HOLDTYPE_ADDTOQUEUEERRHOLD);
                        lotHoldReq.setHoldReasonCodeID(new ObjectIdentifier(BizConstant.SP_REASON_ADDTOQUEUEERRHOLD));
                        lotHoldReq.setHoldUserID(objCommon.getUser().getUserID());
                        lotHoldReq.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                        lotHoldReq.setRouteID(lotCurrentOpeInfoRetCode.getRouteID());
                        lotHoldReq.setOperationNumber(lotCurrentOpeInfoRetCode.getOperationNumber());
                        lotHoldReq.setClaimMemo(BizConstant.EMPTY);
                        log.debug("step55 - hold lot");
                        lotService.sxHoldLotReq(objCommon, lotInCassette.getLotID(), lotHoldReqList);
                    }
                    throw ex;
                }
                opeStartLotIDs.add(lotInCassette.getLotID());

                log.debug("step56 - UpDate RequiredCassetteCategory");
                lotMethod.lotCassetteCategoryUpdateForContaminationControl(objCommon, lotInCassette.getLotID());
            }
        }

        //lot FutureHold Post By Previous Operation Effect after Operation Move;
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            for (int fHCnt = 0; fHCnt < CimArrayUtils.getSize(fuHoldReuests); fHCnt++) {
                Outputs.ObjLotFutureHoldRequestsEffectByConditionOut futureHoldReuest = fuHoldReuests.get(fHCnt);
                if (CimArrayUtils.isEmpty(futureHoldReuest.getStrLotHoldReqList())) {
                    continue;
                }

                log.debug("step57 - Convert OpeNo, RouteID from previous to current");
                Outputs.ObjLotFutureHoldEffectedProcessConversionOut processConversionRetCode = lotMethod.lotFutureHoldEffectedProcessConversion(
                        objCommon, futureHoldReuest.getLotID(), futureHoldReuest.getStrLotHoldReqList());
                try {
                    log.debug("step58 - hold lot");
                    lotService.sxHoldLotReq(objCommon, futureHoldReuest.getLotID(), processConversionRetCode.getLotHoldReqList());
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getExistSameHold(), e.getCode())) {
                        throw e;
                    }
                }
            }
        }

        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            log.debug("step59 - Effect PO's Direction for TEL Furnace");
            List<Infos.LotHoldEffectList> effectRetCode = lotMethod.lotHoldRecordEffectMonitorIssue(objCommon, startCassetteList);

            int nMonitorHoldEffectLen = CimArrayUtils.getSize(effectRetCode);
            log.trace("nMonitorHoldEffectLen is {}",nMonitorHoldEffectLen);
            if (nMonitorHoldEffectLen > 0) {
                List<Infos.LotHoldReq> lotHoldReqList = new ArrayList<>();
                Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                lotHoldReqList.add(lotHoldReq);
                for (int i = 0; i < nMonitorHoldEffectLen; i++) {
                    Infos.LotHoldEffectList lotHoldEffectList = effectRetCode.get(i);
                    lotHoldReq.setHoldType(lotHoldEffectList.getHoldType());
                    lotHoldReq.setHoldReasonCodeID(lotHoldEffectList.getReasonCodeID());
                    lotHoldReq.setHoldUserID(lotHoldEffectList.getUserID());
                    lotHoldReq.setResponsibleOperationMark(lotHoldEffectList.getResponsibleOperationMark());
                    lotHoldReq.setRouteID(lotHoldEffectList.getRouteID());
                    lotHoldReq.setOperationNumber(lotHoldEffectList.getOperationNumber());
                    lotHoldReq.setRelatedLotID(lotHoldEffectList.getRelatedLotID());
                    lotHoldReq.setClaimMemo(lotHoldEffectList.getClaimMemo());
                    try {
                        log.debug("step60 - hold lot");
                        lotService.sxHoldLotReq(objCommon, lotHoldEffectList.getLotID(), lotHoldReqList);
                    } catch (ServiceException ex) {
                        Validations.check(!Validations.isEquals(retCodeConfig.getExistSameHold(), ex.getCode()), new OmCode(ex.getCode(), ex.getMessage()));
                    }
                }
            }
        }

        log.debug("step61 - Effect Future Hold Direction if Exist");
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            for (int i = 0; i < startCassetteLen; i++) {
                Infos.StartCassette startCassette = startCassetteList.get(i);
                for (int j = 0; j < CimArrayUtils.getSize(startCassette.getLotInCassetteList()); j++) {
                    Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                    //Omit Not-OpeStart lot ;
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    log.debug("step62 - Get Effected Future Hold PRE of Current after Operation Move");
                    Infos.EffectCondition effectCondition = new Infos.EffectCondition(BizConstant.SP_FUTUREHOLD_PRE, BizConstant.SP_FUTUREHOLD_ALL);
                    Outputs.ObjLotFutureHoldRequestsEffectByConditionOut effectByConditionOutRetCode = lotMethod.lotFutureHoldRequestsEffectByCondition(
                            objCommon, lotInCassette.getLotID(), effectCondition);

                    log.trace("StrLotHoldReqList size is {}", CimArrayUtils.getSize(effectByConditionOutRetCode.getStrLotHoldReqList()));
                    if (CimArrayUtils.getSize(effectByConditionOutRetCode.getStrLotHoldReqList()) > 0) {
                        try {
                            log.debug("step63 - hold lot");
                            lotService.sxHoldLotReq(objCommon, lotInCassette.getLotID(), effectByConditionOutRetCode.getStrLotHoldReqList());
                        } catch (ServiceException ex) {
                            Validations.check(!Validations.isEquals(retCodeConfig.getExistSameHold(), ex.getCode()), new OmCode(ex.getCode(), ex.getMessage()));
                        }

                    }

                    log.debug("step64 - Get Effected Future Hold Cancel PRE and SINGLE of Current after Operation Move");
                    Infos.EffectCondition effectConditionDel = new Infos.EffectCondition(BizConstant.SP_FUTUREHOLD_PRE, BizConstant.SP_FUTUREHOLD_SINGLE);
                    Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut deleteEffectedByConditionRetCode = lotMethod.lotFutureHoldRequestsDeleteEffectedByCondition(
                            objCommon, lotInCassette.getLotID(), effectConditionDel);

                    log.trace("StrFutureHoldReleaseReqList is {}", CimArrayUtils.getSize(deleteEffectedByConditionRetCode.getStrFutureHoldReleaseReqList()));
                    if (CimArrayUtils.getSize(deleteEffectedByConditionRetCode.getStrFutureHoldReleaseReqList()) > 0) {
                        Params.FutureHoldCancelReqParams inParams = new Params.FutureHoldCancelReqParams();
                        inParams.setLotID(lotInCassette.getLotID());
                        inParams.setReleaseReasonCodeID(releaseReasonCodeID);
                        inParams.setEntryType(BizConstant.SP_ENTRYTYPE_REMOVE);
                        inParams.setLotHoldList(deleteEffectedByConditionRetCode.getStrFutureHoldReleaseReqList());
                        log.debug("step65 - cancel future hold");
                        processControlService.sxFutureHoldCancelReq(objCommon, inParams);
                    }
                }
            }
        }

        //eqp Related Information Update Procedure;
        log.debug("step66 - Remove ControlJobLot from EqpInfo's ProcessingLot Sequence");
        equipmentMethod.equipmentProcessingLotDelete(objCommon, params.getEquipmentID(), startCassetteList);

        //Maintain Eqp's Status when OFF-LINE Mod;
        log.trace("OnlineMode is {}",operationModeRetCode.getOperationMode().getOnlineMode());
        if (CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, operationModeRetCode.getOperationMode().getOnlineMode())) {
            log.debug("step67 - Change eqp's Status to 'STANDBY' if necessary");
            Boolean checkEqpStateOut = equipmentMethod.equipmentCurrentStateCheckToManufacturing(objCommon, params.getEquipmentID());
            log.trace("checkEqpStateOut is {}",checkEqpStateOut);
            if (CimBooleanUtils.isTrue(checkEqpStateOut)) {
                log.debug("step68 - get Defaclt Status CimCode for Productive / Standby");
                ObjectIdentifier recoverStateOut = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, params.getEquipmentID());

                try {
                    log.debug("step69 - call sxEqpStatusChangeReq");
                    sxEqpStatusChangeReq(objCommon, params.getEquipmentID(), recoverStateOut, params.getOpeMemo());
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getInvalidStateTransition(), e.getCode())) {
                        throw e;
                    }
                }
            }
        }
        log.debug("step70 - eqp Usage Limitation Check");
        Outputs.ObjEquipmentUsageLimitationCheckOut checkEqpUseLimitOut = equipmentMethod.equipmentUsageLimitationCheck(objCommon, params.getEquipmentID());

        log.trace("UsageLimitOverFlag is {}",checkEqpUseLimitOut.isUsageLimitOverFlag());
        if (checkEqpUseLimitOut.isUsageLimitOverFlag()) {
            log.debug("step71 - Call System Message");
            Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
            alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
            alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_EQPUSAGELIMITOVER);
            alertMessageRptParams.setSystemMessageText(checkEqpUseLimitOut.getMessageText());
            alertMessageRptParams.setNotifyFlag(true);
            alertMessageRptParams.setEquipmentID(params.getEquipmentID());
            alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.getTimestampAsString(objCommon.getTimeStamp().getReportTimeStamp()));
            Results.AlertMessageRptResult alertMessageRptResult = systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
        }

        //controljob Related Information Update Proceure;
        log.trace("TransactionID is {}",objCommon.getTransactionID());
        if (!TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ, objCommon.getTransactionID())
                && !TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ, objCommon.getTransactionID())) {
            log.trace("step72 - Delete controljob from EQP:The relation of it with lot and cassette is deleted in txEDCWithSpecCheckActionReq");
            Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
            cjStatusChangeReqParams.setControlJobID(params.getControlJobID());
            cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE_FROM_EQP);
            cjStatusChangeReqParams.setClaimMemo(params.getOpeMemo());
            cjStatusChangeReqParams.setControlJobCreateRequest(null);
            controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);
        }

        //cassette Related Information Update Procedure ;
        for (int i = 0; i < startCassetteLen; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            log.debug("step73 - cassette Usage Limitation Check");
            Outputs.ObjCassetteUsageLimitationCheckOut checkCassetteUseLimitOut = cassetteMethod.cassetteUsageLimitationCheck(
                    objCommon, startCassette.getCassetteID());

            log.trace("UsageLimitOverFlag is {}",checkCassetteUseLimitOut.isUsageLimitOverFlag());
            if (checkCassetteUseLimitOut.isUsageLimitOverFlag()) {
                log.debug("step74 - Call System Message");
                Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_CASTUSAGELIMITOVER);
                alertMessageRptParams.setSystemMessageText(checkCassetteUseLimitOut.getMessageText());
                alertMessageRptParams.setNotifyFlag(true);
                alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.getTimestampAsString(objCommon.getTimeStamp().getReportTimeStamp()));
                Results.AlertMessageRptResult alertMessageRptResult = systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
            }

            log.debug("step75 - Update cassette's MultiLotType");
            cassetteMethod.cassetteMultiLotTypeUpdate(objCommon, startCassette.getCassetteID());
        }

        // ProcessLagTime Information Update Procedure;
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            //ProcessLagTime Information Update Procedure ;
            log.debug("ProcessLagTime Information Update Procedure...");
            for (int i = 0; i < startCassetteLen; i++) {
                Infos.StartCassette startCassette = startCassetteList.get(i);
                nLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                for (int j = 0; j < nLen; j++) {
                    Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                    //Omit Not-OpeStart lot ;
                    log.trace("MoveInFlag is {}",lotInCassette.getMoveInFlag());
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }
                    log.debug("step76 - call sxProcessLagTimeUpdate");
                    Params.LagTimeActionReqParams lagTimeUpdateReqParams = new Params.LagTimeActionReqParams();
                    lagTimeUpdateReqParams.setAction(BizConstant.SP_PROCESSLAGTIME_ACTION_SET);
                    lagTimeUpdateReqParams.setClaimMemo(params.getOpeMemo());
                    lagTimeUpdateReqParams.setLotID(lotInCassette.getLotID());
                    lagTimeUpdateReqParams.setUser(objCommon.getUser());
                    processControlService.sxProcessLagTimeUpdate(objCommon, lagTimeUpdateReqParams);
                }

            }
        }

        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            for (int i = 0; i < startCassetteLen; i++) {
                Infos.StartCassette startCassette = startCassetteList.get(i);
                int lcLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                for (int j = 0; j < lcLen; j++) {
                    Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                    log.trace("MoveInFlag is {}",lotInCassette.getMoveInFlag());
                    if (CimBooleanUtils.isTrue(lotInCassette.getMoveInFlag())) {
                        log.debug("step77 - call sxProcessHoldDoActionReq");
                        processControlService.sxProcessHoldDoActionReq(objCommon, lotInCassette.getLotID(), params.getOpeMemo());
                    }
                }
            }
        }

        log.debug("step78 - Event Make Procedure");
        String eventTxID = BizConstant.EMPTY;
        if (TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ, objCommon.getTransactionID())
                || TransactionIDEnum.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ, objCommon.getTransactionID())) {
            eventTxID = objCommon.getTransactionID();
        } else {
            eventTxID = TransactionIDEnum.OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue();
        }
        log.trace("startCassetteLen is {}",startCassetteLen);
        if (startCassetteLen > 0) {
            for (int i = 0; i < startCassetteLen; i++) {
                Infos.StartCassette startCassette = startCassetteList.get(i);
                nLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                for (int j = 0; j < nLen; j++) {
                    Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                    //Omit Not-OpeStart lot ;
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }
                    // Make OperationMoveEvent for Operation History - OpeComp ;
                    log.debug("step79 - Event Make Procedure");
                    Inputs.LotOperationMoveEventMakeOpeComp lotOperationMoveEventMakeOpeComp = new Inputs.LotOperationMoveEventMakeOpeComp();
                    lotOperationMoveEventMakeOpeComp.setTransactionID(eventTxID);
                    lotOperationMoveEventMakeOpeComp.setEquipmentID(params.getEquipmentID());
                    lotOperationMoveEventMakeOpeComp.setOperationMode(operationModeRetCode.getOperationMode().getOperationMode().getValue());
                    lotOperationMoveEventMakeOpeComp.setCassetteID(startCassette.getCassetteID());
                    lotOperationMoveEventMakeOpeComp.setLotInCassette(lotInCassette);
                    lotOperationMoveEventMakeOpeComp.setClaimMemo(params.getOpeMemo());
                    lotOperationMoveEventMakeOpeComp.setControlJobID(params.getControlJobID());
                    eventMethod.lotOperationMoveEventMakeOpeComp(objCommon, lotOperationMoveEventMakeOpeComp);
                }
            }
        }

        Results.EDCWithSpecCheckActionReqResult edcWithSpecCheckActionReqResultRetCode = null;
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            log.debug("step80 - Invoking Action for Collected Data");
            Infos.EDCWithSpecCheckActionReqInParm strEDCWithSpecCheckActionReqInParm = new Infos.EDCWithSpecCheckActionReqInParm();
            strEDCWithSpecCheckActionReqInParm.setEquipmentID(params.getEquipmentID());
            strEDCWithSpecCheckActionReqInParm.setControlJobID(params.getControlJobID());
            strEDCWithSpecCheckActionReqInParm.setStrStartCassette(startCassetteList);
            edcWithSpecCheckActionReqResultRetCode = engineerDataCollectionService.sxEDCWithSpecCheckActionReq(objCommon, strEDCWithSpecCheckActionReqInParm, params.getOpeMemo());
            out.setHoldReleasedLotIDs(edcWithSpecCheckActionReqResultRetCode.getHoldReleasedLotIDs());
            out.setMoveOutLot(edcWithSpecCheckActionReqResultRetCode.getMoveOutReqResult().getMoveOutLot());
        } else {
            log.debug("step81 - DataValue CheckValidity for SpeckChec");
            Results.SpecCheckReqResult specCheckReqResultRetCode = this.dataValueCheckValidityForSpeckCheck(params.getEquipmentID(), params.getControlJobID(), startCassetteList);

            log.debug("step82 - Set Initialized Data into PO");
            processMethod.processOperationTempDataSet(objCommon, params.getControlJobID(), specCheckReqResultRetCode.getStartCassetteList());

            log.debug("step83 - Set DC Spec's detailed information into PO");
            List<Infos.StartCassette> dcSpecRetCode = processMethod.processDataCollectionSpecificationSet(objCommon, specCheckReqResultRetCode.getStartCassetteList());
            specCheckReqResultRetCode.setStartCassetteList(dcSpecRetCode);

            try {
                log.debug("step84 - Validity Check");
                dataValueMethod.dataValueCheckValidityForSpecCheckDR(objCommon, specCheckReqResultRetCode.getEquipmentID(),
                        specCheckReqResultRetCode.getControlJobID(), specCheckReqResultRetCode.getStartCassetteList());
            } catch (ServiceException ex) {
                if (!Validations.isEquals(ex.getCode(), retCodeConfig.getAllDataValAsterisk())) {
                    throw ex;
                }
            }
            if (!TransactionIDEnum.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ)
                    && !TransactionIDEnum.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ)) {
                log.debug("step85 - Delete Control Job From lot and cassette");
                Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
                cjStatusChangeReqParams.setControlJobID(params.getControlJobID());
                cjStatusChangeReqParams.setClaimMemo(params.getOpeMemo());
                cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE_FROM_LOTANDCASSETTE);
                cjStatusChangeReqParams.setControlJobCreateRequest(null);
                controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);
            }
        }

        log.debug("step86 - Future Action Procedure");
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            for (int i = 0; i < startCassetteLen; i++) {
                Infos.StartCassette startCassette = startCassetteList.get(i);
                nLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
                for (int j = 0; j < nLen; j++) {
                    Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                    //Omit Not-OpeStart lot;
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }

                    String tmpRouteID = CimObjectUtils.getObjectValue(lotInCassette.getStartOperationInfo().getProcessFlowID());
                    log.debug("step87 - Call schdlChangeReservation_CheckForActionDR");
                    Inputs.ObjSchdlChangeReservationCheckForActionDRIn objSchdlChangeReservationCheckForActionDRIn = new Inputs.ObjSchdlChangeReservationCheckForActionDRIn();
                    objSchdlChangeReservationCheckForActionDRIn.setLotID(lotInCassette.getLotID());
                    objSchdlChangeReservationCheckForActionDRIn.setRouteID(tmpRouteID);
                    objSchdlChangeReservationCheckForActionDRIn.setOperationNumber(lotInCassette.getStartOperationInfo().getOperationNumber());
                    Outputs.ObjSchdlChangeReservationCheckForActionDROut objSchdlChangeReservationCheckForActionDROut
                            = scheduleChangeReservationMethod.schdlChangeReservationCheckForActionDR(objCommon, objSchdlChangeReservationCheckForActionDRIn);

                    log.trace("ExistFlag is {}",objSchdlChangeReservationCheckForActionDROut.isExistFlag());
                    if (objSchdlChangeReservationCheckForActionDROut.isExistFlag()) {
                        List<Infos.ReScheduledLotAttributes> reScheduledLotAttributesList = new ArrayList<>();
                        Infos.ReScheduledLotAttributes reScheduledLotAttributes = new Infos.ReScheduledLotAttributes();
                        reScheduledLotAttributesList.add(reScheduledLotAttributes);
                        reScheduledLotAttributes.setLotID(lotInCassette.getLotID());
                        reScheduledLotAttributes.setProductID(objSchdlChangeReservationCheckForActionDROut.getStrSchdlChangeReservation().getProductID());
                        reScheduledLotAttributes.setRouteID(objSchdlChangeReservationCheckForActionDROut.getStrSchdlChangeReservation().getRouteID());
                        reScheduledLotAttributes.setCurrentOperationNumber(objSchdlChangeReservationCheckForActionDROut.getStrSchdlChangeReservation().getOperationNumber());
                        reScheduledLotAttributes.setSubLotType(objSchdlChangeReservationCheckForActionDROut.getStrSchdlChangeReservation().getSubLotType());

                        log.debug("step88 - Get current RouteID by lotID");
                        ObjectIdentifier currentRouteID = lotMethod.lotCurrentRouteIDGet(objCommon, lotInCassette.getLotID());
                        reScheduledLotAttributes.setOriginalRouteID(ObjectIdentifier.fetchValue(currentRouteID));

                        log.debug("step89 - Get current oparation No. by lotID");
                        String currentOperationNumber = lotMethod.lotCurrentOpeNoGet(objCommon, lotInCassette.getLotID());
                        reScheduledLotAttributes.setOriginalOperationNumber(currentOperationNumber);

                        log.debug("step90 - sxLotPlanChangeReserveDoActionReq");
                        List<Infos.ChangeLotSchdlReturn> changeLotSchdlReturnList = planService.sxLotPlanChangeReserveDoActionReq(objCommon, reScheduledLotAttributesList, objSchdlChangeReservationCheckForActionDROut.getStrSchdlChangeReservation().getEventID());

                        log.debug("step91 - schdlChangeReservationApplyCountIncreaseDR");
                        scheduleChangeReservationMethod.schdlChangeReservationApplyCountIncreaseDR(objCommon, objSchdlChangeReservationCheckForActionDROut.getStrSchdlChangeReservation());
                    }
                }
            }
        }

        log.debug("step92 - BR Script Procedure - Execute BRScript");
        for (int i = 0; i < startCassetteLen; i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            int nLenLotInCassette = CimArrayUtils.getSize(lotInCassetteList);
            for (int j = 0; j < nLenLotInCassette; j++) {
                Infos.LotInCassette lotInCassette = lotInCassetteList.get(j);
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                    continue;
                }
                /*-------------------------*/
                /*   Execute Post BRScript */
                /*-------------------------*/
                Params.ProcessControlScriptRunReqParams processControlScriptRunReqParams = new Params.ProcessControlScriptRunReqParams();
                processControlScriptRunReqParams.setEquipmentId(params.getEquipmentID());
                processControlScriptRunReqParams.setLotId(lotInCassette.getLotID());
                processControlScriptRunReqParams.setPhase(BizConstant.SP_BRSCRIPT_POST);
                try {
                    processControlScriptService.sxProcessControlScriptRunReq(objCommon, processControlScriptRunReqParams);
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getNotFoundScript(), e.getCode())) {
                        throw e;
                    }
                }
            }
        }

        //Auto-bank-In Procedure;
        log.trace("postProcForLotFlag is {}",postProcForLotFlag);
        if (postProcForLotFlag != 1) {
            int opeStartLotCount = CimArrayUtils.getSize(opeStartLotIDs);
            for (int i = 0; i < opeStartLotCount; i++) {
                log.debug("step93 - before auto bank in to do check");
                boolean autoBankInOutRetCode = lotMethod.lotCheckConditionForAutoBankIn(objCommon, opeStartLotIDs.get(i));
                log.trace("autoBankInOutRetCode is {}",autoBankInOutRetCode);
                if (!autoBankInOutRetCode) {
                    continue;
                }
                log.debug("step94 - get lot hold state");
                String lotHoldStateGetOutRetCode = lotMethod.lotHoldStateGet(objCommon, opeStartLotIDs.get(i));
                log.trace("lotHoldStateGetOutRetCode is {}",lotHoldStateGetOutRetCode);
                if (BizConstant.equalsIgnoreCase(BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD, lotHoldStateGetOutRetCode)) {
                    //retCode.setReturnCode(lotHoldStateGetOutRetCode.getReturnCode());
                    continue;
                }
                log.debug("step95 - Call txBankInReq() for Auto-bank-In");
                bankService.sxBankInReq(objCommon, i, opeStartLotIDs, params.getOpeMemo());
            }
        }

        /*------------------------------------------------------------------------*/
        /*                                                                        */
        /*   Send OpeComp Request to TCS Procedure                                */
        /*                                                                        */
        /*   - If specified portGroup's operationCompMode is Manual, OpeComp trx  */
        /*     must be sent to TCS. In TCS, if "ProcessEnd" report is not come    */
        /*     from eqp yet, OpeComp trx from MM is rejected by TCS.              */
        /*                                                                        */
        /*------------------------------------------------------------------------*/
        log.debug("step96 - Send Request to TCS");
        log.trace("MoveOutMode is {}",operationModeRetCode.getOperationMode().getMoveOutMode());
        if (CimStringUtils.equals(BizConstant.SP_EQP_COMPMODE_MANUAL, operationModeRetCode.getOperationMode().getMoveOutMode())) {
            /*--------------------------*/
            /*    Send Request to TCS   */
            /*--------------------------*/
            if (!CimStringUtils.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue(), objCommon.getTransactionID())//PartialMoveOutReq
                    && !CimStringUtils.equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(), objCommon.getTransactionID())) {//PartialMoveOutForIBReq
//                Inputs.SendMoveOutForIBReqIn sendMoveOutForIBReqIn = new Inputs.SendMoveOutForIBReqIn();
//                sendMoveOutForIBReqIn.setObjCommonIn(objCommon);
//                sendMoveOutForIBReqIn.setRequestUserID(objCommon.getUser());
//                sendMoveOutForIBReqIn.setEquipmentID(params.getEquipmentID());
//                sendMoveOutForIBReqIn.setControlJobID(params.getControlJobID());
//                sendMoveOutForIBReqIn.setSpcResultRequiredFlag(params.getSpcResultRequiredFlag());
//                sendMoveOutForIBReqIn.setClaimMemo(params.getOpeMemo());
//                Outputs.SendMoveOutForIBReqOut sendMoveOutForIBReqOut = (Outputs.SendMoveOutForIBReqOut) tcsMethod.sendTCSReq(TCSReqEnum.sendMoveOutForIBReq, sendMoveOutForIBReqIn);
                String tmpSleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue();
                String tmpRetryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue();
                Long sleepTimeValue = 0L;
                Long retryCountValue = 0L;

                if (0 == CimStringUtils.length(tmpSleepTimeValue)) {
                    sleepTimeValue = BizConstant.SP_DEFAULT_SLEEP_TIME_TCS;
                } else {
                    sleepTimeValue = BaseStaticMethod.parseToLong(tmpSleepTimeValue);
                }

                if (0 == CimStringUtils.length(tmpRetryCountValue)) {
                    retryCountValue = BizConstant.SP_DEFAULT_RETRY_COUNT_TCS;
                } else {
                    retryCountValue = BaseStaticMethod.parseToLong(tmpRetryCountValue);
                }

                for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                    log.debug("{} {}", "loop to retryCountValue + 1", retryNum);
                    /*--------------------------*/
                    /*    Send Request to EAP   */
                    /*--------------------------*/
                    IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,params.getUser(),params.getEquipmentID(),null,true);
                    if (null == eapRemoteManager) {
                        log.info("MES not configure EAP host");
                        break;
                    }
                    try {
                        Object moveOutForIBReqEapOut = eapRemoteManager.sendMoveOutForIBReq(params);
                        log.info("Now EAP subSystem is alive!! Go ahead");
                        break;
                    } catch (ServiceException ex) {
                        if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                            log.info("{} {}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...", retryNum);
                            log.info("{} {}", "now sleeping... ", sleepTimeValue);
                            if (retryNum != retryCountValue){
                                try {
                                    Thread.sleep(sleepTimeValue);
                                    continue;
                                } catch (InterruptedException e) {
                                    ex.addSuppressed(e);
                                    Thread.currentThread().interrupt();
                                    throw ex;
                                }
                            }else {
                                Validations.check(true,retCodeConfig.getTcsNoResponse());
                            }
                        } else {
                            Validations.check(true,new OmCode(ex.getCode(),ex.getMessage()));
                        }
                    }
                }
            }
        }
        //TODO-NOTIMPL:【Step69】Send OpeComp Report to DCS Procedure;

        log.debug("step98 - Call controlJobAPCRunTimeCapabilityGetDR");
        boolean bActionTriggerFlag = false;
        List<Infos.APCRunTimeCapabilityResponse> apcRunTimeCapabilityResponseList = controlJobMethod.controlJobAPCRunTimeCapabilityGetDR(objCommon, params.getControlJobID());
        int response_cnt = CimArrayUtils.getSize(apcRunTimeCapabilityResponseList);
        for (int loop_response_cnt = 0; loop_response_cnt < response_cnt; loop_response_cnt++) {
            List<Infos.APCRunTimeCapability> strAPCRunTimeCapability = apcRunTimeCapabilityResponseList.get(loop_response_cnt).getStrAPCRunTimeCapability();
            int capability_cnt = CimArrayUtils.getSize(strAPCRunTimeCapability);
            for (int loop_capability_cnt = 0; loop_capability_cnt < capability_cnt; loop_capability_cnt++) {
                Infos.APCRunTimeCapability apcRunTimeCapability = strAPCRunTimeCapability.get(loop_capability_cnt);
                List<Infos.APCBaseAPCSystemFunction1> strAPCBaseAPCSystemFunction1 = apcRunTimeCapability.getStrAPCBaseAPCSystemFunction1();
                int function_cnt = CimArrayUtils.getSize(strAPCBaseAPCSystemFunction1);
                for (int loop_function_cnt = 0; loop_function_cnt < function_cnt; loop_function_cnt++) {
                    if (CimStringUtils.equals(strAPCBaseAPCSystemFunction1.get(loop_function_cnt).getType(), BizConstant.SP_APCFUNCTIONTYPE_PRODUCTDISPOSITION)) {
                        bActionTriggerFlag = true;
                        break;
                    }
                }
            }
        }
        log.trace("bActionTriggerFlag is {}",bActionTriggerFlag);
        if (!bActionTriggerFlag) {
            /*-----------------------------------------------------*/
            /*   Call APCRuntimeCapability_DeleteDR                */
            /*-----------------------------------------------------*/
            log.debug("step99 - Call apcRuntimeCapabilityDeleteDR");
            apcMethod.apcRuntimeCapabilityDeleteDR(objCommon, params.getControlJobID());
        }
        if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
            try {
                log.debug("step100 - call APCMgrSendControlJobInformationDR");
                apcMethod.APCMgrSendControlJobInformationDR(objCommon, params.getEquipmentID(), params.getControlJobID(), BizConstant.SP_APC_CONTROLJOBSTATUS_COMPLETED, apcBaseCassettes);
            } catch (ServiceException e) {
                if (!Validations.isEquals(retCodeConfigEx.getOkNoIF(), e.getCode())) {
                    throw e;
                }
            }
        }

        log.debug("step101 - Update Reticle's LastUsedTimestamp");
        reticleMethod.reticleLastUsedTimeStampUpdate(objCommon,
                controlJobStartReserveInformationOutRetCode.getStartCassetteList());

        Inputs.ObjEntityInhibitExceptionLotChangeForOpeCompIn inputs = new Inputs.ObjEntityInhibitExceptionLotChangeForOpeCompIn();
        inputs.setControlJobID(params.getControlJobID());
        inputs.setLotIDs(opeStartLotIDs);

        log.debug("step102 - entity inhibit exception lot to do Change For Operation Complete");
        constraintMethod.constraintExceptionLotChangeForOpeComp(objCommon, inputs.getLotIDs(), inputs.getControlJobID());

        log.debug("step103 - Return to Caller");
        if (postProcForLotFlag != 1) {
            List<Infos.OpeCompLot> opeCompLotList = edcWithSpecCheckActionReqResultRetCode.getMoveOutReqResult().getMoveOutLot();
            out.setMoveOutLot(opeCompLotList);
        } else {
            List<Infos.OpeCompLot> lotList = new ArrayList<>();
            opeStartLotIDs.forEach(lotID -> {
                Infos.OpeCompLot opeCompLot = new Infos.OpeCompLot();
                opeCompLot.setLotID(lotID);
                lotList.add(opeCompLot);
            });
            out.setMoveOutLot(lotList);
        }

        log.debug("step104 - check contamination level and pr flag");
        contaminationMethod.lotCheckContaminationLevelAndPrFlagStepOut(objCommon, lotIDs, params.getEquipmentID());

        log.debug("【Method Exit】sxMoveOutForIBReq()");
        return out;
    }

    //region Private Methods;
    private Results.SpecCheckReqResult dataValueCheckValidityForSpeckCheck(ObjectIdentifier equipmentID
            , ObjectIdentifier controlJobID, List<Infos.StartCassette> startCassetteList) {
        Results.SpecCheckReqResult outObject = new Results.SpecCheckReqResult();
        outObject.setEquipmentID(equipmentID);
        outObject.setControlJobID(controlJobID);
        outObject.setStartCassetteList(startCassetteList);

        // Loop for strStartCassette;
        if (CimArrayUtils.isEmpty(startCassetteList)) {
            return outObject;
        }

        for (int i = 0; i < CimArrayUtils.getSize(startCassetteList); i++) {
            Infos.StartCassette startCassette = startCassetteList.get(i);
            // Loop for strLotInCassette;
            int lcLen = CimArrayUtils.getSize(startCassette.getLotInCassetteList());
            if (lcLen < 1) {
                continue;
            }
            for (int j = 0; j < lcLen; j++) {
                // Omit Not-Start lot;
                log.info(" Omit Not-Start lot.");
                Infos.LotInCassette lotInCassette = startCassette.getLotInCassetteList().get(j);
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                    log.info("Non-DCDef Lot. continue...");
                    continue;
                }

                //Omit Non-DataColloection lot;
                log.info("Omit Non-DataClooection lot.");
                if (CimBooleanUtils.isFalse(lotInCassette.getStartRecipe().getDataCollectionFlag())) {
                    continue;
                }

                // Clear;
                int dcLen = CimArrayUtils.getSize(lotInCassette.getStartRecipe().getDcDefList());
                if (dcLen < 1) {
                    continue;
                }
                for (int n = 0; n < dcLen; n++) {
                    Infos.DataCollectionInfo dcDef = lotInCassette.getStartRecipe().getDcDefList().get(n);
                    int itLen = CimArrayUtils.getSize(dcDef.getDcItems());
                    if (itLen < 1) {
                        continue;
                    }
                    for (int l = 0; l < itLen; l++) {
                        Boolean bClearFlag = true;
                        Infos.DataCollectionItemInfo dcItem = dcDef.getDcItems().get(l);
                        if (!CimStringUtils.equals(dcItem.getMeasurementType(), BizConstant.SP_DCDEF_MEAS_LOT)
                                && !CimStringUtils.equals(dcItem.getMeasurementType(), BizConstant.SP_DCDEF_MEAS_PJWAFER)
                                && !CimStringUtils.equals(dcItem.getMeasurementType(), BizConstant.SP_DCDEF_MEAS_PJWAFERSITE)) {
                            continue;
                        }
                        if (!CimStringUtils.isEmpty(dcItem.getSpecCheckResult())) {
                            if (CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_OK)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_UPPERCONTROLLIMIT)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_LOWERCONTROLLIMIT)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_UPPERSPECLIMIT)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_LOWERSPECLIMIT)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_UPPERSCREENLIMIT)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_LOWERSCREENLIMIT)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_ASTERISK)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_APCERROR)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_1X_POUND)
                                    || CimStringUtils.equals(dcItem.getSpecCheckResult(), BizConstant.SP_SPECCHECKRESULT_ERROR)) {
                                //Do Nothing
                                log.info("Nothing to do.");
                            } else {
                                log.info("Set bClearFlag = false");
                                bClearFlag = false;
                            }
                        }
                        if (CimBooleanUtils.isTrue(bClearFlag)) {
                            //Clear specCheckResult / actionCode;
                            log.info("Clear specCheckResult / actionCode...");
                            dcItem.setSpecCheckResult(null);
                            dcItem.setActionCodes(null);

                            //Clear dataValue;
                            log.info("Clear dataValue...");
                            if (CimStringUtils.equals(dcItem.getItemType(), BizConstant.SP_DCDEF_ITEM_RAW)) {
                                log.info("Ram Item, continue...");
                                continue;
                            }
                            dcItem.setDataValue(null);
                        }
                    }
                }
            }
        }

        return outObject;
    }
    //endregion;

    @Deprecated
    @Override
    public Results.PartialMoveOutReqResult sxPartialMoveOutReq(Infos.ObjCommon objCommon,
                                                               Params.PartialMoveOutReqParams partialMoveOutReqParams,
                                                               String APCIFControlStatus,
                                                               String DCSIFControlStatus) {
        Results.PartialMoveOutReqResult partialMoveOutReqResult = new Results.PartialMoveOutReqResult();
        ObjectIdentifier equipmentID = partialMoveOutReqParams.getEquipmentID();
        ObjectIdentifier controlJobID = partialMoveOutReqParams.getControlJobID();
        //------------------------------------------------------
        // step1 - Check Function Availability
        //------------------------------------------------------
        log.info("Step1 - Check Function Availability");
        String PJCtrlFunc = StandardProperties.OM_PJ_CONTROL_ENABLE_FLAG.getValue();
        Validations.check(!CimObjectUtils.equalsWithValue(PJCtrlFunc, BizConstant.SP_FUNCTION_AVAILABLE_TRUE), retCodeConfig.getFunctionNotAvailable());
        // step2 - object_lockMode_Get
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // step3 - advanced_object_Lock
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            /*--------------------------------*/
            /*   Lock objects to be updated   */
            /*--------------------------------*/
            // step4 - object_Lock
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        // step5 controlJob_startLotWaferInfo_Get
        log.info("Step5 - controlJob_startLotWaferInfo_Get");
        Inputs.ControlJobStartLotWaferInfoGetIn controlJobStartLotWaferInfoGetIn = new Inputs.ControlJobStartLotWaferInfoGetIn();
        controlJobStartLotWaferInfoGetIn.setControlJobID(controlJobID);
        controlJobStartLotWaferInfoGetIn.setStartLotOnlyFlag(false);
        Infos.ControlJobInformation objControlJobStartLotWaferInfoGetOutResult = controlJobMethod.controlJobStartLotWaferInfoGet(objCommon, controlJobStartLotWaferInfoGetIn);
        boolean SLMCapabilityFlag = false;
        /*--------------------------------------*/
        /*   Get SLM Switch for the equipment   */
        /*--------------------------------------*/
        log.info("Step6 - equipment_brInfo_GetDR__120");
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentID);
        // Check SLM Capability
        if (CimBooleanUtils.isTrue(eqpBrInfo.isFmcCapabilityFlag())) {
            SLMCapabilityFlag = true;
        }
        List<Infos.EqpContainerPosition> eqpContainerPositionList = null;
        if (SLMCapabilityFlag) {
            log.info("Step7 - equipmentContainerPosition_info_Get");
            Infos.EqpContainerPositionInfo equipmentContainerPositionInfoResult = equipmentMethod.equipmentContainerPositionInfoGet(objCommon, equipmentID, controlJobID, BizConstant.SP_SLM_KEYCATEGORY_CONTROLJOB);
            eqpContainerPositionList = equipmentContainerPositionInfoResult.getEqpContainerPositionList();
        }
        boolean bEquipmentOnLineFlag = true;
        /*--------------------------------*/
        /*   Lock Cassette / Lot Object   */
        /*--------------------------------*/
        List<Infos.ControlJobCassetteInfo> controlJobCassetteInfoList = objControlJobStartLotWaferInfoGetOutResult.getControlJobCassetteInfoList();
        List<Infos.ControlJobCassetteInfo> tmpControlJobCassetteInfoList = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
        List<ObjectIdentifier> orgLotIDs = new ArrayList<>();
        int totalStartWaferCount = 0;
        if (!CimObjectUtils.isEmpty(controlJobCassetteInfoList)) {
            for (Infos.ControlJobCassetteInfo controlJobCassetteInfo : controlJobCassetteInfoList) {
                tmpControlJobCassetteInfoList.add(controlJobCassetteInfo);
                cassetteIDs.add(controlJobCassetteInfo.getCassetteID());
                List<Infos.ControlJobCassetteLot> controlJobCassetteLotList = controlJobCassetteInfo.getControlJobCassetteLotList();
                for (Infos.ControlJobCassetteLot controlJobCassetteLot : controlJobCassetteLotList) {
                    if (!controlJobCassetteLot.isOperationStartFlag()) {
                        continue;
                    }
                    boolean bLotFoundFlag = false;
                    for (ObjectIdentifier orgLotID : orgLotIDs) {
                        if (CimObjectUtils.equalsWithValue(controlJobCassetteLot.getLotID(), orgLotID)) {
                            bLotFoundFlag = true;
                        }
                    }
                    if (!bLotFoundFlag) {
                        orgLotIDs.add(controlJobCassetteLot.getLotID());
                        totalStartWaferCount = totalStartWaferCount + CimArrayUtils.getSize(controlJobCassetteLot.getWaferIDs());
                    }
                }
            }
        }
        partialMoveOutReqResult.setEquipmentID(equipmentID);
        partialMoveOutReqResult.setControlJobID(controlJobID);

        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.info("lockMode != SP_EQP_LOCK_MODE_WRITE");
            // Step8 - equipment_onlineMode_Get
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                // Step9 - advanced_object_Lock
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            // Lock eqp ProcLot Element
            // Step10 - advanced_object_Lock
            List<String> procLotSeq = orgLotIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, procLotSeq));
            // Lock Equipment LoadCassette Element (Write)
            List<String> loadCastSeq = cassetteIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            if (!CimArrayUtils.isEmpty(loadCastSeq)) {
                // Step11 - advanced_object_Lock
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, loadCastSeq));
            }
            //*------------------------------*//
            //*   Lock controljob Object     *//
            //*------------------------------*//
            // Step12 - object_Lock
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
        }
        /*------------------------------*/
        /*   Lock cassette/lot Object   */
        /*------------------------------*/
        // Step13 - objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);
        // step14 - objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, orgLotIDs);

        //------------------------------------------------------
        // Check Equipment
        //------------------------------------------------------
        // The "PJ Level Control Flag" of the equipment should be "True"
        // Equipment online mode should be "On-Line Remote"
        // Multiple recipe capability of the equipment should be "MultipleRecipe"
        log.info("Step15 - equipment_processJobLevelControlCheck");
        try {
            equipmentMethod.equipmentProcessJobLevelControlCheck(objCommon, equipmentID, true, true, true, false);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getEqpOnlineMode(), e.getCode())) {
                bEquipmentOnLineFlag = false;
            } else {
                throw e;
            }
        }

        // Check Actions
        //     Action should be one of the followings
        //         a.   SP_PartialOpeComp_Action_OpeComp
        //         b.   SP_PartialOpeComp_Action_OpeCompWithHold
        //         c.   SP_PartialOpeComp_Action_OpeStartCancel
        //         d.   SP_PartialOpeComp_Action_OpeStartCancelWithHold
        List<Infos.PartialOpeCompAction> partialOpeCompActionList = partialMoveOutReqParams.getPartialOpeCompActionList();
        log.info("Step16 - Check Actions");
        for (Infos.PartialOpeCompAction partialOpeCompAction : partialOpeCompActionList) {
            if (!CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)
                    && !CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD)
                    && !CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCEL)
                    && !CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCELWITHHOLD)) {
                throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(), "Invalid Action Code"));
            }
        }
        // Check controlJob status if equipment is Online
        //   controlJob should be "Executing"
        log.info("Step17 - equipment_onlineMode_Get");
        String operationMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
        if (!CimObjectUtils.equalsWithValue(operationMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
            Outputs.ObjControlJobStatusGetOut controlJobStatusResult = controlJobMethod.controlJobStatusGet(objCommon, controlJobID);
            // Check ControlJob Status
            if (!CimObjectUtils.equalsWithValue(controlJobStatusResult.getControlJobStatus(), BizConstant.SP_CONTROLJOBSTATUS_EXECUTING)) {
                throw new ServiceException(new OmCode(retCodeConfigEx.getInvalidCjstatus(), controlJobStatusResult.getControlJobStatus()));
            }
        }
        // Check waferIDs
        // All specified waferIDs should be inside the start lot of the controlJob.
        log.info("Step18 - Check waferIDs");
        int requestedWaferCount = 0;
        for (Infos.PartialOpeCompAction partialOpeCompAction : partialOpeCompActionList) {
            requestedWaferCount = requestedWaferCount + CimArrayUtils.getSize(partialOpeCompAction.getWaferIDs());
        }
        // Get waferID from controlJob
        if (requestedWaferCount != totalStartWaferCount) {
            // request wafer count is not correct
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(), "All started lot wafer should be selected"));
        }
        // All wafers in start lot should be specified in input waferIDs (including non-sampled wafers).
        // Create result structure
        List<Infos.PartialOpeCompLot> partialOpeCompLotList = new ArrayList<>();
        for (Infos.PartialOpeCompAction partialOpeCompAction : partialOpeCompActionList) {
            List<ObjectIdentifier> waferIDs = partialOpeCompAction.getWaferIDs();
            for (ObjectIdentifier tmpWaferID : waferIDs) {
                boolean bFoundWaferFlag = false;
                for (Infos.ControlJobCassetteInfo controlJobCassetteInfo : controlJobCassetteInfoList) {
                    List<Infos.ControlJobCassetteLot> controlJobCassetteLotList = controlJobCassetteInfo.getControlJobCassetteLotList();
                    for (Infos.ControlJobCassetteLot controlJobCassetteLot : controlJobCassetteLotList) {
                        if (!controlJobCassetteLot.isOperationStartFlag()) {
                            continue;
                        }
                        for (ObjectIdentifier waferID : controlJobCassetteLot.getWaferIDs()) {
                            if (CimObjectUtils.equalsWithValue(tmpWaferID, waferID)) {
                                bFoundWaferFlag = true;
                                // found the wafer
                                ObjectIdentifier tmpLotID = controlJobCassetteLot.getLotID();
                                // find tmpLotID in strPartialOpeCompLotSeq
                                boolean bFoundCompLotFlag = false;
                                for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
                                    if (CimObjectUtils.equalsWithValue(tmpLotID, partialOpeCompLot.getLotID())) {
                                        // Check if action is the same
                                        if (CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), partialOpeCompLot.getActionCode())) {
                                            // add this wafer to the lot
                                            List<ObjectIdentifier> waferIDs2 = partialOpeCompLot.getWaferIDs();
                                            waferIDs2.add(tmpWaferID);
                                            bFoundCompLotFlag = true;
                                            break;
                                        }
                                        continue;
                                    }
                                }
                                if (!bFoundCompLotFlag) {
                                    // create this lot to new strPartialOpeCompLotSeq
                                    Infos.PartialOpeCompLot partialOpeCompLot = new Infos.PartialOpeCompLot();
                                    partialOpeCompLot.setLotID(tmpLotID);
                                    partialOpeCompLot.setActionCode(partialOpeCompAction.getActionCode());
                                    List<ObjectIdentifier> waferIDs3 = new ArrayList<>();
                                    waferIDs3.add(tmpWaferID);
                                    partialOpeCompLot.setWaferIDs(waferIDs3);
                                    partialOpeCompLotList.add(partialOpeCompLot);
                                }
                                break;
                            }
                        }
                        if (bFoundWaferFlag) {
                            break;
                        }
                    }
                    if (bFoundWaferFlag) {
                        break;
                    }
                }
                if (!bFoundWaferFlag) {
                    throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(), "tmpWaferID is not found"));
                }
                if (SLMCapabilityFlag && (CimObjectUtils.equalsWithValue(BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP, partialOpeCompAction.getActionCode())
                        || CimObjectUtils.equalsWithValue(BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD, partialOpeCompAction.getActionCode()))) {
                    for (Infos.EqpContainerPosition eqpContainerPosition : eqpContainerPositionList) {
                        if (CimObjectUtils.equalsWithValue(tmpWaferID, eqpContainerPosition.getWaferID())) {
                            if (CimObjectUtils.equalsWithValue(BizConstant.SP_SLMSTATE_RESERVED, eqpContainerPosition.getFmcState())
                                    || CimObjectUtils.equalsWithValue(BizConstant.SP_SLMSTATE_STORED, eqpContainerPosition.getFmcState())) {
                                throw new ServiceException(new OmCode(retCodeConfig.getInvalidSLMStatusOfContainerPosition(), eqpContainerPosition.getContainerPositionID().getValue(), eqpContainerPosition.getFmcState()));
                            }
                            break;
                        }
                    }
                }
            }

        }
        //  Lot needs to be split if wafers within the lot are selected for different actions
        for (ObjectIdentifier orgLotID : orgLotIDs) {
            List<String> actionCodes = new ArrayList<>();
            for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
                if (CimObjectUtils.equalsWithValue(orgLotID, partialOpeCompLot.getLotID())) {
                    actionCodes.add(partialOpeCompLot.getActionCode());
                }
            }
            if (CimArrayUtils.getSize(actionCodes) > 1) {
                // This lot need to split
                //  Decide parent Lot: Parent lot should be decided from following priorities. If wafer sampling is used, non-sampled wafers should be in the same lot
                //      a.   OpeComp lot
                //      b.   OpeCompWithHold Lot
                //      c.   OpeStartCancel Lot
                //      d.   OpeStartCancelWithHold Lot
                boolean bParentLotFoundFlag = false;
                String parentLotActionCode = null;
                // First look for OpeComp lot
                for (String actionCode : actionCodes) {
                    if (CimObjectUtils.equalsWithValue(actionCode, BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)) {
                        bParentLotFoundFlag = true;
                        parentLotActionCode = actionCode;
                        break;
                    }
                }
                if (!bParentLotFoundFlag) {
                    for (String actionCode : actionCodes) {
                        if (CimObjectUtils.equalsWithValue(actionCode, BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)) {
                            // Parent lot found
                            bParentLotFoundFlag = true;
                            parentLotActionCode = actionCode;
                            break;
                        }
                    }
                }
                if (!bParentLotFoundFlag) {
                    // Continue to look for OpeCompWithHold Lot
                    for (String actionCode : actionCodes) {
                        if (CimObjectUtils.equalsWithValue(actionCode, BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD)) {
                            // Parent lot found
                            bParentLotFoundFlag = true;
                            parentLotActionCode = actionCode;
                            break;
                        }
                    }
                }
                if (!bParentLotFoundFlag) {
                    // Continue to look for OpeStartCancel Lot
                    for (String actionCode : actionCodes) {
                        if (CimObjectUtils.equalsWithValue(actionCode, BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCEL)) {
                            // Parent lot found
                            bParentLotFoundFlag = true;
                            parentLotActionCode = actionCode;
                            break;
                        }
                    }
                }
                for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
                    if (CimObjectUtils.equalsWithValue(orgLotID, partialOpeCompLot.getLotID())) {
                        if (CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), parentLotActionCode)) {
                            // Skip the parent lot
                        } else {
                            // split lot
                            Params.SplitLotReqParams splitLotReqParams = new Params.SplitLotReqParams();
                            splitLotReqParams.setParentLotID(orgLotID);
                            splitLotReqParams.setChildWaferIDs(partialOpeCompLot.getWaferIDs());
                            splitLotReqParams.setFutureMergeFlag(false);
                            splitLotReqParams.setMergedRouteID(new ObjectIdentifier());
                            splitLotReqParams.setMergedOperationNumber("");
                            splitLotReqParams.setBranchingRouteSpecifyFlag(false);
                            splitLotReqParams.setSubRouteID(new ObjectIdentifier());
                            splitLotReqParams.setReturnOperationNumber("");
                            log.info("Step20 - txSplitLotReq");
                            Results.SplitLotReqResult splitLotReqResultRetCode = lotService.sxSplitLotReq(objCommon, splitLotReqParams);

                            partialOpeCompLot.setLotID(splitLotReqResultRetCode.getChildLotID());
                            // Transfer following PO data from parent lot to child lot by waferID if child lot is going to perform opeComp
                            //     a.   Wafer chamber process
                            //     b.   Inside Chamber wafer position
                            //     c.   Processed wafers (Sampling wafers)
                            //     d.   Assigned Recipe parameters
                            //     e.   Collected data
                            //     f.   Assigned reticles
                            //     g.   Assigned fixtures
                            // Copy following PO data from parent PO to child lot
                            //     a.   Assigned equipment
                            //     b.   Assigned port group
                            //     c.   Assigned logical recipe
                            //     d.   Assigned recipe
                            //     e.   Assigned physical recipe
                            //     f.   Assigned recipe parameter change type
                            //     g.   Assigned dc flag
                            log.info("Step21 - lot_processOperationData_transferInProcessing");
                            lotMethod.lotProcessOperationDataTransferInProcessing(objCommon, orgLotID, partialOpeCompLot.getLotID());

                            if (CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)
                                    || CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD)) {
                                // Copy schedule change reservation information to child lot for OpeComp and OpeCompWithHold lot
                                //     A.   Get schedule change reservation (object type = Lot) of the original lot (parent lot = opeComp lot)
                                //     B.   Copy the schedule change reservation to newly created child lots
                                Params.LotPlanChangeReserveListInqParams params = new Params.LotPlanChangeReserveListInqParams();
                                params.setObjectID(orgLotID.getValue());
                                params.setObjectType(BizConstant.SP_SCHDL_CHG_OBJTYPE_LOT);
                                params.setLotInfoChangeFlag(0);
                                log.info("Step22 - txLotPlanChangeReserveListInq__110");
                                Results.LotPlanChangeReserveListInqResult lotPlanChangeReserveListInqResult = planInqService.sxLotPlanChangeReserveListInq(objCommon, params);
                                List<Infos.SchdlChangeReservation> schdlChangeReservationList = lotPlanChangeReserveListInqResult.getSchdlChangeReservations();
                                if (!CimObjectUtils.isEmpty(schdlChangeReservationList)) {
                                    for (Infos.SchdlChangeReservation schdlChangeReservation : schdlChangeReservationList) {
                                        log.info("Step23 - txLotPlanChangeReserveCreateReq__110");
                                        planService.sxLotPlanChangeReserveCreateReq(objCommon, schdlChangeReservation, "");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // Notify external subsystems (TCS)
        //     a.   Notify Conditions (No action needs to be taken if condition does not match)
        //         i.   Equipment should be under manual Comp mode
        //     b.   Handle Result
        //         i.   If returned "actionResult" is not "SP_ActionResult_OK", MMS should rollback the transaction and return the result to caller.
        Outputs.SendPartialMoveOutReqOut sendPartialMoveOutReqOut = null;
        if (bEquipmentOnLineFlag) {
            //step24 - TCSMgr_SendPartialMoveOutReq
            Inputs.SendPartialMoveOutReqIn sendPartialMoveOutReqIn = new Inputs.SendPartialMoveOutReqIn();
            sendPartialMoveOutReqIn.setEquipmentID(equipmentID);
            sendPartialMoveOutReqIn.setObjCommonIn(objCommon);
            sendPartialMoveOutReqIn.setControlJobID(controlJobID);
            sendPartialMoveOutReqIn.setStrPartialOpeCompLotSeq(partialOpeCompLotList);
            sendPartialMoveOutReqOut = (Outputs.SendPartialMoveOutReqOut) tcsMethod.sendTCSReq(TCSReqEnum.sendPartialMoveOutReq, sendPartialMoveOutReqIn);
        }
        int size = 0;
        if (sendPartialMoveOutReqOut != null) {
            size = CimArrayUtils.getSize(sendPartialMoveOutReqOut.getPartialMoveOutReqResult().getPartialOpeCompLotList());
        }
        for (int iCnt1 = 0; iCnt1 < size; iCnt1++) {
            Validations.check(!CimStringUtils.equals(BizConstant.SP_ACTIONRESULT_OK, sendPartialMoveOutReqOut.getPartialMoveOutReqResult().getPartialOpeCompLotList().get(iCnt1).getActionCode()), retCodeConfigEx.getRequestRejectByTcs());
        }
        // Merge result from TCS
        List<Infos.PartialOpeCompLot> tmpPartialOpeCompLotSeq = null;
        if (null != sendPartialMoveOutReqOut && null != sendPartialMoveOutReqOut.getPartialMoveOutReqResult()) {
            tmpPartialOpeCompLotSeq = sendPartialMoveOutReqOut.getPartialMoveOutReqResult().getPartialOpeCompLotList();
        }
        for (int i = 0; i < CimArrayUtils.getSize(partialOpeCompLotList); i++) {
            for (int j = 0; j < CimArrayUtils.getSize(tmpPartialOpeCompLotSeq); j++) {
                if (CimObjectUtils.equalsWithValue(partialOpeCompLotList.get(i).getLotID(), tmpPartialOpeCompLotSeq.get(j).getLotID())) {
                    log.info("Found the Lot, set actionResult ");
                    //found the lot
                    partialOpeCompLotList.get(i).setActionResult(tmpPartialOpeCompLotSeq.get(j).getActionResult());
                    break;
                }
            }
        }
        partialMoveOutReqResult.setPartialOpeCompLotList(partialOpeCompLotList);
        List<Infos.ApcBaseCassette> strAPCBaseCassetteListForOpeComp = new ArrayList<>();
        List<Infos.ApcBaseCassette> strAPCBaseCassetteListForOpeStartCancel = new ArrayList<>();
        // Get updated controlJob information
        Inputs.ControlJobStartLotWaferInfoGetIn controlJobStartLotWaferInfoGetIn2 = new Inputs.ControlJobStartLotWaferInfoGetIn();
        controlJobStartLotWaferInfoGetIn2.setControlJobID(controlJobID);
        controlJobStartLotWaferInfoGetIn2.setStartLotOnlyFlag(true);
        log.info("Step25 - controlJob_startLotWaferInfo_Get");
        Infos.ControlJobInformation objControlJobStartLotWaferInfoGetOutResult2 = controlJobMethod.controlJobStartLotWaferInfoGet(objCommon, controlJobStartLotWaferInfoGetIn2);

        // For OpeComp and OpeCompWithHold Lot
        //     A.   Update controlJob information with involved lots
        //     B.   Call txMoveOutReq (txMoveOutForIBReq)

        // Create OpeComp and OpeCompWithHold Lot list => opeCompLotInfoList
        List<Infos.PartialOpeCompLot> partialOpeCompLotSeqForOpeComp = new ArrayList<>();
        for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
            if (CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)
                    || CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD)) {
                partialOpeCompLotSeqForOpeComp.add(partialOpeCompLot);
            }
        }
        if (!CimObjectUtils.isEmpty(partialOpeCompLotSeqForOpeComp)) {
            log.info("Step26 - controlJob_updateForPartialOpeComp");
            controlJobMethod.controlJobUpdateForPartialOpeComp(objCommon, objControlJobStartLotWaferInfoGetOutResult2, partialOpeCompLotSeqForOpeComp);
            Params.OpeComWithDataReqParams opeComWithDataReqParams = new Params.OpeComWithDataReqParams();
            opeComWithDataReqParams.setEquipmentID(equipmentID);
            opeComWithDataReqParams.setControlJobID(controlJobID);
            opeComWithDataReqParams.setSpcResultRequiredFlag(partialMoveOutReqParams.isSpcResultRequiredFlag());
            opeComWithDataReqParams.setOpeMemo(partialMoveOutReqParams.getClaimMemo());
            opeComWithDataReqParams.setApcBaseCassetteListForOpeComp(strAPCBaseCassetteListForOpeComp);

            opeComWithDataReqParams.setApcifControlStatus(APCIFControlStatus);
            opeComWithDataReqParams.setDcsifControlStatus(DCSIFControlStatus);

            log.info("Step27 - txMoveOutReq__120");
            Results.MoveOutReqResult moveOutReqResultRetCode = this.sxMoveOutReq(objCommon, opeComWithDataReqParams);
            partialMoveOutReqResult.setHoldReleasedLotIDs(moveOutReqResultRetCode.getHoldReleasedLotIDs());

            List<Infos.OpeCompLot> operationCompleteLot = moveOutReqResultRetCode.getMoveOutLot();
            for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
                for (Infos.OpeCompLot opeCompLot : operationCompleteLot) {
                    if (CimObjectUtils.equalsWithValue(partialOpeCompLot.getLotID(), opeCompLot.getLotID())) {
                        // found the lot, set result
                        partialOpeCompLot.setLotStatus(opeCompLot.getLotStatus());
                        partialOpeCompLot.setSpecCheckResult(opeCompLot.getSpcCheckResult());
                        partialOpeCompLot.setSpcCheckResult(opeCompLot.getSpcCheckResult());
                        break;
                    }
                }
            }
        }
        // For OpeStartCancel and OpeStartCancelWithHold Lot
        //     A.   Update controlJob information with involved lots
        //     B.   Call txMoveInCancelReq (txMoveInCancelForIBReq)
        List<Infos.PartialOpeCompLot> partialOpeCompLotSeqForOpeStartCancel = new ArrayList<>();
        for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
            if (CimStringUtils.equals(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCEL)
                    || CimStringUtils.equals(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCELWITHHOLD)) {
                partialOpeCompLotSeqForOpeStartCancel.add(partialOpeCompLot);
            }
        }
        if (!CimObjectUtils.isEmpty(partialOpeCompLotSeqForOpeStartCancel)) {
            log.info("Step28 - controlJob_updateForPartialOpeComp");
            controlJobMethod.controlJobUpdateForPartialOpeComp(objCommon, objControlJobStartLotWaferInfoGetOutResult2, partialOpeCompLotSeqForOpeStartCancel);
            log.info("Step29 - txMoveInCancelReq__120");
            this.sxMoveInCancelReq(objCommon, equipmentID, controlJobID, "", strAPCBaseCassetteListForOpeComp, APCIFControlStatus, DCSIFControlStatus);
        }
        // Update controlJob as actual data
        log.info("Step30 - controlJob_updateForPartialOpeComp");
        controlJobMethod.controlJobUpdateForPartialOpeComp(objCommon, objControlJobStartLotWaferInfoGetOutResult2, partialOpeCompLotList);

        // Delete controlJob
        Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
        cjStatusChangeReqParams.setControlJobID(controlJobID);
        cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE);
        cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());
        log.info("Step31 - txCJStatusChangeReq");
        controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);

        // Notify external subsystems (APC)
        //     a.   Notify Conditions (No action needs to be taken if condition does not match)
        //         i.   APC system is configured
        //     b.   Handle Result
        //         i.   If the return code is not RC_OK, MMS should rollback the transaction and return the result to caller.

        //TODO Step32 - APCMgr_SendControlJobInfoForPartialOpeCompDR

        return partialMoveOutReqResult;
    }

    @Deprecated
    @Override
    public Results.PartialMoveOutReqResult sxMoveOutWithRunningSplitForIBReq(Infos.ObjCommon objCommon,
                                                                             Params.PartialMoveOutReqParams partialMoveOutReqParams,
                                                                             String APCIFControlStatus,
                                                                             String DCSIFControlStatus) {
        Results.PartialMoveOutReqResult partialMoveOutReqResult = new Results.PartialMoveOutReqResult();
        ObjectIdentifier equipmentID = partialMoveOutReqParams.getEquipmentID();
        ObjectIdentifier controlJobID = partialMoveOutReqParams.getControlJobID();
        //------------------------------------------------------
        // step1 - Check Function Availability
        //------------------------------------------------------
        log.info("Step1 - Check Function Availability");
        String PJCtrlFunc = StandardProperties.OM_PJ_CONTROL_ENABLE_FLAG.getValue();
        Validations.check(!CimObjectUtils.equalsWithValue(PJCtrlFunc, BizConstant.SP_FUNCTION_AVAILABLE_TRUE), retCodeConfig.getFunctionNotAvailable());
        // step2 - object_lockMode_Get
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        // step3 - advanced_object_Lock
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // step3 - advanced_object_Lock
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            /*--------------------------------*/
            /*   Lock objects to be updated   */
            /*--------------------------------*/
            // step4 - object_Lock
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        // step5 controlJob_startLotWaferInfo_Get
        log.info("Step5 - controlJob_startLotWaferInfo_Get");
        Inputs.ControlJobStartLotWaferInfoGetIn controlJobStartLotWaferInfoGetIn = new Inputs.ControlJobStartLotWaferInfoGetIn();
        controlJobStartLotWaferInfoGetIn.setControlJobID(controlJobID);
        controlJobStartLotWaferInfoGetIn.setStartLotOnlyFlag(false);
        Infos.ControlJobInformation objControlJobStartLotWaferInfoGetOutResult = controlJobMethod.controlJobStartLotWaferInfoGet(objCommon, controlJobStartLotWaferInfoGetIn);

        boolean SLMCapabilityFlag = false;
        /*--------------------------------------*/
        /*   Get SLM Switch for the equipment   */
        /*--------------------------------------*/

        boolean bEquipmentOnLineFlag = true;
        /*--------------------------------*/
        /*   Lock Cassette / Lot Object   */
        /*--------------------------------*/
        List<Infos.ControlJobCassetteInfo> controlJobCassetteInfoList = objControlJobStartLotWaferInfoGetOutResult.getControlJobCassetteInfoList();
        List<Infos.ControlJobCassetteInfo> strControlJobCassetteInfoSeq = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
        List<ObjectIdentifier> orgLotIDs = new ArrayList<>();
        int totalStartWaferCount = 0;
        if (!CimObjectUtils.isEmpty(controlJobCassetteInfoList)) {
            for (Infos.ControlJobCassetteInfo controlJobCassetteInfo : controlJobCassetteInfoList) {
                strControlJobCassetteInfoSeq.add(controlJobCassetteInfo);
                cassetteIDs.add(controlJobCassetteInfo.getCassetteID());
                List<Infos.ControlJobCassetteLot> controlJobCassetteLotList = controlJobCassetteInfo.getControlJobCassetteLotList();
                for (Infos.ControlJobCassetteLot controlJobCassetteLot : controlJobCassetteLotList) {
                    if (!controlJobCassetteLot.isOperationStartFlag()) {
                        continue;
                    }
                    boolean bLotFoundFlag = false;
                    for (ObjectIdentifier orgLotID : orgLotIDs) {
                        if (CimObjectUtils.equalsWithValue(controlJobCassetteLot.getLotID(), orgLotID)) {
                            bLotFoundFlag = true;
                        }
                    }
                    if (!bLotFoundFlag) {
                        orgLotIDs.add(controlJobCassetteLot.getLotID());
                        totalStartWaferCount = totalStartWaferCount + CimArrayUtils.getSize(controlJobCassetteLot.getWaferIDs());
                    }
                }
            }
        }
        partialMoveOutReqResult.setEquipmentID(equipmentID);
        partialMoveOutReqResult.setControlJobID(controlJobID);
        // Step8 - equipment_onlineMode_Get

        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.info("lockMode != SP_EQP_LOCK_MODE_WRITE");
            // Step8 - equipment_onlineMode_Get
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                // Step9 - advanced_object_Lock
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            // Lock eqp ProcLot Element
            // Step10 - advanced_object_Lock
            List<String> procLotSeq = orgLotIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, procLotSeq));
            // Lock Equipment LoadCassette Element (Write)
            List<String> loadCastSeq = cassetteIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            if (!CimArrayUtils.isEmpty(loadCastSeq)) {
                // Step11 - advanced_object_Lock
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, loadCastSeq));
            }
            for (int ij = 0; ij < CimArrayUtils.getSize(controlJobCassetteInfoList); ij++) {
                Inputs.ObjAdvancedObjectLockForEquipmentResourceIn strAdvanced_object_LockForEquipmentResource_in = new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
                strAdvanced_object_LockForEquipmentResource_in.setEquipmentID(equipmentID);
                strAdvanced_object_LockForEquipmentResource_in.setClassName(BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCJ);
                strAdvanced_object_LockForEquipmentResource_in.setObjectID(controlJobID);
                strAdvanced_object_LockForEquipmentResource_in.setObjectLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
                strAdvanced_object_LockForEquipmentResource_in.setBufferResourceName(controlJobCassetteInfoList.get(ij).getLoadPurposeType());
                strAdvanced_object_LockForEquipmentResource_in.setBufferResourceLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);

                log.info("calling advanced_object_LockForEquipmentResource() : {}", BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCJ);
                objectLockMethod.advancedObjectLockForEquipmentResource(objCommon, strAdvanced_object_LockForEquipmentResource_in);
            }
            //*------------------------------*//
            //*   Lock controljob Object     *//
            //*------------------------------*//
            // Step12 - object_Lock
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
        }
        /*------------------------------*/
        /*   Lock cassette/lot Object   */
        /*------------------------------*/
        // Step13 - objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);
        // step14 - objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, orgLotIDs);

        //------------------------------------------------------
        // Check Equipment
        //------------------------------------------------------
        // The "PJ Level Control Flag" of the equipment should be "True"
        // Equipment online mode should be "On-Line Remote"
        // Multiple recipe capability of the equipment should be "MultipleRecipe"
        log.info("Step15 - equipment_processJobLevelControlCheck");
        try {
            equipmentMethod.equipmentProcessJobLevelControlCheck(objCommon, equipmentID, true, true, true, false);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getEqpOnlineMode(), e.getCode())) {
                bEquipmentOnLineFlag = false;
            } else {
                throw e;
            }
        }

        // Check Actions
        //     Action should be one of the followings
        //         a.   SP_PartialOpeComp_Action_OpeComp
        //         b.   SP_PartialOpeComp_Action_OpeCompWithHold
        //         c.   SP_PartialOpeComp_Action_OpeStartCancel
        //         d.   SP_PartialOpeComp_Action_OpeStartCancelWithHold
        List<Infos.PartialOpeCompAction> partialOpeCompActionList = partialMoveOutReqParams.getPartialOpeCompActionList();
        log.info("Step16 - Check Actions");
        for (Infos.PartialOpeCompAction partialOpeCompAction : partialOpeCompActionList) {
            if (!CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)
                    && !CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD)
                    && !CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCEL)
                    && !CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCELWITHHOLD)) {
                throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(), "Invalid Action Code"));
            }
        }
        // Check controlJob status if equipment is Online
        //   controlJob should be "Executing"
        log.info("Step17 - equipment_onlineMode_Get");
        String operationMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
        if (!CimObjectUtils.equalsWithValue(operationMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
            Outputs.ObjControlJobStatusGetOut controlJobStatusResult = controlJobMethod.controlJobStatusGet(objCommon, controlJobID);
            // Check ControlJob Status
            if (!CimObjectUtils.equalsWithValue(controlJobStatusResult.getControlJobStatus(), BizConstant.SP_CONTROLJOBSTATUS_EXECUTING)) {
                throw new ServiceException(new OmCode(retCodeConfigEx.getInvalidCjstatus(), controlJobStatusResult.getControlJobStatus()));
            }
        }
        // Check waferIDs
        // All specified waferIDs should be inside the start lot of the controlJob.
        log.info("Step18 - Check waferIDs");
        int requestedWaferCount = 0;
        for (Infos.PartialOpeCompAction partialOpeCompAction : partialOpeCompActionList) {
            requestedWaferCount = requestedWaferCount + CimArrayUtils.getSize(partialOpeCompAction.getWaferIDs());
        }
        // Get waferID from controlJob
        if (requestedWaferCount != totalStartWaferCount) {
            // request wafer count is not correct
            throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(), "All started lot wafer should be selected"));
        }
        // All wafers in start lot should be specified in input waferIDs (including non-sampled wafers).
        // Create result structure
        List<Infos.PartialOpeCompLot> partialOpeCompLotList = new ArrayList<>();
        for (Infos.PartialOpeCompAction partialOpeCompAction : partialOpeCompActionList) {
            List<ObjectIdentifier> waferIDs = partialOpeCompAction.getWaferIDs();
            for (ObjectIdentifier tmpWaferID : waferIDs) {
                boolean bFoundWaferFlag = false;
                for (Infos.ControlJobCassetteInfo controlJobCassetteInfo : controlJobCassetteInfoList) {
                    List<Infos.ControlJobCassetteLot> controlJobCassetteLotList = controlJobCassetteInfo.getControlJobCassetteLotList();
                    for (Infos.ControlJobCassetteLot controlJobCassetteLot : controlJobCassetteLotList) {
                        if (!controlJobCassetteLot.isOperationStartFlag()) {
                            continue;
                        }
                        for (ObjectIdentifier waferID : controlJobCassetteLot.getWaferIDs()) {
                            if (CimObjectUtils.equalsWithValue(tmpWaferID, waferID)) {
                                bFoundWaferFlag = true;
                                // found the wafer
                                ObjectIdentifier tmpLotID = controlJobCassetteLot.getLotID();
                                // find tmpLotID in strPartialOpeCompLotSeq
                                boolean bFoundCompLotFlag = false;
                                for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
                                    if (CimObjectUtils.equalsWithValue(tmpLotID, partialOpeCompLot.getLotID())) {
                                        // Check if action is the same
                                        if (CimObjectUtils.equalsWithValue(partialOpeCompAction.getActionCode(), partialOpeCompLot.getActionCode())) {
                                            // add this wafer to the lot
                                            List<ObjectIdentifier> waferIDs2 = partialOpeCompLot.getWaferIDs();
                                            waferIDs2.add(tmpWaferID);
                                            bFoundCompLotFlag = true;
                                            break;
                                        }
                                        continue;
                                    }
                                }
                                if (!bFoundCompLotFlag) {
                                    // create this lot to new strPartialOpeCompLotSeq
                                    Infos.PartialOpeCompLot partialOpeCompLot = new Infos.PartialOpeCompLot();
                                    partialOpeCompLot.setLotID(tmpLotID);
                                    partialOpeCompLot.setActionCode(partialOpeCompAction.getActionCode());
                                    List<ObjectIdentifier> waferIDs3 = new ArrayList<>();
                                    waferIDs3.add(tmpWaferID);
                                    partialOpeCompLot.setWaferIDs(waferIDs3);
                                    partialOpeCompLotList.add(partialOpeCompLot);
                                }
                                break;
                            }
                        }
                        if (bFoundWaferFlag) {
                            break;
                        }
                    }
                    if (bFoundWaferFlag) {
                        break;
                    }
                }
                if (!bFoundWaferFlag) {
                    throw new ServiceException(new OmCode(retCodeConfig.getInvalidParameterWithMsg(), "tmpWaferID is not found"));
                }
            }

        }

        //  Lot needs to be split if wafers within the lot are selected for different actions
        for (ObjectIdentifier orgLotID : orgLotIDs) {
            List<String> actionCodes = new ArrayList<>();
            for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
                if (CimObjectUtils.equalsWithValue(orgLotID, partialOpeCompLot.getLotID())) {
                    actionCodes.add(partialOpeCompLot.getActionCode());
                }
            }
            if (CimArrayUtils.getSize(actionCodes) > 1) {
                // This lot need to split
                //  Decide parent Lot: Parent lot should be decided from following priorities. If wafer sampling is used, non-sampled wafers should be in the same lot
                //      a.   OpeComp lot
                //      b.   OpeCompWithHold Lot
                //      c.   OpeStartCancel Lot
                //      d.   OpeStartCancelWithHold Lot
                boolean bParentLotFoundFlag = false;
                String parentLotActionCode = null;
                // First look for OpeComp lot
                for (String actionCode : actionCodes) {
                    if (CimObjectUtils.equalsWithValue(actionCode, BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)) {
                        bParentLotFoundFlag = true;
                        parentLotActionCode = actionCode;
                        break;
                    }
                }
                if (!bParentLotFoundFlag) {
                    for (String actionCode : actionCodes) {
                        if (CimObjectUtils.equalsWithValue(actionCode, BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)) {
                            // Parent lot found
                            bParentLotFoundFlag = true;
                            parentLotActionCode = actionCode;
                            break;
                        }
                    }
                }
                if (!bParentLotFoundFlag) {
                    // Continue to look for OpeCompWithHold Lot
                    for (String actionCode : actionCodes) {
                        if (CimObjectUtils.equalsWithValue(actionCode, BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD)) {
                            // Parent lot found
                            bParentLotFoundFlag = true;
                            parentLotActionCode = actionCode;
                            break;
                        }
                    }
                }
                if (!bParentLotFoundFlag) {
                    // Continue to look for OpeStartCancel Lot
                    for (String actionCode : actionCodes) {
                        if (CimObjectUtils.equalsWithValue(actionCode, BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCEL)) {
                            // Parent lot found
                            bParentLotFoundFlag = true;
                            parentLotActionCode = actionCode;
                            break;
                        }
                    }
                }
                for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
                    if (CimObjectUtils.equalsWithValue(orgLotID, partialOpeCompLot.getLotID())) {
                        if (CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), parentLotActionCode)) {
                            // Skip the parent lot
                            continue;
                        } else {
                            // split lot
                            Params.SplitLotReqParams splitLotReqParams = new Params.SplitLotReqParams();
                            splitLotReqParams.setParentLotID(orgLotID);
                            splitLotReqParams.setChildWaferIDs(partialOpeCompLot.getWaferIDs());
                            splitLotReqParams.setFutureMergeFlag(false);
                            splitLotReqParams.setMergedRouteID(new ObjectIdentifier());
                            splitLotReqParams.setMergedOperationNumber("");
                            splitLotReqParams.setBranchingRouteSpecifyFlag(false);
                            splitLotReqParams.setSubRouteID(new ObjectIdentifier());
                            splitLotReqParams.setReturnOperationNumber("");
                            log.info("Step20 - txSplitLotReq");
                            Results.SplitLotReqResult splitLotReqResultRetCode = lotService.sxSplitLotReq(objCommon, splitLotReqParams);

                            partialOpeCompLot.setLotID(splitLotReqResultRetCode.getChildLotID());
                            // Transfer following PO data from parent lot to child lot by waferID if child lot is going to perform opeComp
                            //     a.   Wafer chamber process
                            //     b.   Inside Chamber wafer position
                            //     c.   Processed wafers (Sampling wafers)
                            //     d.   Assigned Recipe parameters
                            //     e.   Collected data
                            //     f.   Assigned reticles
                            //     g.   Assigned fixtures
                            // Copy following PO data from parent PO to child lot
                            //     a.   Assigned equipment
                            //     b.   Assigned port group
                            //     c.   Assigned logical recipe
                            //     d.   Assigned recipe
                            //     e.   Assigned physical recipe
                            //     f.   Assigned recipe parameter change type
                            //     g.   Assigned dc flag
                            log.info("Step21 - lot_processOperationData_transferInProcessing");
                            lotMethod.lotProcessOperationDataTransferInProcessing(objCommon, orgLotID, partialOpeCompLot.getLotID());

                            if (CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)
                                    || CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD)) {
                                // Copy schedule change reservation information to child lot for OpeComp and OpeCompWithHold lot
                                //     A.   Get schedule change reservation (object type = Lot) of the original lot (parent lot = opeComp lot)
                                //     B.   Copy the schedule change reservation to newly created child lots
                                Params.LotPlanChangeReserveListInqParams params = new Params.LotPlanChangeReserveListInqParams();
                                params.setObjectID(orgLotID.getValue());
                                params.setObjectType(BizConstant.SP_SCHDL_CHG_OBJTYPE_LOT);
                                params.setLotInfoChangeFlag(0);
                                log.info("Step22 - txLotPlanChangeReserveListInq__110");
                                Results.LotPlanChangeReserveListInqResult lotPlanChangeReserveListInqResult = planInqService.sxLotPlanChangeReserveListInq(objCommon, params);
                                List<Infos.SchdlChangeReservation> schdlChangeReservationList = lotPlanChangeReserveListInqResult.getSchdlChangeReservations();
                                if (!CimObjectUtils.isEmpty(schdlChangeReservationList)) {
                                    for (Infos.SchdlChangeReservation schdlChangeReservation : schdlChangeReservationList) {
                                        log.info("Step23 - txLotPlanChangeReserveCreateReq__110");
                                        planService.sxLotPlanChangeReserveCreateReq(objCommon, schdlChangeReservation, "");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // Notify external subsystems (EAP)
        //     a.   Notify Conditions (No action needs to be taken if condition does not match)
        //         i.   Equipment should be under manual Comp mode
        //     b.   Handle Result
        //         i.   If returned "actionResult" is not "SP_ActionResult_OK", MMS should rollback the transaction and return the result to caller.
        Outputs.SendPartialMoveOutReqOut sendPartialMoveOutReqOut = null;
        if (bEquipmentOnLineFlag) {
            //step24 - TCSMgr_SendPartialMoveOutForIBReq
            Inputs.SendPartialMoveOutReqIn sendPartialMoveOutReqIn = new Inputs.SendPartialMoveOutReqIn();
            sendPartialMoveOutReqIn.setEquipmentID(equipmentID);
            sendPartialMoveOutReqIn.setObjCommonIn(objCommon);
            sendPartialMoveOutReqIn.setControlJobID(controlJobID);
            sendPartialMoveOutReqIn.setStrPartialOpeCompLotSeq(partialOpeCompLotList);
            sendPartialMoveOutReqOut = (Outputs.SendPartialMoveOutReqOut) tcsMethod.sendTCSReq(TCSReqEnum.sendPartialMoveOutForInternalBufferReq, sendPartialMoveOutReqIn);
        }
        int size = CimObjectUtils.isEmpty(sendPartialMoveOutReqOut) || CimObjectUtils.isEmpty(sendPartialMoveOutReqOut.getPartialMoveOutReqResult()) ? 0 : CimArrayUtils.getSize(sendPartialMoveOutReqOut.getPartialMoveOutReqResult().getPartialOpeCompLotList());
        for (int iCnt1 = 0; iCnt1 < size; iCnt1++) {
            Validations.check(!CimStringUtils.equals(BizConstant.SP_ACTIONRESULT_OK, sendPartialMoveOutReqOut.getPartialMoveOutReqResult().getPartialOpeCompLotList().get(iCnt1).getActionCode()), retCodeConfigEx.getRequestRejectByTcs());
        }

        List<Infos.PartialOpeCompLot> tmpPartialOpeCompLotSeq = null;
        // Merge result from EAP
        if (null != sendPartialMoveOutReqOut && null != sendPartialMoveOutReqOut.getPartialMoveOutReqResult()) {
            tmpPartialOpeCompLotSeq = sendPartialMoveOutReqOut.getPartialMoveOutReqResult().getPartialOpeCompLotList();
        }

        for (int i = 0; i < CimArrayUtils.getSize(partialOpeCompLotList); i++) {
            for (int j = 0; j < CimArrayUtils.getSize(tmpPartialOpeCompLotSeq); j++) {
                if (CimObjectUtils.equalsWithValue(partialOpeCompLotList.get(i).getLotID(), tmpPartialOpeCompLotSeq.get(j).getLotID())) {
                    log.info("Found the Lot, set actionResult ");
                    //found the lot
                    partialOpeCompLotList.get(i).setActionResult(tmpPartialOpeCompLotSeq.get(j).getActionResult());
                    break;
                }
            }
        }


        partialMoveOutReqResult.setPartialOpeCompLotList(partialOpeCompLotList);
        List<Infos.ApcBaseCassette> strAPCBaseCassetteListForOpeComp = new ArrayList<>();
        List<Infos.ApcBaseCassette> strAPCBaseCassetteListForOpeStartCancel = new ArrayList<>();
        // Get updated controlJob information
        Inputs.ControlJobStartLotWaferInfoGetIn controlJobStartLotWaferInfoGetIn2 = new Inputs.ControlJobStartLotWaferInfoGetIn();
        controlJobStartLotWaferInfoGetIn2.setControlJobID(controlJobID);
        controlJobStartLotWaferInfoGetIn2.setStartLotOnlyFlag(true);
        log.info("Step25 - controlJob_startLotWaferInfo_Get");
        Infos.ControlJobInformation objControlJobStartLotWaferInfoGetOutResult2 = controlJobMethod.controlJobStartLotWaferInfoGet(objCommon, controlJobStartLotWaferInfoGetIn2);

        // For OpeComp and OpeCompWithHold Lot
        //     A.   Update controlJob information with involved lots
        //     B.   Call txMoveOutReq (txMoveOutForIBReq)

        // Create OpeComp and OpeCompWithHold Lot list => opeCompLotInfoList
        List<Infos.PartialOpeCompLot> partialOpeCompLotSeqForOpeComp = new ArrayList<>();
        for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
            if (CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMP)
                    || CimObjectUtils.equalsWithValue(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPECOMPWITHHOLD)) {
                partialOpeCompLotSeqForOpeComp.add(partialOpeCompLot);
            }
        }
        if (!CimObjectUtils.isEmpty(partialOpeCompLotSeqForOpeComp)) {
            log.info("Step26 - controlJob_updateForPartialOpeComp");
            controlJobMethod.controlJobUpdateForPartialOpeComp(objCommon, objControlJobStartLotWaferInfoGetOutResult2, partialOpeCompLotSeqForOpeComp);

            Params.MoveOutForIBReqParams opeComWithDataReqParams = new Params.MoveOutForIBReqParams();
            opeComWithDataReqParams.setEquipmentID(equipmentID);
            opeComWithDataReqParams.setControlJobID(controlJobID);
            opeComWithDataReqParams.setSpcResultRequiredFlag(partialMoveOutReqParams.isSpcResultRequiredFlag());
            opeComWithDataReqParams.setOpeMemo(partialMoveOutReqParams.getClaimMemo());

            /*Params.MoveOutForIBReqExtraParams moveOutForIBReqExtraParams = new Params.MoveOutForIBReqExtraParams();
            moveOutForIBReqExtraParams.setHoldReleasedLotIDs(holdReleasedLotIDs);
            moveOutForIBReqExtraParams.setApcBaseCassetteList(strAPCBaseCassetteListForOpeComp);
            moveOutForIBReqExtraParams.setApcifControlStatus(APCIFControlStatus);
            moveOutForIBReqExtraParams.setDcsifControlStatus(DCSIFControlStatus);*/
            log.info("Step27 - txMoveOutReq__120");
            final Results.MoveOutReqResult moveOutReqResult = equipmentProcessOperation.sxMoveOutForIBReq(objCommon, opeComWithDataReqParams);
            List<Infos.OpeCompLot> operationCompleteLot = moveOutReqResult.getMoveOutLot();
            for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
                for (Infos.OpeCompLot opeCompLot : operationCompleteLot) {
                    if (CimObjectUtils.equalsWithValue(partialOpeCompLot.getLotID(), opeCompLot.getLotID())) {
                        // found the lot, set result
                        partialOpeCompLot.setLotStatus(opeCompLot.getLotStatus());
                        partialOpeCompLot.setSpecCheckResult(opeCompLot.getSpcCheckResult());
                        partialOpeCompLot.setSpcCheckResult(opeCompLot.getSpcCheckResult());
                        break;
                    }
                }
            }
        }

        // For OpeStartCancel and OpeStartCancelWithHold Lot
        //     A.   Update controlJob information with involved lots
        //     B.   Call txMoveInCancelReq (txMoveInCancelForIBReq)
        List<Infos.PartialOpeCompLot> partialOpeCompLotSeqForOpeStartCancel = new ArrayList<>();
        for (Infos.PartialOpeCompLot partialOpeCompLot : partialOpeCompLotList) {
            if (CimStringUtils.equals(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCEL)
                    || CimStringUtils.equals(partialOpeCompLot.getActionCode(), BizConstant.SP_PARTIALOPECOMP_ACTION_OPESTARTCANCELWITHHOLD)) {
                partialOpeCompLotSeqForOpeStartCancel.add(partialOpeCompLot);
            }
        }
        if (!CimObjectUtils.isEmpty(partialOpeCompLotSeqForOpeStartCancel)) {
            log.info("Step28 - controlJob_updateForPartialOpeComp");
            controlJobMethod.controlJobUpdateForPartialOpeComp(objCommon, objControlJobStartLotWaferInfoGetOutResult2, partialOpeCompLotSeqForOpeStartCancel);
            log.info("Step29 - txMoveInCancelReq__120");
            this.sxMoveInCancelForIBReq(objCommon, equipmentID, controlJobID, strAPCBaseCassetteListForOpeComp, APCIFControlStatus, DCSIFControlStatus);
        }
        // Update controlJob as actual data
        log.info("Step30 - controlJob_updateForPartialOpeComp");
        controlJobMethod.controlJobUpdateForPartialOpeComp(objCommon, objControlJobStartLotWaferInfoGetOutResult2, partialOpeCompLotList);

        // Delete controlJob
        Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
        cjStatusChangeReqParams.setControlJobID(controlJobID);
        cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE);
        cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());
        log.info("Step31 - txCJStatusChangeReq");
        controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);

        // Notify external subsystems (APC)
        //     a.   Notify Conditions (No action needs to be taken if condition does not match)
        //         i.   APC system is configured
        //     b.   Handle Result
        //         i.   If the return code is not RC_OK, MMS should rollback the transaction and return the result to caller.

        //TODO Step32 - APCMgr_SendControlJobInfoForPartialOpeCompDR

        return partialMoveOutReqResult;
    }

    @Override
    public void sxEqpBufferTypeModifyReq(Infos.ObjCommon objCommon, Params.EqpBufferTypeModifyReqInParm params) {
        //------------------------------------
        //  In-Parameter Trace
        //------------------------------------
        log.debug("step1 - In-Parameter Trace");
        ObjectIdentifier equipmentID = params.getEquipmentID();
        List<Infos.BufferResourceUpdateInfo> strBufferResourceUpdateInfoSeq = params.getStrBufferResourceUpdateInfoSeq();
        int lenBufferResource = CimArrayUtils.getSize(strBufferResourceUpdateInfoSeq);
        Validations.check(lenBufferResource <= 0, retCodeConfig.getInvalidInputParam());
        //------------------------------------
        //  Object Lock Process
        //------------------------------------
        log.debug("step2 - Object Lock Process");
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.EQP_BUFFER_RRESOURCE_TYPE_CHANGE_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);

        log.debug("step3 - get mode lock");
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        log.trace("lockMode is 【{}】",lockMode);
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!BizConstant.SP_EQP_LOCK_MODE_WRITE.equals(lockMode)) {
            log.debug("step4 - Lock eqp Main Object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            log.debug("step5 - Machine Object Lock Process");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        //--------------------------------------------------
        // Lock buffer category for update
        //--------------------------------------------------
        for (int i = 0; i < lenBufferResource; i++) {
            String bufferCategory = params.getStrBufferResourceUpdateInfoSeq().get(i).getBufferCategory();
            long newCapacity = params.getStrBufferResourceUpdateInfoSeq().get(i).getNewCapacity();
            long smCapacity = params.getStrBufferResourceUpdateInfoSeq().get(i).getSmCapacity();
            long dynCapacity = params.getStrBufferResourceUpdateInfoSeq().get(i).getDynamicCapacity();
            log.trace("bufferCategory is 【{}】",bufferCategory);
            if (!CimStringUtils.equals(bufferCategory, BizConstant.SP_BUFFERCATEGORY_ANYPROCESSLOT)
                    || newCapacity != smCapacity + dynCapacity) {
                ObjectIdentifier objectID = new ObjectIdentifier(bufferCategory);

                log.debug("step6 - lock equipment resource");
                objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, objectID, BizConstant.SP_CLASSNAME_POSMATERIALLOCATION);
            }
        }
        //--------------------------------------------------
        // Call obj to change resource types
        //--------------------------------------------------
        Inputs.ObjEquipmentBufferResourceTypeChangeIn strEquipmentBufferResourceTypeChangeIn = new Inputs.ObjEquipmentBufferResourceTypeChangeIn();
        strEquipmentBufferResourceTypeChangeIn.setEquipmentID(equipmentID);
        strEquipmentBufferResourceTypeChangeIn.setStrBufferResourceUpdateInfoSeq(params.getStrBufferResourceUpdateInfoSeq());

        log.debug("step7 - change equipment buffer resource type");
        equipmentMethod.equipmentBufferResourceTypeChange(objCommon, strEquipmentBufferResourceTypeChangeIn);

        //--------------------------------------------------
        // Create Event
        //--------------------------------------------------

        log.debug("step8 - create event");
        Inputs.EquipmentBufferResourceTypeChangeEventMakeParams eventMakeParams = new Inputs.EquipmentBufferResourceTypeChangeEventMakeParams();
        eventMakeParams.setClaimMemo(params.getClaimMemo());
        eventMakeParams.setEquipmentID(equipmentID);
        eventMakeParams.setBufferResourceUpdateInfoList(params.getStrBufferResourceUpdateInfoSeq());
        eventMethod.equipmentBufferResourceTypeChangeEventMake(objCommon, eventMakeParams);
    }

    @Override
    public void sxReserveUnloadingLotsForIBRpt(Infos.ObjCommon objCommon,
                                               ObjectIdentifier equipmentID,
                                               ObjectIdentifier cassetteID,
                                               ObjectIdentifier unloadReservePortID,
                                               String claimMemo) {
        if (log.isDebugEnabled()){
            log.debug("step1 - Check Transaction ID and equipment Category combination");
        }
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*   Object Lock Process                                                 */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

        if (log.isDebugEnabled()){
            log.debug("step2 - Get required equipment lock mode");
        }
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(
                TransactionIDEnum.UN_LOADING_LOTS_RESERVATION_FOR_INTERNAL_BUFFER_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);

        Long lockMode = objLockModeOut.getLockMode();
        if (log.isTraceEnabled()){
            log.trace("lockMode is 【{}】",lockMode);
        }
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            if (log.isDebugEnabled()){
                log.debug("step3 - Lock Equipment Main Object");
            }
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
            if (log.isDebugEnabled()){
                log.debug("step4 - Lock the target portID only");
            }
            objectLockMethod.objectLockForEquipmentResource(objCommon,
                    equipmentID,
                    unloadReservePortID,
                    BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            if (log.isTraceEnabled()){
                log.trace("Locked port object : {}", unloadReservePortID);
            }
        } else {
            /*--------------------------------*/
            /*   Lock objects to be updated   */
            /*--------------------------------*/
            if (log.isDebugEnabled()){
                log.debug("ste5 - Lock objects to be updated");
            }
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        if (log.isDebugEnabled()){
            log.debug("step6 - Lock Port Object for internal Buffer Equipment only");
        }
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon, equipmentID);
        List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo.getEqpPortStatuses();
        for (Infos.EqpPortStatus eqpPortStatus : eqpPortStatuses) {
            if (log.isTraceEnabled()){
                log.trace("lockMode is 【{}】",lockMode);
            }
            if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
                if (log.isDebugEnabled()){
                    log.debug("lockMode != SP_EQP_LOCK_MODE_WRITE");
                }

                if (log.isDebugEnabled()){
                    log.debug("step7 - lock advance for equipment resource");
                }
                if (ObjectIdentifier.equalsWithValue(eqpPortStatus.getPortID(), unloadReservePortID)) {
                    Inputs.ObjAdvancedObjectLockForEquipmentResourceIn advancedObjectLockForEquipmentResourceIn =
                            new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
                    advancedObjectLockForEquipmentResourceIn.setEquipmentID(equipmentID);
                    advancedObjectLockForEquipmentResourceIn.setClassName(
                            BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCASTID);
                    advancedObjectLockForEquipmentResourceIn.setObjectID(cassetteID);
                    advancedObjectLockForEquipmentResourceIn.setObjectLockType(
                            BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
                    advancedObjectLockForEquipmentResourceIn.setBufferResourceName("");
                    advancedObjectLockForEquipmentResourceIn.setBufferResourceLockType(
                            BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);
                    objectLockMethod.advancedObjectLockForEquipmentResource(objCommon,
                            advancedObjectLockForEquipmentResourceIn);
                    break;
                }
            } else {
                if (log.isDebugEnabled()){
                    log.debug("step8 - lock equipment resource");
                }
                objectLockMethod.objectLockForEquipmentResource(objCommon,
                        equipmentID,
                        eqpPortStatus.getPortID(),
                        BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
                if (log.isTraceEnabled()){
                    log.trace("Locked port object : {}", eqpPortStatus.getPortID());
                }
            }
        }
        if (log.isDebugEnabled()){
            log.debug("step9 - lock cassette 【{}】",cassetteID);
        }
        objectLockMethod.objectLock(objCommon, CimCassette.class, cassetteID);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*   Check Process                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*---------------------------------*/
        /*   Check   ControlJobID          */
        /*---------------------------------*/
        if (log.isDebugEnabled()){
            log.debug("step10 - get cassette control job");
        }
        ObjectIdentifier controlJobID = cassetteMethod.cassetteControlJobIDGet(objCommon, cassetteID);
        Validations.check(!ObjectIdentifier.isEmpty(controlJobID), retCodeConfig.getNotClearedControlJob());

        /*----------------------------------*/
        /*   Get Eqp Internal Buffer Info   */
        /*----------------------------------*/
        if (log.isDebugEnabled()){
            log.debug("step11 - Get Eqp Internal Buffer Info");
        }
        List<Infos.EqpInternalBufferInfo> eqpInternalBufferInfos = equipmentMethod.equipmentInternalBufferInfoGet(
                objCommon, equipmentID);

        /*-----------------------------------*/
        /*   Check UnlodingLotsReservation   */
        /*-----------------------------------*/
        if (log.isDebugEnabled()){
            log.debug("step12 - Check UnlodingLotsReservation");
        }
        equipmentMethod.equipmentCheckConditionForUnloadingForInternalBuffer(objCommon,
                eqpInternalBufferInfos,
                equipmentID,
                cassetteID,
                unloadReservePortID);

        /*------------------------*/
        /*   reserve unloadPort   */
        /*------------------------*/
        if (log.isDebugEnabled()){
            log.debug("step13 - reservation equipment unloading lot for internal buffer");
        }
        equipmentMethod.equipmentUnloadingLotsReservationForInternalBuffer(objCommon,
                equipmentID,
                cassetteID,
                unloadReservePortID);
    }

    @Override
    public void sxReserveCancelUnloadingLotsForIBReq(Infos.ObjCommon objCommon,
                                                     ObjectIdentifier equipmentID,
                                                     ObjectIdentifier cassetteID) {
        if (log.isDebugEnabled()){
            log.debug("step1 -Get required equipment lock mode");
        }
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.
                UN_LOADING_LOTS_RESERVATION_CANCEL_FOR_INTERNAL_BUFFER_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);

        Long lockMode = objLockModeOut.getLockMode();
        if (log.isTraceEnabled()){
            log.trace("lockMode is 【{}】",lockMode);
        }
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            if (log.isDebugEnabled()){
                log.debug("step2 - Lock Equipment Main Object");
            }
            Inputs.ObjAdvanceLockIn objAdvanceLockIn = new Inputs.ObjAdvanceLockIn();
            objAdvanceLockIn.setObjectID(equipmentID);
            objAdvanceLockIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            objAdvanceLockIn.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            objAdvanceLockIn.setLockType(objLockModeOut.getRequiredLockForMainObject());
            objAdvanceLockIn.setKeyList(new ArrayList<>());
            objectLockMethod.advancedObjectLock(objCommon, objAdvanceLockIn);

            if (log.isDebugEnabled()){
                log.debug("step3 - Lock Material Location");
            }
            Inputs.ObjAdvancedObjectLockForEquipmentResourceIn advancedObjectLockForEquipmentResourceIn
                    = new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
            advancedObjectLockForEquipmentResourceIn.setEquipmentID(equipmentID);
            advancedObjectLockForEquipmentResourceIn.setClassName(BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCASTID);
            advancedObjectLockForEquipmentResourceIn.setObjectID(cassetteID);
            advancedObjectLockForEquipmentResourceIn.setObjectLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
            advancedObjectLockForEquipmentResourceIn.setBufferResourceName("");
            advancedObjectLockForEquipmentResourceIn.setBufferResourceLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);
            objectLockMethod.advancedObjectLockForEquipmentResource(objCommon, advancedObjectLockForEquipmentResourceIn);
        } else {
            if (log.isTraceEnabled()){
                log.trace("lockMode = SP_EQP_LOCK_MODE_WRITE");
            }
            //--------------------------------
            //   Lock objects to be updated
            //--------------------------------
            if (log.isDebugEnabled()){
                log.debug("step4 - Lock objects to be updated");
            }
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);

            /**********************************************************/
            /*  Lock Port Object for internal Buffer Equipment only.  */
            /**********************************************************/
            if (log.isDebugEnabled()){
                log.debug("step5 - get equipment port info for internal buffer");
            }
            Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon,
                    equipmentID);
            List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo.getEqpPortStatuses();

            if (log.isDebugEnabled()){
                log.debug("step6 - lock equipment resource");
            }
            for (Infos.EqpPortStatus eqpPortStatus : eqpPortStatuses) {
                objectLockMethod.objectLockForEquipmentResource(objCommon,
                        equipmentID,
                        eqpPortStatus.getPortID(),
                        BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
                if (log.isDebugEnabled()){
                    log.debug("Locked port object : {}", eqpPortStatus.getPortID());
                }
            }
        }

        if (log.isDebugEnabled()){
            log.debug("step7 - lock cassette 【{}】",cassetteID);

        }
        objectLockMethod.objectLock(objCommon, CimCassette.class, cassetteID);

        //----------------------------
        //   Check Unloading Reservation
        //----------------------------
        if (log.isDebugEnabled()){
            log.debug("step8 - Check Unloading Reservation");
        }
        equipmentMethod.equipmentCheckConditionForUnloadReserveCancelForInternalBuffer(objCommon,
                equipmentID, cassetteID);

        //----------------------------
        //   Cancel Reservation of unload port
        //----------------------------
        if (log.isDebugEnabled()){
            log.debug("step9 - Cancel Reservation of unload port");
        }
        equipmentMethod.equipmentUnloadingLotsReservationCancelForInternalBuffer(objCommon, equipmentID, cassetteID);

        //--------------------------------------------------------------------------
        //   Get Eqp's Online Mode
        //--------------------------------------------------------------------------
        /*------------------------------------------------------------------------*/
        /*   Send UnloadingLotsReservationCancelReq() to EAP Procedure            */
        /*------------------------------------------------------------------------*/
        if (log.isDebugEnabled()){
            log.debug("/*---------------------------------------------------------------*/");
            log.debug("/*   Send UnloadingLotsReservationCancelReq() to EAP Procedure   */");
            log.debug("/*---------------------------------------------------------------*/");
        }

        //--------------------------------------------------------------------------
        //   Get Eqp's Online Mode
        //   - If Eqp is Offline, EAP rejects "UnloadReserveCancel" request,
        //     So, only when Online case, TCSMgr_SendXxxx should be proceeded.
        //--------------------------------------------------------------------------
        if (log.isDebugEnabled()){
            log.debug("step10 - Get Eqp's Online Mode");
        }
        String onlineModeGet = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
        if (CimStringUtils.equals(onlineModeGet,BizConstant.SP_EQP_ONLINEMODE_OFFLINE)){
            if (log.isDebugEnabled()){
                log.debug("Eqp is now Offline. No need to notify to EAP...");
            }
        }else {
            if (log.isDebugEnabled()) {
                log.debug("step11 - Eqp is now Online. Action is required for EAP...");
            }
            Inputs.SendReserveCancelUnloadingLotsForIBReqIn sendReserveCancelUnloadingLotsForIBReqIn =
                    new Inputs.SendReserveCancelUnloadingLotsForIBReqIn();
            sendReserveCancelUnloadingLotsForIBReqIn.setEquipmentID(equipmentID);
            sendReserveCancelUnloadingLotsForIBReqIn.setCassetteID(cassetteID);
            Long sleepTimeValue = CimStringUtils.isEmpty(StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue()) ?
                    BizConstant.SP_DEFAULT_SLEEP_TIME_TCS :
                    Long.parseLong(StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue());

            Long retryCountValue = CimStringUtils.isEmpty(StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue()) ?
                    BizConstant.SP_DEFAULT_SLEEP_TIME_TCS :
                    Long.parseLong(StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue());


            //QianDao add MES-EAP Integration cassetteChangeFlag
            for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                /*--------------------------*/
                /*    Send Request to EAP   */
                /*--------------------------*/
                IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,
                        objCommon.getUser(), equipmentID, null, false);
                if (null == eapRemoteManager) {
                    if (log.isDebugEnabled()){
                        log.debug("MES not configure EAP host");
                    }
                    break;
                }
                Params.ReserveCancelUnloadingLotsForIBReqParams params =
                        new Params.ReserveCancelUnloadingLotsForIBReqParams();
                params.setUser(objCommon.getUser());
                params.setEquipmentID(equipmentID);
                params.setCarrierID(cassetteID);
                try {
                    Object reserveUnloadCancelOut = eapRemoteManager.sendReserveCancelUnloadingLotsForIBReq(params);
                    break;
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                        if (log.isDebugEnabled()) {
                            log.debug("{}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...",
                                    retryNum);
                            log.debug("{}", "now sleeping... ", sleepTimeValue);
                        }
                        if (retryNum != retryCountValue) {
                            try {
                                Thread.sleep(sleepTimeValue);
                                continue;
                            } catch (InterruptedException e) {
                                ex.addSuppressed(e);
                                Thread.currentThread().interrupt();
                                throw ex;
                            }
                        } else {
                            Validations.check(true, retCodeConfig.getTcsNoResponse());
                        }
                    } else {
                        Validations.check(true, new OmCode(ex.getCode(), ex.getMessage()));
                    }
                }
            }
        }
    }

    @Override
    public void sxChamberWithProcessWaferRpt(Infos.ObjCommon objCommon, Params.ChamberWithProcessWaferRptInParams params) {

        /*-----------------*/
        /*   Initialize    */
        /*-----------------*/
        List<Infos.ChamberProcessLotInfo> strChamberProcessLotInfos = params.getChamberProcessLotInfos();
        ObjectIdentifier equipmentID = params.getEquipmentID();
        ObjectIdentifier controlJobID = params.getControlJobID();

        /*-----------------------------------*/
        /*   Lock Wafer Chamber Reporting    */
        /*-----------------------------------*/
        class TempWaferChamberInfo {
            public ObjectIdentifier lotID;
            public String waferId;
        }
        params.getChamberProcessLotInfos().stream()
                .filter(info -> CimStringUtils.equals(info.getActionCode(), BizConstant.SP_CHAMBERPROCACTIONCODE_PROCESSEND))
                .flatMap(info -> info.getChamberProcessWaferInfos().stream()
                        .map(chamberInfo -> {
                            TempWaferChamberInfo tempInfo = new TempWaferChamberInfo();
                            tempInfo.lotID = info.getLotID();
                            tempInfo.waferId = ObjectIdentifier.fetchValue(chamberInfo.getWaferID());
                            return tempInfo;
                        }))
                .forEach(info ->
                        objectLockMethod.advanceLockChamberForReporting(objCommon, info.lotID, info.waferId)
                );

        /*-----------------------------------------------------------------------------*/
        /*   Get Inprocessing Lots information with using equipmentID.                 */
        /*   Check controlJob of in-parameter is in-processing with equipment or not   */
        /*-----------------------------------------------------------------------------*/
        log.debug("step1 - Get Inprocessing Lots information with using equipmentID.");
        List<Infos.EqpInprocessingControlJob> eqpInprocessingControlJobs = equipmentMethod.equipmentInprocessingControlJobInfoGetDR(objCommon, equipmentID);
        boolean foundFlag = false;
        log.trace("controlJobID.identifier = {}", controlJobID);
        int nLen = CimArrayUtils.getSize(eqpInprocessingControlJobs);
        for (int i = 0; i < nLen; i++) {
            ObjectIdentifier processingControlJob = eqpInprocessingControlJobs.get(i).getControlJobID();
            log.trace("strEqpInprocessingControlJob[n].controlJobID.identifier = {}", processingControlJob);
            if (ObjectIdentifier.equalsWithValue(processingControlJob, controlJobID)) {
                foundFlag = true;
                break;
            }
        }
        log.trace("foundFlag is 【{}】",foundFlag);
        if (CimBooleanUtils.isFalse(foundFlag)) {
            boolean SLMCapabilityFlag = false;
            /*--------------------------------------*/
            /*   Get SLM Switch for the equipment   */
            /*--------------------------------------*/
            log.debug("step2 - get equipment BR info");
            Infos.EqpBrInfo equipmentBRInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentID);

            log.trace("FmcCapabilityFlag is 【{}】",equipmentBRInfo.isFmcCapabilityFlag());
            if (CimBooleanUtils.isTrue(equipmentBRInfo.isFmcCapabilityFlag())) {
                SLMCapabilityFlag = true;
            }

            Validations.check(CimBooleanUtils.isFalse(SLMCapabilityFlag), retCodeConfig.getLotPortControlJobUnMatch());

            return;
        }

        /*-----------------------------------------------------*/
        /*   Check In-parm's Lot and Wafer and Chamber Count   */
        /*-----------------------------------------------------*/
        Validations.check(CimObjectUtils.isEmpty(strChamberProcessLotInfos), retCodeConfig.getInvalidInputParam());

        int lotCount = strChamberProcessLotInfos.size();
        log.trace("LotCount     = {}", lotCount);
        for (int i = 0; i < lotCount; i++) {
            List<Infos.ChamberProcessWaferInfo> strChamberProcessWaferInfos = strChamberProcessLotInfos.get(i).getChamberProcessWaferInfos();
            Validations.check(CimObjectUtils.isEmpty(strChamberProcessWaferInfos), retCodeConfig.getInvalidInputParam());
            int waferCount = CimArrayUtils.getSize(strChamberProcessWaferInfos);
            for (int j = 0; j < waferCount; j++) {
                List<Infos.ProcessedChamberInfo> strProcessedChamberInfos = strChamberProcessWaferInfos.get(j).getProcessedChamberInfos();
                Validations.check(CimObjectUtils.isEmpty(strProcessedChamberInfos), retCodeConfig.getInvalidInputParam());
            }
        }

        /*---------------------------------*/
        /*   Check In-parm's Action Code   */
        /*---------------------------------*/
        String actionCode = strChamberProcessLotInfos.get(0).getActionCode();
        log.trace("ActionCode = {}", actionCode);

        Validations.check(!CimStringUtils.equals(actionCode, BizConstant.SP_CHAMBERPROCACTIONCODE_PROCESSSTART)
                        && !CimStringUtils.equals(actionCode, BizConstant.SP_CHAMBERPROCACTIONCODE_PROCESSEND),
                new OmCode(retCodeConfigEx.getNotValidAct(), actionCode));


        for (int i = 0; i < lotCount; i++) {
            log.trace("actionCode {} {}", i, actionCode);
            if (0 == i) {
                continue;
            }
            Validations.check(!CimStringUtils.equals(strChamberProcessLotInfos.get(i).getActionCode(), actionCode), retCodeConfig.getActionCodeNotSame());
        }

        /*-------------------------------*/
        /*   Get Equipment's ChamberID   */
        /*-------------------------------*/
        log.debug("step3 - Get Equipment's ChamberID");
        Infos.EqpChamberInfo equipmentChamberInfo = equipmentMethod.equipmentChamberInfoGetDR(objCommon, equipmentID);
        List<Infos.EqpChamberStatusInfo> eqpChamberStatuses = equipmentChamberInfo.getEqpChamberStatuses();

        /*-----------------------------------------------*/
        /*   Check Lot's ProcessState and ControlJobID   */
        /*-----------------------------------------------*/
        for (int i = 0; i < lotCount; i++) {
            ObjectIdentifier chamberProcesslotID = strChamberProcessLotInfos.get(i).getLotID();
            log.trace("strChamberProcessLotInfos[i].lotID.identifier = {}", chamberProcesslotID);
            /*----------------------------*/
            /*   Get Lot's ProcessState   */
            /*----------------------------*/
            log.debug("step4 - Get Lot's ProcessState");
            String lotProcessStateGet = lotMethod.lotProcessStateGet(objCommon, chamberProcesslotID);
            Validations.check(!CimStringUtils.equals(lotProcessStateGet, BizConstant.SP_LOT_PROCSTATE_PROCESSING),
                    new OmCode(retCodeConfig.getInvalidLotProcessState(), ObjectIdentifier.fetchValue(chamberProcesslotID), lotProcessStateGet));

            /*----------------------------*/
            /*   Get Lot's ControlJobID   */
            /*----------------------------*/
            log.debug("step5 - Get Lot's ControlJobID");
            ObjectIdentifier lotControlJobID = lotMethod.lotControlJobIDGet(objCommon, chamberProcesslotID);

            log.trace("strLot_controlJobID_Get_out.controlJobID.identifier = {}", lotControlJobID);
            log.trace("controlJobID.identifier = {}", controlJobID);
            if (!ObjectIdentifier.equalsWithValue(lotControlJobID, controlJobID)) {
                throw new ServiceException(new OmCode(retCodeConfig.getControlJobLotUnmatch(), ObjectIdentifier.fetchValue(controlJobID), ObjectIdentifier.fetchValue(chamberProcesslotID)));
            }

            Inputs.ObjLotWaferIDListGetDRIn objLotWaferIDListGetDRIn = new Inputs.ObjLotWaferIDListGetDRIn();
            objLotWaferIDListGetDRIn.setLotID(chamberProcesslotID);
            objLotWaferIDListGetDRIn.setScrapCheckFlag(true);

            log.debug("step6 - get lot wafer");
            List<ObjectIdentifier> waferIDs = lotMethod.lotWaferIDListGetDR(objCommon, objLotWaferIDListGetDRIn);
            int waferLen = CimArrayUtils.getSize(waferIDs);
            /*-------------------------*/
            /*   Check Wafer's LotID   */
            /*-------------------------*/
            List<Infos.ChamberProcessWaferInfo> strChamberProcessWaferInfos = strChamberProcessLotInfos.get(i).getChamberProcessWaferInfos();
            int waferCount = CimArrayUtils.getSize(strChamberProcessWaferInfos);
            for (int j = 0; j < waferCount; j++) {
                Infos.ChamberProcessWaferInfo chamberProcessWaferInfo = strChamberProcessWaferInfos.get(j);
                log.trace("strChamberProcessLotInfos[i].strChamberProcessWaferInfos[j].waferID.identifier = {}", chamberProcessWaferInfo.getWaferID());
                boolean foundWaferFlag = false;
                for (int k = 0; k < waferLen; k++) {
                    ObjectIdentifier waferID = waferIDs.get(k);
                    log.trace("strLot_waferIDList_GetDR_out.waferIDs[n].identifier = {}", waferID);
                    if (ObjectIdentifier.equalsWithValue(waferID, chamberProcessWaferInfo.getWaferID())) {
                        foundWaferFlag = true;
                        break;
                    }
                }

                Validations.check(CimBooleanUtils.isFalse(foundWaferFlag),
                        new OmCode(retCodeConfig.getControlJobLotUnmatch(), ObjectIdentifier.fetchValue(chamberProcesslotID), ObjectIdentifier.fetchValue(chamberProcessWaferInfo.getWaferID())));

                /*---------------------------------*/
                /*   Check Equipment's ChamberID   */
                /*---------------------------------*/
                List<Infos.ProcessedChamberInfo> strProcessedChamberInfos = chamberProcessWaferInfo.getProcessedChamberInfos();
                int chamberCount = CimArrayUtils.getSize(strProcessedChamberInfos);
                for (int k = 0; k < chamberCount; k++) {
                    Infos.ProcessedChamberInfo processedChamberInfo = strProcessedChamberInfos.get(k);
                    foundFlag = false;
                    log.trace("strProcessedChamberInfos[k].chamberID.identifier = {}", ObjectIdentifier.fetchValue(processedChamberInfo.getChamberID()));
                    if (!CimArrayUtils.isEmpty(eqpChamberStatuses)) {
                        for (Infos.EqpChamberStatusInfo eqpChamberStatusInfo : eqpChamberStatuses) {
                            if (ObjectIdentifier.equalsWithValue(eqpChamberStatusInfo.getChamberID(), processedChamberInfo.getChamberID())) {
                                processedChamberInfo.setChamberID(eqpChamberStatusInfo.getChamberID());
                                foundFlag = true;
                                break;
                            }
                        }
                    }
                    Validations.check(!foundFlag,
                            new OmCode(retCodeConfig.getNotFoundReqChamber(), ObjectIdentifier.fetchValue(processedChamberInfo.getChamberID()), ObjectIdentifier.fetchValue(equipmentID)));
                }
            }
        }

        /*-----------------------------------------*/
        /*   Set Wafer-Chamber Information in PO   */
        /*-----------------------------------------*/
        log.trace("actionCode is 【{}】",actionCode);
        if (CimStringUtils.equals(actionCode, BizConstant.SP_CHAMBERPROCACTIONCODE_PROCESSEND)) {
            log.debug("step7 - ActionCode is 'ProcessEnd'. So, set Wafer-Chamber Information in PO.");
            processMethod.processWaferChamberInformationSet(objCommon, strChamberProcessLotInfos);
        }

        /*-----------------------------------*/
        /*   Make WaferChamberProcessEvent   */
        /*-----------------------------------*/
        log.debug("step8 - Make WaferChamberProcessEvent");
        Inputs.WaferChamberProcessEventMakeParams waferChamberProcessEventMakeParams = new Inputs.WaferChamberProcessEventMakeParams();
        waferChamberProcessEventMakeParams.setTransactionID(TransactionIDEnum.CHAMBER_PROCESS_WAFER_RPT.getValue());
        waferChamberProcessEventMakeParams.setEquipmentID(params.getEquipmentID());
        waferChamberProcessEventMakeParams.setClaimMemo(params.getOpeMemo());
        waferChamberProcessEventMakeParams.setChamberProcessLotInfos(params.getChamberProcessLotInfos());
        eventMethod.waferChamberProcessEventMake(objCommon, waferChamberProcessEventMakeParams);
    }

    @Override
    public void sxCarrierOutFromIBReq(Infos.ObjCommon strObjCommonIn, ObjectIdentifier equipmentID, ObjectIdentifier cassetteID, String claimMemo) {
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Check TransactionID                                                 */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        log.debug("step1 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(strObjCommonIn, equipmentID);


        /*------------------------*/
        /*   Check ControlJobID   */
        /*------------------------*/
        log.debug("step2 - Check ControlJobID");
        ObjectIdentifier strCassetteControlJobIDGetOut = cassetteMethod.cassetteControlJobIDGet(strObjCommonIn, cassetteID);

        Validations.check(0 < CimStringUtils.length(strCassetteControlJobIDGetOut.getValue()), retCodeConfig.getNotClearedControlJob());

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Main Process                                                        */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

        /*------------------------------------------------------------------------*/
        /*                                                                        */
        /*   Send CarrierOutFromIBReq() to EAP Procedure              */
        /*                                                                        */
        /*------------------------------------------------------------------------*/
        String tmpSleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue();
        String tmpRetryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue();
        int sleepTimeValue = 0;
        int retryCountValue = 0;

        log.trace("tmpSleepTimeValue length is 【{}】", CimStringUtils.length(tmpSleepTimeValue));
        if (CimStringUtils.length(tmpSleepTimeValue) == 0) {
            sleepTimeValue = BizConstant.SP_DEFAULT_SLEEP_TIME_TCS.intValue();
        } else {
            sleepTimeValue = CimNumberUtils.intValue(tmpSleepTimeValue);
        }

        log.trace("tmpRetryCountValue length is 【{}】", CimStringUtils.length(tmpRetryCountValue));
        if (CimStringUtils.length(tmpRetryCountValue) == 0) {
            retryCountValue = BizConstant.SP_DEFAULT_RETRY_COUNT_TCS.intValue();
        } else {
            retryCountValue = CimNumberUtils.intValue(tmpRetryCountValue);
        }

        log.trace("env value of OM_EAP_CONNECT_SLEEP_TIME  = {}", sleepTimeValue);
        log.trace("env value of OM_EAP_CONNECT_RETRY_COUNT = {}", retryCountValue);

        //'retryCountValue + 1' means first try plus retry count
        for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
            /*--------------------------*/
            /*    Send Request to EAP   */
            /*--------------------------*/
            try {
                log.debug("step3 - Send Request to EAP");
                tcsMethod.sendCarrierOutFromIBReq(
                        strObjCommonIn,
                        strObjCommonIn.getUser(),
                        equipmentID,
                        cassetteID,
                        claimMemo);
                break;
            } catch (ServiceException ex) {
                if (Validations.isEquals(ex.getCode(), retCodeConfig.getExtServiceBindFail()) ||
                        Validations.isEquals(ex.getCode(), retCodeConfig.getExtServiceNilObj()) ||
                        Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                    log.trace("EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...{}", retryNum);
                    log.trace("now sleeping... {}", sleepTimeValue);
                    try {
                        Thread.sleep(sleepTimeValue);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        e.printStackTrace();
                    }
                    continue;
                } else {
                    throw ex;
                }
            }
        }

        /*----------------------*/
        /*                      */
        /*   Return to Caller   */
        /*                      */
        /*----------------------*/
    }


    @Override
    public Results.EqpAlarmRptResult sxEqpAlarmRpt(Infos.ObjCommon strObjCommonIn, ObjectIdentifier equipmentID,
                                                   ObjectIdentifier stockerID, ObjectIdentifier AGVID,
                                                   Infos.EquipmentAlarm strEquipmentAlarm, String claimMemo) {
        /*---------------------------*/
        /*   Check Input Parameter   */
        /*---------------------------*/
        if (CimStringUtils.length(equipmentID.getValue()) == 0 &&
                CimStringUtils.length(stockerID.getValue()) == 0 &&
                CimStringUtils.length(AGVID.getValue()) == 0) {
            Validations.check(true, retCodeConfig.getInvalidInputParam());
        }

        /*----------------------------------*/
        /*   Make Equipment Alarm Event     */
        /*----------------------------------*/
        log.debug("Make Equipment Alarm Event");
        eventMethod.equipmentAlarmEventMake(
                strObjCommonIn,
                "OEQPR014",
                strObjCommonIn.getUser(),
                equipmentID,
                stockerID,
                AGVID,
                strEquipmentAlarm);

        /*-----------------------*/
        /*   Set out structure   */
        /*-----------------------*/
        return new Results.EqpAlarmRptResult();
    }


    @Override
    public void sxWaferPositionWithProcessResourceRpt(Infos.ObjCommon objCommon, Params.WaferPositionWithProcessResourceRptParam param) {
        log.debug("step1 - sxWaferPositionWithProcessResourceRpt start");
        ObjectIdentifier equipmentID = param.getEquipmentID();
        ObjectIdentifier controlJobID = param.getControlJobID();
        Infos.ProcessResourcePositionInfo processResourcePositionInfo = param.getProcessResourcePositionInfo();
        List<Infos.WaferPositionInProcessResourceInfo> waferPositionInProcessResourceInfoSeq = processResourcePositionInfo.getWaferPositionInProcessResourceInfoList();
        Validations.check(CimArrayUtils.isEmpty(waferPositionInProcessResourceInfoSeq), retCodeConfig.getInvalidInputParam());

        for (Infos.WaferPositionInProcessResourceInfo waferPositionInProcessResourceInfo : waferPositionInProcessResourceInfoSeq) {
            if (ObjectIdentifier.isEmptyWithValue(waferPositionInProcessResourceInfo.getLotID())
                    || ObjectIdentifier.isEmptyWithValue(waferPositionInProcessResourceInfo.getWaferID())
                    || CimStringUtils.isEmpty(waferPositionInProcessResourceInfo.getPosition())
                    || CimStringUtils.isEmpty(waferPositionInProcessResourceInfo.getProcessReportedTimeStamp())) {
                Validations.check(true, retCodeConfig.getInvalidInputParam());
            }
        }
        Outputs.ObjLotWaferIDListGetDROut objLotWaferIDListGetDROut = new Outputs.ObjLotWaferIDListGetDROut();

        log.trace("ProcessResourceID is 【{}】",processResourcePositionInfo.getProcessResourceID());
        if (!ObjectIdentifier.isEmptyWithValue(processResourcePositionInfo.getProcessResourceID())) {
            log.debug("step2 - get equipment chamber info");
            Infos.EqpChamberInfo eqpChamberInfo = equipmentMethod.equipmentChamberInfoGetDR(objCommon, equipmentID);
            List<Infos.EqpChamberStatusInfo> eqpChamberStatuses = eqpChamberInfo.getEqpChamberStatuses();
            boolean foundFlag = false;
            log.trace("eqpChamberStatuses is 【{}】",eqpChamberStatuses);
            if (CimArrayUtils.isNotEmpty(eqpChamberStatuses)) {
                for (Infos.EqpChamberStatusInfo eqpChamberStatus : eqpChamberStatuses) {
                    if (ObjectIdentifier.equalsWithValue(eqpChamberStatus.getChamberID(), processResourcePositionInfo.getProcessResourceID())) {
                        foundFlag = true;
                        break;
                    }
                }
            }
            Validations.check(CimBooleanUtils.isFalse(foundFlag), new OmCode(retCodeConfig.getNotFoundReqChamber()
                    , ObjectIdentifier.fetchValue(processResourcePositionInfo.getProcessResourceID()), ObjectIdentifier.fetchValue(equipmentID)));
        }

        /*************************************************/
        /*   Check Lot's ProcessState and ControlJobID   */
        /*************************************************/
        for (Infos.WaferPositionInProcessResourceInfo waferPositionInProcessResourceInfo : waferPositionInProcessResourceInfoSeq) {
            ObjectIdentifier lotID = waferPositionInProcessResourceInfo.getLotID();
            boolean alreadyCheckedFlag = false;
            List<ObjectIdentifier> strCommonObjectIdentifierStruct = new ArrayList<>();

            if (CimBooleanUtils.isFalse(alreadyCheckedFlag)) {
                log.debug("step2 - get lot process state");
                String lotProcessStateGet = lotMethod.lotProcessStateGet(objCommon, lotID);
                Validations.check(!CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING, lotProcessStateGet)
                        , new OmCode(retCodeConfig.getInvalidLotProcstat(), ObjectIdentifier.fetchValue(lotID), lotProcessStateGet));

                log.debug("step3 - get lot control job");
                ObjectIdentifier lotControlJobID = lotMethod.lotControlJobIDGet(objCommon, lotID);
                log.trace("lotControlJobID is 【{}】，controlJobID is 【{}】",lotControlJobID, controlJobID);
                if (!ObjectIdentifier.equalsWithValue(lotControlJobID, controlJobID)) {
                    throw new ServiceException(new OmCode(retCodeConfig.getControlJobLotUnmatch(), ObjectIdentifier.fetchValue(controlJobID), ObjectIdentifier.fetchValue(lotID)));
                }
                Inputs.ObjLotWaferIDListGetDRIn objLotWaferIDListGetDRIn = new Inputs.ObjLotWaferIDListGetDRIn();
                objLotWaferIDListGetDRIn.setLotID(lotID);
                objLotWaferIDListGetDRIn.setScrapCheckFlag(true);

                log.debug("step4 - get lot wafer");
                strCommonObjectIdentifierStruct = lotMethod.lotWaferIDListGetDR(objCommon, objLotWaferIDListGetDRIn);

                objLotWaferIDListGetDROut.setWaferIDs(strCommonObjectIdentifierStruct);
            } else {
                objLotWaferIDListGetDROut.setWaferIDs(strCommonObjectIdentifierStruct);
            }
            List<ObjectIdentifier> waferIDs = objLotWaferIDListGetDROut.getWaferIDs();
            ObjectIdentifier waferID = waferPositionInProcessResourceInfo.getWaferID();
            boolean foundWaferFlag = false;
            log.trace("waferIDs is 【{}】",waferIDs);
            if (CimArrayUtils.isNotEmpty(waferIDs)) {
                for (ObjectIdentifier waferId : waferIDs) {
                    if (ObjectIdentifier.equalsWithValue(waferId, waferID)) {
                        waferPositionInProcessResourceInfo.setWaferID(waferId);
                        foundWaferFlag = true;
                        break;
                    }
                }
            }
            Validations.check(CimBooleanUtils.isFalse(foundWaferFlag), new OmCode(retCodeConfig.getLotWaferUnmatch(), ObjectIdentifier.fetchValue(lotID), ObjectIdentifier.fetchValue(waferID)));
        }

        log.debug("step5 - get equipment in processing control job info");
        List<Infos.EqpInprocessingControlJob> eqpInprocessingControlJobs = equipmentMethod.equipmentInprocessingControlJobInfoGetDR(objCommon, equipmentID);
        boolean foundFlag = false;
        log.trace("eqpInprocessingControlJobs is 【{}】",eqpInprocessingControlJobs);
        if (CimArrayUtils.isNotEmpty(eqpInprocessingControlJobs)) {
            for (Infos.EqpInprocessingControlJob eqpInprocessingControlJob : eqpInprocessingControlJobs) {
                if (ObjectIdentifier.equalsWithValue(eqpInprocessingControlJob.getControlJobID(), controlJobID)) {
                    foundFlag = true;
                    break;
                }
            }
        }
        Validations.check(CimBooleanUtils.isFalse(foundFlag), new OmCode(retCodeConfig.getControlJobEqpUnmatch()
                , ObjectIdentifier.fetchValue(controlJobID), ObjectIdentifier.fetchValue(equipmentID)));

        log.debug("step6 - processWaferPositionInProcessResourceInformationSet");
        processMethod.processWaferPositionInProcessResourceInformationSet(objCommon, processResourcePositionInfo);
        /***************************************************/
        /*  Make wafer position in Process Resource event  */
        /***************************************************/
        log.debug("step7 - Make wafer position in Process Resource event");
        Inputs.ProcessResourceWaferPositionEventMakeParams processResourceWaferPositionEventMakeParams = new Inputs.ProcessResourceWaferPositionEventMakeParams();
        processResourceWaferPositionEventMakeParams.setClaimMemo(param.getOpeMemo());
        processResourceWaferPositionEventMakeParams.setEquipmentID(equipmentID);
        processResourceWaferPositionEventMakeParams.setTransactionID(objCommon.getTransactionID());
        processResourceWaferPositionEventMakeParams.setControlJobID(controlJobID);
        processResourceWaferPositionEventMakeParams.setProcessResourcePositionInfo(processResourcePositionInfo);
        processResourceWaferPositionEventMakeParams.setClaimMemo(param.getOpeMemo());
        eventMethod.processResourceWaferPositionEventMake(objCommon, processResourceWaferPositionEventMakeParams);
    }

    @Override
    public void sxProcessStatusRpt(Infos.ObjCommon objCommon, Params.ProcessStatusRptParam param) {
        log.debug("step1 - get mode lock for equipment 【{}】",param.getEquipmentID());
        Outputs.ObjLockModeOut strObjectLockModeGetOut;
        Inputs.ObjLockModeIn strObjectLockModeGetIn = new Inputs.ObjLockModeIn();
        ObjectIdentifier equipmentID = param.getEquipmentID();
        strObjectLockModeGetIn.setObjectID(equipmentID);
        strObjectLockModeGetIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        strObjectLockModeGetIn.setFunctionCategory(TransactionIDEnum.PROCESS_STATUS_RPT.getValue());
        strObjectLockModeGetIn.setUserDataUpdateFlag(FALSE);

        strObjectLockModeGetOut = objectMethod.objectLockModeGet(
                objCommon,
                strObjectLockModeGetIn);

        Long lockMode = strObjectLockModeGetOut.getLockMode();
        log.trace("lockMode is 【{}】",lockMode);
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // lock machine object is unnecessary
        } else {
            /*--------------------------------*/
            /*   Lock objects to be updated   */
            /*--------------------------------*/
            log.debug("step2 - Lock objects to be updated");
            lockMethod.objectLock(objCommon, CimMachine.class,
                    equipmentID);
        }

        log.info("step3 - get equipment in processing control job info");
        List<Infos.EqpInprocessingControlJob> eqpInprocessingControlJobs = equipmentMethod.equipmentInprocessingControlJobInfoGetDR(objCommon, param.getEquipmentID());
        boolean foundFlag = false;
        int nLen = CimArrayUtils.getSize(eqpInprocessingControlJobs);
        for (int n = 0; n < nLen; n++) {
            Infos.EqpInprocessingControlJob eqpInprocessingControlJob = eqpInprocessingControlJobs.get(n);
            log.trace("eqpInprocessingControlJob ControlJobID is 【{}】，param ControlJobID is 【{}】",eqpInprocessingControlJob.getControlJobID(), param.getControlJobID());
            if (ObjectIdentifier.equalsWithValue(eqpInprocessingControlJob.getControlJobID(), param.getControlJobID())) {
                foundFlag = true;
                log.trace("lockMode is 【{}】",lockMode);
                if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
                    Inputs.ObjAdvanceLockIn strAdvancedObjectLockIn = new Inputs.ObjAdvanceLockIn();
                    List<ObjectIdentifier> lotIDs;
                    Infos.EqpInprocessingControlJob strEqpInprocessingControlJob = eqpInprocessingControlJobs.get(n);
                    int nLotLen = CimArrayUtils.getSize(strEqpInprocessingControlJob.getEqpInprocessingLotList());
                    lotIDs = new ArrayList<>(nLotLen);
                    for (int i = 0; i < nLotLen; i++) {
                        lotIDs.add(strEqpInprocessingControlJob.getEqpInprocessingLotList().get(i).getLotID());
                    }

                    // Lock Equipment ProcLot Element (Read)
                    List<String> procLotSeq = new ArrayList<>(nLotLen);
                    for (int procLotNo = 0; procLotNo < nLotLen; procLotNo++) {
                        procLotSeq.add(lotIDs.get(procLotNo).getValue());
                    }
                    strAdvancedObjectLockIn.setObjectID(equipmentID);
                    strAdvancedObjectLockIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
                    strAdvancedObjectLockIn.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT);
                    strAdvancedObjectLockIn.setLockType((long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);
                    strAdvancedObjectLockIn.setKeyList(procLotSeq);

                    log.debug("step4 - lock advanced object");
                    lockMethod.advancedObjectLock(
                            objCommon, strAdvancedObjectLockIn);

                    /*------------------------------*/
                    /*   Lock ControlJob Object     */
                    /*------------------------------*/
                    log.debug("step5 - Lock ControlJob Object ");
                    lockMethod.objectLock(
                            objCommon,
                            CimControlJob.class,
                            param.getControlJobID());
                }

                break;

            }
        }
        Validations.check(CimBooleanUtils.isFalse(foundFlag), retCodeConfig.getLotPortControlJobUnMatch());
        /*--------------------------------------*/
        /*   Update Control Job Status and      */
        /*   Make ControlJobStatusChangeEvent   */
        /*--------------------------------------*/
        log.trace("ActionCode is 【{}】",param.getActionCode());
        if (CimStringUtils.equals(param.getActionCode(), BizConstant.SP_PCSTACTIONCODE_PROCESSSTART)) {
            Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
            cjStatusChangeReqParams.setUser(param.getUser());
            cjStatusChangeReqParams.setControlJobID(param.getControlJobID());
            cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_EXECUTE);
            cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());

            log.debug("step6 - change CJ status");
            controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);
        } else if (CimStringUtils.equals(param.getActionCode(), BizConstant.SP_PCSTACTIONCODE_PROCESSEND)) {
            Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
            cjStatusChangeReqParams.setUser(param.getUser());
            cjStatusChangeReqParams.setControlJobID(param.getControlJobID());
            cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_COMPLETE);
            cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());

            log.debug("step7 - change CJ status");
            controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);
        } else {
            //Nothing to do.
        }
        /*-------------------------------*/
        /*   Check In-parm's lot Count   */
        /*-------------------------------*/
        int lotCount = 0;
        List<ObjectIdentifier> lotIDs = param.getLotIDList();
        lotCount = CimArrayUtils.getSize(lotIDs);
        Validations.check(lotCount == 0, retCodeConfig.getSomeLotidDataError());
        /*-------------------------------------------------*/
        /*   Check lot's ProcessState and ProcessGroupID   */
        /*-------------------------------------------------*/
        log.trace("lotIDs is 【{}】",lotIDs);
        if (!CimArrayUtils.isEmpty(lotIDs)) {
            for (ObjectIdentifier lotID : lotIDs) {
                /*-----------------------------*/
                /*   Get lot's Process State   */
                /*-----------------------------*/
                log.debug("step8 - Get lot's Process State");
                String lotProcessState = lotMethod.lotProcessStateGet(objCommon, lotID);
                Validations.check(!CimStringUtils.equals(lotProcessState, BizConstant.SP_LOT_PROCSTATE_PROCESSING),
                        new OmCode(retCodeConfig.getInvalidLotProcessState(), lotID.getValue(), lotProcessState));

                log.debug("step9 - Get lot's control job ID");
                ObjectIdentifier controlJobID = lotMethod.lotControlJobIDGet(objCommon, lotID);
                log.trace("controlJobID is 【{}】",controlJobID);
                if (ObjectIdentifier.isEmptyWithValue(controlJobID)) {
                    throw new ServiceException(new OmCode(retCodeConfig.getLotControlJobIdBlank(), ObjectIdentifier.fetchValue(lotID)));
                } else {
                    if (!ObjectIdentifier.equalsWithValue(param.getControlJobID(), controlJobID)) {
                        throw new ServiceException(new OmCode(retCodeConfig.getNotSameControlJobId(), ObjectIdentifier.fetchValue(lotID)));
                    }
                }
                log.debug("step10 - Make ProcessStatusEvent");
                eventMethod.processStatusEventMake(objCommon, TransactionIDEnum.PROCESS_STATUS_RPT.getValue(), param.getEquipmentID(), controlJobID,
                        lotID, param.getActionCode(), "");
            }
        }
    }

    @Override
    public void sxEqpEAPStatusSyncReq(Infos.ObjCommon objCommon, Params.EqpEAPStatusSyncReqPrams params) {
        log.debug("step1 - get equipment port info");
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, params.getEquipmentID());
        log.trace("EqpPortStatuse is 【{}】",eqpPortInfo.getEqpPortStatuses());
        if (CimObjectUtils.isEmpty(eqpPortInfo.getEqpPortStatuses())) {
            log.error("strEqpPortStatus.length <= 0");
            throw new ServiceException(retCodeConfig.getNotFoundPort());
        }
        log.trace("OnlineMode is 【{}】",eqpPortInfo.getEqpPortStatuses().get(0).getOnlineMode());
        if (CimStringUtils.equals(eqpPortInfo.getEqpPortStatuses().get(0).getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
            log.error("PPTManager_i:: txEqpEAPStatusSyncReq {}",
                    "CIMFWStrCmp(strEquipment_portInfo_Get_out.strEqpPortInfo.strEqpPortStatus[0].onlineMode, SP_Eqp_OnlineMode_Offline) == 0");
            Validations.check(retCodeConfig.getInvalidEquipmentMode(), ObjectIdentifier.fetchValue(params.getEquipmentID()),
                    eqpPortInfo.getEqpPortStatuses().get(0).getOnlineMode());
        }
        log.debug("step2 - Get Eqp's Detail Info from EAP");
        Results.EqpEAPInfoInqResult eqpEAPInfoInqResult = equipmentInqService.sxEqpEAPInfoInq(objCommon, params.getEquipmentID());

        /*-----------------------------------------------------------------*/
        /*   Report Eqp's Status based on Detail Info from EAP             */
        /*   - specify returned equipmentStatus as input equipmentStatus   */
        /*-----------------------------------------------------------------*/
        log.trace("eqpEAPInfoInqResult is 【{}】",eqpEAPInfoInqResult);
        if (!CimObjectUtils.isEmpty(eqpEAPInfoInqResult)
                && !ObjectIdentifier.isEmpty(eqpEAPInfoInqResult.getEquipmentStatusCode())
                && !CimObjectUtils.isEmpty(eqpEAPInfoInqResult.getEquipmentStatusCode().getValue())) {
            Params.EqpStatusChangeRptParams eqpStatusChangeRptParams = new Params.EqpStatusChangeRptParams();
            log.error("PPTManager_i:: txEqpEAPStatusSyncReq {}", "CIMFWStrLen( strEqpEAPInfoInqResult.equipmentStatusCode ) > 0 .....");
            log.debug("step3 txEqpStatusChangeRpt");
            eqpStatusChangeRptParams.setEquipmentID(params.getEquipmentID());
            eqpStatusChangeRptParams.setEquipmentStatusCode(eqpEAPInfoInqResult.getEquipmentStatusCode());
            eqpStatusChangeRptParams.setOpeMemo(params.getClaimMemo());
            Results.EqpStatusChangeRptResult tmpResult = this.sxEqpStatusChangeRpt(objCommon, eqpStatusChangeRptParams);

            log.debug("Step4 - Check and Get Port Status to be Reported");
            List<Infos.EqpPortEventOnTCS> objEquipmentportStateFillInTxEQR002InParmResult = equipmentMethod.equipmentportStateFillInTxEQR002InParm(objCommon, params.getEquipmentID(), eqpEAPInfoInqResult.getEqpInBufferList(), eqpEAPInfoInqResult.getEqpOutBufferList());

            if (!CimObjectUtils.isEmpty(objEquipmentportStateFillInTxEQR002InParmResult)
                    && !CimObjectUtils.isEmpty(objEquipmentportStateFillInTxEQR002InParmResult.size())) {
                log.error("PPTManager_i:: txEqpEAPStatusSyncReq {}", "strEquipment_portState_FillInTxEQR002InParm_out.strEqpPortEventOnTCS.length() > 0 .....");

                log.debug("step5 - Report Eqp's Port Status based on Detail Info from EAP");
                ObjectIdentifier out = this.sxPortStatusChangeRpt(objCommon, params.getEquipmentID(), objEquipmentportStateFillInTxEQR002InParmResult, params.getClaimMemo());
            }
        }
    }

    @Override
    public ObjectIdentifier sxChamberStatusChangeRpt(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, List<Infos.EqpChamberStatus> eqpChamberStatuses) {
        ObjectIdentifier equipmentId = ObjectIdentifier.isEmpty(equipmentID) ? null : equipmentID;

        log.debug("step1 - get lock mode for equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.CHAMBER_PROCESS_WAFER_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // Advanced Mode
            log.debug("step2 - Lock Equipment Main Object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            log.debug("step3 - lock object equipment");
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        log.debug("step4 - lock equipment resource");
        int seqLen = CimArrayUtils.getSize(eqpChamberStatuses);
        for (int j = 0; j < seqLen; j++) {
            objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, eqpChamberStatuses.get(j).getChamberID(), BizConstant.SP_CLASSNAME_POSPROCESSRESOURCE);
        }

        log.debug("step5 - get equipment port info");
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID);
        List<Infos.EqpPortStatus> eqpPortInfos = eqpPortInfo.getEqpPortStatuses();
        log.trace("onlineMode is 【{}】",eqpPortInfos.get(0).getOnlineMode());
        if (BizConstant.SP_EQP_ONLINEMODE_OFFLINE.equals(eqpPortInfos.get(0).getOnlineMode())) {
            Validations.check(retCodeConfig.getInvalidEquipmentMode(),ObjectIdentifier.fetchValue(equipmentID),
                    eqpPortInfos.get(0).getOnlineMode());
        }

        log.debug("step6 - Translate RawEqpState if defined");
        processMethod.rawProcessResourceStateTranslate(objCommon, equipmentID, eqpChamberStatuses);

        log.debug("step7 - Convert Chamber Status");
        Outputs.ObjProcessResourceStateConvertOut stateConvertOutRetCode = processMethod.processResourceStateConvert(objCommon, equipmentId, eqpChamberStatuses);

        log.debug("step8 - Check Chamber Status Transition");
        List<Infos.EqpChamberStatusCheckResult> stateCheckOutRetCode = null;
        try {
            stateCheckOutRetCode = processMethod.processResourceCurrentStateCheckTransition(objCommon, equipmentId, stateConvertOutRetCode.getEqpChamberStatusCheckResults(), true);
        } catch (ServiceException ex) {
            if (ex.getCode() == retCodeConfig.getCurrentStateSame().getCode()
                    || ex.getCode() == retCodeConfig.getInvalidStateTransition().getCode()) {
            } else {
                throw ex;
            }
        }

        log.debug("step9 - Change each Chamber status by Input data");
        List<Infos.ActualChamberStatus> actualChamberStatuses = new ArrayList<>(CimArrayUtils.getSize(stateCheckOutRetCode));
        List<Infos.EqpChamberStatusCheckResult> statusCheckResults = stateCheckOutRetCode;
        if (stateCheckOutRetCode != null) {
            for (int i = 0; i < stateCheckOutRetCode.size(); i++) {
                for (int j = 0; j < stateCheckOutRetCode.size(); j++) {
                    Infos.EqpChamberStatusCheckResult statusCheckResult = statusCheckResults.get(i);
                    Infos.EqpChamberStatus eqpChamberStatus = eqpChamberStatuses.get(j);

                    if (statusCheckResult.getChamberID().equals(eqpChamberStatus.getChamberID())) {
                        Infos.ActualChamberStatus actualChamberStatus = new Infos.ActualChamberStatus();
                        actualChamberStatus.setChamberID(statusCheckResult.getChamberID());
                        actualChamberStatus.setChamberStatusCode(statusCheckResult.getChamberStatusCode());
                        actualChamberStatus.setActualStatusCode(eqpChamberStatus.getChamberStatusCode());
                        actualChamberStatus.setResult(statusCheckResult.getResult());

                        actualChamberStatuses.add(actualChamberStatus);
                        break;
                    }
                }
            }
        }

        Outputs.ObjProcessResourceCurrentStateChangeByAutoOut stateChangeByAutoOutRetCode = processMethod.processResourceCurrentStateChangeByAuto(objCommon, equipmentId, actualChamberStatuses);

        log.debug("step10 - Create Chamber Status Change Event");
        /*----------------------------------------*/
        /*   Create Chamber Status Change Event   */
        /*----------------------------------------*/
        List<Infos.EqpChamberState> eqpChamberStateList = stateChangeByAutoOutRetCode.getChamberStateHisByAuto().stream().map(chamberStateHisByAuto -> {
            Infos.EqpChamberState eqpChamberState = new Infos.EqpChamberState();
            BeanUtils.copyProperties(chamberStateHisByAuto, eqpChamberState);
            eqpChamberState.setChamberE10Status(chamberStateHisByAuto.getE10Status());
            return eqpChamberState;
        }).collect(Collectors.toList());
        eventMethod.chamberStatusChangeEventMake(objCommon, TransactionIDEnum.CHAMBER_STATUS_CHANGE_RPT.getValue(), equipmentID, eqpChamberStateList, "");

        log.debug("step11 - Judge new eqp status if all chamber status are changed");
        ObjectIdentifier stateBecomeWhatOutRetCode = equipmentMethod.getEquipmentStateByChambers(equipmentId,
                eqpChamberStatuses);

        log.debug("step12 - Convert eqp Status");
        Outputs.ObjEquipmentStateConvertOut convertOut = equipmentMethod.equipmentStateConvertV2(
                equipmentId, stateBecomeWhatOutRetCode);

        log.debug("step13 - Check estimated-new-eqp-status vs. allowed-new-staus by Current mode");
        boolean equipmentStatusChangeReqiredFlag = false;
        try {
            equipmentMethod.equipmentCurrentStateCheckTransitionV2(objCommon, equipmentId,
                    convertOut.getConvertedStatusCode(), true);
            equipmentStatusChangeReqiredFlag = true;
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getCurrentStateSame(), e.getCode())
                    && !Validations.isEquals(retCodeConfig.getInvalidStateTransition(), e.getCode())) {
                throw e;
            }
        }
        log.debug("step14 - Change eqp status by judged new status");
        log.trace("equipmentStatusChangeReqiredFlag is 【{}】",equipmentStatusChangeReqiredFlag);
        if (equipmentStatusChangeReqiredFlag) {
            Outputs.ObjEquipmentCurrentStateChangeOut stateChangeOutRetCode = equipmentMethod
                    .equipmentCurrentStateChange(objCommon, equipmentId, convertOut.getConvertedStatusCode());
            //Step15 - Create eqp Status Change Even - equipmentStatusChangeEvent_Make
            Inputs.EquipmentStatusChangeEventMakeParams equipmentStatusChangeEventMakeParams = new Inputs.EquipmentStatusChangeEventMakeParams();
            equipmentStatusChangeEventMakeParams.setTransactionID(TransactionIDEnum.CHAMBER_STATUS_CHANGE_REQ.getValue());
            equipmentStatusChangeEventMakeParams.setEquipmentID(equipmentID);
            equipmentStatusChangeEventMakeParams.setStockerID(new ObjectIdentifier());
            equipmentStatusChangeEventMakeParams.setNewEquipmentStatus(convertOut.getConvertedStatusCode());
            equipmentStatusChangeEventMakeParams.setNewE10Status(stateChangeOutRetCode.getE10Status());
            equipmentStatusChangeEventMakeParams.setNewActualStatus(stateChangeOutRetCode.getActualStatus());
            equipmentStatusChangeEventMakeParams.setNewActualE10Status(stateChangeOutRetCode.getActualE10Status());
            equipmentStatusChangeEventMakeParams.setNewOperationMode(stateChangeOutRetCode.getOperationMode());
            equipmentStatusChangeEventMakeParams.setPreviousStatus(stateChangeOutRetCode.getPreviousStatus());
            equipmentStatusChangeEventMakeParams.setPreviousE10Status(stateChangeOutRetCode.getPreviousE10Status());
            equipmentStatusChangeEventMakeParams.setPreviousActualStatus(stateChangeOutRetCode.getPreviousActualStatus());
            equipmentStatusChangeEventMakeParams.setPreviousActualE10Status(stateChangeOutRetCode.getPreviousActualE10Status());
            equipmentStatusChangeEventMakeParams.setPreviousOpeMode(stateChangeOutRetCode.getPreviousOpeMode());
            equipmentStatusChangeEventMakeParams.setPrevStateStartTime(stateChangeOutRetCode.getPrevStateStartTime());
            equipmentStatusChangeEventMakeParams.setClaimMemo("");
            eventMethod.equipmentStatusChangeEventMake(objCommon, equipmentStatusChangeEventMakeParams);

        }

        /*-----------------------------------------------------------*/
        /*  Return Result                                            */
        /*-----------------------------------------------------------*/
        return equipmentID;
    }

    @Override
    public void sxEqpModeChangeReq(Infos.ObjCommon objCommon, Params.EqpModeChangeReqPrams params) {
        log.debug("step1 - objectLockModeGet");
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(params.getEquipmentID());
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.EQP_MODE_CHANGE_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        log.trace("lockMode is {}",lockMode);
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step2 - add advanced object lock");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(params.getEquipmentID());
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            log.debug("step3 - add object lock to the equipment");
            objectLockMethod.objectLock(objCommon, CimMachine.class, params.getEquipmentID());
        }
        //-------------------------------
        // Check for requested operation mode by each port group
        //-------------------------------
        List<ObjectIdentifier> portIDs = new ArrayList<>();

        log.debug("step4 - add advance lock to equipment port");
        int nLen = CimArrayUtils.getSize(params.getPortOperationModeList());
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            for (int i = 0; i < nLen; i++) {
                objectLockMethod.objectLockForEquipmentResource(objCommon, params.getEquipmentID(), params.getPortOperationModeList().get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            }
        }

        log.debug("step5 - get the port info for the equipment");
        String checkFlag = StandardProperties.OM_EQP_CHK_CARRIER_LOT_ON_PORT.getValue();
        Boolean checkCarrierFlag = FALSE;
        Boolean checkInProcLotFlag = FALSE;
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, params.getEquipmentID());
        List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo.getEqpPortStatuses();
        int lenPortInfo = CimArrayUtils.getSize(eqpPortStatuses);
        for (int j = 0; j < lenPortInfo; j++) {
            log.trace("OnlineMode is {}",eqpPortInfo.getEqpPortStatuses().get(j).getOnlineMode());
            if (CimStringUtils.equals(eqpPortInfo.getEqpPortStatuses().get(j).getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                checkInProcLotFlag = TRUE;
                log.trace("checkFlag is {}",checkFlag);
                if (CimStringUtils.equals(checkFlag, "1")) {
                    checkCarrierFlag = TRUE;
                }
                break;
            }
        }
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.trace("checkInProcLotFlag is {}",checkInProcLotFlag);
            if (checkInProcLotFlag) {
                log.debug("step6 - Lock Equipment ProcLot Element (Count)");
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(params.getEquipmentID(),
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            if (checkCarrierFlag) {
                log.debug("step7 - Lock Equipment LoadCassette Element (Count)");
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(params.getEquipmentID(),
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }

            log.debug("step8 - Lock the all ports");
            for (int i = 0; i < lenPortInfo; i++) {
                objectLockMethod.objectLockForEquipmentResource(objCommon, params.getEquipmentID(), eqpPortStatuses.get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            }
        }
        log.trace("sxEqpModeChangeReq", "nLen = ", nLen);
        for (int i = 0; i < nLen; i++) {
            portIDs.add(params.getPortOperationModeList().get(i).getPortID());
        }

        log.debug("step9 - check requested port combination");
        Outputs.ObjEquipmentPortCombinationCheck checkRetCode = portMethod.equipmentPortCombinationCheck(objCommon, params.getEquipmentID(), portIDs);

        log.debug("step10 - check equipment operation mode comobination");
        Outputs.ObjEquipmentOperationModeCombinationCheck equipmentOperationModeCombinationOut = equipmentMethod.equipmentOperationModeCombinationCheck(objCommon, params.getEquipmentID(), params.getPortOperationModeList());

        log.debug("step11 - get sorter job list");
        com.fa.cim.sorter.Params.ObjSorterJobListGetDRIn objSorterJobListGetDRIn = new com.fa.cim.sorter.Params.ObjSorterJobListGetDRIn();
        objSorterJobListGetDRIn.setEquipmentID(params.getEquipmentID());
        List<Info.SortJobListAttributes> objSorterJobListGetDROut = sorterNewMethod.sorterJobListGetDR(objCommon, objSorterJobListGetDRIn);
        for (int portCount = 0; portCount < params.getPortOperationModeList().size(); portCount++) {
            for (int sorterCount = 0; sorterCount < objSorterJobListGetDROut.size(); sorterCount++) {
                if (ObjectIdentifier.equalsWithValue(params.getPortOperationModeList().get(portCount).getPortGroup(), objSorterJobListGetDROut.get(sorterCount).getPortGroupID())) {
                    throw new ServiceException(new OmCode(retCodeConfigEx.getInvalidModeChangeForSorter(), ObjectIdentifier.fetchValue(params.getEquipmentID()), ObjectIdentifier.fetchValue(objSorterJobListGetDROut.get(sorterCount).getSorterJobID())));
                }
            }
        }

        log.debug("step12 - get equipment info");
        Params.EqpInfoInqParams eqpInfoInqParams = new Params.EqpInfoInqParams();

        eqpInfoInqParams.setEquipmentID(params.getEquipmentID());
        eqpInfoInqParams.setRequestFlagForBasicInfo(false);
        eqpInfoInqParams.setRequestFlagForStatusInfo(false);
        eqpInfoInqParams.setRequestFlagForPMInfo(false);
        eqpInfoInqParams.setRequestFlagForPortInfo(true);
        eqpInfoInqParams.setRequestFlagForChamberInfo(false);
        eqpInfoInqParams.setRequestFlagForStockerInfo(false);
        eqpInfoInqParams.setRequestFlagForInprocessingLotInfo(true);
        eqpInfoInqParams.setRequestFlagForReservedControlJobInfo(false);
        eqpInfoInqParams.setRequestFlagForRSPPortInfo(true);
        eqpInfoInqParams.setRequestFlagForEqpContainerInfo(false);

        Results.EqpInfoInqResult eqpInfoInqResult = equipmentInqService.sxEqpInfoInq(objCommon, eqpInfoInqParams);

        log.trace("checkCarrierFlag is {}",checkCarrierFlag);
        if (CimBooleanUtils.isTrue(checkCarrierFlag)) {
            String equipmentCategory = "";

            log.debug("step13 - equipmentBRInfoGetDR");
            Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, params.getEquipmentID());
            equipmentCategory = eqpBrInfo.getEquipmentCategory();
            String checkForNPW = StandardProperties.OM_EQP_GO_ONLINE_POSSIBLE_WITH_NPW.getValue();
            long chekcForNPWFlag = 0;
            if (!CimObjectUtils.isEmpty(checkForNPW)) {
                chekcForNPWFlag = Long.parseLong(checkForNPW);
            }
            Boolean bDispClearedFlag = false;
            Boolean bDispLoadCheckFlag = true;
            Boolean bDispUnloadCheckFlag = true;
            if (CimStringUtils.equals(StandardProperties.SP_DISPATCH_CAST_CLEARED_BY_CHANGE_TO_ONLINE.getValue(), "1")) {
                bDispClearedFlag = true;
            }
            if (CimStringUtils.equals(equipmentCategory, BizConstant.SP_MC_CATEGORY_INTERNALBUFFER)) {

                log.debug("step14 - sxEqpInfoForIBInq");
                Params.EqpInfoForIBInqParams param = new Params.EqpInfoForIBInqParams();
                param.setEquipmentID(params.getEquipmentID());
                param.setRequestFlagForBasicInfo(false);
                param.setRequestFlagForStatusInfo(false);
                param.setRequestFlagForPMInfo(false);
                param.setRequestFlagForPortInfo(true);
                param.setRequestFlagForChamberInfo(false);
                param.setRequestFlagForInternalBufferInfo(true);
                param.setRequestFlagForStockerInfo(false);
                param.setRequestFlagForInprocessingLotInfo(true);
                param.setRequestFlagForReservedControlJobInfo(false);
                param.setRequestFlagForRSPPortInfo(true);
                Results.EqpInfoForIBInqResult eqpInfoForIBInqResultRetCode = equipmentInqService.sxEqpInfoForIBInq(objCommon, param);

                int lenInternalPort = CimArrayUtils.getSize(eqpInfoForIBInqResultRetCode.getEquipmentPortInfo().getEqpPortStatuses());
                for (int jj = 0; jj < lenInternalPort; jj++) {
                    log.trace("bDispClearedFlag is {}",bDispClearedFlag);
                    if (bDispClearedFlag) {
                        for (int portIdx = 0; portIdx < nLen; portIdx++) {
                            if (ObjectIdentifier.equalsWithValue(params.getPortOperationModeList().get(portIdx).getPortID(), eqpInfoForIBInqResultRetCode.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getPortID())) {
                                if (CimStringUtils.equals(params.getPortOperationModeList().get(portIdx).getOperationMode().getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_ONLINELOCAL) || CimStringUtils.equals(params.getPortOperationModeList().get(portIdx).getOperationMode().getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_ONLINEREMOTE)) {
                                    if (CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                                        bDispUnloadCheckFlag = false;
                                        if (CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getAccessMode(), BizConstant.SP_EQP_ACCESSMODE_MANUAL)) {
                                            bDispLoadCheckFlag = false;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                    if (!ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadedCassetteID())) {
                        log.trace("chekcForNPWFlag is {}",chekcForNPWFlag);
                        if (1 == chekcForNPWFlag) {
                            int lenBufCategory = CimArrayUtils.getSize(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos());
                            for (int kk = 0; kk < lenBufCategory; kk++) {
                                if (CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getBufferCategory(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE) ||
                                        CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getBufferCategory(), BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY) ||
                                        CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getBufferCategory(), BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT) ||
                                        CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getBufferCategory(), BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT)) {
                                    log.error("", "### A shelf cateogry is NPW purpose. So even if a carrier is in shelf, eqp mode change is allowed.");
                                } else {
                                    int lenBufShelf = CimArrayUtils.getSize(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getShelfInBufferList());
                                    for (int ll = 0; ll < lenBufShelf; ll++) {
                                        if (!ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getShelfInBufferList().get(ll).getLoadedCarrierID())
                                                || !ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getShelfInBufferList().get(ll).getReservedCarrierID())) {
                                            throw new ServiceException(retCodeConfig.getLotCassetteOnPort());
                                        }
                                    }
                                }
                            }
                        } else {
                            throw new ServiceException(retCodeConfig.getLotCassetteOnPort());
                        }
                    } else if ((CimBooleanUtils.isTrue(bDispLoadCheckFlag)
                            && !ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getDispatchLoadCassetteID()))
                            || (CimBooleanUtils.isTrue(bDispUnloadCheckFlag) && !ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getDispatchUnloadCassetteID()))) {
                        throw new ServiceException(retCodeConfig.getLotCassetteOnPort());
                    }
                }
                int lenBufCategory = CimArrayUtils.getSize(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos());
                for (int kk = 0; kk < lenBufCategory; kk++) {
                    if (1 == chekcForNPWFlag && ((CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getBufferCategory(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE))
                            || (CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getBufferCategory(), BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY))
                            || (CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getBufferCategory(), BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT))
                            || (CimStringUtils.equals(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getBufferCategory(), BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT)))) {
                        log.error("", "### A shelf cateogry is NPW purpose. So even if a carrier is in shelf, eqp mode change is allowed.");
                    } else {
                        int lenBufShelf = CimArrayUtils.getSize(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getShelfInBufferList());
                        for (int ll = 0; ll < lenBufShelf; ll++) {
                            if (!ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getShelfInBufferList().get(ll).getLoadedCarrierID())
                                    || !ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEqpInternalBufferInfos().get(kk).getShelfInBufferList().get(ll).getReservedCarrierID())) {
                                log.error("", "loadedCarrier != NULL || reservedCarrier != NULL");
                                throw new ServiceException(retCodeConfig.getLotCassetteOnPort());
                            }
                        }
                    }
                }
                if (!CimObjectUtils.isEmpty(eqpInfoForIBInqResultRetCode.getEquipmentInprocessingControlJobList())) {
                    log.error("", "strEqpInfoForIBInqResult.equipmentInprocessingControlJob.length != 0");
                    throw new ServiceException(retCodeConfig.getLotStatusProcessing());
                }
                int RSPportLen = CimArrayUtils.getSize(eqpInfoForIBInqResultRetCode.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList());
                for (int i = 0; i < RSPportLen; i++) {
                    if (!ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getLoadedReticlePodID())
                            || !ObjectIdentifier.isEmpty(eqpInfoForIBInqResultRetCode.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getReservedReticlePodID())
                            || CimObjectUtils.equals(eqpInfoForIBInqResultRetCode.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getDispatchStatus(), BizConstant.SP_PORTRSC_DISPATCHSTATE_DISPATCHED)) {
                        Validations.check(retCodeConfigEx.getReticlePodNotOnRspPort(), ObjectIdentifier.fetchValue(eqpInfoForIBInqResultRetCode.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getReticlePodPortID()));
                    }
                }
            } else {
                log.error("", "This eqp is not InternalBuuffer");
                int lenNormalPort = CimObjectUtils.isEmpty(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses()) ? 0 : CimArrayUtils.getSize(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses());
                log.trace("", "port length = ", lenNormalPort);
                for (int jj = 0; jj < lenNormalPort; jj++) {
                    if (CimBooleanUtils.isTrue(bDispClearedFlag)) {
                        log.error("", "bDispClearedFlag = TRUE");
                        for (int portIdx = 0; portIdx < nLen; portIdx++) {
                            if (ObjectIdentifier.equalsWithValue(params.getPortOperationModeList().get(portIdx).getPortID(), eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getPortID())) {
                                log.trace("", "portID", params.getPortOperationModeList().get(portIdx).getPortID());
                                if (CimStringUtils.equals(params.getPortOperationModeList().get(portIdx).getOperationMode().getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_ONLINELOCAL)
                                        || CimStringUtils.equals(params.getPortOperationModeList().get(portIdx).getOperationMode().getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_ONLINEREMOTE)) {
                                    log.trace("", "onlineMode", params.getPortOperationModeList().get(portIdx).getOperationMode().getOnlineMode());
                                    if (CimStringUtils.equals(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                                        log.error("", "Offline => Online");
                                        bDispUnloadCheckFlag = false;
                                        if (CimStringUtils.equals(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getAccessMode(), BizConstant.SP_EQP_ACCESSMODE_MANUAL)) {
                                            log.error("", "Offline => Online");
                                            bDispUnloadCheckFlag = false;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                    if (!CimStringUtils.isEmpty(ObjectIdentifier.isEmpty(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadedCassetteID()) ? null : eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadedCassetteID().getValue())
                            || !CimStringUtils.isEmpty(ObjectIdentifier.isEmpty(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadResrvedCassetteID()) ? null : eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadResrvedCassetteID().getValue())
                            || (CimBooleanUtils.isTrue(bDispLoadCheckFlag) && !CimStringUtils.isEmpty(ObjectIdentifier.isEmpty(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getDispatchLoadCassetteID()) ? null : eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getDispatchLoadCassetteID().getValue()))
                            || (CimBooleanUtils.isTrue(bDispUnloadCheckFlag) && !CimStringUtils.isEmpty(ObjectIdentifier.isEmpty(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getDispatchUnloadCassetteID()) ? null : eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getDispatchUnloadCassetteID().getValue()))) {
                        Boolean allowedFlag = false;
                        if (1 == chekcForNPWFlag && (CimStringUtils.equals(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_OTHER)
                                || CimStringUtils.equals(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)
                                || CimStringUtils.equals(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY)
                                || CimStringUtils.equals(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT)
                                || CimStringUtils.equals(eqpInfoInqResult.getEquipmentPortInfo().getEqpPortStatuses().get(jj).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT))) {
                            allowedFlag = true;
                            log.error("", "### A carrier is on port. But equipment mode change is allowed bacause the carrier is NPW purpose. ");
                        }
                        if (CimBooleanUtils.isFalse(allowedFlag)) {
                            log.error("", "loadedCarrier != NULL || reservedCarrier != NULL || dispatchCassette != NULL");
                            throw new ServiceException(retCodeConfig.getLotCassetteOnPort());
                        }
                    }
                }
                if (CimArrayUtils.isNotEmpty(eqpInfoInqResult.getEquipmentInprocessingControlJobList())) {
                    log.error("", "strEqpInfoInqResult.equipmentInprocessingControlJob.length != 0");
                    throw new ServiceException(retCodeConfig.getLotStatusProcessing());
                }
                int RSPportLen = CimObjectUtils.isEmpty(eqpInfoInqResult.getEquipmentAdditionalReticleAttribute()) ? 0 : CimObjectUtils.isEmpty(eqpInfoInqResult.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList()) ? 0 : eqpInfoInqResult.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().size();
                for (int i = 0; i < RSPportLen; i++) {
                    if (!CimStringUtils.isEmpty(ObjectIdentifier.isEmpty(eqpInfoInqResult.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getLoadedReticlePodID()) ? null : eqpInfoInqResult.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getLoadedReticlePodID().getValue())
                            || !CimStringUtils.isEmpty(ObjectIdentifier.isEmpty(eqpInfoInqResult.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getReservedReticlePodID()) ? null : eqpInfoInqResult.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getReservedReticlePodID().getValue())
                            || CimStringUtils.equals(eqpInfoInqResult.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getDispatchStatus(), BizConstant.SP_PORTRSC_DISPATCHSTATE_DISPATCHED)) {
                        Validations.check(retCodeConfigEx.getReticlePodNotOnRspPort(),ObjectIdentifier.fetchValue(eqpInfoInqResult.getEquipmentAdditionalReticleAttribute().getReticlePodPortIDList().get(i).getReticlePodPortID()));
                    }
                }
            }
        }
        equipmentMethod.equipmentPortOperationModeChange(objCommon, params.getEquipmentID(), params.getPortOperationModeList());

        if (CimBooleanUtils.isTrue(params.getNotifyToEqpFlag()) || CimBooleanUtils.isTrue(params.getNotifyToEAPFlag())) {
//            Inputs.SendEqpModeChangeReqIn sendEqpModeChangeReqIn = new Inputs.SendEqpModeChangeReqIn();
//            sendEqpModeChangeReqIn.setPortOperationModes(params.getPortOperationModeList());
//            sendEqpModeChangeReqIn.setObjCommonIn(objCommon);
//            sendEqpModeChangeReqIn.setEquipmentID(params.getEquipmentID());
//            sendEqpModeChangeReqIn.setNotifyToTCSFlag(params.getNotifyToEAPFlag());
//            sendEqpModeChangeReqIn.setNotifyToEqpFlag(params.getNotifyToEqpFlag());
//            //【sun】【2019/06/12】note the line:368, because oms waitting the reply of simulator-eap-rabbit,but it didn't deploy.
//            tcsMethod.sendTCSReq(TCSReqEnum.sendEqpModeChangeReq, sendEqpModeChangeReqIn);
            String tmpSleepTimeValue = StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue();
            String tmpRetryCountValue = StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue();
            Long sleepTimeValue = 0L;
            Long retryCountValue = 0L;

            if (0 == CimStringUtils.length(tmpSleepTimeValue)) {
                sleepTimeValue = BizConstant.SP_DEFAULT_SLEEP_TIME_TCS;
            } else {
                sleepTimeValue = CimNumberUtils.longValue(tmpSleepTimeValue);
            }

            if (0 == CimStringUtils.length(tmpRetryCountValue)) {
                retryCountValue = BizConstant.SP_DEFAULT_RETRY_COUNT_TCS;
            } else {
                retryCountValue = CimNumberUtils.longValue(tmpRetryCountValue);
            }

            for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                log.trace("{} {}", "loop to retryCountValue + 1", retryNum);
                log.debug("step15 - Send Request to EAP");
                IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,params.getUser(),params.getEquipmentID(),null,false);
                if (null == eapRemoteManager) {
                    log.debug("MES not configure EAP host");
                    break;
                }
                try {
                    Object modeChangeReqResult = eapRemoteManager.sendEqpModeChangeReq(params);
                    log.debug("Now EAP subSystem is alive!! Go ahead");
                    break;
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                        log.trace("{} {}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...", retryNum);
                        log.trace("{} {}", "now sleeping... ", sleepTimeValue);
                        if (retryNum != retryCountValue){
                            try {
                                Thread.sleep(sleepTimeValue);
                                continue;
                            } catch (InterruptedException e) {
                                ex.addSuppressed(e);
                                Thread.currentThread().interrupt();
                                throw ex;
                            }
                        }else {
                            Validations.check(true,retCodeConfig.getTcsNoResponse());
                        }
                    } else {
                        Validations.check(true,new OmCode(ex.getCode(),ex.getMessage()));
                    }
                }
            }
        }
        log.debug("step16 - add event to the equipment mode change");
        eventMethod.equipmentModeChangeEventMake(objCommon, params.getEquipmentID(), params.getPortOperationModeList(), params.getOpeMemo());
    }

    @Override
    public ObjectIdentifier sxEqpMemoAddReq(Infos.ObjCommon objCommon, Params.EqpMemoAddReqParams params) {
        log.debug("sxEqpMemoInfoInq(): enter here");

        ObjectIdentifier equipmentID = params.getEquipmentID();
        Inputs.ObjectLockModeGetIn objectLockModeGetIn = new Inputs.ObjectLockModeGetIn();
        objectLockModeGetIn.setObjectID(equipmentID);
        objectLockModeGetIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objectLockModeGetIn.setFunctionCategory(TransactionIDEnum.EQP_NOTE_REGIST_REQ.getValue());
        objectLockModeGetIn.setUserDataUpdateFlag(false);

        log.debug("step1 - get lock mode for equipment 【{}】",equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.EQP_NOTE_REGIST_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // Advanced Mode
            log.debug("Lock Equipment Main Object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(params.getEquipmentID());
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);


            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        }
        log.debug("maike equipment note");
        equipmentMethod.equipmentNoteMake(objCommon, params.getEquipmentID(), params.getNoteTitle(), params.getEquipmentNote());

        log.debug("step4 - add event");
        Inputs.ObjectNoteEventMakeParams objectNoteEventMakeParams = new Inputs.ObjectNoteEventMakeParams();
        objectNoteEventMakeParams.setObjectID(equipmentID);
        objectNoteEventMakeParams.setNoteType(BizConstant.SP_NOTETYPE_EQPNOTE);
        objectNoteEventMakeParams.setAction(BizConstant.SP_NOTEACTION_CREATE);
        objectNoteEventMakeParams.setNoteTitle(params.getNoteTitle());
        objectNoteEventMakeParams.setNoteContents(params.getEquipmentNote());
        objectNoteEventMakeParams.setOwnerID(objCommon.getUser().getUserID());
        objectNoteEventMakeParams.setTransactionID(objCommon.getTransactionID());
        objectNoteEventMakeParams.setClaimMemo(params.getClaimMemo());
        eventMethod.objectNoteEventMake(objCommon, objectNoteEventMakeParams);
        return equipmentID;
    }

    @Override
    public ObjectIdentifier sxPortStatusChangeRpt(Infos.ObjCommon objCommon, ObjectIdentifier equipmentID, List<Infos.EqpPortEventOnTCS> eqpPortEventOnTCSes, String claimMemo) {
        log.debug("step1 - if the portStatus is unKnow,change to '-'");
        for (Infos.EqpPortEventOnTCS eqpPortEventOnTCS : eqpPortEventOnTCSes) {
            if (BizConstant.SP_PORTRSC_PORTSTATE_UNKNOWNFORTCS.equals(eqpPortEventOnTCS.getPortStatus())) {
                eqpPortEventOnTCS.setPortStatus(BizConstant.SP_PORTRSC_PORTSTATE_UNKNOWN);
            }
        }

        log.debug("step2 - Lock objects to be updated - objectLockForEquipmentResource");
        int seqLen = CimArrayUtils.getSize(eqpPortEventOnTCSes);
        List<Boolean> accessModeFlags = new ArrayList<>();
        for (int i = 0; i < seqLen; i++) {
            objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, eqpPortEventOnTCSes.get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
        }

        log.debug("step3 - Check port Operation Mode - portResourceCurrentOperationModeGet");
        for (Infos.EqpPortEventOnTCS eqpPortEventOnTCS : eqpPortEventOnTCSes) {
            Outputs.ObjPortResourceCurrentOperationModeGetOut currentOperationModeOut = portMethod.portResourceCurrentOperationModeGet(objCommon, equipmentID, eqpPortEventOnTCS.getPortID());
            Infos.OperationMode operationMode = currentOperationModeOut.getOperationMode();

            log.trace("AccessMode is {}",operationMode.getAccessMode());
            if (BizConstant.SP_EQP_ACCESSMODE_AUTO.equals(operationMode.getAccessMode())) {
                accessModeFlags.add(true);
            } else {
                accessModeFlags.add(false);
            }

            log.trace("OnlineMode is {}",operationMode.getOnlineMode());
            if (BizConstant.SP_EQP_ONLINEMODE_OFFLINE.equals(operationMode.getOnlineMode())) {
                Validations.check(retCodeConfig.getInvalidEquipmentMode(), ObjectIdentifier.fetchValue(equipmentID),
                        operationMode.getOnlineMode());
            }
        }

        log.debug("step4 - Check eqp TakeOutInMode  - equipmentTakeOutInModeCheck");
        Long eqpTakeOutInSupport = equipmentMethod.equipmentTakeOutInModeCheck(objCommon, equipmentID);

        log.debug("step5 - Get eqp port information - equipmentPortInfoGet");
        boolean takeOutInModeFlag = false;

        Infos.EqpPortInfo eqpPortInfo = null;
        log.trace("eqpTakeOutInSupport is {}",eqpTakeOutInSupport);
        if (eqpTakeOutInSupport == 1) {
            eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID);
        }

        List<Infos.DeleteUnloadableLot> deleteUnloadableLots = new ArrayList<>();

        for (int i = 0; i < eqpPortEventOnTCSes.size(); i++) {
            Infos.EqpPortEventOnTCS eqpPortEventOnTCS = eqpPortEventOnTCSes.get(i);
            log.trace("eqpTakeOutInSupport is {}",eqpTakeOutInSupport);
            if (eqpTakeOutInSupport == 1) {
                List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo.getEqpPortStatuses();
                for (Infos.EqpPortStatus eqpPortStatus : eqpPortStatuses) {
                    //Check port controlJob existence
                    if (ObjectIdentifier.equalsWithValue(eqpPortEventOnTCS.getPortID().getValue(), eqpPortStatus.getPortID()) && !ObjectIdentifier.isEmpty(eqpPortStatus.getLoadResrvedCassetteID())) {
                        log.debug("step6 - equipmentPortStateChangeForTakeOutInMode");
                        portMethod.equipmentPortStateChangeForTakeOutInMode(objCommon, equipmentID, eqpPortEventOnTCS.getPortID(), eqpPortEventOnTCS.getPortStatus(), eqpPortEventOnTCS.getCassetteID());
                        takeOutInModeFlag = true;
                        break;
                    }
                }

                log.trace("takeOutInModeFlag is {}",takeOutInModeFlag);
                if (takeOutInModeFlag) {
                    continue;
                }
            }

            log.debug("step7 - Change eqp port Status - equipmentPortStateChange");
            portMethod.equipmentPortStateChange(objCommon, equipmentID, eqpPortEventOnTCS.getPortID(), eqpPortEventOnTCS.getPortStatus(), eqpPortEventOnTCS.getCassetteID());

            log.trace("portStatus is {}",eqpPortEventOnTCS.getPortStatus());
            if (BizConstant.SP_PORTRSC_PORTSTATE_UNLOADCOMP.equals(eqpPortEventOnTCS.getPortStatus())) {
                /*-----------------------------------------------------------*/
                /*   Set Unload lot Information to be deleted in eqp   */
                /*-----------------------------------------------------------*/
                if (CimStringUtils.isEmpty(eqpPortEventOnTCS.getLotID().getValue()) && CimStringUtils.isEmpty(eqpPortEventOnTCS.getCassetteID().getValue())) {
                    continue;
                }

                Infos.DeleteUnloadableLot deleteUnloadableLot = new Infos.DeleteUnloadableLot();
                deleteUnloadableLot.setLotID(eqpPortEventOnTCS.getLotID());

                deleteUnloadableLot.setUnloadPortID(eqpPortEventOnTCS.getPortID());

                deleteUnloadableLots.add(deleteUnloadableLot);
            }

            if (BizConstant.SP_PORTRSC_PORTSTATE_LOADREQ.equals(eqpPortEventOnTCS.getPortStatus())) {
                log.debug("Step8 - Check NPW Reservation for Fixed buffer equipment - equipmentBrInfoForInternalBufferGetDR");
                Infos.EqpBrInfoForInternalBuffer eqpPortInfoInternalBuffer = equipmentMethod.equipmentBrInfoForInternalBufferGetDR(objCommon, equipmentID);

                if (eqpPortInfoInternalBuffer != null && !CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_INTERNALBUFFER, eqpPortInfoInternalBuffer.getEquipmentCategory())) {
                    //-------------------------------------
                    //   Get Reserve CarrierID
                    //-------------------------------------
                    List<Outputs.NPWReserveInfo> npwReserveInfoList = equipmentMethod.equipmentNPWReserveInfoGetDR(objCommon, equipmentID);

                    for (Outputs.NPWReserveInfo npwReserveInfo : npwReserveInfoList) {
                        if (CimStringUtils.equals(npwReserveInfo.getCassetteID().getValue(), eqpPortEventOnTCSes.get(i).getPortID().getValue())) {
                            log.debug("step9 - Check Cassette's Dispatch State - cassetteDispatchStateGet");
                            Boolean cassetteDispatchState = cassetteMethod.cassetteDispatchStateGet(objCommon, npwReserveInfo.getCassetteID());

                            log.trace("cassetteDispatchState is {}",cassetteDispatchState);
                            if (CimBooleanUtils.isFalse(cassetteDispatchState)) {
                                log.debug("dispatchReservedFlag == FALSE, dispatchReserve is already Cleared.");
                            } else {
                                log.debug("step10 - Need to Change Cassette's Dispatch State to FALSE.");
                                cassetteMethod.cassetteDispatchStateChange(objCommon, npwReserveInfo.getCassetteID(), false);

                                log.debug("step11 - Change Cassette's NPWLoadPurposeType to NULL");
                                cassetteMethod.cassetteSetNPWLoadPurposeType(objCommon, npwReserveInfo.getCassetteID(), null);
                            }
                        }
                    }
                }

                log.debug("step12 - Get All Ports registered as Same port Group - equipment_portGroupInfo_Get");
                Outputs.ObjEquipmentPortGroupInfoGetOut portGroupInfoGetOut = portMethod.equipmentPortGroupInfoGet(objCommon, equipmentID, null, eqpPortEventOnTCS.getPortID());

                List<Infos.EqpPortAttributes> eqpPortAttributesList = portGroupInfoGetOut.getEqpPortAttributes();

                /*------------------------------*/
                /* Find Port ID to be Updated   */
                /*------------------------------*/
                for (Infos.EqpPortAttributes eqpPortAttributes : eqpPortAttributesList) {
                    if (eqpPortEventOnTCS.getPortID().getValue().equals(eqpPortAttributes.getPortID().getValue())) {
                        continue;
                    }

                    if (BizConstant.SP_PORTRSC_PORTSTATE_LOADREQ.equals(eqpPortAttributes.getPortState())
                            && BizConstant.SP_PORTRSC_DISPATCHSTATE_NOTDISPATCHED.equals(eqpPortAttributes.getDispatchState())) {
                        log.debug("step13 Change Same Group's Not-Specified Port's DispatchState to Required");
                        equipmentMethod.equipmentDispatchStateChange(objCommon, equipmentID,
                                eqpPortAttributes.getPortID(), BizConstant.SP_PORTRSC_DISPATCHSTATE_REQUIRED,
                                null, null, null, null);
                    }
                }
            }

            if (BizConstant.SP_PORTRSC_PORTSTATE_UNLOADREQ.equals(eqpPortEventOnTCS.getPortStatus())) {
                log.debug("step14 - Check NPW Reservation for Fixed buffer equipment");
                Infos.EqpBrInfoForInternalBuffer eqpPortInfoInternalBuffer = equipmentMethod.equipmentBrInfoForInternalBufferGetDR(objCommon, equipmentID);
                if (eqpPortInfoInternalBuffer != null && !CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_INTERNALBUFFER, eqpPortInfoInternalBuffer.getEquipmentCategory())) {
                    log.debug("step15 - Get Reserve CarrierID - equipmentNPWReserveInfoGetDR");
                    List<Outputs.NPWReserveInfo> npwReserveInfoList = equipmentMethod.equipmentNPWReserveInfoGetDR(objCommon, equipmentID);

                    for (Outputs.NPWReserveInfo npwReserveInfo : npwReserveInfoList) {
                        if (CimStringUtils.equals(npwReserveInfo.getCassetteID().getValue(), eqpPortEventOnTCSes.get(i).getPortID().getValue())) {
                            log.debug("step16 - Check Cassette's Dispatch State - cassetteDispatchStateGet");
                            Boolean cassetteDispatchState = cassetteMethod.cassetteDispatchStateGet(objCommon, npwReserveInfo.getCassetteID());

                            log.trace("cassetteDispatchState is {}",cassetteDispatchState);
                            if (CimBooleanUtils.isFalse(cassetteDispatchState)) {
                                log.debug("dispatchReservedFlag == FALSE, dispatchReserve is already Cleared.");
                            } else {
                                log.info("step17 - Need to Change Cassette's Dispatch State to FALSE - cassetteDispatchStateChange");
                                cassetteMethod.cassetteDispatchStateChange(objCommon, npwReserveInfo.getCassetteID(), false);

                                log.debug("step18 - Change Cassette's NPWLoadPurposeType to NULL - cassetteSetNPWLoadPurposeType");
                                cassetteMethod.cassetteSetNPWLoadPurposeType(objCommon, npwReserveInfo.getCassetteID(), null);
                            }

                        }
                    }
                }

                log.debug("step19 - sxAlertMessageRpt");
                if (accessModeFlags.get(i) && CimStringUtils.isEmpty(ObjectIdentifier.fetchValue(eqpPortEventOnTCS.getCassetteID())) && CimStringUtils.isEmpty(ObjectIdentifier.fetchReferenceKey(eqpPortEventOnTCS.getCassetteID()))) {
                    //-------------------------------------------------------
                    // Prepare e-mail Message Text
                    //-------------------------------------------------------
                    Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                    alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                    alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_DELIVERYERROR);
                    String msgStringBuffer = "<<< Unexpected Carrier was Placed >>>" + "\n" +
                            "Eqpipment ID         : " +
                            equipmentID.getValue() + "\n" +
                            "Port ID              : " +
                            eqpPortEventOnTCS.getPortID().getValue() + "\n" +
                            "Port State           :" +
                            eqpPortEventOnTCS.getPortStatus() + "\n" +
                            "Lot ID               : " +
                            eqpPortEventOnTCS.getLotID().getValue() + "\n" +
                            "Cassette ID          : " +
                            eqpPortEventOnTCS.getCassetteID().getValue() + "\n";
                    alertMessageRptParams.setSystemMessageText(msgStringBuffer);
                    alertMessageRptParams.setNotifyFlag(true);
                    alertMessageRptParams.setEquipmentID(equipmentID);
                    alertMessageRptParams.setLotID(eqpPortEventOnTCS.getLotID());
                    alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                    systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);

                }
            }

            /*-----------------------------------------------------------*/
            /*      Create event for eqp port status change        */
            /*-----------------------------------------------------------*/
            Inputs.EquipmentPortStatusChangeEventMakeParams equipmentPortStatusChangeEventMakeParams = new Inputs.EquipmentPortStatusChangeEventMakeParams();
            equipmentPortStatusChangeEventMakeParams.setEquipmentID(equipmentID);
            equipmentPortStatusChangeEventMakeParams.setPortType(BizConstant.SP_DURABLECAT_CASSETTE);
            equipmentPortStatusChangeEventMakeParams.setPortID(eqpPortEventOnTCS.getPortID());
            equipmentPortStatusChangeEventMakeParams.setPortStatus(eqpPortEventOnTCS.getPortStatus());
            equipmentPortStatusChangeEventMakeParams.setDispatchDurableID(ObjectIdentifier.fetchValue(eqpPortEventOnTCS.getCassetteID()));
            equipmentPortStatusChangeEventMakeParams.setClaimMemo(claimMemo);

            log.debug("step20 - get equipment port group info - equipmentPortGroupInfoGet");
            Outputs.ObjEquipmentPortGroupInfoGetOut portGroupInfoGetOut = portMethod.equipmentPortGroupInfoGet(objCommon, equipmentID, null, eqpPortEventOnTCS.getPortID());
            List<Infos.EqpPortAttributes> eqpPortAttributesList = portGroupInfoGetOut.getEqpPortAttributes();
            if (!CimObjectUtils.isEmpty(eqpPortAttributesList)) {
                for (Infos.EqpPortAttributes eqpPortAttributes : eqpPortAttributesList) {
                    if (ObjectIdentifier.equalsWithValue(eqpPortEventOnTCS.getPortID(), eqpPortAttributes.getPortID())) {
                        equipmentPortStatusChangeEventMakeParams.setPortUsage(eqpPortAttributes.getPortUsage());
                        equipmentPortStatusChangeEventMakeParams.setAccessMode(eqpPortAttributes.getCurrentAccessMode());
                        equipmentPortStatusChangeEventMakeParams.setDispatchTime(eqpPortAttributes.getPortDispatchTimeStamp());
                        equipmentPortStatusChangeEventMakeParams.setDispatchState(eqpPortAttributes.getDispatchState());
                        break;
                    }
                }
            }

            log.debug("step21 - add equipment port change event");
            eventMethod.equipmentPortStatusChangeEventMake(objCommon, equipmentPortStatusChangeEventMakeParams);
        }

        return equipmentID;
    }

    @Override
    public void sxRunningHoldReq(Infos.ObjCommon objCommon, ObjectIdentifier equipmentId, ObjectIdentifier controlJobId, ObjectIdentifier holdReasonCodeId, String claimMemo) {
        //Check Prcess
        log.debug("sxRunningHoldReq", "Check Prcess");

        log.trace("equipmentId is 【{}】，controlJobId is 【{}】",equipmentId.getValue(),controlJobId.getValue());
        if (CimObjectUtils.isEmpty(equipmentId.getValue()) && CimObjectUtils.isEmpty(controlJobId.getValue())) {
            log.info("sxRunningHoldReq", "StringUtils.isEmpty(equipmentId.getValue()) && StringUtils.isEmpty(controlJobId.getValue())");
            throw new ServiceException(new OmCode(retCodeConfig.getNotFoundEqp(), equipmentId.getValue()));
        }

        log.debug("step1 - Get Inprocessing ControlJobID");
        List<Infos.EqpInprocessingControlJob> eqpInprocessingControlJobs = equipmentMethod.equipmentInprocessingControlJobInfoGetDR(objCommon, equipmentId);

        //Check ControlJobID
        if (CimStringUtils.isNotEmpty(equipmentId.getValue()) && CimStringUtils.isNotEmpty(controlJobId.getValue())) {
            log.trace("sxRunningHoldReq", "StringUtils.isNotEmpty(equipmentId.getValue()) && StringUtils.isNotEmpty(controlJobId.getValue())");
            int mLen = CimArrayUtils.getSize(eqpInprocessingControlJobs);
            log.trace("sxRunningHoldReq", "mLen:{}", mLen);
            log.trace("sxRunningHoldReq", "Input controlJobID:{}", controlJobId.getValue());
            Boolean matchFlag = false;
            for (int jCnt = 0; jCnt < mLen; jCnt++) {
                log.trace("sxRunningHoldReq", "jCnt:{}", jCnt);
                log.trace("sxRunningHoldReq", "InProcessing controlJobID:{}", eqpInprocessingControlJobs.get(jCnt).getControlJobID().getValue());
                if (CimStringUtils.equals(controlJobId.getValue(), eqpInprocessingControlJobs.get(jCnt).getControlJobID().getValue())) {
                    log.trace("sxRunningHoldReq", "Input controlJobID == InProcessing controlJobID ,matchFlag = TRUE");
                    matchFlag = true;
                    break;
                }
            }
            if (CimBooleanUtils.isFalse(matchFlag)) {
                log.trace("sxRunningHoldReq", "matchFlag == FALSE");
                throw new ServiceException(retCodeConfig.getUnmatchControljobEqpVsCast());
            }
        }
        log.debug("step2 - check code existance");
        List<ObjectIdentifier> strCheckedCodes = new ArrayList<>();
        strCheckedCodes.add(holdReasonCodeId);
        String cateGoryId = BizConstant.SP_REASONCAT_LOTHOLD;
        codeMethod.codeCheckExistanceDR(objCommon, cateGoryId, strCheckedCodes);

        log.debug("step3 - Get CassetteList & LotList");
        int lotCnt = 0;
        int lotLen = 0;
        Outputs.ObjControlJobStartReserveInformationOut controlJobStartReserveInformationOut =
                controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                        controlJobId,
                        false);

        log.debug("step4 - Object Lock Prcess");
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentId);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.RUNNING_HOLD_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step5 - lock equipment main object");
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentId);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            log.debug("step6 - lock object equipment for 【{}】",controlJobStartReserveInformationOut.getEquipmentID());
            objectLockMethod.objectLock(objCommon, CimMachine.class, controlJobStartReserveInformationOut.getEquipmentID());
        }
        List<Infos.StartCassette> startCassetteList = controlJobStartReserveInformationOut.getStartCassetteList();
        int mLen = CimArrayUtils.getSize(startCassetteList);
        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
        for (int jCnt = 0; jCnt < mLen; jCnt++) {
            /*--------------------*/
            /*   Lock Cassette    */
            /*--------------------*/
            if (!ObjectIdentifier.isEmptyWithValue(startCassetteList.get(jCnt).getCassetteID())) {
                cassetteIDs.add(startCassetteList.get(jCnt).getCassetteID());
            }
            List<Infos.LotInCassette> lotInCassetteList = startCassetteList.get(jCnt).getLotInCassetteList();
            int lLen = CimArrayUtils.getSize(lotInCassetteList);
            for (int kCnt = 0; kCnt < lLen; kCnt++) {
                if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE) && CimBooleanUtils.isFalse(lotInCassetteList.get(kCnt).getMoveInFlag())) {
                    continue;
                }
                lotIDs.add(lotInCassetteList.get(kCnt).getLotID());
            }
        }
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            log.debug("step7 - Lock Equipment ProcLot Element (Read)");
            List<String> procLotSeq = lotIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(
                    controlJobStartReserveInformationOut.getEquipmentID(),
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ, procLotSeq));

            log.debug("step8 - Lock ControlJob Object");
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobId);
        }
        log.debug("step9 - Lock Cassette Object");
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);

        log.debug("step10 - Lock Lot Object");
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, lotIDs);
        //Main Process
        log.debug("sxRunningHoldReq", "Main Process");

        log.trace("sxRunningHoldReq", "mLen:{}", mLen);
        for (int jCnt = 0; jCnt < mLen; jCnt++) {
            int lLen = CimArrayUtils.getSize(controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getLotInCassetteList());
            log.trace("sxRunningHoldReq", "mLen:{}", mLen);
            for (int kCnt = 0; kCnt < lLen; kCnt++) {
                log.trace("sxRunningHoldReq", "lotAllStateGet:{}", controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getLotInCassetteList().get(kCnt).getLotID().getValue());
                if (CimBooleanUtils.isFalse(controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getLotInCassetteList().get(kCnt).getMoveInFlag())) {
                    log.trace("sxRunningHoldReq", "operationStartFlag == False");
                    log.trace("sxRunningHoldReq", "LotID::,{}", controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getLotInCassetteList().get(kCnt).getLotID().getValue());
                    continue;
                }
                log.debug("step11 - Retrieve all state for Lot");
                Outputs.ObjLotAllStateGetOut lotAllStateGetOut = lotMethod.lotAllStateGet(objCommon, controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getLotInCassetteList().get(kCnt).getLotID());

                log.trace("ProcessState is 【{}】",lotAllStateGetOut.getProcessState());
                if (!CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING, lotAllStateGetOut.getProcessState())) {
                    log.trace("sxRunningHoldReq", "lotAllStateGet() strLot_allState_Get_out.processState == SP_Lot_ProcState_Processing");
                    throw new ServiceException(retCodeConfig.getInvalidLotProcstat());
                }
                log.trace("HoldState is 【{}】",lotAllStateGetOut.getHoldState());
                if (!CimStringUtils.equals(CIMStateConst.CIM_LOT_HOLD_STATE_NOTONHOLD, lotAllStateGetOut.getHoldState())) {
                    log.trace("sxRunningHoldReq", "HoldState == OnHold");
                    continue;
                }

                //Set Data
                List<Infos.LotHoldReq> strLotHoldReqList = new ArrayList<>();
                Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                lotHoldReq.setHoldType(BizConstant.SP_HOLDTYPE_LOTHOLD);
                lotHoldReq.setHoldReasonCodeID(holdReasonCodeId);
                lotHoldReq.setHoldUserID(objCommon.getUser().getUserID());
                lotHoldReq.setClaimMemo(claimMemo);
                lotHoldReq.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                lotHoldReq.setRouteID(new ObjectIdentifier(""));
                lotHoldReq.setOperationNumber("");
                lotHoldReq.setRelatedLotID(new ObjectIdentifier(""));
                strLotHoldReqList.add(lotHoldReq);

                log.debug("step12 - hold lot");
                List<Infos.HoldHistory> LotHoldOut = lotMethod.lotHold(objCommon, controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getLotInCassetteList().get(kCnt).getLotID(), strLotHoldReqList);

                // empty startCassette.cassetteID is allowed by SLM
                if (ObjectIdentifier.isNotEmpty(controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getCassetteID())) {
                    log.trace("cassette is 【{}】",controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getCassetteID().getValue());
                    log.debug("step13 - Update Cassette's MultiLotType");
                    cassetteMethod.cassetteMultiLotTypeUpdate(objCommon,
                            controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getCassetteID());
                }
                log.debug("step14 - event make");
                String transactionId = TransactionIDEnum.RUNNING_HOLD_REQ.getValue();
                Inputs.LotHoldEventMakeParams lotHoldEventMakeParams = new Inputs.LotHoldEventMakeParams();
                lotHoldEventMakeParams.setTransactionID(transactionId);
                lotHoldEventMakeParams.setLotID(controlJobStartReserveInformationOut.getStartCassetteList().get(jCnt).getLotInCassetteList().get(kCnt).getLotID());
                lotHoldEventMakeParams.setHoldHistoryList(LotHoldOut);
                eventMethod.lotHoldEventMake(objCommon, lotHoldEventMakeParams);
            }
        }
    }

    @Override
    public Results.ForceMoveOutReqResult sxForceMoveOutReq(Infos.ObjCommon objCommon,
                                                           ObjectIdentifier equipmentID,
                                                           ObjectIdentifier controlJobID,
                                                           Boolean spcResultRequiredFlag,
                                                           String claimMemo) {
        //init
        log.info("PPTManager_i:: txForceMoveOutReq");
        Results.ForceMoveOutReqResult out = new Results.ForceMoveOutReqResult();
        int postProcForLotFlag = StandardProperties.OM_PP_FOR_LOT_MOVEOUT_FLAG.getIntValue();

        //Check Process
        log.info("Check Transaction ID and equipment Category combination.");

        //【step1】equipment_categoryVsTxID_CheckCombination
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);
        //Object Lock Process
        boolean emptyPortFlag = false;

        //Get Started Lot information which is sepcified with ControlJob ID
        //【step2】controlJob_startReserveInformation_Get
        Outputs.ObjControlJobStartReserveInformationOut controlJobStartReserveInformationOut =
                controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                        controlJobID,
                        false);
        // step 3 object_lockMode_Get
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.FORCE_OPERATION_COMP_REQ.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        Inputs.ObjAdvanceLockIn strAdvancedobjecLockin = new Inputs.ObjAdvanceLockIn();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            // step 4 advanced_object_Lock
            List<String> dummySeq;
            dummySeq = new ArrayList<>(0);
            strAdvancedobjecLockin.setObjectID(equipmentID);
            strAdvancedobjecLockin.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvancedobjecLockin.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvancedobjecLockin.setLockType(objLockModeOut.getRequiredLockForMainObject());
            strAdvancedobjecLockin.setKeyList(dummySeq);

            objectLockMethod.advancedObjectLock(objCommon, strAdvancedobjecLockin);
        } else {
            // step 5 object_Lock
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }
        /*--------------------------------*/
        /*   Lock Cassette / Lot Object   */
        /*--------------------------------*/
        List<Infos.StartCassette> strStartCassette = controlJobStartReserveInformationOut.getStartCassetteList();
        int scLen = CimArrayUtils.getSize(strStartCassette);
        Validations.check(scLen <= 0, new OmCode(retCodeConfig.getNotFoundCassette(), "(There is no started cassette.)"));
        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();
        for (int i = 0; i < scLen; i++) {
            List<Infos.LotInCassette> lotInCassetteList = strStartCassette.get(i).getLotInCassetteList();
            int nLen = CimArrayUtils.getSize(lotInCassetteList);
            /*--------------------------*/
            /*   Lock Cassette Object   */
            /*--------------------------*/
            if (CimStringUtils.equals(strStartCassette.get(i).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                emptyPortFlag = true;
                // step 6 equipment_monitorCreationFlag_Get
                try {
                    equipmentMethod.equipmentMonitorCreationFlagGet(objCommon, equipmentID);
                } catch (ServiceException e) {
                    if (Validations.isEquals(retCodeConfigEx.getMonitorCreatReqd(), e.getCode())) {
                        if (nLen == 0) {
                            throw e;
                        }
                    } else if (Validations.isEquals(retCodeConfig.getNotFoundEqp(), e.getCode())) {
                        throw e;
                    } else {
                        // Do nothing.
                    }
                }
                cassetteIDs.add(strStartCassette.get(i).getCassetteID());
                continue;
            }
            cassetteIDs.add(strStartCassette.get(i).getCassetteID());
            for (int j = 0; j < nLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(lotInCassetteList.get(j).getMoveInFlag())) {
                    continue;
                }
                lotIDs.add(lotInCassetteList.get(j).getLotID());
            }
        }

        //【step7】 equipment_brInfo_GetDR__120
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentID);
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            //【step8】 equipment_onlineMode_Get
            log.info("lockMode != SP_EQP_LOCK_MODE_WRITE");
            String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
            if (CimStringUtils.equals(onlineMode, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                // Lock Equipment ProcLot Element (Count)
                // step9 advanced_object_Lock
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT, new ArrayList<>()));
            }
            // step10 advanced_object_Lock
            List<String> procLotSeq = lotIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, procLotSeq));
            // For wafer stacking, lock load cassette
            if (CimStringUtils.equals(eqpBrInfo.getEquipmentCategory(), BizConstant.SP_MC_CATEGORY_WAFERBONDING) && 1 != postProcForLotFlag) {
                List<String> loadCastSeq = cassetteIDs.stream().map(ObjectIdentifier::getValue).collect(Collectors.toList());
                // Lock Equipment LoadCassette Element (Write)
                // step11 advanced_object_Lock
                objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                        BizConstant.SP_CLASSNAME_POSMACHINE,
                        BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                        (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, loadCastSeq));
            }
            // step12 object_Lock
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
        }
        /*------------------------------*/
        /*   Lock Cassette/Lot Object   */
        /*-------------------------------*/
        // step13 objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimCassette.class, cassetteIDs);
        // step14 objectSequence_Lock
        objectLockMethod.objectSequenceLock(objCommon, CimLot.class, lotIDs);

        //  add season by ho
        seasoningService.sxSeasonForForceMoveOut(objCommon, equipmentID);

        //TODO-NOTIMPL: step15 cassette_APCInformation_GetDR
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Check Process                                                       */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        boolean SLMCapabilityFlag = eqpBrInfo.isFmcCapabilityFlag();
        List<ObjectIdentifier> destCassetteList = new ArrayList<>();
        int destCassetteListLen = 0;
        int pstLen = 0;
        if (SLMCapabilityFlag) {
            // step16 object_LockForEquipmentContainerPosition
            Inputs.ObjObjectLockForEquipmentContainerPositionIn objObjectLockForEquipmentContainerPositionIn = new Inputs.ObjObjectLockForEquipmentContainerPositionIn();
            objObjectLockForEquipmentContainerPositionIn.setEquipmentID(equipmentID);
            objObjectLockForEquipmentContainerPositionIn.setControlJobID(controlJobID);
            objectLockMethod.objectLockForEquipmentContainerPosition(objCommon, objObjectLockForEquipmentContainerPositionIn);
            //【step17】equipmentContainerPosition_info_Get
            String keyCategory = BizConstant.SP_SLM_KEYCATEGORY_CONTROLJOB;
            Infos.EqpContainerPositionInfo equipmentContainerPositionInfoOut = equipmentMethod.equipmentContainerPositionInfoGet(objCommon, equipmentID, controlJobID, keyCategory);
            pstLen = CimArrayUtils.getSize(equipmentContainerPositionInfoOut.getEqpContainerPositionList());
            log.info("pstLen", pstLen);
            if (pstLen > 0) {
                log.info("pstLen > 0");
                Infos.EqpContainerPosition tmpStrEqpContainerPosition = new Infos.EqpContainerPosition();
                log.info("Get Destination Cassette List");
                int nCnt1 = 0;
                int nCnt2 = 0;
                for (nCnt1 = 0; nCnt1 < pstLen; nCnt1++) {
                    log.info("# Loop[nCnt1], nCnt1 = ", nCnt1);
                    tmpStrEqpContainerPosition = equipmentContainerPositionInfoOut.getEqpContainerPositionList().get(nCnt1);
                    /*-----------------------------------------------------------------------*/
                    /*   Check SLM condition for EqpContainerPosition                        */
                    /*   The following conditions are checked by this object                 */
                    /*   - All SLM Status of Equipment container position which has relation */
                    /*     with controljob has NOT to be 'Stored'.                           */
                    /*-----------------------------------------------------------------------*/
                    if (CimStringUtils.equals(BizConstant.SP_SLMSTATE_STORED, tmpStrEqpContainerPosition.getFmcState())) {
                        log.info("# SLMState = SP_SLMState_Stored");
                        throw new ServiceException(retCodeConfig.getInvalidSLMStatusOfContainerPosition());
                    }
                    // --------------------------------------------------------------
                    // Get Destination Cassette List.
                    // These cassettes should be locked before update
                    // --------------------------------------------------------------
                    if (!ObjectIdentifier.isEmptyWithValue(tmpStrEqpContainerPosition.getDestCassetteID())) {
                        // destination cassette is assigned
                        for (nCnt2 = 0; nCnt2 < destCassetteListLen; nCnt2++) {
                            if (ObjectIdentifier.equalsWithValue(destCassetteList.get(nCnt2), tmpStrEqpContainerPosition.getDestCassetteID())) {
                                // found destnationCast
                                break;
                            }
                        }
                        if (nCnt2 == destCassetteListLen) {
                            // new destcassette
                            destCassetteListLen++;
                            destCassetteList.add(tmpStrEqpContainerPosition.getDestCassetteID());
                        }
                    }
                }
                // step18 object_Lock
                for (nCnt1 = 0; nCnt1 < destCassetteListLen; nCnt1++) {
                    // lock the cassette
                    objectLockMethod.objectLock(objCommon, CimCassette.class, destCassetteList.get(nCnt1));
                }
            }
        }
        //Get Equipment's Online Mode
        //【step19】portResource_currentOperationMode_Get
        Outputs.ObjPortResourceCurrentOperationModeGetOut portResourceCurrentOperationModeOut = portComp.portResourceCurrentOperationModeGet(objCommon, equipmentID, strStartCassette.get(0).getUnloadPortID());
        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process for Lot                                               */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   - lotProcessState                                                   */
        /*   - lotHoldState                                                      */
        /*-----------------------------------------------------------------------*/
        for (int i = 0; i < scLen; i++) {
            int nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }
                //【step20】  lot_allState_Get
                Outputs.ObjLotAllStateGetOut lotAllStateGetOut = lotMethod.lotAllStateGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                if (!CimStringUtils.equals(BizConstant.SP_LOT_PROCSTATE_PROCESSING, lotAllStateGetOut.getProcessState())) {
                    log.info("lot_allState_Get() strLot_allState_Get_out.processState == SP_Lot_ProcState_Processing");
                    throw new ServiceException(retCodeConfig.getInvalidLotProcstat());
                }
                if (CimStringUtils.equals(BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD, lotAllStateGetOut.getHoldState())) {
                    log.info("HoldState == NotOnHold");
                    throw new ServiceException(retCodeConfig.getInvalidLotHoldStat());
                }
            }
        }
        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process for Equipment                                         */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   - All of lot which is contained in controlJob must be existing      */
        /*     in the equipment's processing information.                        */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        //【step21】equipment_CheckConditionForOpeComp
        equipmentMethod.equipmentCheckConditionForOpeComp(objCommon, equipmentID, strStartCassette);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Main Process (Reverse Order of OpeStart Procedure)                  */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        //TODO【step22】 - configurationInformation_GetDR  hxd
        /*---------------------------------------------------------------------*/
        /*   In case of post process migration mode, fix PostProcForLotFlag    */
        /*---------------------------------------------------------------------*/
        if (postProcForLotFlag == -1) {
            Infos.ConfigInfo configurationInformationGetDROut = null;
            try {
                configurationInformationGetDROut = cimComp.configurationInformationGetDR(objCommon, ObjectIdentifier.fetchValue(equipmentID), BizConstant.SP_CONFIGURATIONCATEGORY_EQUIPMENTPOSTPROCDECOUPLEMODE);
            } catch (ServiceException ex) {
                if (Validations.isEquals(retCodeConfig.getNotFoundEntry(), ex.getCode())) {
                    log.info("Entry isn't found in OSPPRCCONFIG");
                    postProcForLotFlag = 0;
                } else {
                    if (CimStringUtils.equals(configurationInformationGetDROut.getValue(), "1")) {
                        log.info("EquipmentPostProcActionDecoupleMode = 1");
                        postProcForLotFlag = 1;
                    } else {
                        log.info("EquipmentPostProcActionDecoupleMode != 1");
                        postProcForLotFlag = 0;
                    }
                }
            }
            // Store PostProcForLotFlag as thread specific data
            ThreadContextHolder.setThreadSpecificDataString(BizConstant.SP_THREADSPECIFICDATA_KEY_POSTPROCFORLOTFLAG, String.valueOf(postProcForLotFlag));
        }

        for (Infos.StartCassette startCassette : strStartCassette) {
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                    continue;
                }
                /*-----------------------------------------*/
                /*   Check Test Type of Current Process    */
                /*-----------------------------------------*/
                ObjectIdentifier testTypeID = null;
                try {
                    testTypeID = lotMethod.lotTestTypeIDGet(objCommon, lotInCassette.getLotID());
                } catch (ServiceException ex) {
                    if (!Validations.isEquals(retCodeConfig.getNotFoundTestType(), ex.getCode())) {
                        throw ex;
                    }
                }

                if (!ObjectIdentifier.isEmpty(testTypeID)) {
                    /*---------------------------------------------------------------*/
                    /*   Gather Bin Summary Information based on lotID & testTypeID  */
                    /*---------------------------------------------------------------*/
                    List<Infos.WaferBinSummary> waferBinSummaries = binSummaryMethod.binSummaryGetByTestTypeDR(objCommon, lotInCassette.getLotID(), testTypeID);
                    /*----------------------------------------------------------*/
                    /*   Update Wafer Die quantity based on the input parameter  */
                    /*-----------------------------------------------------------*/
                    List<Infos.LotWaferAttributes> lotWaferAttributes = new ArrayList<>();
                    for (Infos.WaferBinSummary waferBinSummary : waferBinSummaries) {
                        if (waferBinSummary.getBinReportCount() > 0) {
                            Infos.LotWaferAttributes lotWaferAttribute = new Infos.LotWaferAttributes();
                            lotWaferAttribute.setWaferID(waferBinSummary.getWaferId());
                            lotWaferAttribute.setGoodUnitCount(waferBinSummary.getGoodUnitCount());
                            lotWaferAttribute.setRepairUnitCount(waferBinSummary.getRepairUnitCount());
                            lotWaferAttribute.setFailUnitCount(waferBinSummary.getFailUnitCount());
                            lotWaferAttributes.add(lotWaferAttribute);
                        }
                    }
                    lotMethod.lotWaferChangeDie(objCommon, lotInCassette.getLotID(), lotWaferAttributes);
                }
            }
        }
        /*------------------------------------------------------*/
        /*                                                      */
        /*     FlowBatch Related Information Update Procedure   */
        /*                                                      */
        /*------------------------------------------------------*/
        /*----------------------------------------------------------*/
        /*   Update FlowBatch Information of Equipment              */
        /*----------------------------------------------------------*/
        //【step26】 flowBatch_Information_UpdateByOpeComp
        flowBatchMethod.flowBatchInformationUpdateByOpeComp(objCommon, equipmentID, strStartCassette);

        /*----------------------------------------------*/
        /*                                              */
        /*   Process Operation Update Procedure         */
        /*                                              */
        /*----------------------------------------------*/
        /*-------------------------------------------------*/
        /*   Update Process Operation (actual comp xxxx)   */
        /*-------------------------------------------------*/
        //【step27】 process_actualCompInformation_Set
        processMethod.processActualCompInformationSet(objCommon, strStartCassette);
        boolean bondingEqpFlag = false;
        if (CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERBONDING, eqpBrInfo.getEquipmentCategory())) {
            log.info("Equipment Category is SP_Mc_Category_WaferBonding");
            bondingEqpFlag = true;
        }

        Outputs.ObjBondingGroupInfoByEqpGetDROut objBondingGroupInfoByEqpGetDROut = null;
        if (bondingEqpFlag) {
            //----------------------------------------------------------------
            // Bonding Map Info Get
            //----------------------------------------------------------------
            objBondingGroupInfoByEqpGetDROut = bondingGroupMethod.bondingGroupInfoByEqpGetDR(objCommon, equipmentID, controlJobID, true);

            List<Infos.BondingGroupInfo> bondingGroupInfoList = objBondingGroupInfoByEqpGetDROut.getBondingGroupInfoList();
            for (Infos.BondingGroupInfo bondingGroupInfo : bondingGroupInfoList) {
                Validations.check(!CimStringUtils.equals(bondingGroupInfo.getBondingGroupState(), BizConstant.SP_BONDINGGROUPSTATE_PROCESSED),
                        retCodeConfigEx.getBondgrpStateInvalid(), bondingGroupInfo.getBondingGroupState(), "OpeComp");

                /*------------------------------------*/
                /*   Update Bonding Group State       */
                /*------------------------------------*/
                bondingGroupMethod.bondingGroupStateUpdateDR(objCommon, bondingGroupInfo.getBondingGroupID(), BizConstant.SP_BONDINGGROUPSTATE_ERROR, null, null);
            }
        }
        List<ObjectIdentifier> topLotIDSeq = (!CimObjectUtils.isEmpty(objBondingGroupInfoByEqpGetDROut) && !CimObjectUtils.isEmpty(objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq())) ? objBondingGroupInfoByEqpGetDROut.getTopLotIDSeq() : Collections.emptyList();
        List<Infos.StartCassette> baseStartCassette = new ArrayList<>();
        if (postProcForLotFlag != 1 && bondingEqpFlag) {
            log.info("bondingEqpFlag == TRUE");

            for (Infos.StartCassette startCassette : strStartCassette) {
                Infos.StartCassette tmpBaseStartCassette = new Infos.StartCassette();
                tmpBaseStartCassette.setLoadSequenceNumber(startCassette.getLoadSequenceNumber());
                tmpBaseStartCassette.setLoadPurposeType(startCassette.getLoadPurposeType());
                tmpBaseStartCassette.setLoadPortID(startCassette.getLoadPortID());
                tmpBaseStartCassette.setCassetteID(startCassette.getCassetteID());
                List<Infos.LotInCassette> baseLotsInCassette = new ArrayList<>();
                for (Infos.LotInCassette lotInCassette : startCassette.getLotInCassetteList()) {
                    Infos.LotInCassette baseLotInCassette = new Infos.LotInCassette();
                    baseLotsInCassette.add(baseLotInCassette);
                    baseLotInCassette.setMoveInFlag(lotInCassette.getMoveInFlag());
                    baseLotInCassette.setRecipeParameterChangeType(lotInCassette.getRecipeParameterChangeType());
                    baseLotInCassette.setStartOperationInfo(lotInCassette.getStartOperationInfo());
                    baseLotInCassette.setProductID(lotInCassette.getProductID());
                    baseLotInCassette.setSubLotType(lotInCassette.getSubLotType());
                    baseLotInCassette.setLotWaferList(lotInCassette.getLotWaferList());
                    baseLotInCassette.setLotType(lotInCassette.getLotType());
                    baseLotInCassette.setStartRecipe(lotInCassette.getStartRecipe());
                    baseLotInCassette.setMonitorLotFlag(lotInCassette.getMonitorLotFlag());
                    baseLotInCassette.setLotID(lotInCassette.getLotID());
                }
                tmpBaseStartCassette.setLotInCassetteList(baseLotsInCassette);
                tmpBaseStartCassette.setUnloadPortID(startCassette.getUnloadPortID());
                baseStartCassette.add(tmpBaseStartCassette);
            }

            for (Infos.StartCassette startCassette : baseStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    boolean isTopLot = false;
                    for (ObjectIdentifier topLotID : topLotIDSeq) {
                        if (ObjectIdentifier.equalsWithValue(topLotID,
                                lotInCassette.getLotID())) {
                            isTopLot = true;
                            break;
                        }
                    }
                    if (isTopLot) {
                        lotInCassette.setMoveInFlag(false);
                        continue;
                    }
                }
            }
        }

        //step30 - collectedDataEvent_Make
        if (postProcForLotFlag != 1) {
            eventMethod.collectedDataEventMake(objCommon, TransactionIDEnum.OPERATION_COMP_WITH_DATA_REQ.getValue(), strStartCassette, controlJobID, equipmentID, claimMemo);
        }

        //【step31】- lot_futureHoldRequests_EffectByCondition
        int fHCnt = 0;
        ObjectIdentifier releaseReasonCodeId = new ObjectIdentifier();
        releaseReasonCodeId.setValue(BizConstant.SP_REASON_GATEPASS);
        List<RetCode<Outputs.ObjLotFutureHoldRequestsEffectByConditionOut>> lotFutureHoldRequestsEffectByConditionOutSequence = new ArrayList<>();
        if (postProcForLotFlag != 1) {
            /*-------------------------------------------*/
            /*   Delete Effected Future Hold Direction   */
            /*-------------------------------------------*/
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(lotInCassette.getMoveInFlag())) {
                        continue;
                    }

                    if (bondingEqpFlag) {
                        log.info("bondingEqpFlag == TRUE");

                        boolean isTopLot = false;
                        for (ObjectIdentifier topLotID : topLotIDSeq) {
                            if (ObjectIdentifier.equalsWithValue(topLotID,
                                    lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }
                        }
                        if (isTopLot) {
                            continue;
                        }
                    }

                    /*-------------------------------*/
                    /*   Get Effected Future Hold    */
                    /*-------------------------------*/
                    log.info("Get Effected Future Hold");
                    Infos.EffectCondition effectCondition = new Infos.EffectCondition();
                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_POST);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);
                    lotMethod.lotFutureHoldRequestsEffectByCondition(objCommon, lotInCassette.getLotID(), effectCondition);

                    fHCnt++;

                    /*-------------------------------------------*/
                    /*   Delete Effected Future Hold Direction   */
                    /*-------------------------------------------*/
                    effectCondition = new Infos.EffectCondition();
                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_ALL);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);
                    Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut deleteEffectedByConditionOut = lotMethod.lotFutureHoldRequestsDeleteEffectedByCondition(objCommon, lotInCassette.getLotID(), effectCondition);

                    // Pass hold cancel record list
                    List<Infos.LotHoldReq> strFutureHoldReleaseReqList = deleteEffectedByConditionOut.getStrFutureHoldReleaseReqList();
                    if (!CimObjectUtils.isEmpty(strFutureHoldReleaseReqList)) {
                        processControlService.sxFutureHoldCancelReq(objCommon, lotInCassette.getLotID(), releaseReasonCodeId, BizConstant.SP_ENTRYTYPE_REMOVE, strFutureHoldReleaseReqList);
                    }
                }
            }
        }

        /*------------------------------------------------------------*/
        /*   Reticle / Fixture Related Information Update Procedure   */
        /*------------------------------------------------------------*/
        //【step34】 - equipment_processDurableRequiredFlag_Get
        int usedReticleSeqLen = 0;
        int usedFixtureSeqLen = 0;
        //Check ProcessDurable was Used for Operation or Not
        try {
            equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, equipmentID);
        } catch (ServiceException e) {
            if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableNotRequired(), e.getCode())) {
                log.info("equipment_processDurableRequiredFlag_Get() == RC_EQP_PROCDRBL_NOT_REQD");
                //result.setReturnCode(retCodeConfig.getSucc());
            } else if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode()) ||
                    Validations.isEquals(retCodeConfig.getEquipmentProcessDurableFixtRequired(), e.getCode())) {
                log.info("equipment_processDurableRequiredFlag_Get() == RC_EQP_PROCDRBL_RTCL_REQD || RC_EQP_PROCDRBL_FIXT_REQD");
                for (int i = 0; i < scLen; i++) {
                    int nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
                    for (int j = 0; j < nLen; j++) {
                        if (strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag() == false) {
                            continue;
                        }
                        if (Validations.isEquals(retCodeConfig.getEquipmentProcessDurableReticleRequired(), e.getCode())) {
                            //Get Used Reticles for Lot
                            //【step35】 - process_assignedReticle_Get
                            List<Infos.StartReticle> processAssignedReticleOut = processMethod.processAssignedReticleGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                            usedReticleSeqLen = CimArrayUtils.getSize(processAssignedReticleOut);
                            log.info("strProcess_assignedReticle_Get_out.strStartReticle.length() : {}", usedFixtureSeqLen);
                            for (int k = 0; k < usedReticleSeqLen; k++) {
                                //【step36】 - reticle_usageLimitation_Check
                                Outputs.ObjReticleUsageLimitationCheckOut reticleUsageLimitationCheckOut = reticleMethod.reticleUsageLimitationCheck(objCommon, processAssignedReticleOut.get(k).getReticleID());
                                if (reticleUsageLimitationCheckOut.isUsageLimitOverFlag()) {
                                    log.info("strReticle_usageLimitation_Check_out.usageLimitOverFlag == TRUE");
                                    // step37 - txAlertMessageRpt
                                    Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                                    alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                                    alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_RTCLUSAGELIMITOVER);
                                    alertMessageRptParams.setSystemMessageText(reticleUsageLimitationCheckOut.getMessageText());
                                    alertMessageRptParams.setNotifyFlag(true);
                                    alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                                    systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
                                }
                                //Set last used time stamp for used reticle
                                //【step38】  reticle_lastUsedTime_Set
                                reticleMethod.reticleLastUsedTimeSet(processAssignedReticleOut.get(k).getReticleID()
                                        , objCommon.getTimeStamp() == null ? new Timestamp(System.currentTimeMillis()) : objCommon.getTimeStamp().getReportTimeStamp());
                            }
                        } else {
                            //【step39】process_assignedFixture_Get
                            List<Infos.StartFixture> startFixtures = processMethod.processAssignedFixtureGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                            usedFixtureSeqLen = CimArrayUtils.getSize(startFixtures);
                            log.info("strProcess_assignedFixture_Get_out.strStartFixture.length() : {}", usedFixtureSeqLen);
                            //Fixture Usage Limitation Check

                            for (Infos.StartFixture startFixture : startFixtures) {
                                Outputs.objFixtureUsageLimitationCheckOut objFixtureUsageLimitationCheckOut = fixtureMethod.fixtureUsageLimitationCheck(objCommon, startFixture.getFixtureID());
                                if (objFixtureUsageLimitationCheckOut.isUsageLimitOverFlag()) {
                                    Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                                    alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                                    alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_FIXTUSAGELIMITOVER);
                                    alertMessageRptParams.setSystemMessageText(objFixtureUsageLimitationCheckOut.getMessageText());
                                    alertMessageRptParams.setNotifyFlag(true);
                                    alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                                    systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
                                }
                            }

                        }
                    }
                }
            } else {
                log.info("equipment_processDurableRequiredFlag_Get() != RC_OK");
                throw e;
            }
        }
        //Lot Related Information Update Procedure
        if (postProcForLotFlag != 1) {
            //【step42】 - qtime_SetClearByOpeComp
            List<Infos.QTimeActionRegisterInfo> qTimeSetClearByOpeCompOut = qTimeMethod.qtimeSetClearByOpeComp(objCommon, bondingEqpFlag ? baseStartCassette : strStartCassette);
            //Reset Q-Time actions
            ObjectIdentifier resetReasonCodeId = new ObjectIdentifier();
            resetReasonCodeId.setValue(BizConstant.SP_REASON_QTIMECLEAR);
            int resetLen = CimArrayUtils.getSize(qTimeSetClearByOpeCompOut);
            for (int resetCnt = 0; resetCnt < resetLen; resetCnt++) {
                Infos.QTimeActionRegisterInfo strResetAction = qTimeSetClearByOpeCompOut.get(resetCnt);
                //Lot Hold Actions
                if (CimArrayUtils.getSize(strResetAction.getLotHoldList()) > 0) {
                    log.info("The lot hold actions to reset was found.");
                    //【step43】 - txHoldLotReleaseReq ---调用接口
                    Params.HoldLotReleaseReqParams holdLotReleaseReqParams = new Params.HoldLotReleaseReqParams();
                    holdLotReleaseReqParams.setLotID(strResetAction.getLotID());
                    holdLotReleaseReqParams.setHoldReqList(strResetAction.getLotHoldList());
                    holdLotReleaseReqParams.setReleaseReasonCodeID(resetReasonCodeId);
                    lotService.sxHoldLotReleaseReq(objCommon, holdLotReleaseReqParams);

                }
                //Future Hold Actions
                if (CimArrayUtils.getSize(strResetAction.getFutureHoldList()) > 0) {
                    log.info("The future hold actions to cancel was found.");
                    //【step44】 - txFutureHoldCancelReq  --调用接口
                    processControlService.sxFutureHoldCancelReq(objCommon
                            , strResetAction.getLotID()
                            , resetReasonCodeId
                            , BizConstant.SP_ENTRYTYPE_CANCEL
                            , strResetAction.getFutureHoldList());
                }
                // Future Rework Actions
                List<Infos.FutureReworkInfo> futureReworkList = strResetAction.getFutureReworkList();
                if (!CimObjectUtils.isEmpty(futureReworkList)) {
                    for (Infos.FutureReworkInfo futureReworkInfo : futureReworkList) {
                        processControlService.sxFutureReworkCancelReq(objCommon, futureReworkInfo.getLotID(), futureReworkInfo.getRouteID(), futureReworkInfo.getOperationNumber(), futureReworkInfo.getFutureReworkDetailInfoList(), "");
                    }
                }
            }

            // 检查并设置Min Q-Time最小时间限制
            minQTimeMethod.checkAndSetRestrictions(objCommon, bondingEqpFlag ? baseStartCassette : strStartCassette);
        }
        //Change Lot Process State to Waiting
        //【step46】 - lot_processState_MakeWaiting
        lotMethod.lotProcessStateMakeWaiting(objCommon, strStartCassette);

        //Procedure for PO Moving
        int lotCount = 0;
        for (int i = 0; i < scLen; i++) {
            int nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            log.info("strStartCassette[i].strLotInCassette.length() : {}", nLen);
            lotCount = lotCount + nLen;
        }
        log.info("lotcount : {}", lotCount);
        List<ObjectIdentifier> autoBankInLotIds = new ArrayList<>();
        List<ObjectIdentifier> opeStartLotIds = new ArrayList<>();
        int opeStartLotCount = 0;
        lotCount = 0;
        for (int i = 0; i < scLen; i++) {
            int nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {
                //Omit Not-OpeStart Lot
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }

                //set contamination flag for operation
                contaminationMethod.lotContaminationLevelAndPrFlagSet(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                //Move Process Operation of Lot
                //【step47】 - process_Move
                Outputs.ObjProcessMoveOut processMoveOut = null;
                try {
                    processMoveOut = processMethod.processMove(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                } catch (ServiceException ex) {
                    if (retCodeConfig.getAddToQueueFail().getCode() == ex.getCode()) {
                        log.info("process_Move() == RC_ADDTOQUEUE_FAIL");
                        //【step48】 - lot_currentOperationInfo_Get
                        Outputs.ObjLotCurrentOperationInfoGetOut lotCurrentOperationInfoOut = lotMethod.lotCurrentOperationInfoGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                        RetCode<Object> strHoldLotReqResult = new RetCode<>();
                        List<Infos.LotHoldReq> strHoldListSeqList = new ArrayList<>();
                        Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                        strHoldListSeqList.add(lotHoldReq);
                        lotHoldReq.setHoldType(BizConstant.SP_HOLDTYPE_ADDTOQUEUEERRHOLD);
                        lotHoldReq.setHoldReasonCodeID(ObjectIdentifier.buildWithValue(BizConstant.SP_REASON_ADDTOQUEUEERRHOLD));
                        lotHoldReq.setHoldUserID(objCommon.getUser().getUserID());
                        lotHoldReq.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                        lotHoldReq.setRouteID(lotCurrentOperationInfoOut.getRouteID());
                        lotHoldReq.setOperationNumber(lotCurrentOperationInfoOut.getOperationNumber());
                        lotHoldReq.setClaimMemo("");
                        // 【step49】txHoldLotReq    -- 调用接口
                        lotService.sxHoldLotReq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strHoldListSeqList);
                    } else {
                        throw ex;
                    }
                }
                //object.setAutoBankInFlag(false);

                if (!CimObjectUtils.isEmpty(processMoveOut) && processMoveOut.getAutoBankInFlag()) {
                    autoBankInLotIds.add(lotCount, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                    lotCount++;
                }
                opeStartLotIds.add(opeStartLotCount, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                opeStartLotCount++;
                //UpDate RequiredCassetteCategory
                //【step50】 - lot_CassetteCategory_UpdateForContaminationControl
                lotMethod.lotCassetteCategoryUpdateForContaminationControl(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
            }
        }
        // Auto Hold after force complete
        for (int i = 0; i < scLen; i++) {
            int nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {
                // Omit Not-OpeStart Lot
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }
                //【step51】 - txHoldLotListInq --调用接口
                List<Infos.LotHoldListAttributes> sxHoldLotListInqOut = lotInqService.sxHoldLotListInq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                log.info("strStartCassette[i].strLotInCassette[j].lotID = {}", strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                int oLen = CimArrayUtils.getSize(sxHoldLotListInqOut);
                for (int k = 0; k < oLen; k++) {
                    log.info("k = {}", k);
                    if (CimStringUtils.equals(BizConstant.SP_REASON_RUNNINGHOLD, sxHoldLotListInqOut.get(k).getReasonCodeID().getValue())) {
                        log.info("Find Running Hold Record!!");
                        List<Infos.LotHoldReq> strLotHoldReleaseReqList = new ArrayList<>();
                        Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                        strLotHoldReleaseReqList.add(lotHoldReq);
                        lotHoldReq.setHoldType(sxHoldLotListInqOut.get(k).getHoldType());
                        lotHoldReq.setHoldReasonCodeID(sxHoldLotListInqOut.get(k).getReasonCodeID());
                        lotHoldReq.setHoldUserID(sxHoldLotListInqOut.get(k).getUserID());
                        lotHoldReq.setResponsibleOperationMark(sxHoldLotListInqOut.get(k).getResponsibleOperationMark());
                        lotHoldReq.setRouteID(sxHoldLotListInqOut.get(k).getResponsibleRouteID());
                        lotHoldReq.setOperationNumber(sxHoldLotListInqOut.get(k).getResponsibleOperationNumber());
                        lotHoldReq.setRelatedLotID(sxHoldLotListInqOut.get(k).getRelatedLotID());
                        lotHoldReq.setClaimMemo("");
                        ObjectIdentifier aReasonCodeId = new ObjectIdentifier(BizConstant.SP_REASON_RUNNINGHOLDRELEASE);

                        Params.HoldLotReleaseReqParams holdLotReleaseReqParams = new Params.HoldLotReleaseReqParams();
                        holdLotReleaseReqParams.setLotID(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                        holdLotReleaseReqParams.setReleaseReasonCodeID(aReasonCodeId);
                        holdLotReleaseReqParams.setHoldReqList(strLotHoldReleaseReqList);
                        //【step52】 - txHoldLotReleaseReq
                        lotService.sxHoldLotReleaseReq(objCommon, holdLotReleaseReqParams);

                        break;
                    }
                }
                //Execute Lot Hold
                ObjectIdentifier reasonCodeId = new ObjectIdentifier(BizConstant.SP_REASON_FORCECOMPHOLD);
                List<Infos.LotHoldReq> strHoldListSeq = new ArrayList<>();
                Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                strHoldListSeq.add(lotHoldReq);
                lotHoldReq.setHoldType(BizConstant.SP_HOLDTYPE_LOTHOLD);
                lotHoldReq.setHoldReasonCodeID(reasonCodeId);
                lotHoldReq.setHoldUserID(objCommon.getUser().getUserID());
                lotHoldReq.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                lotHoldReq.setRouteID(new ObjectIdentifier());
                lotHoldReq.setOperationNumber("");
                lotHoldReq.setRelatedLotID(new ObjectIdentifier());
                lotHoldReq.setClaimMemo("SYSAUTO:Force Complete System Hold");

                //【step53】 - txHoldLotReq  --调用接口
                lotService.sxHoldLotReq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strHoldListSeq);
            }
        }
        if (postProcForLotFlag != 1) {
            //Lot FutureHold Post By Previous Operation Effect after Operation Move
            log.info("Lot FutureHold Post By Previous Operation Effect after Operation Move  ");
            int fhLen = CimArrayUtils.getSize(lotFutureHoldRequestsEffectByConditionOutSequence);
            for (int fhCnt = 0; fhCnt < fhLen; fhCnt++) {
                log.info("fhCnt ={}", fhCnt);
                if (CimArrayUtils.getSize(lotFutureHoldRequestsEffectByConditionOutSequence.get(fhCnt).getObject().getStrLotHoldReqList()) > 0) {
                    log.info("strLotHoldReqList.length() > 0");
                    //Convert OpeNo, RouteID from previous to current
                    log.info("Convert OpeNo from previous to current");
                    //【step54】 - lot_futureHold_EffectedProcessConversion
                    lotMethod.lotFutureHoldEffectedProcessConversion(objCommon, lotFutureHoldRequestsEffectByConditionOutSequence.get(fhCnt).getObject().getLotID(), lotFutureHoldRequestsEffectByConditionOutSequence.get(fhCnt).getObject().getStrLotHoldReqList());

                    //【step55】 - txHoldLotReq --调用接口
                    try {
                        lotService.sxHoldLotReq(objCommon, lotFutureHoldRequestsEffectByConditionOutSequence.get(fhCnt).getObject().getLotID(), lotFutureHoldRequestsEffectByConditionOutSequence.get(fhCnt).getObject().getStrLotHoldReqList());
                    } catch (ServiceException ex) {
                        if (!Validations.isEquals(retCodeConfig.getExistSameHold(), ex.getCode())) {
                            log.info("txHoldLotReq() != RC_OK");
                            throw new ServiceException(new OmCode(ex.getCode(), ex.getMessage()));
                        }
                    }

                }
            }
        }
        //Execute Lot Hold Action based on SpecCheck and also SPC Check result.
        if (postProcForLotFlag != 1) {
            //Effect PO's Direction for TEL Furnace
            //【step56】 - lot_holdRecord_EffectMonitorIssue
            List<Infos.LotHoldEffectList> lotHoldRecordEffectMonitorIssueOut = lotMethod.lotHoldRecordEffectMonitorIssue(objCommon, bondingEqpFlag ? baseStartCassette : strStartCassette);


            int nMonitorHoldEffectLen = 0;
            nMonitorHoldEffectLen = CimArrayUtils.getSize(lotHoldRecordEffectMonitorIssueOut);
            log.info("strLot_holdRecord_EffectMonitorIssue_out.strLotHoldEffectList.length() : {}", nMonitorHoldEffectLen);

            if (nMonitorHoldEffectLen > 0) {
                List<Infos.LotHoldReq> strLotHoldReqList = new ArrayList<>();
                Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                strLotHoldReqList.add(lotHoldReq);
                for (int i = 0; i < nMonitorHoldEffectLen; i++) {
                    lotHoldReq.setHoldType(lotHoldRecordEffectMonitorIssueOut.get(i).getHoldType());
                    lotHoldReq.setHoldReasonCodeID(lotHoldRecordEffectMonitorIssueOut.get(i).getReasonCodeID());
                    lotHoldReq.setHoldUserID(lotHoldRecordEffectMonitorIssueOut.get(i).getUserID());
                    lotHoldReq.setResponsibleOperationMark(lotHoldRecordEffectMonitorIssueOut.get(i).getResponsibleOperationMark());
                    lotHoldReq.setRouteID(lotHoldRecordEffectMonitorIssueOut.get(i).getRouteID());
                    lotHoldReq.setOperationNumber(lotHoldRecordEffectMonitorIssueOut.get(i).getOperationNumber());
                    lotHoldReq.setRelatedLotID(lotHoldRecordEffectMonitorIssueOut.get(i).getRelatedLotID());
                    lotHoldReq.setClaimMemo(lotHoldRecordEffectMonitorIssueOut.get(i).getClaimMemo());
                    //【step57】 - txHoldLotReq --调用接口
                    try {
                        lotService.sxHoldLotReq(objCommon, lotHoldRecordEffectMonitorIssueOut.get(i).getLotID(), strLotHoldReqList);
                    } catch (ServiceException ex) {
                        if (!Validations.isEquals(retCodeConfig.getExistSameHold(), ex.getCode())) {
                            log.info("txHoldLotReq() != RC_OK");
                            throw ex;
                        }
                    }

                }
            }
        }
        if (postProcForLotFlag != 1) {
            //Effect Future Hold Direction if Exist
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    // Omit Not-OpeStart Lot
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }
                    if (bondingEqpFlag) {
                        boolean isTopLot = false;
                        log.info("bondingEqpFlag == TRUE");
                        for (ObjectIdentifier topLotID : topLotIDSeq) {
                            if (ObjectIdentifier.equalsWithValue(topLotID, lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }
                        }
                        if (isTopLot) {
                            continue;
                        }
                    }
                    //Get Effected Future Hold
                    //【step58】 - lot_futureHoldRequests_EffectByCondition
                    Infos.EffectCondition effectCondition = new Infos.EffectCondition();
                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_POST);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);
                    lotMethod.lotFutureHoldRequestsEffectByCondition(objCommon, lotInCassette.getLotID(), effectCondition);
                    fHCnt++;

                    //Delete Effected Future Hold Direction
                    //【step60】 - lot_futureHoldRequests_DeleteEffectedByCondition
                    effectCondition.setPhase(BizConstant.SP_FUTUREHOLD_ALL);
                    effectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);
                    Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut lotFutureHoldRequestsDeleteEffectedByConditionOut = lotMethod.lotFutureHoldRequestsDeleteEffectedByCondition(objCommon, lotInCassette.getLotID(), effectCondition);

                    //Pass hold cancel record list
                    if (CimArrayUtils.getSize(lotFutureHoldRequestsDeleteEffectedByConditionOut.getStrFutureHoldReleaseReqList()) > 0) {
                        //【step61】 - txFutureHoldCancelReq  --调用接口
                        processControlService.sxFutureHoldCancelReq(objCommon
                                , lotInCassette.getLotID()
                                , releaseReasonCodeId
                                , BizConstant.SP_ENTRYTYPE_REMOVE
                                , lotFutureHoldRequestsDeleteEffectedByConditionOut.getStrFutureHoldReleaseReqList());
                    }
                }
            }
        }
        //Equipment Related Information Update Procedure
        //Remove ControlJobLot from EqpInfo's ProcessingLot Sequence
        //【step62】 - equipment_processingLot_Delete
        equipmentMethod.equipmentProcessingLotDelete(objCommon, equipmentID, strStartCassette);
        //Maintain Eqp's Status when OFF-LINE Mode
        if (CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, portResourceCurrentOperationModeOut.getOperationMode().getOnlineMode())) {
            log.info("strPortResource_currentOperationMode_Get_out.strOperationMode.onlineMode == SP_Eqp_OnlineMode_Offline");
            //Change Equipment's Status to 'STANDBY' if necessary
            //【step63】 - equipment_currentState_CheckToManufacturing
            Boolean checkEquipmentCurrentState2ManufacturingOut = equipmentMethod.equipmentCurrentStateCheckToManufacturing(objCommon, equipmentID);
            //checkEquipmentCurrentState2ManufacturingOut.setObject(false); //????

            if (checkEquipmentCurrentState2ManufacturingOut) {
                log.info("strEquipment_currentState_CheckToManufacturing_out.ManufacturingStateChangeableFlag == TRUE");
                //【step64】 - equipment_recoverState_GetManufacturing
                ObjectIdentifier equipmentStatus = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, equipmentID);
                //Call txEqpStatusChangeReq()
                //【step65】 - txEqpStatusChangeReq --调用接口
                Results.EqpStatusChangeReqResult eqpStatusChangeReqResultOut = null;
                try {
                    eqpStatusChangeReqResultOut = sxEqpStatusChangeReq(objCommon, equipmentID, equipmentStatus, claimMemo);
                } catch (ServiceException e) {
                    if (!Validations.isEquals(retCodeConfig.getInvalidStateTransition(), e.getCode())) {
                        log.info("txEqpStatusChangeReq() != RC_OK");
                        throw e;
                    }
                }

            }
        }
        //Equipment Usage Limitation Check
        //【step66】 - equipment_usageLimitation_Check
        Outputs.ObjEquipmentUsageLimitationCheckOut equipmentUsageLimitationCheckOut = equipmentMethod.equipmentUsageLimitationCheck(objCommon, equipmentID);

        if (CimBooleanUtils.isTrue(equipmentUsageLimitationCheckOut.isUsageLimitOverFlag())) {
            log.info("strEquipment_usageLimitation_Check_out.usageLimitOverFlag == TRUE");
            //step67 -  txAlertMessageRpt
            Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
            alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
            alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_EQPUSAGELIMITOVER);
            alertMessageRptParams.setSystemMessageText(equipmentUsageLimitationCheckOut.getMessageText());
            alertMessageRptParams.setNotifyFlag(true);
            alertMessageRptParams.setEquipmentID(equipmentID);
            alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
            systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
        }
        //ControlJob Related Information Update Procedure
        //Clear all  container positions
        if (pstLen > 0) {
            Inputs.ObjEquipmentContainerPositionInfoClearIn objEquipmentContainerPositionInfoClearIn = new Inputs.ObjEquipmentContainerPositionInfoClearIn();
            objEquipmentContainerPositionInfoClearIn.setEquipmentID(equipmentID);
            objEquipmentContainerPositionInfoClearIn.setKey(controlJobID);
            objEquipmentContainerPositionInfoClearIn.setKeyCategory(BizConstant.SP_SLM_KEYCATEGORY_CONTROLJOB);

            //【Step68】 - equipmentContainerPosition_info_Clear
            equipmentContainerPositionMethod.equipmentContainerPositionInfoClear(objCommon, objEquipmentContainerPositionInfoClearIn);
        }
        // Delete SLM reservation from container position
        //TODO-NOTIMPL step69 - cassette_SLMReserveEquipment_Set

        //Delete Control Job
        if (!objCommon.getTransactionID().equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                && !objCommon.getTransactionID().equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
            log.info("strObjCommonIn.transactionID is not OEQPW012 and OEQPW024");
            //【Step70】 - txCJStatusChangeReq  --接口调用
            Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
            cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE_FROM_EQP);
            cjStatusChangeReqParams.setControlJobID(controlJobID);
            cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());

            controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);

        }
        //Cassette Related Information Update Procedure
        for (int i = 0; i < scLen; i++) {
            // Cassette Usage Limitation Check
            //【step71】 - cassette_usageLimitation_Check
            Outputs.ObjCassetteUsageLimitationCheckOut cassetteUsageLimitationCheckOut = cassetteMethod.cassetteUsageLimitationCheck(objCommon, strStartCassette.get(i).getCassetteID());
            if (cassetteUsageLimitationCheckOut.isUsageLimitOverFlag()) {
                log.info("strCassette_usageLimitation_Check_out.usageLimitOverFlag == TRUE");
                // step72 - txAlertMessageRpt
                Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_CASTUSAGELIMITOVER);
                alertMessageRptParams.setSystemMessageText(cassetteUsageLimitationCheckOut.getMessageText());
                alertMessageRptParams.setNotifyFlag(true);
                alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
            }
            //Update Cassette's MultiLotType
            //【step73】 - cassette_multiLotType_Update
            cassetteMethod.cassetteMultiLotTypeUpdate(objCommon, strStartCassette.get(i).getCassetteID());
        }
        // ProcessLagTime Information Update Procedure
        if (postProcForLotFlag != 1) {
            log.info("ProcessLagTime Information Update Procedure...");
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    // Omit Not-OpeStart Lot
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }
                    if (bondingEqpFlag) {
                        boolean isTopLot = false;
                        log.info("bondingEqpFlag == TRUE");
                        for (ObjectIdentifier topLotID : topLotIDSeq) {
                            if (ObjectIdentifier.equalsWithValue(topLotID, lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }
                        }
                        if (isTopLot) {
                            continue;
                        }
                    }
                    //【step74】 - txLagTimeActionReq
                    log.info("Call txLagTimeActionReq()...");
                    Params.LagTimeActionReqParams lagTimeActionReqParams = new Params.LagTimeActionReqParams();
                    lagTimeActionReqParams.setUser(objCommon.getUser());
                    lagTimeActionReqParams.setLotID(lotInCassette.getLotID());
                    lagTimeActionReqParams.setAction(BizConstant.SP_PROCESSLAGTIME_ACTION_SET);
                    processControlService.sxProcessLagTimeUpdate(objCommon, lagTimeActionReqParams);
                }
            }
        }
        if (postProcForLotFlag != 1) {
            //Process Hold
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    // Omit Not-OpeStart Lot
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }
                    if (bondingEqpFlag) {
                        boolean isTopLot = false;
                        log.info("bondingEqpFlag == TRUE");
                        for (ObjectIdentifier topLotID : topLotIDSeq) {
                            if (ObjectIdentifier.equalsWithValue(topLotID, lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }
                        }
                        if (isTopLot) {
                            continue;
                        }
                    }
                    log.info("Call txProcessHoldDoActionReq()");
                    //【step75】 - txProcessHoldDoActionReq
                    processControlService.sxProcessHoldDoActionReq(objCommon, lotInCassette.getLotID(), claimMemo);

                }
            }
        }
        // Event Make Procedure
        for (int i = 0; i < scLen; i++) {
            int nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            log.info("strStartCassette[i].strLotInCassette.length()=> {}", nLen);
            for (int j = 0; j < nLen; j++) {

                // Omit Not-OpeStart Lot
                if (!strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag()) {
                    continue;
                }
                log.info("counter j for lotOperationMoveEvent_MakeOpeComp={}", j);
                //Make OperationMoveEvent for Operation History - OpeComp
                //step76 - lotOperationMoveEvent_MakeOpeComp
                Inputs.LotOperationMoveEventMakeOpeComp lotOperationMoveEventMakeOpeComp = new Inputs.LotOperationMoveEventMakeOpeComp();
                lotOperationMoveEventMakeOpeComp.setTransactionID(TransactionIDEnum.FORCE_OPERATION_COMP_REQ.getValue());
                lotOperationMoveEventMakeOpeComp.setEquipmentID(equipmentID);
                lotOperationMoveEventMakeOpeComp.setOperationMode(portResourceCurrentOperationModeOut.getOperationMode().getOperationMode().getValue());
                lotOperationMoveEventMakeOpeComp.setControlJobID(controlJobID);
                lotOperationMoveEventMakeOpeComp.setCassetteID(strStartCassette.get(i).getCassetteID());
                lotOperationMoveEventMakeOpeComp.setLotInCassette(strStartCassette.get(i).getLotInCassetteList().get(j));
                lotOperationMoveEventMakeOpeComp.setClaimMemo(claimMemo);
                eventMethod.lotOperationMoveEventMakeOpeComp(objCommon, lotOperationMoveEventMakeOpeComp);

            }
        }
        Results.EDCWithSpecCheckActionReqResult edcWithSpecCheckActionReqResultRetCodeOut = null;
        if (postProcForLotFlag != 1) {
            //Invoking Action for Collected Data.
            //【step77】 - txEDCWithSpecCheckActionReq
            Infos.EDCWithSpecCheckActionReqInParm strEDCWithSpecCheckActionReqInParm = new Infos.EDCWithSpecCheckActionReqInParm();
            strEDCWithSpecCheckActionReqInParm.setEquipmentID(equipmentID);
            strEDCWithSpecCheckActionReqInParm.setControlJobID(controlJobID);
            strEDCWithSpecCheckActionReqInParm.setStrStartCassette(strStartCassette);
            edcWithSpecCheckActionReqResultRetCodeOut = engineerDataCollectionService.sxEDCWithSpecCheckActionReq(objCommon, strEDCWithSpecCheckActionReqInParm, claimMemo);

            List<ObjectIdentifier> holdReleaseLotIdList = edcWithSpecCheckActionReqResultRetCodeOut.getHoldReleasedLotIDs();
            List<Infos.OpeCompLot> strOpeCompLot = edcWithSpecCheckActionReqResultRetCodeOut.getMoveOutReqResult().getMoveOutLot();
            out.setStrOpeCompLot(strOpeCompLot);
        } else {
            //DataValue CheckValidity for SpeckCheck
            Results.SpecCheckReqResult tg = new Results.SpecCheckReqResult();
            tg.setStartCassetteList(strStartCassette);
            Outputs.ObjDataValueCheckValidityForSpecCheckDrOut strDataValueCheckValidityForSpecCheckDROut = new Outputs.ObjDataValueCheckValidityForSpecCheckDrOut();
            strDataValueCheckValidityForSpecCheckDROut.setEquipmentID(equipmentID);
            strDataValueCheckValidityForSpecCheckDROut.setControlJobID(controlJobID);
            strDataValueCheckValidityForSpecCheckDROut.setStartCassetteList(strStartCassette);
            //Initialize Logic
            log.info("Initialize Logic...");
            //Loop for strStartCassette
            log.info("Loop for strStartCassette...");
            for (int i = 0; i < scLen; i++) {
                //Loop for strLotInCassette
                log.info("scLen ={}/ i = {}", scLen, i);
                log.info("Loop for strLotInCassette...");
                int lcLen = CimArrayUtils.getSize(strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList());
                for (int j = 0; j < lcLen; j++) {
                    log.info("lcLen = {} / j = {}", lcLen, j);
                    //Omit Not-Start Lot
                    log.info("Omit Not-Start Lot...");
                    if (!strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList().get(j).getMoveInFlag()) {
                        log.info("Not-Start Lot. continue...");
                        continue;
                    }
                    //Omit Non-DataClooection Lot
                    log.info("Omit Non-DataClooection Lot...");
                    if (!strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDataCollectionFlag()) {
                        log.info("Non-DCDef Lot. continue...");
                        continue;
                    }
                    //Clear
                    log.info("Clear...");
                    int dcLen = CimArrayUtils.getSize(strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList());
                    for (int n = 0; n < dcLen; n++) {
                        log.info("dcLen = {}/ n = {}", dcLen, n);
                        int itLen = CimArrayUtils.getSize(strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems());
                        for (int l = 0; l < itLen; l++) {
                            log.info("itLen = {} / l = {}", itLen, l);
                            String measurementType = strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getMeasurementType();
                            String specCheckResult = strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult();
                            boolean bClearFlag = true;
                            if (CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJ, measurementType)
                                    || CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJWAFER, measurementType)
                                    || CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJWAFERSITE, measurementType)) {
                                log.info("measurementType : {} is SP_DCDef_Meas_PJ: {} or SP_DCDef_Meas_PJWafer : {} or SP_DCDef_Meas_PJWaferSite : {}", i, j, n, l);
                                if (CimStringUtils.length(specCheckResult) > 0) {
                                    log.info("0 < CIMFWStrLen(specCheckResult)");
                                    if (CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_OK, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_UPPERCONTROLLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERCONTROLLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_UPPERSPECLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERSPECLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_UPPERSCREENLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERSCREENLIMIT, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_APCERROR, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_ASTERISK, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_POUND, specCheckResult)
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_ERROR, specCheckResult)) {
                                        //Do Nothing
                                        log.info("Do Nothing");
                                    } else {
                                        log.info("set bClearFlag = FALSE");
                                        bClearFlag = false;
                                    }
                                }
                            }
                            if (CimBooleanUtils.isTrue(bClearFlag)) {
                                // Clear specCheckResult / actionCode
                                log.info("Clear specCheckResult / actionCode...");
                                Infos.DataCollectionItemInfo dataCollectionItemInfo = strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l);
                                dataCollectionItemInfo.setSitePosition("");
                                dataCollectionItemInfo.setActionCodes("");

                                // Clear dataValue
                                log.info("Clear dataValue...");
                                if (CimStringUtils.equals(BizConstant.SP_DCDEF_ITEM_RAW, strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getItemType())) {
                                    log.info("Raw Item. continue...");
                                    continue;
                                }
                                dataCollectionItemInfo.setDataType("");
                            }
                        }
                    }
                }
            }
            //Set Initialized Data into PO
            //【step78】 - processOperation_tempData_Set
            log.info("Set Initialized Data into PO...");
            processMethod.processOperationTempDataSet(objCommon, controlJobID, strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList());
            //Set DC Spec's detailed information into PO
            //【step79】 - process_dataCollectionSpecification_Set
            List<Infos.StartCassette> processDataCollectionSpecificationOut = processMethod.processDataCollectionSpecificationSet(objCommon, strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList());
            strDataValueCheckValidityForSpecCheckDROut.setStartCassetteList(processDataCollectionSpecificationOut);
            log.info("Do dataValue_CheckValidityForSpecCheck");
            //【step80】 - dataValue_CheckValidityForSpecCheckDR
            try {
                dataValueMethod.dataValueCheckValidityForSpecCheckDR(objCommon, equipmentID, controlJobID, strDataValueCheckValidityForSpecCheckDROut.getStartCassetteList());
            } catch (ServiceException e) {
                if (!Validations.isEquals(retCodeConfig.getAllDataValAsterisk(), e.getCode())) {
                    log.info("dataValue_CheckValidityForSpecCheckDR() == RC_ALL_DATAVAL_ASTERISK");
                    throw e;
                }
            }

            if (!objCommon.getTransactionID().equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())
                    && !objCommon.getTransactionID().equals(TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue())) {
                log.info("Delete controlJob from Lot and Cassette.");
                //【Step81】 - txCJStatusChangeReq  --接口调用
                Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
                cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE_FROM_LOTANDCASSETTE);
                cjStatusChangeReqParams.setControlJobID(controlJobID);
                cjStatusChangeReqParams.setControlJobCreateRequest(new Infos.ControlJobCreateRequest());

                controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);

            }
        }
        if (postProcForLotFlag != 1) {
            //Future Action Procedure
            for (Infos.StartCassette startCassette : strStartCassette) {
                List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
                for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                    // Omit Not-OpeStart Lot
                    if (!lotInCassette.getMoveInFlag()) {
                        continue;
                    }
                    if (bondingEqpFlag) {
                        boolean isTopLot = false;
                        log.info("bondingEqpFlag == TRUE");
                        for (ObjectIdentifier topLotID : topLotIDSeq) {
                            if (ObjectIdentifier.equalsWithValue(topLotID, lotInCassette.getLotID())) {
                                isTopLot = true;
                                break;
                            }
                        }
                        if (isTopLot) {
                            continue;
                        }
                    }
                    String tmpRouteId = lotInCassette.getStartOperationInfo().getProcessFlowID().getValue();
                    Inputs.ObjSchdlChangeReservationCheckForActionDRIn objSchdlChangeReservationCheckForActionDRIn = new Inputs.ObjSchdlChangeReservationCheckForActionDRIn();
                    objSchdlChangeReservationCheckForActionDRIn.setLotID(lotInCassette.getLotID());
                    objSchdlChangeReservationCheckForActionDRIn.setRouteID(tmpRouteId);
                    objSchdlChangeReservationCheckForActionDRIn.setOperationNumber(lotInCassette.getStartOperationInfo().getOperationNumber());
                    Outputs.ObjSchdlChangeReservationCheckForActionDROut objSchdlChangeReservationCheckForActionDROut = scheduleChangeReservationMethod.schdlChangeReservationCheckForActionDR(objCommon, objSchdlChangeReservationCheckForActionDRIn);


                    if (objSchdlChangeReservationCheckForActionDROut.isExistFlag()) {
                        Infos.SchdlChangeReservation strSchdlChangeReservation = objSchdlChangeReservationCheckForActionDROut.getStrSchdlChangeReservation();
                        List<Infos.ReScheduledLotAttributes> reScheduledLotAttributes = new ArrayList<>();
                        Infos.ReScheduledLotAttributes reScheduledLotAttribute = new Infos.ReScheduledLotAttributes();
                        reScheduledLotAttribute.setLotID(lotInCassette.getLotID());
                        reScheduledLotAttribute.setProductID(strSchdlChangeReservation.getProductID());
                        reScheduledLotAttribute.setRouteID(strSchdlChangeReservation.getRouteID());
                        reScheduledLotAttribute.setCurrentOperationNumber(strSchdlChangeReservation.getOperationNumber());
                        reScheduledLotAttribute.setSubLotType(strSchdlChangeReservation.getSubLotType());
                        reScheduledLotAttributes.add(reScheduledLotAttribute);

                        //------------------------------------------------------------------------//
                        // Get current RouteID by lotID                                           //
                        //------------------------------------------------------------------------//
                        ObjectIdentifier lotCurrentRouteID = lotMethod.lotCurrentRouteIDGet(objCommon, lotInCassette.getLotID());
                        reScheduledLotAttribute.setOriginalRouteID(ObjectIdentifier.fetchValue(lotCurrentRouteID));

                        //------------------------------------------------------------------------//
                        // Get current operation No. by lotID                                     //
                        //------------------------------------------------------------------------//
                        reScheduledLotAttribute.setOriginalOperationNumber(lotMethod.lotCurrentOpeNoGet(objCommon, lotInCassette.getLotID()));

                        //txLotPlanChangeReserveDoActionReq__110
                        planService.sxLotPlanChangeReserveDoActionReq(objCommon, reScheduledLotAttributes, strSchdlChangeReservation.getEventID());

                        //schdlChangeReservation_applyCount_IncreaseDR__110
                        scheduleChangeReservationMethod.schdlChangeReservationApplyCountIncreaseDR(objCommon, strSchdlChangeReservation);

                    }
                }
            }
        }

        //BR Script Procedure
        for (Infos.StartCassette startCassette : strStartCassette) {
            List<Infos.LotInCassette> lotInCassetteList = startCassette.getLotInCassetteList();
            for (Infos.LotInCassette lotInCassette : lotInCassetteList) {
                // Omit Not-OpeStart Lot
                if (!lotInCassette.getMoveInFlag()) {
                    continue;
                }
                if (bondingEqpFlag) {
                    boolean isTopLot = false;
                    log.info("bondingEqpFlag == TRUE");
                    for (ObjectIdentifier topLotID : topLotIDSeq) {
                        if (ObjectIdentifier.equalsWithValue(topLotID, lotInCassette.getLotID())) {
                            isTopLot = true;
                            break;
                        }
                    }
                    if (isTopLot) {
                        continue;
                    }
                }
                /*-------------------------*/
                /*   Execute Post Script   */
                /*-------------------------*/
                log.info("Execute POST Script");
                Params.ProcessControlScriptRunReqParams scriptParams = new Params.ProcessControlScriptRunReqParams();
                scriptParams.setEquipmentId(equipmentID);
                scriptParams.setLotId(lotInCassette.getLotID());
                scriptParams.setPhase(BizConstant.SP_BRSCRIPT_POST);
                scriptParams.setUser(objCommon.getUser());
                processControlScriptService.sxProcessControlScriptRunReq(objCommon, scriptParams);
            }
        }
        //Call APCRuntimeCapability_DeleteDR
        log.info("call APCRuntimeCapability_DeleteDR");
        //TODO-NOTIMPL step89 APCRuntimeCapability_DeleteDR
        //Call APCMgr_SendControlJobInformationDR
        log.info("call APCMgr_SendControlJobInformationDR()");
        //TODO-NOTIMPL step90 - APCMgr_SendControlJobInformationDR

        //Update Reticle's LastUsedTimestamp
        //【step91】 - reticle_lastUsedTimeStamp_Update
        reticleMethod.reticleLastUsedTimeStampUpdate(objCommon, controlJobStartReserveInformationOut.getStartCassetteList());


        //【step92】 - entityInhibitExceptionLot_ChangeForOpeComp
        Inputs.ObjEntityInhibitExceptionLotChangeForOpeCompIn inputs = new Inputs.ObjEntityInhibitExceptionLotChangeForOpeCompIn();
        inputs.setControlJobID(controlJobID);
        inputs.setLotIDs(opeStartLotIds);
        constraintMethod.constraintExceptionLotChangeForOpeComp(objCommon, inputs.getLotIDs(), inputs.getControlJobID());

        // 【step 93】 check contamination level and pr flag
        contaminationMethod.lotCheckContaminationLevelAndPrFlagStepOut(objCommon, lotIDs, equipmentID);

        // Set Return Structure
        if (postProcForLotFlag != 1) {
            out.setStrOpeCompLot(edcWithSpecCheckActionReqResultRetCodeOut.getMoveOutReqResult().getMoveOutLot());
        } else {
            List<Infos.OpeCompLot>  strOpeCompLot = new ArrayList<>();
            out.setStrOpeCompLot(strOpeCompLot);
            opeStartLotIds.forEach(opeStartLot -> {
                Infos.OpeCompLot opeCompLot = new Infos.OpeCompLot();
                opeCompLot.setLotID(opeStartLot);
                strOpeCompLot.add(opeCompLot);
            });
        }
        return out;
    }

    @Deprecated
    @Override
    public Results.ForceMoveOutReqResult sxForceMoveOutForIBReq(Infos.ObjCommon objCommon,
                                                         ObjectIdentifier equipmentID,
                                                         ObjectIdentifier controlJobID,
                                                         Boolean spcResultRequiredFlag,
                                                         String claimMemo) {

        Results.ForceMoveOutReqResult retVal = new Results.ForceMoveOutReqResult();
        List<Infos.OpeCompLot> opeCompLots = new ArrayList<>();
        retVal.setStrOpeCompLot(opeCompLots);
        //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        //   Check Process
        //=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        int PostProcForLotFlag = StandardProperties.OM_PP_FOR_LOT_MOVEOUT_FLAG.getIntValue();

        log.info("Check Transaction ID and equipment Category combination.");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Object Lock Process                                                 */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

        /*-----------------------------------------------------------------------*/
        /*   Get Started Lot information which is sepcified with ControlJob ID   */
        /*-----------------------------------------------------------------------*/
        Outputs.ObjControlJobStartReserveInformationOut objControlJobStartReserveInformationOut =
                controlJobMethod.controlJobStartReserveInformationGet(objCommon,
                        controlJobID,
                        false);

        int scLen = CimArrayUtils.getSize(objControlJobStartReserveInformationOut.getStartCassetteList());
        log.info("objControlJobStartReserveInformationOut.getStartCassetteList().length() : {}", scLen);

        int ii, jj, kk, ll;
        int leng1, leng2, leng3;
        for (ii = 0; ii < scLen; ii++) {
            leng1 = CimArrayUtils.getSize(objControlJobStartReserveInformationOut.getStartCassetteList().get(ii).getLotInCassetteList());
            log.info("strLotInCassette.length---> : {}", leng1);
            for (jj = 0; jj < leng1; jj++) {
                if (CimBooleanUtils.isTrue(objControlJobStartReserveInformationOut.getStartCassetteList().get(ii).getLotInCassetteList().get(jj).getMoveInFlag())) {

                }
                leng2 = CimArrayUtils.getSize(objControlJobStartReserveInformationOut.getStartCassetteList().get(ii).getLotInCassetteList().get(jj).getStartRecipe().getDcDefList());
                log.info("strStartRecipe.strDCDef.length---> : {}", leng2);
                for (kk = 0; kk < leng2; kk++) {
                    leng3 = CimArrayUtils.getSize(objControlJobStartReserveInformationOut.getStartCassetteList().get(ii).getLotInCassetteList().get(jj).getStartRecipe().getDcDefList().get(kk).getDcItems());
                    log.info("strDCDef.strDCItem.length---> : {}", leng3);
                    for (ll = 0; ll < leng3; ll++) {
                        log.info("specCheckResult---> : {}", objControlJobStartReserveInformationOut.getStartCassetteList().get(ii).getLotInCassetteList().get(jj).getStartRecipe().getDcDefList().get(kk).getDcItems().get(ll).getSpecCheckResult());
                    }
                }
            }
        }

        // Get required equipment lock mode
        log.info("calling object_lockMode_Get() ： {}", equipmentID);
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(objCommon.getTransactionID());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut strObject_lockMode_Get_out = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        int lockMode = strObject_lockMode_Get_out.getLockMode().intValue();
        log.info("lockMode ： {}", lockMode);
        if (lockMode != BizConstant.SP_EQP_LOCK_MODE_WRITE) {
            log.info("lockMode != SP_EQP_LOCK_MODE_WRITE");

            // Lock Equipment Main Object
            Inputs.ObjAdvanceLockIn strAdvanced_object_Lock_in = new Inputs.ObjAdvanceLockIn();
            strAdvanced_object_Lock_in.setObjectID(equipmentID);
            strAdvanced_object_Lock_in.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvanced_object_Lock_in.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            strAdvanced_object_Lock_in.setLockType(strObject_lockMode_Get_out.getRequiredLockForMainObject());
            log.info("calling advanced_object_Lock() : {} ", BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            objectLockMethod.advancedObjectLock(objCommon, strAdvanced_object_Lock_in);
        } else {
            log.info("lockMode = SP_EQP_LOCK_MODE_WRITE");
            //   Lock Macihne object
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        /*--------------------------------*/
        /*   Lock Cassette / Lot Object   */
        /*--------------------------------*/

        List<Infos.StartCassette> strStartCassette = new ArrayList<>(scLen);

        // Check length of Start Cassette
        Validations.check(0 >= scLen, retCodeConfig.getNotFoundCassette());

        List<ObjectIdentifier> lotIDs = new ArrayList<>();
        List<ObjectIdentifier> cassetteIDs = new ArrayList<>();

        for (int i = 0; i < scLen; i++) {
            strStartCassette.add(objControlJobStartReserveInformationOut.getStartCassetteList().get(i));

            int nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            log.info("strStartCassette(i).strLotInCassette.length() : {}", nLen);

            /*--------------------------*/
            /*   Lock Cassette Object   */
            /*--------------------------*/
            if (CimStringUtils.equals(strStartCassette.get(i).getLoadPurposeType(), BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
                log.info("CIMFWStrCmp(strStartCassette(i).loadPurposeType, SP_LoadPurposeType_EmptyCassette ) == 0 : {}", i);

                try {
                    equipmentMethod.equipmentMonitorCreationFlagGet(objCommon, equipmentID);
                } catch (ServiceException e) {
                    //---------------------------------------------------------------------------------------------
                    //    if monitor creationflag was TRUE, at least one Lot should be existed in Empty Cassete.
                    //---------------------------------------------------------------------------------------------
                    if (Validations.isEquals(e.getCode(), retCodeConfigEx.getMonitorCreatReqd())) {
                        if (nLen == 0) {
                            throw e;
                        }
                    } else if (Validations.isEquals(e.getCode(), retCodeConfig.getNotFoundEqp())) {
                        log.info("equipment_monitorCreationFlag_Get() == RC_NOT_FOUND_EQP");
                        throw e;
                    } else {
                        // Do nothing.
                        // Because equipment_monitorCreationFlag_Get returns
                        // RC_MONITOR_CREAT_REQD, RC_MONITOR_CREAT_NOT_REQD,
                        // or RC_NOT_FOUND_EQP only.
                        log.info("equipment_monitorCreationFlag_Get() Returns");
                    }
                }

                cassetteIDs.add(strStartCassette.get(i).getCassetteID());
                continue;
            }

            cassetteIDs.add(strStartCassette.get(i).getCassetteID());

            for (int j = 0; j < nLen; j++) {

                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    log.info("strStartCassette(i).getLotInCassetteList().get(j).operationStartFlag == FALSE");
                    continue;
                }
                lotIDs.add(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
            }
        }

        log.info("cassetteIDCnt : {}", CimArrayUtils.getSize(cassetteIDs));
        log.info("lotIDCnt : {}", CimArrayUtils.getSize(lotIDs));

        if (lockMode != BizConstant.SP_EQP_LOCK_MODE_WRITE) {
            log.info("lockMode != SP_EQP_LOCK_MODE_WRITE");
            String strEquipment_onlineMode_Get_out = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);


            if (CimStringUtils.equals(strEquipment_onlineMode_Get_out, BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                // Lock Equipment ProcLot Element (Count)
                Inputs.ObjAdvanceLockIn strAdvanced_object_Lock_in = new Inputs.ObjAdvanceLockIn();
                strAdvanced_object_Lock_in.setObjectID(equipmentID);
                strAdvanced_object_Lock_in.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
                strAdvanced_object_Lock_in.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT);
                strAdvanced_object_Lock_in.setLockType(BaseStaticMethod.converLong(BizConstant.SP_OBJECTLOCK_LOCKTYPE_COUNT));
                strAdvanced_object_Lock_in.setKeyList(new ArrayList<>());
                log.info("calling advanced_object_Lock() : {} ", BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
                objectLockMethod.advancedObjectLock(objCommon, strAdvanced_object_Lock_in);
            }

            // Lock Equipment ProcLot Element (Write)
            List<String> procLotSeq = new ArrayList<>();
            for (int procLotNo = 0; procLotNo < CimArrayUtils.getSize(lotIDs); procLotNo++) {
                procLotSeq.add(CimObjectUtils.getObjectValue(lotIDs.get(procLotNo)));
            }

            Inputs.ObjAdvanceLockIn strAdvanced_object_Lock_in = new Inputs.ObjAdvanceLockIn();
            strAdvanced_object_Lock_in.setObjectID(equipmentID);
            strAdvanced_object_Lock_in.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
            strAdvanced_object_Lock_in.setObjectType(BizConstant.SP_OBJECTLOCK_OBJECTTYPE_INPROCESSINGLOT);
            strAdvanced_object_Lock_in.setLockType(BaseStaticMethod.converLong(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE));
            strAdvanced_object_Lock_in.setKeyList(procLotSeq);
            log.info("calling advanced_object_Lock() : {} ", BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT);
            objectLockMethod.advancedObjectLock(objCommon, strAdvanced_object_Lock_in);
        } else {
            log.info("lockMode = SP_EQP_LOCK_MODE_WRITE");
            //**********************************************************//*
            //*  Lock All Port Object for internal Buffer Equipment.   *//*
            //**********************************************************//*
            Infos.EqpPortInfo strEquipment_portInfoForInternalBuffer_GetDR_out = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon, equipmentID);

            int lenPortInfo = CimArrayUtils.getSize(strEquipment_portInfoForInternalBuffer_GetDR_out.getEqpPortStatuses());
            for (int j = 0; j < lenPortInfo; j++) {
                objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, strEquipment_portInfoForInternalBuffer_GetDR_out.getEqpPortStatuses().get(j).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
                log.info("Locked port object : {}", strEquipment_portInfoForInternalBuffer_GetDR_out.getEqpPortStatuses().get(j).getPortID());
            }
        }
        if (lockMode != BizConstant.SP_EQP_LOCK_MODE_WRITE) {
            //*------------------------------*//*
            //*   Lock Material Location     *//*
            //*------------------------------*//*
            for (int ij = 0; ij < scLen; ij++) {
                Inputs.ObjAdvancedObjectLockForEquipmentResourceIn strAdvanced_object_LockForEquipmentResource_in = new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
                strAdvanced_object_LockForEquipmentResource_in.setEquipmentID(equipmentID);
                strAdvanced_object_LockForEquipmentResource_in.setClassName(BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCJ);
                strAdvanced_object_LockForEquipmentResource_in.setObjectID(controlJobID);
                strAdvanced_object_LockForEquipmentResource_in.setObjectLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
                strAdvanced_object_LockForEquipmentResource_in.setBufferResourceName(strStartCassette.get(ij).getLoadPurposeType());
                strAdvanced_object_LockForEquipmentResource_in.setBufferResourceLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);

                log.info("calling advanced_object_LockForEquipmentResource() : {}", BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCJ);
                objectLockMethod.advancedObjectLockForEquipmentResource(objCommon, strAdvanced_object_LockForEquipmentResource_in);
            }
            //*------------------------------*//*
            //*   Lock ControlJob Object     *//*
            //*------------------------------*//*
            log.info("calling object_Lock() : {}", BizConstant.SP_CLASSNAME_POSCONTROLJOB);
            objectLockMethod.objectLock(objCommon, CimControlJob.class, controlJobID);
        }

        /*------------------------------*/
        /*   Lock Cassette/Lot Object   */
        /*-------------------------------*/

        log.info("calling objectSequence_Lock() : {}", BizConstant.SP_CLASSNAME_POSCASSETTE);
        //objectLockMethod.objectSequenceLock( strObjectSequence_Lock_out, strObjCommonIn, cassetteIDs, SP_ClassName_PosCassette );

        log.info("calling objectSequence_Lock() : {}", BizConstant.SP_CLASSNAME_POSLOT);
        //objectSequenceLock( strObjectSequence_Lock_out, strObjCommonIn, lotIDs, SP_ClassName_PosLot );

        /*-------------------------------------------------*/
        /*   call cassette_APCInformation_GetDR            */
        /*-------------------------------------------------*/
        log.info("call cassette_APCInformation_GetDR");

        //【TODO】【TODO - NOTIMPL】- cassette_APCInformation_GetDR
        /*
        objCassette_APCInformation_GetDR_out strCassette_APCInformation_GetDR_out;
        cassette_APCInformation_GetDR ( strCassette_APCInformation_GetDR_out,
                strObjCommonIn,
                equipmentID,
                strStartCassette );
        if ( rc == RC_SYSTEM_ERROR )
        {
            log.info( "cassette_APCInformation_GetDR() == RC_SYSTEM_ERROR");
            strForceMoveOutForIBReqResult.strResult = strCassette_APCInformation_GetDR_out.strResult;
            return ( rc );
        }
        else if( rc != RC_OK )
        {
            log.info( "cassette_APCInformation_GetDR() != RC_OK");
            strForceMoveOutForIBReqResult.strResult = strCassette_APCInformation_GetDR_out.strResult;
        }*/

        // add season by ho
        seasoningService.sxSeasonForForceMoveOut(objCommon, equipmentID);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Check Process                                                       */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

        /*---------------------------------*/
        /*   Get Equipment's Online Mode   */
        /*---------------------------------*/
        Outputs.ObjPortResourceCurrentOperationModeGetOut strPortResource_currentOperationMode_Get_out = portMethod.portResourceCurrentOperationModeGet(objCommon, equipmentID, strStartCassette.get(0).getUnloadPortID());


        /*----------------------------------------------------------------------------*/
        /*                                                                            */
        /*   If AccessMode is Auto or OnlineMode is Offline, do the following check.  */
        /*                                                                            */
        /*----------------------------------------------------------------------------*/


        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process for Lot                                               */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   - lotProcessState                                                   */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        for (int i = 0; i < scLen; i++) {
            int nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }

                Outputs.ObjLotAllStateGetOut strLot_allState_Get_out = lotMethod.lotAllStateGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                if (!CimStringUtils.equals(strLot_allState_Get_out.getProcessState(), BizConstant.SP_LOT_PROCSTATE_PROCESSING)) {
                    log.info("lot_allState_Get() strLot_allState_Get_out.processState == SP_Lot_ProcState_Processing");
                    Validations.check(new OmCode(retCodeConfig.getInvalidLotProcstat()));
                }

                if (CimStringUtils.equals(strLot_allState_Get_out.getHoldState(), BizConstant.CIMFW_LOT_HOLDSTATE_NOTONHOLD)) {
                    log.info("HoldState == NotOnHold");
                    Validations.check(new OmCode(retCodeConfig.getInvalidLotHoldStat()));

                }
            }
        }


        /*-----------------------------------------------------------------------*/
        /*                                                                       */
        /*   Check Process for Equipment                                         */
        /*                                                                       */
        /*   The following conditions are checked by this object                 */
        /*                                                                       */
        /*   - All lof lot, which is contained in controlJob, must be existing   */
        /*     in the equipment's processing information.                        */
        /*                                                                       */
        /*-----------------------------------------------------------------------*/
        equipmentMethod.equipmentCheckConditionForOpeComp(objCommon, equipmentID, strStartCassette);

        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
        /*                                                                       */
        /*   Main Process (Reverse Order of OpeStart Procedure)                  */
        /*                                                                       */
        /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

        /*-------------------------*/
        /*   SPC Check Procedure   */
        /*-------------------------*/


        /*----------------------------*/
        /*   Send SPC Check Request   */
        /*----------------------------*/

        /*---------------------------------------------------------------------*/
        /*   In case of post process migration mode, fix PostProcForLotFlag    */
        /*---------------------------------------------------------------------*/
        if (-1 == PostProcForLotFlag) {
            log.info("Post Process Migration Mode");
            /*----------------------------------------------------------------------*/
            /*   In case of post process migration mode, check value in OSPPRCCONFIG    */
            /*----------------------------------------------------------------------*/
            Infos.ConfigInfo strConfigurationInformation_GetDR_out = null;
            try {
                strConfigurationInformation_GetDR_out = cimComp.configurationInformationGetDR(objCommon, CimObjectUtils.getObjectValue(equipmentID), BizConstant.SP_CONFIGURATIONCATEGORY_EQUIPMENTPOSTPROCDECOUPLEMODE);
            } catch (ServiceException e) {
                if (!Validations.isEquals(e.getCode(), retCodeConfig.getNotFoundEntry())) {
                    throw e;
                }

                if (Validations.isEquals(e.getCode(), retCodeConfig.getNotFoundEntry())) {
                    log.info("Entry isn't found in OSPPRCCONFIG");
                    PostProcForLotFlag = 0;
                } else {
                    if (CimStringUtils.equals(strConfigurationInformation_GetDR_out.getValue(), "1")) {
                        log.info("EquipmentPostProcActionDecoupleMode = 1");
                        PostProcForLotFlag = 1;
                    } else {
                        log.info("EquipmentPostProcActionDecoupleMode != 1");
                        PostProcForLotFlag = 0;
                    }
                }
            }


            // Store PostProcForLotFlag as thread specific data
            String methodName = null;
            String strPostProcForLotFlag = String.format("%d", PostProcForLotFlag);
            ThreadContextHolder.setThreadSpecificDataString(BizConstant.SP_THREADSPECIFICDATA_KEY_POSTPROCFORLOTFLAG, strPostProcForLotFlag);
        }
        /*--------------------------------*/
        /*                                */
        /*   CP Test Function Procedure   */
        /*                                */
        /*--------------------------------*/
        int nLen = 0;
        for (int i = 0; i < scLen; i++) {
            nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }
                /*-----------------------------------------*/
                /*   Check Test Type of Current Process    */
                /*-----------------------------------------*/
                ObjectIdentifier strLot_testTypeID_Get_out = null;
                try {
                    strLot_testTypeID_Get_out = lotMethod.lotTestTypeIDGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                } catch (ServiceException e) {
                    if (!Validations.isEquals(e.getCode(), retCodeConfig.getNotFoundTestType())) {
                        throw e;
                    }
                }

                if (CimObjectUtils.isNotEmpty(strLot_testTypeID_Get_out)) {
                    /*---------------------------------------------------------------*/
                    /*   Gather Bin Summary Information based on lotID & testTypeID  */
                    /*---------------------------------------------------------------*/
                    List<Infos.WaferBinSummary> strBinSummary_GetByTestTypeDR_out = binSummaryMethod.binSummaryGetByTestTypeDR(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strLot_testTypeID_Get_out);

                    /*----------------------------------------------------------*/
                    /*   Update Wafer Die quantity based on the input parameter  */
                    /*-----------------------------------------------------------*/
                    int bsLen = CimArrayUtils.getSize(strBinSummary_GetByTestTypeDR_out);
                    log.info("strBinSummary_GetByTestTypeDR_out.strWaferBinSummary.length() : {}", bsLen);

                    List<Infos.LotWaferAttributes> strLotWaferAttributes = new ArrayList<>();
                    for (int k = 0; k < bsLen; k++) {
                        if (0 != strBinSummary_GetByTestTypeDR_out.get(k).getBinReportCount()) {
                            Infos.LotWaferAttributes lotWaferAttributes = new Infos.LotWaferAttributes();
                            lotWaferAttributes.setWaferID(strBinSummary_GetByTestTypeDR_out.get(k).getWaferId());
                            lotWaferAttributes.setGoodUnitCount(strBinSummary_GetByTestTypeDR_out.get(k).getGoodUnitCount());
                            lotWaferAttributes.setRepairUnitCount(strBinSummary_GetByTestTypeDR_out.get(k).getRepairUnitCount());
                            lotWaferAttributes.setFailUnitCount(strBinSummary_GetByTestTypeDR_out.get(k).getFailUnitCount());
                            strLotWaferAttributes.add(lotWaferAttributes);
                        }
                    }
                    lotMethod.lotWaferChangeDie(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strLotWaferAttributes);
                }
            }
        }

        /*------------------------------------------------------*/
        /*                                                      */
        /*     FlowBatch Related Information Update Procedure   */
        /*                                                      */
        /*------------------------------------------------------*/
        /*----------------------------------------------------------*/
        /*   Update FlowBatch Information of Equipment              */
        /*----------------------------------------------------------*/
        flowBatchMethod.flowBatchInformationUpdateByOpeComp(objCommon, equipmentID, strStartCassette);

        /*----------------------------------------------*/
        /*                                              */
        /*   Process Operation Update Procedure         */
        /*                                              */
        /*----------------------------------------------*/
        /*-------------------------------------------------*/
        /*   Update Process Operation (actual comp xxxx)   */
        /*-------------------------------------------------*/
        processMethod.processActualCompInformationSet(objCommon, strStartCassette);

        if (PostProcForLotFlag != 1) {
            /*-------------------------------------------------*/
            /*   Make Measurement & Process Data History       */
            /*-------------------------------------------------*/
            eventMethod.collectedDataEventMake(objCommon, TransactionIDEnum.FORCE_OPE_COMP_FOR_INTERNAL_BUFFER_REQ.getValue(), strStartCassette, controlJobID, equipmentID, claimMemo);
        }

        List<Outputs.ObjLotFutureHoldRequestsEffectByConditionOut> strLot_futureHoldRequests_EffectByCondition_outSequence = new ArrayList<>();
        int fHCnt = 0;
        ObjectIdentifier releaseReasonCodeID = new ObjectIdentifier(BizConstant.SP_REASON_GATEPASS);

        if (PostProcForLotFlag != 1) {
            /*-------------------------------------------*/
            /*   Delete Effected Future Hold Direction   */
            /*-------------------------------------------*/

            for (int i = 0; i < scLen; i++) {
                nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
                for (int j = 0; j < nLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                        continue;
                    }

                    //D4100083 Add Start
                    log.info("i : {}", i);
                    log.info("j : {}", j);
                    log.info("strStartCassette(i).getLotInCassetteList().get(j).lotID : {}", strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                    /*-------------------------------*/
                    /*   Get Effected Future Hold    */
                    /*-------------------------------*/
                    log.info("Get Effected Future Hold");
                    Infos.EffectCondition strEffectCondition = new Infos.EffectCondition();
                    strEffectCondition.setPhase(BizConstant.SP_FUTUREHOLD_POST);
                    strEffectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);

                    Outputs.ObjLotFutureHoldRequestsEffectByConditionOut objLotFutureHoldRequestsEffectByConditionOut = lotMethod.lotFutureHoldRequestsEffectByCondition(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strEffectCondition);
                    strLot_futureHoldRequests_EffectByCondition_outSequence.add(objLotFutureHoldRequestsEffectByConditionOut);

                    /*-------------------------------------------*/
                    /*   Delete Effected Future Hold Direction   */
                    /*-------------------------------------------*/
                    strEffectCondition.setPhase(BizConstant.SP_FUTUREHOLD_ALL);
                    strEffectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);

                    Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut strLot_futureHoldRequests_DeleteEffectedByCondition_out = lotMethod.lotFutureHoldRequestsDeleteEffectedByCondition(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strEffectCondition);

                    // Pass hold cancel record list
                    if (CimArrayUtils.getSize(strLot_futureHoldRequests_DeleteEffectedByCondition_out.getStrFutureHoldReleaseReqList()) > 0) {
                        processControlService.sxFutureHoldCancelReq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), releaseReasonCodeID,
                                BizConstant.SP_ENTRYTYPE_REMOVE, strLot_futureHoldRequests_DeleteEffectedByCondition_out.getStrFutureHoldReleaseReqList());
                    }
                }
            }
        }

        /*------------------------------------------------------------*/
        /*                                                            */
        /*   Reticle / Fixture Related Information Update Procedure   */
        /*                                                            */
        /*------------------------------------------------------------*/

        int usedReticleSeqLen = 0;
        int usedFixtureSeqLen = 0;
        /*--------------------------------------------------------*/
        /*   Check ProcessDurable was Used for Operation or Not   */
        /*--------------------------------------------------------*/
        try {
            equipmentMethod.equipmentProcessDurableRequiredFlagGet(objCommon, equipmentID);
        } catch (ServiceException e) {
            if (Validations.isEquals(e.getCode(), retCodeConfig.getEquipmentProcessDurableNotRequired())) {
                log.info("equipment_processDurableRequiredFlag_Get() == RC_EQP_PROCDRBL_NOT_REQD");

            } else if (Validations.isEquals(e.getCode(), retCodeConfig.getEquipmentProcessDurableReticleRequired())
                    || Validations.isEquals(e.getCode(), retCodeConfig.getEquipmentProcessDurableFixtRequired())) {
                log.info("equipment_processDurableRequiredFlag_Get() == RC_EQP_PROCDRBL_RTCL_REQD || RC_EQP_PROCDRBL_FIXT_REQD");
                for (int i = 0; i < scLen; i++) {
                    nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
                    for (int j = 0; j < nLen; j++) {
                        if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                            continue;
                        }

                        if (Validations.isEquals(e.getCode(), retCodeConfig.getEquipmentProcessDurableReticleRequired())) {

                            /*-------------------------------*/
                            /*   Get Used Reticles for Lot   */
                            /*-------------------------------*/
                            List<Infos.StartReticle> strProcess_assignedReticle_Get_out = processMethod.processAssignedReticleGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                            usedReticleSeqLen = CimArrayUtils.getSize(strProcess_assignedReticle_Get_out);
                            log.info("strProcess_assignedReticle_Get_out.strStartReticle.length() : {}", usedReticleSeqLen);

                            for (int k = 0; k < usedReticleSeqLen; k++) {
                                Outputs.ObjReticleUsageLimitationCheckOut strReticle_usageLimitation_Check_out = reticleMethod.reticleUsageLimitationCheck(objCommon, strProcess_assignedReticle_Get_out.get(k).getReticleID());

                                if (CimBooleanUtils.isTrue(strReticle_usageLimitation_Check_out.isUsageLimitOverFlag())) {
                                    log.info("strReticle_usageLimitation_Check_out.usageLimitOverFlag == TRUE");

                                    /*-------------------------*/
                                    /*   Call System Message   */
                                    /*-------------------------*/
                                    Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                                    alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                                    alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_RTCLUSAGELIMITOVER);
                                    alertMessageRptParams.setSystemMessageText(strReticle_usageLimitation_Check_out.getMessageText());
                                    alertMessageRptParams.setNotifyFlag(true);
                                    alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.getTimestampAsString(objCommon.getTimeStamp().getReportTimeStamp()));
                                    systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
                                }
                                /*---------------------------------------------*/
                                /*  Set last used time stamp for used reticle  */
                                /*---------------------------------------------*/
                                reticleMethod.reticleLastUsedTimeSet(strProcess_assignedReticle_Get_out.get(k).getReticleID(), objCommon.getTimeStamp().getReportTimeStamp());
                            }
                        } else {

                            /*------------------------------*/
                            /*   Get Used Fixture for Lot   */
                            /*------------------------------*/
                            List<Infos.StartFixture> strProcess_assignedFixture_Get_out = processMethod.processAssignedFixtureGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                            usedFixtureSeqLen = CimArrayUtils.getSize(strProcess_assignedFixture_Get_out);
                            log.info("strProcess_assignedFixture_Get_out.strStartFixture.length() : {}", usedFixtureSeqLen);

                            /*------------------------------------*/
                            /*   Fixture Usage Limitation Check   */
                            /*------------------------------------*/
                            for (int k = 0; k < usedFixtureSeqLen; k++) {
                                Outputs.objFixtureUsageLimitationCheckOut strFixture_usageLimitation_Check_out = fixtureMethod.fixtureUsageLimitationCheck(objCommon, strProcess_assignedFixture_Get_out.get(k).getFixtureID());

                                if (strFixture_usageLimitation_Check_out.isUsageLimitOverFlag()) {
                                    log.info("strFixture_usageLimitation_Check_out.usageLimitOverFlag == TRUE");

                                    /*-------------------------*/
                                    /*   Call System Message   */
                                    /*-------------------------*/
                                    Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                                    alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                                    alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_FIXTUSAGELIMITOVER);
                                    alertMessageRptParams.setSystemMessageText(strFixture_usageLimitation_Check_out.getMessageText());
                                    alertMessageRptParams.setNotifyFlag(true);
                                    alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.getTimestampAsString(objCommon.getTimeStamp().getReportTimeStamp()));
                                    systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
                                }

                            }

                        }

                    }

                }
            } else {
                throw e;
            }
        }


        /*----------------------------------------------*/
        /*                                              */
        /*   Lot Related Information Update Procedure   */
        /*                                              */
        /*----------------------------------------------*/
        if (PostProcForLotFlag != 1) {
            /*---------------------------------*/
            /*   Set/Clear Q-Time Management   */
            /*---------------------------------*/
            List<Infos.QTimeActionRegisterInfo> strQtime_SetClearByOpeComp_out = qTimeMethod.qtimeSetClearByOpeComp(objCommon, strStartCassette);

            //D7000354 Add Start
            //--------------------------------------------------
            // Reset Q-Time actions
            //--------------------------------------------------
            ObjectIdentifier resetReasonCodeID = new ObjectIdentifier(BizConstant.SP_REASON_QTIMECLEAR);

            int resetLen = CimArrayUtils.getSize(strQtime_SetClearByOpeComp_out);
            for (int resetCnt = 0; resetCnt < resetLen; resetCnt++) {
                Infos.QTimeActionRegisterInfo strResetAction = strQtime_SetClearByOpeComp_out.get(resetCnt);

                //----- Lot Hold Actions -------//
                if (CimArrayUtils.getSize(strResetAction.getLotHoldList()) > 0) {
                    log.info("The lot hold actions to reset was found.");

                    Params.HoldLotReleaseReqParams holdLotReleaseReqParams = new Params.HoldLotReleaseReqParams();
                    holdLotReleaseReqParams.setHoldReqList(strResetAction.getLotHoldList());
                    holdLotReleaseReqParams.setLotID(strResetAction.getLotID());
                    holdLotReleaseReqParams.setReleaseReasonCodeID(resetReasonCodeID);
                    lotService.sxHoldLotReleaseReq(objCommon, holdLotReleaseReqParams);
                }

                //----- Future Hold Actions -------//
                if (CimArrayUtils.getSize(strResetAction.getFutureHoldList()) > 0) {
                    log.info("The future hold actions to cancel was found.");

                    processControlService.sxFutureHoldCancelReq(objCommon, strResetAction.getLotID(), releaseReasonCodeID,
                            BizConstant.SP_ENTRYTYPE_CANCEL, strResetAction.getFutureHoldList());

                }

                //----- Future Rework Actions -------//
                int cancelLen = CimArrayUtils.getSize(strResetAction.getFutureReworkList());
                if (cancelLen > 0) {
                    log.info("The future rework actions to cancel was found. : {}", cancelLen);

                    for (int cancelCnt = 0; cancelCnt < cancelLen; cancelCnt++) {
                        Infos.FutureReworkInfo strFutureRework = strResetAction.getFutureReworkList().get(cancelCnt);
                        processControlService.sxFutureReworkCancelReq(objCommon, strFutureRework.getLotID(), strFutureRework.getRouteID(),
                                strFutureRework.getOperationNumber(), strFutureRework.getFutureReworkDetailInfoList(), "");
                    }
                }
            }

            // 检查并设置Min Q-Time最小时间限制
            minQTimeMethod.checkAndSetRestrictions(objCommon, strStartCassette);
        }

        /*-----------------------------------------*/
        /*   Change Lot Process State to Waiting   */
        /*-----------------------------------------*/
        lotMethod.lotProcessStateMakeWaiting(objCommon, strStartCassette);

        /*-----------------------------------------------------------------------*/
        /*   Procedure for PO Moving                                             */
        /*-----------------------------------------------------------------------*/

        List<ObjectIdentifier> autoBankInLotIDs = new ArrayList<>();
        List<ObjectIdentifier> opeStartLotIDs = new ArrayList<>();

        for (int i = 0; i < scLen; i++) {
            nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {
                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }
                //set contamination flag for operation
                contaminationMethod.lotContaminationLevelAndPrFlagSet(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                /*-----------------------------------*/
                /*   Move Process Operation of Lot   */
                /*-----------------------------------*/
                Outputs.ObjProcessMoveOut strProcessMoveOut = null;
                try {
                    strProcessMoveOut = processMethod.processMove(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                } catch (ServiceException e) {
                    if (Validations.isEquals(e.getCode(), retCodeConfig.getAddToQueueFail())) {
                        log.info("process_Move() == RC_ADDTOQUEUE_FAIL");

                        Outputs.ObjLotCurrentOperationInfoGetOut strLot_currentOperationInfo_Get_out = lotMethod.lotCurrentOperationInfoGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                        List<Infos.LotHoldReq> strLotHoldReqList = new ArrayList<>(1);
                        Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                        lotHoldReq.setHoldType(BizConstant.SP_HOLDTYPE_ADDTOQUEUEERRHOLD);
                        lotHoldReq.setHoldReasonCodeID(new ObjectIdentifier(BizConstant.SP_REASON_ADDTOQUEUEERRHOLD));
                        lotHoldReq.setHoldUserID(objCommon.getUser().getUserID());
                        lotHoldReq.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_CURRENT);
                        lotHoldReq.setRouteID(strLot_currentOperationInfo_Get_out.getRouteID());
                        lotHoldReq.setOperationNumber(strLot_currentOperationInfo_Get_out.getOperationNumber());
                        lotHoldReq.setClaimMemo("");
                        strLotHoldReqList.add(lotHoldReq);
                        lotService.sxHoldLotReq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strLotHoldReqList);
                    } else {
                        throw e;
                    }
                }

                // save the returned lotID as ObjectIdentifier type for last txBankInReq() if autoBankInFlag is TRUE;
                if (!CimObjectUtils.isEmpty(strProcessMoveOut) && strProcessMoveOut.getAutoBankInFlag()) {
                    autoBankInLotIDs.add(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                }
                // set operation start lot
                opeStartLotIDs.add(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                //--------------------------------------------------------------------------------------------------
                // UpDate RequiredCassetteCategory
                //--------------------------------------------------------------------------------------------------
                lotMethod.lotCassetteCategoryUpdateForContaminationControl(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
            }
        }

        /*---------------------------------------------------------------*/
        /*   Auto Hold after force complete                              */
        /*---------------------------------------------------------------*/
        for (int i = 0; i < scLen; i++) {
            nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {

                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }

                List<Infos.LotHoldListAttributes> strHoldLotListInqResult = lotInqService.sxHoldLotListInq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                log.info("strStartCassette(i).getLotInCassetteList().get(j).lotID = : {}", strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                int oLen = CimArrayUtils.getSize(strHoldLotListInqResult);
                for (int k = 0; k < oLen; k++) {
                    log.info("k = : {}", k);
                    if (CimObjectUtils.equalsWithValue(strHoldLotListInqResult.get(k).getReasonCodeID(), BizConstant.SP_REASON_RUNNINGHOLD)) {
                        log.info("Find Running Hold Record!!");
                        List<Infos.LotHoldReq> strLotHoldReleaseReqList = new ArrayList<>(1);
                        Infos.LotHoldReq holdList = new Infos.LotHoldReq();
                        holdList.setHoldType(strHoldLotListInqResult.get(k).getHoldType());
                        holdList.setHoldReasonCodeID(strHoldLotListInqResult.get(k).getReasonCodeID());
                        holdList.setHoldUserID(strHoldLotListInqResult.get(k).getUserID());
                        holdList.setResponsibleOperationMark(strHoldLotListInqResult.get(k).getResponsibleOperationMark());
                        holdList.setRouteID(strHoldLotListInqResult.get(k).getResponsibleRouteID());
                        holdList.setOperationNumber(strHoldLotListInqResult.get(k).getResponsibleOperationNumber());
                        holdList.setRelatedLotID(strHoldLotListInqResult.get(k).getRelatedLotID());
                        holdList.setClaimMemo(strHoldLotListInqResult.get(k).getClaimMemo());
                        strLotHoldReleaseReqList.add(holdList);
                        ObjectIdentifier aReasonCodeID = new ObjectIdentifier(BizConstant.SP_REASON_RUNNINGHOLDRELEASE);

                        Params.HoldLotReleaseReqParams holdLotReleaseReqParams = new Params.HoldLotReleaseReqParams();
                        holdLotReleaseReqParams.setReleaseReasonCodeID(aReasonCodeID);
                        holdLotReleaseReqParams.setLotID(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                        holdLotReleaseReqParams.setHoldReqList(strLotHoldReleaseReqList);
                        lotService.sxHoldLotReleaseReq(objCommon, holdLotReleaseReqParams);

                        break;
                    }
                }

                /*-------------------------*/
                /*   Execute Lot Hold      */
                /*-------------------------*/
                ObjectIdentifier reasonCodeID = new ObjectIdentifier(BizConstant.SP_REASON_FORCECOMPHOLD);

                List<Infos.LotHoldReq> strHoldListSeq = new ArrayList<>(1);
                Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();
                lotHoldReq.setHoldType(BizConstant.SP_HOLDTYPE_LOTHOLD);
                lotHoldReq.setHoldReasonCodeID(reasonCodeID);
                lotHoldReq.setHoldUserID(objCommon.getUser().getUserID());
                lotHoldReq.setResponsibleOperationMark(BizConstant.SP_RESPONSIBLEOPERATION_PREVIOUS);
                lotHoldReq.setOperationNumber("");
                lotHoldReq.setClaimMemo("SYSAUTO:Force Complete System Hold");
                strHoldListSeq.add(lotHoldReq);
                lotService.sxHoldLotReq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strHoldListSeq);
            }
        }
        if (PostProcForLotFlag != 1) {

            /*----------------------------------------------------------------------------*/
            /*   Lot FutureHold Post By Previous Operation Effect after Operation Move    */
            /*----------------------------------------------------------------------------*/
            log.info("Lot FutureHold Post By Previous Operation Effect after Operation Move  ");

            int fhLen = CimArrayUtils.getSize(strLot_futureHoldRequests_EffectByCondition_outSequence);

            for (fHCnt = 0; fHCnt < fhLen; fHCnt++) {
                log.info("fHCnt ： {}", fHCnt);

                if (CimArrayUtils.getSize(strLot_futureHoldRequests_EffectByCondition_outSequence.get(fHCnt).getStrLotHoldReqList()) > 0) {

                    log.info("strLotHoldReqList.length() > 0");
                    /*-----------------------------------------------------*/
                    /*   Convert OpeNo, RouteID from previous to current   */
                    /*-----------------------------------------------------*/
                    log.info("Convert OpeNo from previous to current");

                    Outputs.ObjLotFutureHoldEffectedProcessConversionOut strLot_futureHold_EffectedProcessConversion_out = lotMethod.lotFutureHoldEffectedProcessConversion(objCommon, strLot_futureHoldRequests_EffectByCondition_outSequence.get(fHCnt).getLotID(),
                            strLot_futureHoldRequests_EffectByCondition_outSequence.get(fHCnt).getStrLotHoldReqList());


                    lotService.sxHoldLotReq(objCommon, strLot_futureHoldRequests_EffectByCondition_outSequence.get(fHCnt).getLotID(),
                            strLot_futureHold_EffectedProcessConversion_out.getLotHoldReqList());
                }
            }
        }

        //---------------------------------------------------------------------------
        //   Execute Lot Hold Action based on SpecCheck and also SPC Check result.
        //
        //---------------------------------------------------------------------------

        if (PostProcForLotFlag != 1) {
            /*-------------------------------------------*/
            /*   Effect PO's Direction for TEL Furnace   */
            /*-------------------------------------------*/
            List<Infos.LotHoldEffectList> strLot_holdRecord_EffectMonitorIssue_out = lotMethod.lotHoldRecordEffectMonitorIssue(objCommon, strStartCassette);


            int nMonitorHoldEffectLen = CimArrayUtils.getSize(strLot_holdRecord_EffectMonitorIssue_out);
            log.info("strLot_holdRecord_EffectMonitorIssue_out.strLotHoldEffectList.length() : {}", nMonitorHoldEffectLen);

            if (nMonitorHoldEffectLen > 0) {
                List<Infos.LotHoldReq> strLotHoldReqList = new ArrayList<>(1);

                for (int i = 0; i < nMonitorHoldEffectLen; i++) {
                    Infos.LotHoldReq lotHoldReq = new Infos.LotHoldReq();

                    lotHoldReq.setHoldType(strLot_holdRecord_EffectMonitorIssue_out.get(i).getHoldType());
                    lotHoldReq.setHoldReasonCodeID(strLot_holdRecord_EffectMonitorIssue_out.get(i).getReasonCodeID());
                    lotHoldReq.setHoldUserID(strLot_holdRecord_EffectMonitorIssue_out.get(i).getUserID());
                    lotHoldReq.setResponsibleOperationMark(strLot_holdRecord_EffectMonitorIssue_out.get(i).getResponsibleOperationMark());
                    lotHoldReq.setRouteID(strLot_holdRecord_EffectMonitorIssue_out.get(i).getRouteID());
                    lotHoldReq.setOperationNumber(strLot_holdRecord_EffectMonitorIssue_out.get(i).getOperationNumber());
                    lotHoldReq.setRelatedLotID(strLot_holdRecord_EffectMonitorIssue_out.get(i).getRelatedLotID());
                    lotHoldReq.setClaimMemo(strLot_holdRecord_EffectMonitorIssue_out.get(i).getClaimMemo());
                    strLotHoldReqList.add(lotHoldReq);

                    lotService.sxHoldLotReq(objCommon, strLot_holdRecord_EffectMonitorIssue_out.get(i).getLotID(), strLotHoldReqList);
                }
            }
        }

        if (PostProcForLotFlag != 1) {
            /*------------------------------------------*/
            /*   Effect Future Hold Direction if Exist  */
            /*------------------------------------------*/
            //D4100083    objLot_futureHoldRequests_Effect_out strLot_futureHoldRequests_Effect_out ;

            for (int i = 0; i < scLen; i++) {
                nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
                for (int j = 0; j < nLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag()))
                        continue;

                    /*------------------------------------------*/
                    /*   Effect Future Hold Direction if Exist  */
                    /*------------------------------------------*/

                    log.info("i ； {}", i);
                    log.info("j ： {}", j);
                    log.info("strStartCassette(i).getLotInCassetteList().get(j).lotID : {}", strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());

                    /*------------------------------------------------------------------*/
                    /*   Get Effected Future Hold PRE of Current after Operation Move   */
                    /*------------------------------------------------------------------*/
                    log.info("Get Effected Future Hold PRE of Current after Operation Move");

                    Infos.EffectCondition strEffectCondition = new Infos.EffectCondition();
                    strEffectCondition.setPhase(BizConstant.SP_FUTUREHOLD_PRE);
                    strEffectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_ALL);

                    Outputs.ObjLotFutureHoldRequestsEffectByConditionOut strLot_futureHoldRequests_EffectByCondition_out = lotMethod.lotFutureHoldRequestsEffectByCondition(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strEffectCondition);


                    if (CimArrayUtils.getSize(strLot_futureHoldRequests_EffectByCondition_out.getStrLotHoldReqList()) > 0) {
                        log.info("strLot_futureHoldRequests_EffectByCondition_out.strLotHoldReqList.length() > 0");
                        lotService.sxHoldLotReq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strLot_futureHoldRequests_EffectByCondition_out.getStrLotHoldReqList());
                    }

                    /*------------------------------------------------------------------------------------*/
                    /*   Get Effected Future Hold Cancel PRE and SINGLE of Current after Operation Move   */
                    /*------------------------------------------------------------------------------------*/
                    log.info("Get Effected Future Hold Cancel PRE and SINGLE of Current after Operation Move");

                    strEffectCondition.setPhase(BizConstant.SP_FUTUREHOLD_PRE);
                    strEffectCondition.setTriggerLevel(BizConstant.SP_FUTUREHOLD_SINGLE);

                    Outputs.ObjLotFutureHoldRequestsDeleteEffectedByConditionOut strLot_futureHoldRequests_DeleteEffectedByCondition_out = lotMethod.lotFutureHoldRequestsDeleteEffectedByCondition(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), strEffectCondition);

                    if (CimArrayUtils.getSize(strLot_futureHoldRequests_DeleteEffectedByCondition_out.getStrFutureHoldReleaseReqList()) > 0) {
                        log.info("strLot_futureHoldRequests_DeleteEffectedByCondition_out.strFutureHoldReleaseReqList.length() > 0");
                        processControlService.sxFutureHoldCancelReq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), releaseReasonCodeID,
                                BizConstant.SP_ENTRYTYPE_REMOVE, strLot_futureHoldRequests_DeleteEffectedByCondition_out.getStrFutureHoldReleaseReqList());
                    }
                }
            }
        }


        /*----------------------------------------------------*/
        /*                                                    */
        /*   Equipment Related Information Update Procedure   */
        /*                                                    */
        /*----------------------------------------------------*/

        /*----------------------------------------------------------------*/
        /*   Remove ControlJobLot from EqpInfo's ProcessingLot Sequence   */
        /*----------------------------------------------------------------*/
        equipmentMethod.equipmentProcessingLotDelete(objCommon, equipmentID, strStartCassette);

        /*---------------------------------------------*/
        /*   Maintain Eqp's Status when OFF-LINE Mode  */
        /*---------------------------------------------*/
        if (CimStringUtils.equals(strPortResource_currentOperationMode_Get_out.getOperationMode().getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
            log.info("strPortResource_currentOperationMode_Get_out.strOperationMode.onlineMode == SP_Eqp_OnlineMode_Offline");

            /*--------------------------------------------------------*/
            /*   Change Equipment's Status to 'STANDBY' if necessary  */
            /*--------------------------------------------------------*/

            /*===== get StateChangeableFlag ===*/
            Boolean strEquipment_currentState_CheckToManufacturing_out = equipmentMethod.equipmentCurrentStateCheckToManufacturing(objCommon, equipmentID);

            if (CimBooleanUtils.isTrue(strEquipment_currentState_CheckToManufacturing_out)) {
                log.info("strEquipment_currentState_CheckToManufacturing_out.ManufacturingStateChangeableFlag == TRUE");

                /*===== get Defaclt Status Code for Productive / Standby ===*/
                ObjectIdentifier equipmentStatus = equipmentMethod.equipmentRecoverStateGetManufacturing(objCommon, equipmentID);

                /*---------------------------------*/
                /*   Call txEqpStatusChangeReq()   */
                /*---------------------------------*/
                sxEqpStatusChangeReq(objCommon, equipmentID, equipmentStatus, claimMemo);
            }
        }

        /*--------------------------------------*/
        /*   Equipment Usage Limitation Check   */
        /*--------------------------------------*/
        Outputs.ObjEquipmentUsageLimitationCheckOut strEquipment_usageLimitation_Check_out = equipmentMethod.equipmentUsageLimitationCheck(objCommon, equipmentID);


        if (CimBooleanUtils.isTrue(strEquipment_usageLimitation_Check_out.isUsageLimitOverFlag())) {
            log.info("strEquipment_usageLimitation_Check_out.usageLimitOverFlag == TRUE");

            /*-------------------------*/
            /*   Call System Message   */
            /*-------------------------*/
            Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
            alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
            alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_EQPUSAGELIMITOVER);
            alertMessageRptParams.setSystemMessageText(strEquipment_usageLimitation_Check_out.getMessageText());
            alertMessageRptParams.setNotifyFlag(true);
            alertMessageRptParams.setEquipmentID(equipmentID);
            alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
            systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
        }


        /*----------------------------------------------------*/
        /*                                                    */
        /*   ControlJob Related Information Update Proceure   */
        /*                                                    */
        /*----------------------------------------------------*/

        /*------------------------*/
        /*   Delete Control Job   */
        /*------------------------*/

        if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())    //TxMoveOutWithRunningSplitReq
                && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue()))  //TxPartialMoveOutForIBReq
        {
            log.info("strObjCommonIn.transactionID is not OEQPW012 and OEQPW024");

            //----------------------------------------------------------------------------------
            // Delete ControlJob from EQP.
            // The relation of it with Lot and Cassette is deleted in txEDCWithSpecCheckActionReq.
            //----------------------------------------------------------------------------------
            Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
            cjStatusChangeReqParams.setControlJobID(controlJobID);
            cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE_FROM_EQP);
            cjStatusChangeReqParams.setClaimMemo(claimMemo);
            controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);
        }


        /*---------------------------------------------------*/
        /*                                                   */
        /*   Cassette Related Information Update Procedure   */
        /*                                                   */
        /*---------------------------------------------------*/
        for (int i = 0; i < scLen; i++) {

            /*-------------------------------------*/
            /*   Cassette Usage Limitation Check   */
            /*-------------------------------------*/
            Outputs.ObjCassetteUsageLimitationCheckOut strCassette_usageLimitation_Check_out = cassetteMethod.cassetteUsageLimitationCheck(objCommon, strStartCassette.get(i).getCassetteID());


            if (CimBooleanUtils.isTrue(strCassette_usageLimitation_Check_out.isUsageLimitOverFlag())) {
                log.info("strCassette_usageLimitation_Check_out.usageLimitOverFlag == TRUE");

                /*-------------------------*/
                /*   Call System Message   */
                /*-------------------------*/
                Params.AlertMessageRptParams alertMessageRptParams = new Params.AlertMessageRptParams();
                alertMessageRptParams.setSubSystemID(BizConstant.SP_SUBSYSTEMID_MM);
                alertMessageRptParams.setSystemMessageCode(BizConstant.SP_SYSTEMMSGCODE_CASTUSAGELIMITOVER);
                alertMessageRptParams.setSystemMessageText(strCassette_usageLimitation_Check_out.getMessageText());
                alertMessageRptParams.setNotifyFlag(true);
                alertMessageRptParams.setSystemMessageTimeStamp(CimDateUtils.convertToSpecString(objCommon.getTimeStamp().getReportTimeStamp()));
                systemService.sxAlertMessageRpt(objCommon, alertMessageRptParams);
            }

            /*---------------------------------------*/
            /*   Update Cassette's MultiLotType      */
            /*---------------------------------------*/
            cassetteMethod.cassetteMultiLotTypeUpdate(objCommon, strStartCassette.get(i).getCassetteID());
        }

        if (PostProcForLotFlag != 1) {
            //-------------------------------------------------// //D40A0027
            //                                                 // //D40A0027
            //   ProcessLagTime Information Update Procedure   // //D40A0027
            //                                                 // //D40A0027
            //-------------------------------------------------// //D40A0027
            log.info("ProcessLagTime Information Update Procedure...");
            for (int i = 0; i < scLen; i++) {
                log.info("strStartCassette(i).strLotInCassette.length()=> : {}", nLen);
                nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
                for (int j = 0; j < nLen; j++) {

                    //---------------------------//
                    //   Omit Not-OpeStart Lot   //
                    //---------------------------//
                    log.info("Omit Not-OpeStart Lot...");
                    if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                        continue;
                    }

                    //--------------------------------------//
                    //   Call txLagTimeActionReq()   //
                    //--------------------------------------//
                    log.info("Call txLagTimeActionReq()...");
                    Params.LagTimeActionReqParams lagTimeActionReqParams = new Params.LagTimeActionReqParams();
                    lagTimeActionReqParams.setLotID(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                    lagTimeActionReqParams.setAction(BizConstant.SP_PROCESSLAGTIME_ACTION_SET);
                    lagTimeActionReqParams.setUser(objCommon.getUser());
                    lagTimeActionReqParams.setClaimMemo(claimMemo);
                    processControlService.sxProcessLagTimeUpdate(objCommon, lagTimeActionReqParams);
                }
            }
        }

        if (PostProcForLotFlag != 1) {
            //-----------------------//
            //     Process Hold      //
            //-----------------------//

            for (int i = 0; i < scLen; i++) {
                int lcLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());

                for (int j = 0; j < lcLen; j++) {
                    log.info("Call txProcessHoldDoActionReq()");

                    if (CimBooleanUtils.isTrue(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                        processControlService.sxProcessHoldDoActionReq(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID(), claimMemo);
                    }
                }
            }
        }

        /*--------------------------*/
        /*                          */
        /*   Event Make Procedure   */
        /*                          */
        /*--------------------------*/
        for (int i = 0; i < scLen; i++) {
            log.info("strStartCassette(i).strLotInCassette.length()=> : {}", nLen);
            nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {

                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }

                log.info("counter j for lotOperationMoveEvent_MakeOpeComp = : {}", j);
                /*--------------------------------------------------------------------*/
                /*   Make OperationMoveEvent for Operation History - OpeComp          */
                /*--------------------------------------------------------------------*/
                Inputs.LotOperationMoveEventMakeOpeComp lotOperationMoveEventMakeOpeComp = new Inputs.LotOperationMoveEventMakeOpeComp();
                lotOperationMoveEventMakeOpeComp.setTransactionID(TransactionIDEnum.FORCE_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue());
                lotOperationMoveEventMakeOpeComp.setEquipmentID(equipmentID);
                lotOperationMoveEventMakeOpeComp.setOperationMode(CimObjectUtils.getObjectValue(strPortResource_currentOperationMode_Get_out.getOperationMode().getOperationMode()));
                lotOperationMoveEventMakeOpeComp.setControlJobID(controlJobID);
                lotOperationMoveEventMakeOpeComp.setCassetteID(strStartCassette.get(i).getCassetteID());
                lotOperationMoveEventMakeOpeComp.setLotInCassette(strStartCassette.get(i).getLotInCassetteList().get(j));
                lotOperationMoveEventMakeOpeComp.setClaimMemo(claimMemo);
                eventMethod.lotOperationMoveEventMakeOpeComp(objCommon, lotOperationMoveEventMakeOpeComp);
            }

        }

        Results.EDCWithSpecCheckActionReqResult strEDCWithSpecCheckActionReqResult = null;

        if (PostProcForLotFlag != 1) {
            //-------------------------------------------------//
            //                                                 //
            //     Invoking Action for Collected Data.         //
            //                                                 //
            //-------------------------------------------------//
            Infos.EDCWithSpecCheckActionReqInParm strEDCWithSpecCheckActionReqInParm = new Infos.EDCWithSpecCheckActionReqInParm();
            strEDCWithSpecCheckActionReqInParm.setControlJobID(controlJobID);
            strEDCWithSpecCheckActionReqInParm.setEquipmentID(equipmentID);
            strEDCWithSpecCheckActionReqInParm.setStrStartCassette(strStartCassette);

            strEDCWithSpecCheckActionReqResult = engineerDataCollectionService.sxEDCWithSpecCheckActionReq(objCommon, strEDCWithSpecCheckActionReqInParm, claimMemo);

            List<ObjectIdentifier> holdReleasedLotIDList = strEDCWithSpecCheckActionReqResult.getHoldReleasedLotIDs();
            opeCompLots = strEDCWithSpecCheckActionReqResult.getMoveOutReqResult().getMoveOutLot();
        } else {

            //-------------------------------------------------//
            //                                                 //
            //     DataValue CheckValidity for SpeckCheck      //
            //                                                 //
            //-------------------------------------------------//
            Outputs.ObjDataValueCheckValidityForSpecCheckDrOut strDataValue_CheckValidityForSpecCheckDR_out = new Outputs.ObjDataValueCheckValidityForSpecCheckDrOut();
            strDataValue_CheckValidityForSpecCheckDR_out.setEquipmentID(equipmentID);
            strDataValue_CheckValidityForSpecCheckDR_out.setControlJobID(controlJobID);
            strDataValue_CheckValidityForSpecCheckDR_out.setStartCassetteList(strStartCassette);

            /*----------------------*/
            /*   Initialize Logic   */
            /*----------------------*/
            log.info("Initialize Logic...");

            /*-------------------------------*/
            /*   Loop for strStartCassette   */
            /*-------------------------------*/
            log.info("Loop for strStartCassette...");
            for (int i = 0; i < scLen; i++) {
                /*-------------------------------*/
                /*   Loop for strLotInCassette   */
                /*-------------------------------*/
                log.info("Loop for strLotInCassette...");

                int lcLen = CimArrayUtils.getSize(strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList());
                for (int j = 0; j < lcLen; j++) {
                    /*------------------------*/
                    /*   Omit Not-Start Lot   */
                    /*------------------------*/
                    log.info("Omit Not-Start Lot...");

                    if (CimBooleanUtils.isFalse(strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                        log.info("Not-Start Lot. continue...");
                        continue;
                    }

                    /*---------------------------------*/
                    /*   Omit Non-DataClooection Lot   */
                    /*---------------------------------*/
                    log.info("Omit Non-DataClooection Lot...");

                    if (CimBooleanUtils.isFalse(strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDataCollectionFlag())) {
                        log.info("Non-DCDef Lot. continue...");
                        continue;
                    }

                    /*-----------*/
                    /*   Clear   */
                    /*-----------*/
                    log.info("Clear...");
                    int dcLen = CimArrayUtils.getSize(strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList());
                    for (int n = 0; n < dcLen; n++) {
                        int itLen = CimArrayUtils.getSize(strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems());
                        for (int l = 0; l < itLen; l++) {
                            Boolean bClearFlag = true;
                            if (CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJ, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getMeasurementType())
                                    || CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJWAFER, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getMeasurementType())
                                    || CimStringUtils.equals(BizConstant.SP_DCDEF_MEAS_PJWAFERSITE, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getMeasurementType())) {
                                log.info("strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i) : {}.getLotInCassetteList().get(j) : {}.strStartRecipe.strDCDef(n) : {}.strDCItem(l) ； {}.measurementType is SP_DCDef_Meas_PJ or SP_DCDef_Meas_PJWafer or SP_DCDef_Meas_PJWaferSite", i, j, n, l);
                                if (CimStringUtils.isNotEmpty(strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())) {
                                    log.info("0 < CIMFWStrLen(strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i): {}.getLotInCassetteList().get(j) : {}.strStartRecipe.strDCDef(n) : {}.strDCItem(l) : {}.specCheckResult)", i, j, n, l);
                                    if (CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_OK, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_UPPERCONTROLLIMIT, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERCONTROLLIMIT, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_UPPERSPECLIMIT, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERSPECLIMIT, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_UPPERSCREENLIMIT, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_LOWERSCREENLIMIT, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_APCERROR, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_ASTERISK, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_1X_POUND, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())
                                            || CimStringUtils.equals(BizConstant.SP_SPECCHECKRESULT_ERROR, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getSpecCheckResult())) {
                                        //Do Nothing
                                        log.info("Do Nothing");
                                    } else {
                                        log.info("set bClearFlag = false");
                                        bClearFlag = false;
                                    }
                                }
                            }
                            if (bClearFlag) {
                                /*===== Clear specCheckResult / actionCode =====*/
                                log.info("Clear specCheckResult / actionCode...");
                                strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).setSpecCheckResult("");
                                strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).setActionCodes("");

                                /*===== Clear dataValue =====*/
                                log.info("Clear dataValue...");
                                if (CimStringUtils.equals(strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).getItemType(), BizConstant.SP_DCDEF_ITEM_RAW)) {
                                    log.info("Raw Item. continue...");
                                    continue;
                                }
                                strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList().get(i).getLotInCassetteList().get(j).getStartRecipe().getDcDefList().get(n).getDcItems().get(l).setDataValue("");
                            }
                        }   // Loop for DCItem
                    }   // Loop for DCDef
                }   // Loop for strLotInCassette
            }   // Loop for strStartCassette

            /*----------------------------------*/
            /*   Set Initialized Data into PO   */
            /*----------------------------------*/
            log.info("Set Initialized Data into PO...");
            processMethod.processOperationTempDataSet(objCommon, controlJobID, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList());

            /*------------------------------------------------*/
            /*   Set DC Spec's detailed information into PO   */
            /*------------------------------------------------*/
            List<Infos.StartCassette> strProcess_dataCollectionSpecification_Set_out = processMethod.processDataCollectionSpecificationSet(objCommon, strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList());

            strDataValue_CheckValidityForSpecCheckDR_out.setStartCassetteList(strProcess_dataCollectionSpecification_Set_out);

            log.info("Do dataValue_CheckValidityForSpecCheck");
            /*--------------------*/
            /*   Validity Check   */
            /*--------------------*/
            try {
                Outputs.ObjDataValueCheckValidityForSpecCheckDrOut objDataValueCheckValidityForSpecCheckDrOut = dataValueMethod.dataValueCheckValidityForSpecCheckDR(objCommon, strDataValue_CheckValidityForSpecCheckDR_out.getEquipmentID(), strDataValue_CheckValidityForSpecCheckDR_out.getControlJobID(), strDataValue_CheckValidityForSpecCheckDR_out.getStartCassetteList());
            } catch (ServiceException e) {
                if (!Validations.isEquals(e.getCode(), retCodeConfig.getAllDataValAsterisk())) {
                    throw e;
                }
            }

            if (!CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_WITH_DATA_REQ.getValue())    //TxMoveOutWithRunningSplitReq
                    && !CimStringUtils.equals(objCommon.getTransactionID(), TransactionIDEnum.PARTIAL_OPERATION_COMP_FOR_INTERNAL_BUFFER_REQ.getValue()))  //TxPartialMoveOutForIBReq
            {

                //---------------------------------------------//
                //   Delete Control Job From Lot and Cassette  //
                //---------------------------------------------//
                log.info("Delete controlJob from Lot and Cassette.");
                Params.CJStatusChangeReqParams cjStatusChangeReqParams = new Params.CJStatusChangeReqParams();
                cjStatusChangeReqParams.setControlJobAction(BizConstant.SP_CONTROLJOBACTION_TYPE_DELETE_FROM_LOTANDCASSETTE);
                cjStatusChangeReqParams.setControlJobID(controlJobID);
                cjStatusChangeReqParams.setClaimMemo(claimMemo);
                controlJobProcessJobService.sxCJStatusChangeReqService(objCommon, cjStatusChangeReqParams);
            }
        }

        if (PostProcForLotFlag != 1) {
            /*-----------------------------*/
            /*   Future Action Procedure   */
            /*-----------------------------*/
            for (int i = 0; i < scLen; i++) {
                nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
                for (int j = 0; j < nLen; j++) {
                    /*---------------------------*/
                    /*   Omit Not-OpeStart Lot   */
                    /*---------------------------*/
                    if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                        continue;
                    }

                    String tmpRouteID = CimObjectUtils.getObjectValue(strStartCassette.get(i).getLotInCassetteList().get(j).getStartOperationInfo().getProcessFlowID());

                    Inputs.ObjSchdlChangeReservationCheckForActionDRIn strSchdlChangeReservation_CheckForActionDR_in = new Inputs.ObjSchdlChangeReservationCheckForActionDRIn();
                    strSchdlChangeReservation_CheckForActionDR_in.setLotID(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                    strSchdlChangeReservation_CheckForActionDR_in.setRouteID(tmpRouteID);
                    strSchdlChangeReservation_CheckForActionDR_in.setOperationNumber(strStartCassette.get(i).getLotInCassetteList().get(j).getStartOperationInfo().getOperationNumber());
                    Outputs.ObjSchdlChangeReservationCheckForActionDROut strSchdlChangeReservation_CheckForAction_out = scheduleChangeReservationMethod.schdlChangeReservationCheckForActionDR(objCommon, strSchdlChangeReservation_CheckForActionDR_in);


                    if (CimBooleanUtils.isTrue(strSchdlChangeReservation_CheckForAction_out.isExistFlag())) {
                        List<Infos.ReScheduledLotAttributes> reScheduledLotAttributesList = new ArrayList<>();
                        Infos.ReScheduledLotAttributes reScheduledLotAttributes = new Infos.ReScheduledLotAttributes();
                        reScheduledLotAttributesList.add(reScheduledLotAttributes);
                        reScheduledLotAttributes.setLotID(strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                        reScheduledLotAttributes.setProductID(strSchdlChangeReservation_CheckForAction_out.getStrSchdlChangeReservation().getProductID());
                        reScheduledLotAttributes.setRouteID(strSchdlChangeReservation_CheckForAction_out.getStrSchdlChangeReservation().getRouteID());
                        reScheduledLotAttributes.setCurrentOperationNumber(strSchdlChangeReservation_CheckForAction_out.getStrSchdlChangeReservation().getOperationNumber());
                        reScheduledLotAttributes.setSubLotType(strSchdlChangeReservation_CheckForAction_out.getStrSchdlChangeReservation().getSubLotType());
                        //Get current RouteID by lotID ;
                        ObjectIdentifier currentRouteID = lotMethod.lotCurrentRouteIDGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                        reScheduledLotAttributes.setOriginalRouteID(ObjectIdentifier.fetchValue(currentRouteID));
                        //Get current oparation No. by lotID;
                        String currentOperationNumber = lotMethod.lotCurrentOpeNoGet(objCommon, strStartCassette.get(i).getLotInCassetteList().get(j).getLotID());
                        reScheduledLotAttributes.setOriginalOperationNumber(currentOperationNumber);
                        //txLotPlanChangeReserveDoActionReq__110;
                        List<Infos.ChangeLotSchdlReturn> changeLotSchdlReturnList = planService.sxLotPlanChangeReserveDoActionReq(objCommon, reScheduledLotAttributesList, strSchdlChangeReservation_CheckForAction_out.getStrSchdlChangeReservation().getEventID());
                        //schdlChangeReservation_applyCount_IncreaseDR__110;
                        scheduleChangeReservationMethod.schdlChangeReservationApplyCountIncreaseDR(objCommon, strSchdlChangeReservation_CheckForAction_out.getStrSchdlChangeReservation());

                    }
                }
            }
        }

        /*------------------------------------------------------------------------*/
        /*                                                                        */
        /*   BR Script Procedure                                                  */
        /*                                                                        */
        /*------------------------------------------------------------------------*/

        /*-----------------------*/
        /*   Execute BRScript    */
        /*-----------------------*/
        for (int i = 0; i < scLen; i++) {

            nLen = CimArrayUtils.getSize(strStartCassette.get(i).getLotInCassetteList());
            for (int j = 0; j < nLen; j++) {

                /*---------------------------*/
                /*   Omit Not-OpeStart Lot   */
                /*---------------------------*/
                if (CimBooleanUtils.isFalse(strStartCassette.get(i).getLotInCassetteList().get(j).getMoveInFlag())) {
                    continue;
                }

                /*-------------------------*/
                /*   Execute Post BRScript */
                /*-------------------------*/
                //【TODO】【TODO - NOTIMPL】- txPCSExecReq
                /*
                pptPCSExecReqResult strPCSExecReqResult;
                rc = txPCSExecReq( strPCSExecReqResult,
                        strObjCommonIn,
                        SP_BRScript_Post,
                        strStartCassette(i).getLotInCassetteList().get(j).lotID,
                        equipmentID);
                if ( rc == RC_NOT_FOUND_SCRIPT )
                {
                    log.info( "txPCSExecReq() == RC_NOT_FOUND_SCRIPT") ;
                }
                else if ( rc != RC_OK )
                {
                    log.info( "txPCSExecReq() != RC_OK") ;
                    strForceMoveOutForIBReqResult.strResult = strPCSExecReqResult.strResult ;
                    return(rc);
                }
                */
            }
        }

        /*-----------------------------------------------------*/
        /*   Call APCRuntimeCapability_DeleteDR                */
        /*-----------------------------------------------------*/
        log.info("call APCRuntimeCapability_DeleteDR");
        //【TODO】【TODO - NOTIMPL】- APCRuntimeCapability_DeleteDR
        /*
        objAPCRuntimeCapability_DeleteDR_out strAPCRuntimeCapability_DeleteDR_out;
        rc = APCRuntimeCapability_DeleteDR ( strAPCRuntimeCapability_DeleteDR_out,
                strObjCommonIn,
                controlJobID );
        */

        /*-------------------------------------------------*/
        /*   Call APCMgr_SendControlJobInformationDR       */
        /*-------------------------------------------------*/
        log.info("call APCMgr_SendControlJobInformationDR()");
        //【TODO】【TODO - NOTIMPL】- APCMgr_SendControlJobInformationDR
        /*
        objAPCMgr_SendControlJobInformationDR_out strAPCMgr_SendControlJobInformationDR_out;
        rc = APCMgr_SendControlJobInformationDR ( strAPCMgr_SendControlJobInformationDR_out,
                strObjCommonIn,
                equipmentID,
                controlJobID,
                SP_APC_ControlJobStatus_Completed,
                strCassette_APCInformation_GetDR_out.strAPCBaseCassetteList );
        if ( rc != RC_OK && rc != RC_OK_NO_IF )    //D7000182
        {
            log.info( "APCMgr_SendControlJobInformationDR != RC_OK");
            strForceMoveOutForIBReqResult.strResult = strAPCMgr_SendControlJobInformationDR_out.strResult;
            return( rc );
        }
        */

        log.info("APCControlJobInformation was sent normally.");
        String tmpString = BizConstant.SP_APC_CONTROLJOBSTATUS_EXECUTING;

        /*--------------------------------------*/
        /*  Update Reticle's LastUsedTimestamp  */
        /*--------------------------------------*/
        reticleMethod.reticleLastUsedTimeStampUpdate(objCommon, objControlJobStartReserveInformationOut.getStartCassetteList());

        Inputs.ObjEntityInhibitExceptionLotChangeForOpeCompIn objEntityInhibitExceptionLotChangeForOpeCompIn = new Inputs.ObjEntityInhibitExceptionLotChangeForOpeCompIn();
        objEntityInhibitExceptionLotChangeForOpeCompIn.setControlJobID(controlJobID);
        objEntityInhibitExceptionLotChangeForOpeCompIn.setLotIDs(opeStartLotIDs);
        constraintMethod.constraintExceptionLotChangeForOpeComp(objCommon, objEntityInhibitExceptionLotChangeForOpeCompIn.getLotIDs(), objEntityInhibitExceptionLotChangeForOpeCompIn.getControlJobID());


        // check contamination level and pr flag
        contaminationMethod.lotCheckContaminationLevelAndPrFlagStepOut(objCommon, lotIDs, equipmentID);

        /*--------------------------*/
        /*                          */
        /*   Set Return Structure   */
        /*                          */
        /*--------------------------*/
        if (PostProcForLotFlag != 1) {
            retVal.setStrOpeCompLot(strEDCWithSpecCheckActionReqResult.getMoveOutReqResult().getMoveOutLot());
        } else {
            for (ObjectIdentifier opeStartLotID : opeStartLotIDs) {
                Infos.OpeCompLot opeCompLot = new Infos.OpeCompLot();
                opeCompLot.setLotID(opeStartLotID);
                opeCompLots.add(opeCompLot);
            }
        }

        return retVal;
    }

    /**
     * description:
     * <p></p>
     * change history:
     * date             defect             person             comments
     * ---------------------------------------------------------------------------------------------------------------------
     * 2018/11/14                          Wind
     *
     * @param objCommon
     * @param params
     * @return RetCode<Object>
     * @author Wind
     * @date 2018/11/14 13:59
     */
    @Override
    public void sxCarrierMoveFromIBRpt(Infos.ObjCommon objCommon, Params.CarrierMoveFromIBRptParams params) {
        log.debug("step1 - Transaction ID and eqp Category Consistency Check");
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, params.getEquipmentID());

        log.debug("step2 - get mode lock for equipment 【{}】",params.getEquipmentID());
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(params.getEquipmentID());
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.MOVE_CASSETTE_FROM_INTERNAL_BUFFER_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();

        log.trace("lockMode is 【{}】",lockMode);
        if (!BizConstant.SP_EQP_LOCK_MODE_WRITE.equals(lockMode)) {
            log.debug("step3 - Lock eqp Main Object");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(params.getEquipmentID(),
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_MAINOBJECT,
                    objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));

            log.debug("step4 - Lock eqp LoadCassette Element (Write)");
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(params.getEquipmentID(),
                    BizConstant.SP_CLASSNAME_POSMACHINE,
                    BizConstant.SP_OBJECTLOCK_OBJECTTYPE_LOADCASSETTE,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, Arrays.asList(params.getCarrierID().getValue())));

            log.debug("step5 - Lock the target portID only");
            objectLockMethod.objectLockForEquipmentResource(objCommon, params.getEquipmentID(), params.getDestinationPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
        } else {
            log.debug("step6 - Lock objects to be updated");
            objectLockMethod.objectLock(objCommon, CimMachine.class, params.getEquipmentID());
        }

        /**********************************************************/
        /*  Lock All port Object for internal Buffer eqp.   */
        /**********************************************************/
        log.debug("step7 - get equipment port info for internal buffer");
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoForInternalBufferGetDR(objCommon, params.getEquipmentID());
        List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo.getEqpPortStatuses();
        long lenPortInfo = CimArrayUtils.getSize(eqpPortStatuses);
        for (int j = 0; j < lenPortInfo; j++) {
            log.trace("lockMode is 【{}】",lockMode);
            if (!BizConstant.SP_EQP_LOCK_MODE_WRITE.equals(lockMode)) {
                log.trace("eqpPortStatuses port is 【{}】，params port is 【{}】",eqpPortStatuses.get(j).getPortID(),params.getDestinationPortID());
                if (ObjectIdentifier.equalsWithValue(eqpPortStatuses.get(j).getPortID(), params.getDestinationPortID())) {
                    log.debug("step8 - Lock Material Location");
                    Inputs.ObjAdvancedObjectLockForEquipmentResourceIn objAdvancedObjectLockForEquipmentResourceIn = new Inputs.ObjAdvancedObjectLockForEquipmentResourceIn();
                    objAdvancedObjectLockForEquipmentResourceIn.setEquipmentID(params.getEquipmentID());
                    objAdvancedObjectLockForEquipmentResourceIn.setClassName(BizConstant.SP_CLASSNAME_POSMATERIALLOCATION_BYCASTID);
                    objAdvancedObjectLockForEquipmentResourceIn.setObjectID(params.getCarrierID());
                    objAdvancedObjectLockForEquipmentResourceIn.setObjectLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE);
                    objAdvancedObjectLockForEquipmentResourceIn.setBufferResourceName("");
                    objAdvancedObjectLockForEquipmentResourceIn.setBufferResourceLockType(BizConstant.SP_OBJECTLOCK_LOCKTYPE_READ);
                    objectLockMethod.advancedObjectLockForEquipmentResource(objCommon, objAdvancedObjectLockForEquipmentResourceIn);
                    break;
                }
            } else {
                log.debug("step9 - lock equipment resource");
                objectLockMethod.objectLockForEquipmentResource(objCommon, params.getEquipmentID(), eqpPortStatuses.get(j).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            }
        }
        log.debug("step10 - Lock objects to be updated");
        objectLockMethod.objectLock(objCommon, CimCassette.class, params.getCarrierID());
        /*----------------------------------*/
        /*   Check LotProcessStatus         */
        /*----------------------------------*/

        log.debug("step11 - get lot list for cassette");
        Infos.LotListInCassetteInfo lotListInCassetteInfo = null;
        try {
            lotListInCassetteInfo = cassetteMethod.cassetteGetLotList(objCommon, params.getCarrierID());
        } catch (ServiceException e) {
            if (!Validations.isEquals(retCodeConfig.getNotFoundLot(), e.getCode())) {
                throw e;
            }
        }
        boolean processingFlag = false;
        if (null != lotListInCassetteInfo) {
            for (int i = 0; i < CimArrayUtils.getSize(lotListInCassetteInfo.getLotIDList()); i++) {
                log.debug("step12 - get lot process state");
                String lotProcessStateGet = lotMethod.lotProcessStateGet(objCommon, lotListInCassetteInfo.getLotIDList().get(i));
                if (CimStringUtils.equals(lotProcessStateGet, BizConstant.SP_LOT_PROCSTATE_PROCESSING)) {
                    processingFlag = true;
                    break;
                }
            }
        }
        log.debug("step13 - get durable process state");
        String durableProcessStateGet = durableMethod.durableProcessStateGet(objCommon, BizConstant.SP_DURABLECAT_CASSETTE, params.getCarrierID());
        boolean durableProcessingFlag = CimStringUtils.equals(durableProcessStateGet, BizConstant.SP_LOT_PROCSTATE_PROCESSING);
        Validations.check(durableProcessingFlag, retCodeConfigEx.getDurableStatusProcessing());

        Validations.check(processingFlag, retCodeConfig.getLotStatusProcessing());

        /*---------------------------------*/
        /*   Get cassette's ControlJobID   */
        /*---------------------------------*/
        log.debug("step14 - get cassette control job id");
        ObjectIdentifier cassetteControlJobIDGet = cassetteMethod.cassetteControlJobIDGet(objCommon, params.getCarrierID());
        Validations.check(ObjectIdentifier.isNotEmptyWithValue(cassetteControlJobIDGet), retCodeConfig.getNotClearedControlJob());

        /*----------------------------------*/
        /*   Add to load lot in eqp   */
        /*----------------------------------*/
        log.debug("step15 - add equipment unload carrier");
        equipmentMethod.equipmentUnLoadCarrierAdd(objCommon, params);

        /*----------------------------------*/
        /*   Check contamination capability */
        /*----------------------------------*/
        log.debug("step16 - Check contamination capability");
        cassetteMethod.cassetteCategoryPortCapabilityCheckForContaminationControl(objCommon, params);
    }
    @Override
    public List<Infos.LoadingVerifiedLot> sxCarrierLoadingForSORRpt(Infos.ObjCommon objCommon, String claimMemo,
                                                                    ObjectIdentifier equipmentID, ObjectIdentifier cassetteID, ObjectIdentifier portID, String lotPurposeType) {
        // 适配sorter EAP
        if (CimStringUtils.isEmpty(lotPurposeType)) {
            String objMachineTypeGetOut = equipmentMethod.equipmentCategoryGet(objCommon, equipmentID);
            if (CimStringUtils.equals(objMachineTypeGetOut, BizConstant.SP_MC_CATEGORY_WAFERSORTER)) {
                try {
                    cassetteMethod.cassetteCheckEmpty(cassetteID);
                    lotPurposeType = BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE;
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getCastNotEmpty())) {
                        lotPurposeType = BizConstant.SP_LOADPURPOSETYPE_OTHER;
                    }
                }
            }
        }

        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.LOADING_LOT_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommon, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            objectLockMethod.advancedObjectLock(objCommon, new Inputs.ObjAdvanceLockIn(equipmentID,
                    objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));
        } else {
            objectLockMethod.objectLock(objCommon, CimMachine.class, equipmentID);
        }

        List<Infos.LoadingVerifiedLot> loadingVerifiedLots;

        Infos.EqpPortInfo allPortsInSameGroupListResult = portMethod
                .portResourceAllPortsInSameGroupGet(objCommon, equipmentID, portID);
        List<Infos.EqpPortStatus> allPortsInSameGroupList = allPortsInSameGroupListResult.getEqpPortStatuses();
        /*---------------------------------------------------------*/
        /* Lock All Ports being in the same Port Group as ToPort   */
        /*---------------------------------------------------------*/
        int lenToPort = CimArrayUtils.getSize(allPortsInSameGroupList);
        for (int i = 0; i < lenToPort; i++) {
            objectLockMethod.objectLockForEquipmentResource(objCommon, equipmentID, allPortsInSameGroupList
                    .get(i).getPortID(), BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
        }
        objectLockMethod.objectLock(objCommon, CimCassette.class, cassetteID);
        if (CimStringUtils.equals(lotPurposeType, BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING)) {
            /*-----------------------------------------------*/
            /*                                               */
            /*   Equipment Container Position Lock Process   */
            /*                                               */
            /*-----------------------------------------------*/

            Inputs.ObjObjectLockForEquipmentContainerPositionIn objObjectLockForEquipmentContainerPositionIn = new
                    Inputs.ObjObjectLockForEquipmentContainerPositionIn();
            objObjectLockForEquipmentContainerPositionIn.setDestCassetteID(cassetteID);
            objObjectLockForEquipmentContainerPositionIn.setEquipmentID(equipmentID);
            objectLockMethod.objectLockForEquipmentContainerPosition(objCommon, objObjectLockForEquipmentContainerPositionIn);
        }

        //验证sorter设备是否还有加工任务
        Infos.EqpPortInfo portInfo = this.equipmentPortInfoGet(objCommon,equipmentID);
        String operationMode =null;
        for (Infos.EqpPortStatus eqpPortStatus : portInfo.getEqpPortStatuses()) {
            if (ObjectIdentifier.equalsWithValue(eqpPortStatus.getPortID(), portID)) {
                if (eqpPortStatus.getOperationMode().equals(SorterType.OperationMode.Semi_1.getValue())) {
                    operationMode = eqpPortStatus.getOperationMode();
                } else if (eqpPortStatus.getOperationMode().equals(SorterType.OperationMode.Auto_1.getValue())) {
                    operationMode = eqpPortStatus.getOperationMode();
                }
            }
        }
        Validations.check(null == operationMode || (!operationMode.equals(SorterType.OperationMode.Semi_1.getValue())
                && !operationMode.equals(SorterType.OperationMode.Auto_1.getValue())), retCodeConfig.getInvalidInputParam());

        if (operationMode.equals(SorterType.OperationMode.Auto_1.getValue())
                || operationMode.equals(SorterType.OperationMode.Semi_1.getValue())) {
            com.fa.cim.sorter.Params.SorterActionInqParams componentJobListInqParams
                    = new com.fa.cim.sorter.Params.SorterActionInqParams();
            componentJobListInqParams.setCassetteID(cassetteID);
            componentJobListInqParams.setEquipmentID(equipmentID);
            Info.SortJobInfo jobInfo = sorterMethod.sorterActionInq(objCommon, componentJobListInqParams, SorterType.Status.Created.getValue());
            Validations.check(null == jobInfo.getComponentJob(), retCodeConfigEx.getNoProcessingTask());
            //对比load carrier与预约的carrier是否相等
            ObjectIdentifier destinationCassetteID = jobInfo.getComponentJob().getDestinationCassetteID();
            ObjectIdentifier originalCassetteID = jobInfo.getComponentJob().getOriginalCassetteID();
            ObjectIdentifier destinationPortID = jobInfo.getComponentJob().getDestinationPortID();
            ObjectIdentifier originalPortID = jobInfo.getComponentJob().getOriginalPortID();
            if ((ObjectIdentifier.equalsWithValue(cassetteID, originalCassetteID)
                    && ObjectIdentifier.equalsWithValue(portID, originalPortID))
                    || (ObjectIdentifier.equalsWithValue(cassetteID, destinationCassetteID)
                    && ObjectIdentifier.equalsWithValue(portID, destinationPortID))) {
            }else {
                Validations.check(true,retCodeConfigEx.getEapReportedError() );
            }
            //chck 验证加工的lot是否被hold,hold的lot不允许load
            Set<ObjectIdentifier> lotIDSet=new HashSet<>();
            jobInfo.getComponentJob().getWaferList().forEach(slotMap->{
                lotIDSet.add(slotMap.getLotID());
            });
            if (log.isDebugEnabled()) {
                log.debug("check lot whether hold");
            }
            if(lotIDSet.size()>0){
                lotIDSet.forEach(lotID->{
                    String lotHoldState = lotMethod.lotHoldStateGet(objCommon, lotID);
                    Validations.check(CimStringUtils.equals(BizConstant.CIMFW_LOT_HOLDSTATE_ONHOLD, lotHoldState),
                            retCodeConfig.getInvalidLotHoldStat());
                });
            }
        }


        if (log.isDebugEnabled()) {
            log.debug("step8 - Transaction ID and eqp Category Consistency Check");
        }
        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommon, equipmentID);
        ObjectIdentifier durableDurableControlJobIDGet = ObjectIdentifier.build(null, null);
        if (!SorterHandler.containsFOSB(cassetteID)) {
            durableDurableControlJobIDGet = durableMethod.durableDurableControlJobIDGet(objCommon, cassetteID,
                    BizConstant.SP_DURABLECAT_CASSETTE);
            if (!ObjectIdentifier.isEmpty(durableDurableControlJobIDGet)
                    && !CimStringUtils.isEmpty(durableDurableControlJobIDGet.getValue())) {
                Validations.check(!CimStringUtils.equals(lotPurposeType, BizConstant.SP_LOADPURPOSETYPE_OTHER),
                        new OmCode(retCodeConfig.getInvalidPurposeTypeForProcessdurable(), lotPurposeType));
            }
        }
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommon, equipmentID);
        String strEquipmentCategory = eqpBrInfo.getEquipmentCategory();
        //--------------------------
        // Equipmet is Not Sorter Or，carrier=FOSB 跳过验证
        //--------------------------
        if (!CimStringUtils.equals(BizConstant.SP_MC_CATEGORY_WAFERSORTER, strEquipmentCategory)
                && !CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_OTHER, lotPurposeType)) {
            if (!SorterHandler.containsFOSB(cassetteID)) {
                List<Infos.LotWaferMap> lotWaferMaps = cassetteMethod
                        .cassetteScrapWaferSelectDR(objCommon, Arrays.asList(cassetteID));
                int scrapCount = CimArrayUtils.getSize(lotWaferMaps);
                Validations.check(scrapCount > 0, retCodeConfig.getFoundScrap());
            }

        }
        if (log.isDebugEnabled()) {
            log.debug("step12 - verify loading carrier");
        }
        boolean forceLoaded = false;
        Params.CarrierLoadingVerifyReqParams verifyForLoadingReqParams = new Params.CarrierLoadingVerifyReqParams();
        verifyForLoadingReqParams.setEquipmentId(equipmentID);
        verifyForLoadingReqParams.setCassetteId(cassetteID);
        verifyForLoadingReqParams.setLoadPurposeType(lotPurposeType);
        verifyForLoadingReqParams.setPortId(portID);
        Results.CarrierLoadingVerifyReqResult lotVerifyForLoadingResult = null;
        try {
            lotVerifyForLoadingResult = this.sxCarrierLoadingVerifyReq(objCommon, verifyForLoadingReqParams);
            loadingVerifiedLots = lotVerifyForLoadingResult.getLoadingVerifiedLots();
        } catch (ServiceException ex) {
            loadingVerifiedLots = ex.getData(List.class);
            int rcVerifyedRetCode = ex.getCode();
            try {
                lotMethod.loadedLotVerifiedInfoCheckConditionForForceLoad(objCommon, rcVerifyedRetCode,
                        loadingVerifiedLots, equipmentID, cassetteID, portID, lotPurposeType);
                throw ex;
            } catch (ServiceException e) {
                if (Validations.isEquals(retCodeConfig.getCastForceLoaded(), e.getCode())) {
                    loadingVerifiedLots = e.getData(List.class);
                    lotMethod.loadedLotVerifiedInfoChangeForForceLoad(objCommon, equipmentID, cassetteID,
                            portID, lotPurposeType, loadingVerifiedLots);
                    forceLoaded = true;
                } else {
                    throw e;
                }
            }
        }

        if (CimStringUtils.equals(lotPurposeType, BizConstant.SP_LOADPURPOSETYPE_OTHER)
                || CimStringUtils.equals(lotPurposeType, BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE)) {
            if (CimArrayUtils.isNotEmpty(loadingVerifiedLots)) {
                for (Infos.LoadingVerifiedLot loadingVerifiedLot : loadingVerifiedLots) {
                    if (loadingVerifiedLot.getMoveInFlag()) {
                        contaminationMethod.carrierCategoryCheckAmongLotAndCarrier(cassetteID, loadingVerifiedLot.getLotID());
                    }
                }
            }
        }

        log.debug("step16 - Add to load lot in equipment");
        equipmentMethod.equipmentLoadLotAdd(objCommon, equipmentID, cassetteID, portID, lotPurposeType, loadingVerifiedLots);
        //----------------------------------------------------//
        //   Clear Cassette's DispatchState for NPW Loading   //
        //   - Usually, this cassette's dispatchState is      //
        //     changed to FALSE when OpeStart, but NPW        //
        //     cassettes are never started, so this timing    //
        //     is the best to clear it.                       //
        //----------------------------------------------------//
        List<String> lotPurposeTypeConditions = CimArrayUtils.generateList(
                BizConstant.SP_LOADPURPOSETYPE_OTHER,
                BizConstant.SP_LOADPURPOSETYPE_EMPTYCASSETTE,
                BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY,
                BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT,
                BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING,
                BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT);
        Infos.EqpPortInfo eqpPortInfo = equipmentMethod.equipmentPortInfoGet(objCommon, equipmentID);
        List<Infos.EqpPortStatus> eqpPortStatuses = eqpPortInfo == null ? new ArrayList<>()
                : eqpPortInfo.getEqpPortStatuses();
        if (ObjectIdentifier.isEmptyWithValue(durableDurableControlJobIDGet)
                && lotPurposeTypeConditions.contains(lotPurposeType)) {
            //Get port's LoadPurposeType
            for (Infos.EqpPortStatus eqpPortStatus : eqpPortStatuses) {
                if (ObjectIdentifier.equalsWithValue(eqpPortStatus.getPortID(), portID)) {
                    List<String> conditions = CimArrayUtils.generateList(
                            BizConstant.SP_LOADPURPOSETYPE_OTHER,
                            BizConstant.SP_LOADPURPOSETYPE_FILLERDUMMY,
                            BizConstant.SP_LOADPURPOSETYPE_SIDEDUMMYLOT,
                            BizConstant.SP_LOADPURPOSETYPE_WAITINGMONITORLOT);
                    if (conditions.contains(eqpPortStatus.getLoadPurposeType())
                            || CimStringUtils.equals(lotPurposeType, BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING)) {
                        log.debug("step17 - Change cassette's dispatch State to FALSE");
                        if(!objCommon.getTransactionID().equals(TransactionIDEnum.LOADING_LOT_FOR_SORTER_RPT.getValue())){
                            cassetteMethod.cassetteDispatchStateChange(objCommon, cassetteID, false);
                        }
                        log.debug("step18 - change clear to Dispatched Load CassetteID");
                        equipmentMethod.equipmentDispatchStateChange(objCommon, equipmentID, portID,
                                BizConstant.SP_PORTRSC_DISPATCHSTATE_NOTDISPATCHED, null,
                                null, null, null);
                        log.debug("step19 - Change cassette's NPWLoadPurposeType to NULL");
                        cassetteMethod.cassetteSetNPWLoadPurposeType(objCommon, cassetteID, null);
                    }
                    if (CimStringUtils.equals(BizConstant.SP_LOADPURPOSETYPE_SLMRETRIEVING, lotPurposeType)) {
                        log.debug("step20 - equipmentContainerPositionInfoUpdateForLoading");
                        equipmentMethod.equipmentContainerPositionInfoUpdateForLoading(objCommon,
                                equipmentID, null, cassetteID, portID);
                    }
                    break;
                }
            }
        } else {
            for (Infos.EqpPortStatus eqpPortStatus : eqpPortStatuses) {
                if (ObjectIdentifier.equalsWithValue(eqpPortStatus.getPortID(), portID)
                        && CimStringUtils.equals(eqpPortStatus.getOnlineMode(), BizConstant.SP_EQP_ONLINEMODE_OFFLINE)) {
                    log.debug("step21 - change clear to Dispatched Load CassetteID");
                    equipmentMethod.equipmentDispatchStateChange(objCommon, equipmentID, portID,
                            BizConstant.SP_PORTRSC_DISPATCHSTATE_NOTDISPATCHED, null, null,
                            null, null);
                    break;
                }
            }
        }
        if (!SorterHandler.containsFOSB(cassetteID)) {
            log.debug("step22 - change status carrier transfer");
            Params.CarrierTransferStatusChangeRptParams carrierTransferStatusChangeRptParams = new Params
                    .CarrierTransferStatusChangeRptParams();
            carrierTransferStatusChangeRptParams.setCarrierID(cassetteID);
            carrierTransferStatusChangeRptParams.setXferStatus(BizConstant.SP_TRANSSTATE_EQUIPMENTIN);
            carrierTransferStatusChangeRptParams.setManualInFlag(false);
            carrierTransferStatusChangeRptParams.setMachineID(equipmentID);
            carrierTransferStatusChangeRptParams.setPortID(portID);
            carrierTransferStatusChangeRptParams.setTransferStatusChangeTimeStamp(objCommon.getTimeStamp().getReportTimeStamp());
            transferManagementSystemService.sxCarrierTransferStatusChangeRpt(objCommon, carrierTransferStatusChangeRptParams);
        }
        if (forceLoaded) {
            throw new ServiceException(retCodeConfig.getCastForceLoaded());
        }
        return loadingVerifiedLots;
    }

    @Override
    public void sxCarrierUnloadingForSORRpt(Infos.ObjCommon objCommonIn, String claimMemo,
                                            ObjectIdentifier equipmentID, ObjectIdentifier cassetteID, ObjectIdentifier portID) {
        Inputs.ObjLockModeIn objLockModeIn = new Inputs.ObjLockModeIn();
        objLockModeIn.setObjectID(equipmentID);
        objLockModeIn.setClassName(BizConstant.SP_CLASSNAME_POSMACHINE);
        objLockModeIn.setFunctionCategory(TransactionIDEnum.UN_LOADING_LOT_RPT.getValue());
        objLockModeIn.setUserDataUpdateFlag(false);
        Outputs.ObjLockModeOut objLockModeOut = objectMethod.objectLockModeGet(objCommonIn, objLockModeIn);
        Long lockMode = objLockModeOut.getLockMode();
        if (!lockMode.equals(BizConstant.SP_EQP_LOCK_MODE_WRITE)) {
            objectLockMethod.advancedObjectLock(objCommonIn, new Inputs.ObjAdvanceLockIn(equipmentID,
                    objLockModeOut.getRequiredLockForMainObject(), new ArrayList<>()));
            objectLockMethod.advancedObjectLock(objCommonIn, new Inputs.ObjAdvanceLockIn(equipmentID,
                    (long) BizConstant.SP_OBJECTLOCK_LOCKTYPE_WRITE, Arrays.asList(cassetteID.getValue())));
        } else {
            objectLockMethod.objectLock(objCommonIn, CimMachine.class, equipmentID);
        }
        Infos.EqpPortInfo portsInSameGroupResult = portComp.portResourceAllPortsInSameGroupGet(objCommonIn, equipmentID, portID);
        List<Infos.EqpPortStatus> portsInSameGroup = portsInSameGroupResult.getEqpPortStatuses();
        int lenToPort = CimArrayUtils.getSize(portsInSameGroup);
        if (lenToPort > 0) {
            for (Infos.EqpPortStatus eqpPortStatus : portsInSameGroup) {
                objectLockMethod.objectLockForEquipmentResource(objCommonIn, equipmentID, eqpPortStatus.getPortID(),
                        BizConstant.SP_CLASSNAME_POSPORTRESOURCE);
            }
        }
        Outputs.ObjPortResourceCurrentOperationModeGetOut currentOperationModeOut = portComp
                .portResourceCurrentOperationModeGet(objCommonIn, equipmentID, portID);
        Infos.OperationMode currentOperationMode = currentOperationModeOut.getOperationMode();
        if (CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, currentOperationMode.getOnlineMode())
                || CimStringUtils.equals(BizConstant.SP_EQP_ACCESSMODE_AUTO, currentOperationMode.getAccessMode())) {
            ObjectIdentifier strDurableControlJobIDGetOut = durableMethod.durableDurableControlJobIDGet(objCommonIn,
                    cassetteID, BizConstant.SP_DURABLECAT_CASSETTE);
            if (!ObjectIdentifier.isEmpty(strDurableControlJobIDGetOut)) {
                objectLockMethod.objectLock(objCommonIn, CimDurableControlJob.class, strDurableControlJobIDGetOut);
                //TODO: Step10 - durableControlJob_status_Get
                log.debug("step10 - get durable control job status");
                Infos.DurableControlJobStatusGet strDurableControlJobStatusGetOut = durableMethod
                        .durableControlJobStatusGet(objCommonIn, strDurableControlJobIDGetOut);
                if (!CimStringUtils.equals(strDurableControlJobStatusGetOut.getDurableControlJobStatus(),
                        BizConstant.SP_DURABLECONTROLJOBSTATUS_CREATED)
                        && !CimStringUtils.equals(strDurableControlJobStatusGetOut.getDurableControlJobStatus(),
                        BizConstant.SP_DURABLECONTROLJOBSTATUS_DELETE)) {
                    Validations.check(new OmCode(retCodeConfig.getInvalidDcjstatus(),
                            strDurableControlJobStatusGetOut.getDurableControlJobStatus()));
                }
            }
        }
        objectLockMethod.objectLock(objCommonIn, CimCassette.class, cassetteID);

        equipmentMethod.equipmentCategoryVsTxIDCheckCombination(objCommonIn, equipmentID);

        cassetteMethod.cassetteCheckConditionForUnloading(objCommonIn, cassetteID);

        if (log.isTraceEnabled()) {
            log.trace("OnlineMode is 【{}】，AccessMode is 【{}】",
                    currentOperationMode.getOnlineMode(), currentOperationMode.getAccessMode());
        }
        if (CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, currentOperationMode.getOnlineMode())
                || CimStringUtils.equals(BizConstant.SP_EQP_ACCESSMODE_AUTO, currentOperationMode.getAccessMode())) {
            ObjectIdentifier controlJobID = cassetteMethod.cassetteControlJobIDGet(objCommonIn, cassetteID);
            if (!ObjectIdentifier.isEmpty(controlJobID)) {
                List<Infos.ControlJobCassette> controlJobCassettes = controlJobMethod
                        .controlJobContainedLotGet(objCommonIn, controlJobID);
                //Check ControlJobLot's ProcessState
                int lenCtrlJobCassette = CimArrayUtils.getSize(controlJobCassettes);
                for (int i = 0; i < lenCtrlJobCassette; i++) {
                    Infos.ControlJobCassette controlJobCassette = controlJobCassettes.get(i);
                    if (CimArrayUtils.isEmpty(controlJobCassette.getControlJobLotList())) {
                        continue;
                    }

                    Infos.LotListInCassetteInfo cassetteLotListGetResult = cassetteMethod
                            .cassetteGetLotList(objCommonIn, controlJobCassette.getCassetteID());
                    lotMethod.lotCheckConditionForUnloading(objCommonIn, cassetteLotListGetResult);
                }
            }
        }
        equipmentMethod.equipmentPortStateCheckForUnloading(objCommonIn, equipmentID, portID, cassetteID);
        Infos.EqpBrInfo eqpBrInfo = equipmentMethod.equipmentBRInfoGetDR(objCommonIn, equipmentID);
        if (CimBooleanUtils.isTrue(eqpBrInfo.isFmcCapabilityFlag())) {
            if (log.isDebugEnabled()) {
                log.debug("sxCarrierUnloadingRpt(): SLM Capability is ON.");
            }
            //Check Condition for SLM.
            //TODO: Step20 - SLM_CheckConditionForUnloading
        }

        log.debug("step21 - Clear Loaded cassette Information on eqp");
        equipmentMethod.equipmentLoadLotDelete(objCommonIn, equipmentID, portID, cassetteID);

        //Call txCarrierTransferStatusChangeRpt() with 'EquipmentOut'
        if (log.isDebugEnabled()) {
            log.debug("step22 - Change cassette's TransferState to EquipmentOut");
        }
        if (!SorterHandler.containsFOSB(cassetteID)) {
            Params.CarrierTransferStatusChangeRptParams params = new Params.CarrierTransferStatusChangeRptParams();
            params.setCarrierID(cassetteID);
            params.setXferStatus(BizConstant.SP_TRANSSTATE_EQUIPMENTOUT);
            params.setManualInFlag(false);
            params.setMachineID(equipmentID);
            params.setPortID(portID);
            params.setTransferStatusChangeTimeStamp(objCommonIn.getTimeStamp().getReportTimeStamp());
            transferManagementSystemService.sxCarrierTransferStatusChangeRpt(objCommonIn, params);
        }
    }

    @Override
    public Infos.EqpPortInfo equipmentPortInfoGet(Infos.ObjCommon objCommon, ObjectIdentifier eqpID) {
        return equipmentMethod.equipmentPortInfoGet(objCommon,eqpID);
    }

    @Override
    public List<CarrierOutPortResults> sxCarrierOutPortReq(Infos.ObjCommon objCommon, CarrierOutPortReqParams params) {
        List<CarrierOutPortResults> result = new ArrayList<>();
        //step1 - check inputParam
        if (log.isDebugEnabled()) {
            log.debug("step1 - check inputParam");
        }
        boolean checkFlag = ObjectIdentifier.isEmptyWithValue(params.getEquipmentID())
                || CimArrayUtils.isEmpty(params.getCarrierOutPortInfoList())
                || (CimArrayUtils.isNotEmpty(params.getCarrierOutPortInfoList())
                && params.getCarrierOutPortInfoList().stream().anyMatch(portInfo ->
                ObjectIdentifier.isEmptyWithValue(portInfo.getCarrierID())
                        || ObjectIdentifier.isEmptyWithValue(portInfo.getPortID())));
        Validations.check(checkFlag, retCodeConfig.getInvalidInputParam());

        ObjectIdentifier equipmentID = params.getEquipmentID();
        List<CarrierOutPortInfo> eqpCarrierOutPortInfoList = params.getCarrierOutPortInfoList();

        //step2 - get and check equipment onlineMode
        if (log.isDebugEnabled()) {
            log.debug("step2 - get and check equipment onlineMode");
        }
        String onlineMode = equipmentMethod.equipmentOnlineModeGet(objCommon, equipmentID);
        Validations.check(CimStringUtils.equals(BizConstant.SP_EQP_ONLINEMODE_OFFLINE, onlineMode),
                retCodeConfig.getInvalidEquipmentMode(),
                ObjectIdentifier.fetchValue(equipmentID),
                onlineMode);

        //step3 - check current OMS port info with input carrierPortInfo by EAP
        if (log.isDebugEnabled()) {
            log.debug("step3 - check current OMS port info with input carrierPortInfo by EAP");
        }
        boolean reserveSuccess = true;
        try {
            equipmentMethod.equipmentCarierOutPortInfoCheck(
                    objCommon,
                    equipmentID,
                    eqpCarrierOutPortInfoList);
        } catch (ServiceException e) {
            if (Validations.unequalsIn(e.getCode(),
                    retCodeConfig.getNotFoundCassette(),
                    retCodeConfig.getInvalidLotProcessState())){
                reserveSuccess = false;
                log.error("equipment carrier out portInfo check fail. try reserveUnloading by OMS");
            } else {
                log.error("other basic condition is not ok, return");
                throw e;
            }
        }
        //step4 - reserveUnloading by EAP select carrierOutPortInfo one by one
        if (log.isDebugEnabled()) {
            log.debug("step4 - reserveUnloading by EAP select carrierOutPortInfo one by one");
        }
        if (reserveSuccess){
            try {
                eqpCarrierOutPortInfoList.forEach(carrierOutPortInfo -> {
                    this.sxReserveUnloadingLotsForIBRpt(objCommon,
                            equipmentID,
                            carrierOutPortInfo.getCarrierID(),
                            carrierOutPortInfo.getPortID(),
                            BizConstant.EMPTY);
                });
            } catch (ServiceException e) {
                if (Validations.isEquals(e.getCode(),retCodeConfigEx.getNotFoundCstInEqp())){
                    log.error("carrierOutPort exist carrier out success. error");
                    throw e;
                } else {
                    reserveSuccess = false;
                    log.error("reserveUnloading by EAP select fail: {}. try reserveUnloading by OMS", e.toString());
                }
            }
        }
        if (reserveSuccess) {
            if (log.isDebugEnabled()) {
                log.debug("reserveUnloading by EAP select sucess. return....");
            }
            eqpCarrierOutPortInfoList.forEach(carrierOutPortInfo -> {
                CarrierOutPortResults carrierOutPortResults = new CarrierOutPortResults();
                carrierOutPortResults.setEquipmentID(equipmentID);
                carrierOutPortResults.setCarrierID(carrierOutPortInfo.getCarrierID());
                carrierOutPortResults.setPortID(carrierOutPortInfo.getPortID());
                carrierOutPortResults.setSuccessFlag(true);
                result.add(carrierOutPortResults);
            });
        } else {
            //step5 - check current OMS port info and find appropriate port
            if (log.isDebugEnabled()) {
                log.debug("step5 - check current OMS port info and find appropriate port");
            }
            List<ObjectIdentifier> carrierList = eqpCarrierOutPortInfoList.stream()
                    .map(CarrierOutPortInfo::getCarrierID)
                    .collect(Collectors.toList());
            List<CarrierOutPortResults> carrierOutPortList = equipmentMethod.equipmentCarierOutPortInfoGet(objCommon,
                    equipmentID,
                    carrierList);
            if (CimArrayUtils.isNotEmpty(carrierOutPortList)) {
                if (log.isDebugEnabled()) {
                    log.debug("find appropriate portList size: {}", CimArrayUtils.getSize(carrierOutPortList));
                    log.debug("step6 - reserveUnloading by OMS select carrierOutPortInfo one by one");
                }
                carrierOutPortList.forEach(carrierOutPortInfo -> {
                    CarrierOutPortResults carrierOutPortResults = new CarrierOutPortResults();
                    carrierOutPortResults.setEquipmentID(equipmentID);
                    if (!carrierOutPortInfo.isSuccessFlag()) {
                        carrierOutPortResults.setSuccessFlag(true);
                        try {
                            this.sxReserveUnloadingLotsForIBRpt(objCommon,
                                    equipmentID,
                                    carrierOutPortInfo.getCarrierID(),
                                    carrierOutPortInfo.getPortID(),
                                    BizConstant.EMPTY);
                        } catch (ServiceException e) {
                            if (Validations.isEquals(e.getCode(),retCodeConfigEx.getNotFoundCstInEqp())){
                                log.error("carrierOutPort exist carrier out success. error");
                                throw e;
                            } else {
                                carrierOutPortResults.setSuccessFlag(false);
                                log.error("reserveUnloading by OMS select fail: {}", e.toString());
                            }
                        }
                        carrierOutPortResults.setCarrierID(carrierOutPortInfo.getCarrierID());
                        carrierOutPortResults.setPortID(carrierOutPortInfo.getPortID());
                    } else {
                        carrierOutPortResults.setCarrierID(carrierOutPortInfo.getCarrierID());
                        carrierOutPortResults.setPortID(carrierOutPortInfo.getPortID());
                        carrierOutPortResults.setSuccessFlag(carrierOutPortInfo.isSuccessFlag());
                    }
                    result.add(carrierOutPortResults);
                });
                if (log.isDebugEnabled()) {
                    log.debug("step7 - find carrierOutResult exist fail, save event...");
                }
                Optional.ofNullable(result).ifPresent(list ->
                        list.forEach(carrierOutResult -> {
                            if (!carrierOutResult.isSuccessFlag()) {
                                messageMethod.carrierOutMessageEventMake(objCommon,
                                        carrierOutResult.getCarrierID(), equipmentID);
                            }
                        }));
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("step8 - find none appropriate portList,save event...");
                }
                Optional.ofNullable(carrierList).ifPresent(list -> list.forEach(carrierID ->
                        messageMethod.carrierOutMessageEventMake(objCommon, carrierID, equipmentID)));
                Validations.check(retCodeConfigEx.getNotFoundCarrierOutPort(),
                        CimStringUtils.join(CimArrayUtils.objConvertStringList(carrierList),
                                BizConstant.SEPARATOR_COMMA));
            }
        }
        return result;
    }

    @Override
    public CarrierOutPortResults sxCarrierOutReq(Infos.ObjCommon objCommon, CarrierOutReqParams params) {
        //step1 - check inputParam
        if (log.isDebugEnabled()) {
            log.debug("step1 - check inputParam");
        }
        ObjectIdentifier carrierID = params.getCarrierID();
        ObjectIdentifier equipmentID = params.getEquipmentID();
        ObjectIdentifier portID = params.getPortID();
        Validations.check(ObjectIdentifier.isEmptyWithValue(carrierID)
                || ObjectIdentifier.isEmptyWithValue(equipmentID), retCodeConfig.getInvalidInputParam());

        //step2 - equipmentCarierOutPortInfoGet
        boolean userNotifyFlag = false;
        CarrierOutPortResults tmpCarrierOutportInfo = new CarrierOutPortResults();
        tmpCarrierOutportInfo.setEquipmentID(equipmentID);
        if (ObjectIdentifier.isNotEmptyWithValue(portID)){
            if (log.isDebugEnabled()){
                log.debug("step2 - carrier out notify from OPI");
            }
            userNotifyFlag = true;
            tmpCarrierOutportInfo.setCarrierID(carrierID);
            tmpCarrierOutportInfo.setPortID(portID);
            tmpCarrierOutportInfo.setSuccessFlag(false);
        }else {
            if (log.isDebugEnabled()) {
                log.debug("step2 - equipmentCarierOutPortInfoGet");
            }
            List<CarrierOutPortResults> carrierOutPortList = equipmentMethod.equipmentCarierOutPortInfoGet(objCommon,
                    equipmentID,
                    Collections.singletonList(carrierID));

            //step3 - check carrierOutPortInfo
            if (log.isDebugEnabled()) {
                log.debug("step3 - check carrierOutPortInfo");
            }
            Validations.check(CimArrayUtils.isEmpty(carrierOutPortList)
                            || CimArrayUtils.getSize(carrierOutPortList) > 1,
                    retCodeConfigEx.getInvalidCarrierOutPortSize(),
                    CimArrayUtils.getSize(carrierOutPortList));
            CarrierOutPortResults carrierOutportInfo = carrierOutPortList.get(0);
            tmpCarrierOutportInfo.setCarrierID(carrierOutPortList.get(0).getCarrierID());
            tmpCarrierOutportInfo.setPortID(carrierOutPortList.get(0).getPortID());
            tmpCarrierOutportInfo.setSuccessFlag(carrierOutPortList.get(0).isSuccessFlag());
            Validations.check(ObjectIdentifier.isEmptyWithValue(carrierOutportInfo.getPortID()),
                    retCodeConfig.getInvalidParameter());
        }


        if (userNotifyFlag || !tmpCarrierOutportInfo.isSuccessFlag()) {
            if (log.isDebugEnabled()) {
                log.debug("step4 - sxReserveUnloadingLotsForIBRpt");
            }
            this.sxReserveUnloadingLotsForIBRpt(objCommon,
                    equipmentID,
                    tmpCarrierOutportInfo.getCarrierID(),
                    tmpCarrierOutportInfo.getPortID(),
                    BizConstant.EMPTY);
            //call EAP to carrierOutReq
            if (log.isDebugEnabled()) {
                log.debug("step5 - call EAP CarrierOutReq");
            }
            Long sleepTimeValue = CimStringUtils.isEmpty(StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue()) ?
                    BizConstant.SP_DEFAULT_SLEEP_TIME_TCS :
                    Long.parseLong(StandardProperties.OM_EAP_CONNECT_SLEEP_TIME.getValue());

            Long retryCountValue = CimStringUtils.isEmpty(StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue()) ?
                    BizConstant.SP_DEFAULT_SLEEP_TIME_TCS :
                    Long.parseLong(StandardProperties.OM_EAP_CONNECT_RETRY_COUNT.getValue());

            for (int retryNum = 0; retryNum < (retryCountValue + 1); retryNum++) {
                /*--------------------------*/
                /*    Send Request to EAP   */
                /*--------------------------*/
                IEAPRemoteManager eapRemoteManager = eapMethod.eapRemoteManager(objCommon,
                        objCommon.getUser(), equipmentID, null, true);
                if (null == eapRemoteManager) {
                    Validations.check(retCodeConfig.getError(), "EAP Remote Get Error");
                }
                CarrierOutReqParams sendEapParam = new CarrierOutReqParams();
                sendEapParam.setCarrierID(tmpCarrierOutportInfo.getCarrierID());
                sendEapParam.setEquipmentID(equipmentID);
                sendEapParam.setPortID(tmpCarrierOutportInfo.getPortID());
                sendEapParam.setUser(params.getUser());
                try {
                    Object response = eapRemoteManager.sendCarrierOutReq(sendEapParam);
                    break;
                } catch (ServiceException ex) {
                    if (Validations.isEquals(ex.getCode(), retCodeConfig.getTcsNoResponse())) {
                        if (log.isDebugEnabled()) {
                            log.debug("{}", "EAP subsystem has return NO_RESPONSE!! just retry now!!  now count...",
                                    retryNum);
                            log.debug("{}", "now sleeping... ", sleepTimeValue);
                        }
                        if (retryNum != retryCountValue) {
                            try {
                                Thread.sleep(sleepTimeValue);
                                continue;
                            } catch (InterruptedException e) {
                                ex.addSuppressed(e);
                                Thread.currentThread().interrupt();
                                throw ex;
                            }
                        } else {
                            Validations.check(retCodeConfig.getTcsNoResponse());
                        }
                    } else {
                        throw ex;
                    }
                }
            }
            tmpCarrierOutportInfo.setSuccessFlag(true);
        }
        return tmpCarrierOutportInfo;
    }
}
